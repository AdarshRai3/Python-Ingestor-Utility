[
  {
    "question_id": "",
    "title": "Rotting Oranges",
    "description": "You are given an m x n grid where each cell can have one of three values: 0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (horizontally or vertically) to a rotten orange will become rotten. Return the minimum number of minutes that must elapse until no fresh oranges remain. If it is impossible to rot every fresh orange, return -1.",
    "topic": "Breadth-First Search",
    "subtopic": "Graph Traversal",
    "tags": [
      "BFS",
      "Array",
      "Simulation"
    ],
    "input_format": "A 2D grid of integers, where 0 \u2264 m, n \u2264 300.",
    "output_format": "An integer representing the minimum number of minutes to rot all oranges or -1 if it is impossible.",
    "constraints": [
      "The grid will have at least 1 cell.",
      "The grid will not exceed 300 x 300 cells."
    ],
    "examples": [
      {
        "input": "[[2,1,1],[1,1,0],[0,1,1]]",
        "output": "4",
        "explanation": "In 4 minutes, all fresh oranges become rotten."
      },
      {
        "input": "[[2,1,1],[0,1,1],[1,0,0]]",
        "output": "-1",
        "explanation": "Fresh oranges cannot rot because they are isolated."
      },
      {
        "input": "[[0,2]]",
        "output": "0",
        "explanation": "No fresh oranges to rot, return 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use BFS to explore the grid.",
      "Count initial fresh oranges and track the time.",
      "Stop when there are no fresh oranges left to process."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Read N Characters Given read4 II - Call Multiple Times",
    "description": "Implement the Reader class, which will have a read4 method that reads up to 4 characters from a file. You need to implement a method read that reads N characters from the file, calling read4 multiple times if needed. The read method should return the number of characters actually read.",
    "topic": "Design",
    "subtopic": "File Handling",
    "tags": [
      "Design",
      "File I/O",
      "String Processing"
    ],
    "input_format": "The input consists of a string of characters from a file, and an integer N that represents the number of characters to read.",
    "output_format": "An integer representing the number of characters that were read.",
    "constraints": [
      "1 <= N <= 1000",
      "The read4 function reads at most 4 characters at a time."
    ],
    "examples": [
      {
        "input": "file: 'abcde', N: 3",
        "output": "3",
        "explanation": "The first three characters read from the file are 'a', 'b', and 'c'."
      },
      {
        "input": "file: 'abcde', N: 5",
        "output": "5",
        "explanation": "All characters 'a', 'b', 'c', 'd', and 'e' are read."
      },
      {
        "input": "file: 'abcde', N: 7",
        "output": "5",
        "explanation": "Only 5 characters are available in the file, hence all 5 are read."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to track the number of characters read across multiple calls.",
      "Remember to handle cases where less than 4 characters are available."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Time Based Key-Value Store",
    "description": "Design a time-based key-value data structure that can store multiple values for the same key with an associated timestamp. Implement the data structure with the following methods: \n\n- `set(key: str, value: str, timestamp: int)`: This method will store the value associated with the key at the given timestamp. \n- `get(key: str, timestamp: int) -> str`: This method will retrieve the value associated with the key at the specified timestamp. If there are multiple values for the key before the given timestamp, return the value that was set most recently before that timestamp. If no such value exists, return an empty string.",
    "topic": "Design",
    "subtopic": "Data Structures",
    "tags": [
      "Design",
      "Data Structures",
      "Map"
    ],
    "input_format": "A series of operations on the time-based key-value store.",
    "output_format": "Output of `get` method indicating the most recent value for the key before a given timestamp.",
    "constraints": [
      "1 <= key.length, value.length <= 100",
      "1 <= timestamp <= 10^9",
      "All `set` operations have unique timestamps."
    ],
    "examples": [
      {
        "input": [
          "set('foo', 'bar', 1)",
          "set('foo', 'baz', 2)",
          "get('foo', 1)",
          "get('foo', 3)",
          "get('foo', 0)"
        ],
        "output": [
          null,
          null,
          "bar",
          "baz",
          ""
        ],
        "explanation": "At timestamp 1, 'bar' is set. At timestamp 2, 'baz' is set, which overwrites no existing value but updates the key's most recent entry. The first `get` returns 'bar', the second returns 'baz' and the last returns an empty string because no value exists at timestamp 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a map to store values along with timestamps.",
      "Binary search can help in retrieving the right timestamp efficiently."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Minimum Window Substring",
    "description": "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\". The substring must be a continuous sequence of characters from s.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Hash Table"
    ],
    "input_format": "Two strings s and t.",
    "output_format": "A string representing the minimum window substring of s that includes all characters from t.",
    "constraints": [
      "1 <= s.length, t.length <= 10^5",
      "s and t consist of English letters."
    ],
    "examples": [
      {
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
        "output": "\"BANC\"",
        "explanation": "The minimum window substring is \"BANC\" which contains all the characters of t."
      },
      {
        "input": "s = \"a\", t = \"a\"",
        "output": "\"a\"",
        "explanation": "The minimum window substring is \"a\" which contains the character of t."
      },
      {
        "input": "s = \"a\", t = \"aa\"",
        "output": "\"\"",
        "explanation": "There is no window substring in s that can contain all characters of t."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a hash table to count the characters required.",
      "Maintain a sliding window to keep track of the characters in s.",
      "Adjust the left end of the window when all characters of t are included."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Max Stack",
    "description": "Design a stack that supports push, pop, top, and retrieving the maximum element in constant time. Implement the MaxStack class with the following operations: \n\n- **push(x)**: Pushes the element x onto the stack.\n- **pop()**: Removes the element on the top of the stack.\n- **top()**: Get the top element of the stack.\n- **getMax()**: Retrieve the maximum element in the stack.\n\nYour implementation must support all these operations in O(1) time complexity.",
    "topic": "Stack",
    "subtopic": "Data Structure Design",
    "tags": [
      "Stack",
      "Design",
      "Data Structures"
    ],
    "input_format": "Multiple operations for the MaxStack class, including push, pop, top, and getMax.",
    "output_format": "Return values for the top and getMax operations as integers.",
    "constraints": [
      "All push operations will be valid integers within the range of [-10^4, 10^4].",
      "The max stack will not exceed a total of 10^6 elements."
    ],
    "examples": [
      {
        "input": "maxStack = MaxStack()\nmaxStack.push(5)\nmaxStack.push(1)\nmaxStack.push(5)\nmaxStack.top() \nmaxStack.getMax() \npopped = maxStack.pop() \nmaxStack.getMax()",
        "output": "[5, 5, 5]",
        "explanation": "Initially, we push 5, 1, and 5. The top is 5 and max is also 5. After popping, max remains 5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how you can keep track of the maximum value efficiently.",
      "You might need another stack to help store the maximum values."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Convert Sorted List to Binary Search Tree",
    "description": "Given a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree (BST). A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one.",
    "topic": "Linked List",
    "subtopic": "Binary Tree",
    "tags": [
      "Linked List",
      "Binary Tree",
      "Recursion"
    ],
    "input_format": "The input is a singly linked list node 'head' that points to the head of the sorted linked list.",
    "output_format": "Return the root node of the height-balanced binary search tree.",
    "constraints": [
      "The linked list has at most 3000 nodes.",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "head = [-10, -3, 0, 5, 9]",
        "output": "[0,-3,9,-10,null,5]",
        "explanation": "The resulting BST will have minimal height. Here, 0 is the root, -3 is the left child of 0, and 9 is the right child of 0."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "An empty list results in an empty tree."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the middle element as the root to ensure balance.",
      "Use the 'slow and fast pointer' technique to find the middle element.",
      "Recursive functions can simplify the problem."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Smallest Range Covering Elements from K Lists",
    "description": "You are given k lists of integers. Your task is to find the smallest range that includes at least one number from each of the k lists. The range is defined by the inclusive lower and upper bounds. For example, if the smallest range is [1, 5], it means that all numbers in the range [1, 5] include at least one number from each of the k lists.",
    "topic": "Heap",
    "subtopic": "Sliding Window",
    "tags": [
      "Heap",
      "Sliding Window",
      "Range"
    ],
    "input_format": "A list of k lists of integers, where each list can contain duplicate integers.",
    "output_format": "A list of two integers representing the smallest range [lower, upper].",
    "constraints": [
      "1 <= k <= 10^4",
      "1 <= lists[i].length <= 10^4",
      "-10^5 <= lists[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "[[1, 2, 3], [2, 3, 4], [3, 4, 5]]",
        "output": "[2, 3]",
        "explanation": "The smallest range that includes at least one number from each of the lists is [2, 3]."
      },
      {
        "input": "[[10, 20], [30, 40], [50, 60]]",
        "output": "[20, 30]",
        "explanation": "The smallest range covering elements from the lists is [20, 30], as it includes 20 from the first list and 30 from the second list."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a sliding window approach with heaps.",
      "Keep track of the maximum and minimum values in the current set."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Check Completeness of a Binary Tree",
    "description": "Given a binary tree, determine if it is a complete binary tree. A binary tree is complete if all levels are fully filled except possibly for the last level, which should be filled from left to right. Implement a function that judges whether a given binary tree meets these conditions.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Completeness"
    ],
    "input_format": "The input is the root node of a binary tree.",
    "output_format": "Return true if the binary tree is complete, otherwise return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^5].",
      "Node values are in the range [-10^5, 10^5]."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, 4, 5, 6]",
        "output": "true",
        "explanation": "The binary tree is complete: all levels are fully filled."
      },
      {
        "input": "root = [1, 2, 3, 4, 5, null, null]",
        "output": "false",
        "explanation": "The last level is not filled from left to right."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a level-order traversal to check the completeness.",
      "Keep track of the index of nodes to determine the expected positions."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "String Compression",
    "description": "Given a string `s` consisting of characters, the goal is to compress the string using the following rules: For each group of consecutive identical characters, replace them with the character followed by the count of occurrences in that group. If the compressed string is not smaller than the original string, return the original string. The compression should not be case-sensitive, meaning that 'a' and 'A' are considered the same character.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Compression",
      "Manipulation"
    ],
    "input_format": "A single string `s` of length n where 1 <= n <= 1000.",
    "output_format": "A compressed string if it is smaller than the original, otherwise return the original string.",
    "constraints": [
      "1 <= s.length <= 1000",
      "The input string consists of lowercase and uppercase letters."
    ],
    "examples": [
      {
        "input": "s = 'aaabbc'",
        "output": "a3b2c1",
        "explanation": "The string can be compressed to 'a3b2c1' which is smaller than 'aaabbc'."
      },
      {
        "input": "s = 'abc'",
        "output": "abc",
        "explanation": "The compressed string 'a1b1c1' is not smaller than 'abc', return 'abc'."
      },
      {
        "input": "s = 'AabbAA'",
        "output": "A2b2A2",
        "explanation": "The string can be compressed to 'A2b2A2' which is smaller than 'AabbAA'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Keep a count of consecutive characters and switch when you see a different one.",
      "You might need to iterate through the string to check each character and its neighbor."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Car Pooling",
    "description": "You are given a list of trips, where each trip consists of a start location, an end location, and the number of passengers that will be traveling. You need to determine if it's possible to pick up and drop off all passengers without exceeding the car's capacity at any point in time. The car starts with 0 passengers and can travel along a straight line.",
    "topic": "Greedy",
    "subtopic": "Interval Scheduling",
    "tags": [
      "Greedy",
      "Interval",
      "Array"
    ],
    "input_format": "An integer capacity followed by a list of trips, where each trip is represented by an array of three integers [start, end, passengers].",
    "output_format": "A boolean value indicating whether it is possible to complete all trips without exceeding the car's capacity.",
    "constraints": [
      "1 <= trips.length <= 1000",
      "0 < capacity <= 10000",
      "0 <= start < end <= 1000",
      "1 <= passengers <= 100"
    ],
    "examples": [
      {
        "input": "capacity = 4, trips = [[2, 3, 2], [3, 5, 2]]",
        "output": "true",
        "explanation": "At time 2, 2 passengers are picked up. At time 3, 2 passengers are dropped off, making it possible to fit within the capacity."
      },
      {
        "input": "capacity = 5, trips = [[2, 3, 2], [3, 5, 3]]",
        "output": "false",
        "explanation": "At time 3, there will be 5 passengers (2 picked up and 3 dropped off), which exceeds the capacity."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a timeline approach to track the number of passengers over time.",
      "Sort the trips based on start locations."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Range Sum Query 2D - Immutable",
    "description": "Given a 2D matrix of integers and a list of query boundaries, calculate the sum of the elements within the specified rectangle defined by its upper-left and lower-right corners. The matrix is immutable, meaning it will not change after it has been created.",
    "topic": "Matrix",
    "subtopic": "2D Range Queries",
    "tags": [
      "Matrix",
      "Range Query",
      "Immutable"
    ],
    "input_format": "A 2D matrix of integers matrix and a list of query boundaries represented as a list of tuples, where each tuple contains four integers (row1, col1, row2, col2).",
    "output_format": "A list of integers representing the sum of elements in each specified rectangle in the queries.",
    "constraints": [
      "1 <= matrix.length, matrix[i].length <= 200",
      "-10^5 <= matrix[i][j] <= 10^5",
      "The number of queries will not exceed 10000."
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], queries = [(0, 0, 1, 1), (1, 1, 2, 2)]",
        "output": "[12, 28]",
        "explanation": "The sum of elements in the rectangle from (0,0) to (1,1) is 1 + 2 + 4 + 5 = 12. The sum from (1,1) to (2,2) is 5 + 6 + 8 + 9 = 28."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using prefix sums for efficient range queries.",
      "Store cumulative sums in a separate 2D array."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Min Stack",
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement a MinStack class with the following methods: \n\n- `push(int x)`: Pushes the element x onto the stack. \n- `pop()`: Removes the element on the top of the stack. \n- `top()`: Gets the top element of the stack. \n- `getMin()`: Retrieves the minimum element in the stack.",
    "topic": "Stack",
    "subtopic": "Design",
    "tags": [
      "Stack",
      "Design",
      "Data Structure"
    ],
    "input_format": "There are no specific inputs for this implementation as the MinStack class is defined and its methods are invoked to manipulate and retrieve data.",
    "output_format": "The output consists of the return values of the methods invoked on the MinStack instance.",
    "constraints": [
      "All operations must be performed in constant time.",
      "The stack can contain at most 10^5 elements."
    ],
    "examples": [
      {
        "input": "MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); minStack.pop(); minStack.top(); minStack.getMin();",
        "output": "[-3, 0, -2]",
        "explanation": "Initially, the min stack has -2, 0, -3. The minimum is -3. After popping, the top is 0 and the new minimum is -2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using an auxiliary stack to keep track of the minimum values.",
      "Think about how you can maintain the minimum when elements are pushed and popped."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Word Ladder II",
    "description": "Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, such that only one letter can be changed at a time, and each transformed word must exist in the wordList. Note that beginWord is not a part of wordList. If no such transformation sequence exists, return an empty list.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "Backtracking"
    ],
    "input_format": "Three parameters: a string beginWord, a string endWord, and a list of strings wordList.",
    "output_format": "A list of lists of strings, where each list represents a valid transformation sequence from beginWord to endWord.",
    "constraints": [
      "1 <= beginWord.length <= 10",
      "1 <= endWord.length <= 10",
      "1 <= wordList.length <= 500",
      "beginWord != endWord",
      "All words have the same length.",
      "Words consist of lowercase alphabetic characters.",
      "endWord must be in the wordList."
    ],
    "examples": [
      {
        "input": "beginWord = 'hit', endWord = 'cog', wordList = ['hot', 'dot', 'dog', 'lot', '_log', 'cog']",
        "output": "[['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]",
        "explanation": "The possible shortest transformation sequences are: ['hit', 'hot', 'dot', 'dog', 'cog'] and ['hit', 'hot', 'lot', 'log', 'cog']."
      },
      {
        "input": "beginWord = 'a', endWord = 'c', wordList = ['a', 'b', 'c']",
        "output": "[['a', 'c']]",
        "explanation": "The only transformation is directly from 'a' to 'c'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use BFS to find the shortest path.",
      "Keep track of the paths taken for backtracking."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Longest Consecutive Sequence",
    "description": "Given an unsorted integer array nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Set"
    ],
    "input_format": "An array of integers nums, not necessarily sorted.",
    "output_format": "An integer representing the length of the longest consecutive elements sequence.",
    "constraints": [
      "0 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [100, 4, 200, 1, 3, 2]",
        "output": "4",
        "explanation": "The longest consecutive elements sequence is [1, 2, 3, 4]. Its length is 4."
      },
      {
        "input": "nums = [0, 0, 1, 1, 2, 2, 3]",
        "output": "4",
        "explanation": "The longest consecutive elements sequence is [0, 1, 2, 3]. Its length is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash set to store all unique elements.",
      "Check for consecutive sequences starting from each element."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Implement Trie (Prefix Tree)",
    "description": "A Trie (pronounced as 'try') is a special type of tree used to store associative data structures. It is primarily used for retrieving keys in a dataset of strings, where the key is a string. Implement a Trie with the following methods: `insert`, `search`, and `startsWith`.\n\n- `insert(word: str)`: Inserts the string `word` into the Trie.\n- `search(word: str)`: Returns `true` if the string `word` is in the Trie (i.e., it was inserted before), and `false` otherwise.\n- `startsWith(prefix: str)`: Returns `true` if there is a previously inserted string `word` that starts with the given `prefix`, and `false` otherwise.",
    "topic": "Design",
    "subtopic": "Data Structure",
    "tags": [
      "Trie",
      "Tree",
      "Data Structure"
    ],
    "input_format": "An array of operations where each operation is a list containing a string and an action ('insert', 'search', 'startsWith').",
    "output_format": "A list of boolean values representing the result of each search and startsWith operation.",
    "constraints": [
      "1 <= word.length <= 200",
      "The input consists of lowercase English letters.",
      "At most 10^4 calls will be made to insert, search, and startsWith."
    ],
    "examples": [
      {
        "input": "[['insert', 'apple'], ['search', 'apple'], ['search', 'app'], ['startsWith', 'app'], ['insert', 'app'], ['search', 'app']]",
        "output": "[true, false, true, true, false]",
        "explanation": "The word 'apple' is inserted successfully, so search returns true. The word 'app' is not in the Trie yet ('search' returns false). But 'app' has been inserted as a prefix, leading to startsWith returning true. After inserting 'app', it can now be found, so 'search' returns true."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hashmap or an array for each node in the Trie.",
      "You can end a word by marking the last character's node.",
      "Use depth-first search for efficient prefix matching."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Water and Jug Problem",
    "description": "You have two jugs with capacities x and y liters. Initially, both jugs are empty. Your goal is to measure exactly z liters using these two jugs. You can fill a jug from the water supply, empty a jug onto the ground, or pour water from one jug into the other until one jug is either full or empty. Determine if it is possible to measure exactly z liters using the two jugs.",
    "topic": "Mathematics",
    "subtopic": "Number Theory",
    "tags": [
      "Mathematics",
      "Water Jug",
      "Number Theory"
    ],
    "input_format": "Three integers x, y, and z representing the capacities of the two jugs and the target volume respectively.",
    "output_format": "Return true if it is possible to measure exactly z liters; otherwise, return false.",
    "constraints": [
      "0 <= x, y <= 10^6",
      "0 <= z <= max(x, y)",
      "Either x or y must not be zero."
    ],
    "examples": [
      {
        "input": "x = 3, y = 5, z = 4",
        "output": "true",
        "explanation": "You can fill the 5-liter jug and then pour from the 5-liter jug into the 3-liter jug until the 3-liter jug is full. This leaves exactly 2 liters in the 5-liter jug, then empty the 3-liter jug and pour again, resulting in 4 liters in the 5-liter jug."
      },
      {
        "input": "x = 2, y = 6, z = 5",
        "output": "false",
        "explanation": "It is not possible to measure 5 liters using jugs of capacity 2 and 6 liters."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use the properties of GCD to determine the feasibility.",
      "Check if z is less than or equal to the maximum of x and y.",
      "Consider the water pouring and emptying operations strategically."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Hash Map"
    ],
    "input_format": "A single string s consisting of English letters, digits, symbols, and spaces.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 10^5",
      "s consists of printable ASCII characters."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"abc\", which has a length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The longest substring without repeating characters is \"b\", with a length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"wke\", with a length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window approach to track characters.",
      "Utilize a hash map to store the last positions of characters."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Decode Ways",
    "description": "A message containing letters from A-Z can be encoded into numbers using the following mapping: 'A' -> 1, 'B' -> 2, ..., 'Z' -> 26. Given a string s consisting of digits, return the number of ways to decode it. The string may contain leading zeros and the mapping is such that you cannot decode '0'.",
    "topic": "Dynamic Programming",
    "subtopic": "Decoding",
    "tags": [
      "Dynamic Programming",
      "String",
      "Counting"
    ],
    "input_format": "A string s consisting of digits.",
    "output_format": "An integer representing the total number of ways to decode the string.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of only digits and may contain leading zeros."
    ],
    "examples": [
      {
        "input": "s = '12'",
        "output": "2",
        "explanation": "'12' can be decoded as 'AB' (1 2) or 'L' (12). Thus, there are 2 ways."
      },
      {
        "input": "s = '226'",
        "output": "3",
        "explanation": "'226' can be decoded as 'BZ' (2 26), 'F' (6), or 'BBF' (2 2 6). Thus, there are 3 ways."
      },
      {
        "input": "s = '06'",
        "output": "0",
        "explanation": "'06' cannot be decoded because it starts with a leading zero."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using an array to store the number of ways to decode up to each position.",
      "Check how to handle sequences where you can decode one or two digits."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Asteroid Collision",
    "description": "We have a number of asteroids in a row, represented by an integer array asteroids. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive for right, negative for left). When two asteroids collide, the smaller asteroid will explode. If both asteroids are of the same size, both will explode. Determine the final state of the asteroids after all collisions.",
    "topic": "Array",
    "subtopic": "Stack",
    "tags": [
      "Array",
      "Stack",
      "Simulation"
    ],
    "input_format": "An array of integers asteroids.",
    "output_format": "An array of integers representing the final state of asteroids after all collisions.",
    "constraints": [
      "1 <= asteroids.length <= 10^4",
      "-1000 <= asteroids[i] <= 1000",
      "Asteroids going in the same direction will not collide."
    ],
    "examples": [
      {
        "input": "asteroids = [5, 10, -5]",
        "output": "[5, 10]",
        "explanation": "The asteroid of size 5 and 10 will remain, while -5 will collide with 10 and explode."
      },
      {
        "input": "asteroids = [8, -8]",
        "output": "[]",
        "explanation": "The asteroid of size 8 will collide with -8 and both will explode."
      },
      {
        "input": "asteroids = [10, 2, -5]",
        "output": "[10]",
        "explanation": "10 will remain, as it collides with -5, which is smaller."
      },
      {
        "input": "asteroids = [-2, -1, 1, 2]",
        "output": "[-2, -1, 1, 2]",
        "explanation": "No collisions will occur as all are moving in the same direction."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to simulate the collisions.",
      "Check the direction of the asteroids involved in collisions."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Meeting Rooms II",
    "description": "Given an array of meeting time intervals represented as a list of start and end times, return the minimum number of meeting rooms required to accommodate all meetings without overlap. Each meeting is represented as an interval [start, end] where 'start' is the start time and 'end' is the end time of the meeting. Overlapping meetings cannot share the same room.",
    "topic": "Greedy",
    "subtopic": "Intervals",
    "tags": [
      "Greedy",
      "Sorting",
      "Intervals"
    ],
    "input_format": "An array of intervals where each interval is a pair of integers [start, end].",
    "output_format": "An integer representing the minimum number of meeting rooms required.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "0 <= intervals[i][0] < intervals[i][1] <= 10^6"
    ],
    "examples": [
      {
        "input": "intervals = [[0, 30], [5, 10], [15, 20]]",
        "output": "2",
        "explanation": "Meetings [0, 30] and [5, 10] overlap, requiring two rooms; the meeting [15, 20] can use any of the rooms."
      },
      {
        "input": "intervals = [[7, 10], [2, 4]]",
        "output": "1",
        "explanation": "Both meetings do not overlap, only one room is required."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the intervals by start time.",
      "Use a min-heap to keep track of end times of meetings."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Maximum Candies You Can Get from Boxes",
    "description": "You have a collection of boxes, each containing a certain number of candies. Each box can only be opened once, and when opened, it gives you candies as well as a certain number of additional boxes that you can later explore. Your goal is to find out the maximum number of candies you can collect by opening boxes strategically. You start with a specified number of boxes that you can open for free. After each box is opened, you can open more boxes if you have the required keys. An important point to consider is that each box may provide different amounts of candies and keys, making some boxes more attractive to open than others. You need to maximize your candies collection by choosing the optimal boxes to open. Write a function that calculates the maximum candies you can collect.",
    "topic": "Greedy",
    "subtopic": "Optimization",
    "tags": [
      "Greedy",
      "Dynamic Programming",
      "Maximization"
    ],
    "input_format": "An integer array `candies` representing the number of candies each box contains, and an integer array `keys` representing the number of additional boxes gained by opening them. An integer `initial_boxes` representing the number of boxes you can open at the start.",
    "output_format": "An integer representing the maximum number of candies you can collect.",
    "constraints": [
      "1 <= candies.length <= 1000",
      "0 <= candies[i] <= 10^5",
      "0 <= keys[i] <= 100"
    ],
    "examples": [
      {
        "input": {
          "candies": [
            5,
            6,
            7
          ],
          "keys": [
            1,
            0,
            1
          ],
          "initial_boxes": 1
        },
        "output": "12",
        "explanation": "Open the first box (5 candies) to gain access to the third box (7 candies), resulting in a total of 12 candies."
      },
      {
        "input": {
          "candies": [
            1,
            2,
            3
          ],
          "keys": [
            0,
            0,
            0
          ],
          "initial_boxes": 3
        },
        "output": "6",
        "explanation": "Since all boxes can be opened initially, opening all gives 1 + 2 + 3 = 6 candies."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Think about how to choose boxes to maximize candies.",
      "Use a priority queue to manage which boxes to open next."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Sort List",
    "description": "You are given an unsorted list of integers. Your task is to implement a function that sorts this list in ascending order and returns the sorted list.",
    "topic": "Sorting",
    "subtopic": "Array Manipulation",
    "tags": [
      "Sorting",
      "Array",
      "Algorithm"
    ],
    "input_format": "An array of integers nums, where 1 <= nums.length <= 10^4.",
    "output_format": "An array of integers representing the sorted list in ascending order.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^6 <= nums[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]",
        "output": "[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]",
        "explanation": "The numbers have been sorted in ascending order."
      },
      {
        "input": "nums = [10, -1, 2, 0, -5]",
        "output": "[-5, -1, 0, 2, 10]",
        "explanation": "The numbers have been sorted in ascending order."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using built-in sorting functions.",
      "You can implement sorting algorithms like Quick Sort or Merge Sort."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Process Tasks Using Servers",
    "description": "You have a list of tasks, each with a specific duration. You have multiple servers available, and each server can process one task at a time. Your goal is to minimize the total time when all tasks are completed. Tasks can be assigned to any server that is available at the time. Determine the minimum time required to complete all tasks.",
    "topic": "Greedy Algorithm",
    "subtopic": "Task Scheduling",
    "tags": [
      "Greedy",
      "Scheduling",
      "Minimization"
    ],
    "input_format": "An integer array tasks where tasks[i] represents the duration of each task. An integer servers indicating the number of available servers.",
    "output_format": "An integer representing the minimum time required to complete all tasks.",
    "constraints": [
      "1 <= tasks.length <= 10^5",
      "1 <= tasks[i] <= 1000",
      "1 <= servers <= 1000"
    ],
    "examples": [
      {
        "input": "tasks = [1, 2, 3, 4], servers = 2",
        "output": "4",
        "explanation": "Two servers can handle the tasks in parallel. One server does tasks of duration 1 and 3, while the other does tasks of duration 2 and 4. The total time taken is the longer of the two, which is 4."
      },
      {
        "input": "tasks = [3, 2, 5, 7], servers = 3",
        "output": "7",
        "explanation": "With three servers, the tasks can be distributed as (3), (2), and (5, 7). The server handling tasks of duration 5 and 7 will take the longest, which is 7."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a priority queue to manage the available servers efficiently.",
      "Try simulating the task assignment over multiple iterations to see how the distribution changes."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Find Minimum Time to Finish All Jobs",
    "description": "You have a set of jobs, each with a specific duration, that need to be completed. You can assign these jobs to a set of workers, each of whom can work on one job at a time. The goal is to determine the minimum time required to complete all jobs, minimizing the maximum time taken by any worker. Each worker can take on different jobs, but they cannot work simultaneously. Your task is to find the optimal way to assign these jobs to workers to minimize the overall time taken.",
    "topic": "Dynamic Programming",
    "subtopic": "Job Scheduling",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Job Scheduling"
    ],
    "input_format": "An array of integers jobs representing the duration of each job and an integer k, the number of workers.",
    "output_format": "An integer representing the minimum time required to finish all jobs.",
    "constraints": [
      "1 <= jobs.length <= 15",
      "1 <= jobs[i] <= 10^4",
      "1 <= k <= jobs.length"
    ],
    "examples": [
      {
        "input": "jobs = [3, 1, 4, 2], k = 2",
        "output": "4",
        "explanation": "With 2 workers, one can take jobs of duration 3 and 1, while the other takes jobs of duration 4 and 2, resulting in a maximum time of 4."
      },
      {
        "input": "jobs = [1, 2, 3, 4, 5], k = 2",
        "output": "6",
        "explanation": "With optimum assignment, jobs are assigned as [1, 2, 3] and [4, 5], leading to a maximum job duration of 6."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to distribute jobs among the workers evenly.",
      "Think about using backtracking to explore combinations of job assignments."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Coordinate With Maximum Network Quality",
    "description": "You are given a list of connections between nodes where each connection has a quality defined by an integer value. Your task is to determine the maximum network quality over a path connecting any two nodes. The network quality of a path is defined as the minimum quality of the connections along that path. You need to return the maximum network quality that can be achieved from any path in the graph.",
    "topic": "Graph",
    "subtopic": "Pathfinding",
    "tags": [
      "Graph",
      "Pathfinding",
      "Minimum"
    ],
    "input_format": "You are given an integer n representing the number of nodes and a list of connections where each connection is defined as [u, v, quality].",
    "output_format": "An integer representing the maximum network quality found in the graph.",
    "constraints": [
      "1 <= n <= 1000",
      "0 <= connections.length <= 10000",
      "0 <= u, v < n",
      "1 <= quality <= 1000"
    ],
    "examples": [
      {
        "input": "n = 5, connections = [[0, 1, 5], [1, 2, 3], [2, 3, 8], [3, 4, 6]]",
        "output": "3",
        "explanation": "The best path is 0 -> 1 -> 2 which has min quality of 3."
      },
      {
        "input": "n = 4, connections = [[0, 1, 4], [1, 2, 2], [0, 2, 1], [1, 3, 3]]",
        "output": "2",
        "explanation": "The path 1 -> 2 gives a minimum quality of 2, which is the maximum possible."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth First Search or Dijkstra's algorithm.",
      "Keep track of the minimum quality during your traversal of paths."
    ],
    "company": "Lyft"
  },
  {
    "question_id": "",
    "title": "Product of Array Except Self",
    "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].",
    "topic": "Array",
    "subtopic": "Product Calculation",
    "tags": [
      "Array",
      "Product",
      "Prefix-Suffix"
    ],
    "input_format": "An integer array nums of length n.",
    "output_format": "An integer array answer of length n where answer[i] is the product of all elements of nums except nums[i].",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-30 <= nums[i] <= 30",
      "The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer."
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "[24, 12, 8, 6]",
        "explanation": "The product of all elements except for nums[0] is 2 * 3 * 4 = 24, and so on for the rest."
      },
      {
        "input": "nums = [-1, 1, 0, -3, 3]",
        "output": "[0, 0, 9, 0, 0]",
        "explanation": "The product of all elements except for the index of each element is computed, resulting in the output."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to solve the problem in O(n) time without using division.",
      "Use two passes to calculate prefix and suffix products."
    ],
    "company": "Lyft"
  }
]