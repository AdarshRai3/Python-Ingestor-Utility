[
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A substring is a contiguous sequence of characters within a string. A palindrome is a string that reads the same forward and backward.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A single string s, where 1 <= s.length <= 1000.",
    "output_format": "A string representing the longest palindromic substring in s.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only printable ASCII characters."
    ],
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "bab",
        "explanation": "Both 'bab' and 'aba' are valid palindromic substrings of length 3, but 'bab' comes first."
      },
      {
        "input": "s = \"cbbd\"",
        "output": "bb",
        "explanation": "'bb' is the longest palindromic substring in 'cbbd'."
      },
      {
        "input": "s = \"a\"",
        "output": "a",
        "explanation": "The input string is a single character and is thus a palindrome."
      },
      {
        "input": "s = \"ac\"",
        "output": "a",
        "explanation": "The longest palindromic substring is 'a' since it is the only palindrome available."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about expanding around the center of a palindrome.",
      "Consider both odd-length and even-length palindromes.",
      "Dynamic programming can be used to find palindromes efficiently."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Predict the Winner",
    "description": "In a game of coins, two players take turns removing either one or two coins from a pile. The player who takes the last coin wins the game. Given an integer `n`, the number of coins in the pile, determine if the first player can guarantee a win assuming both players play optimally.",
    "topic": "Dynamic Programming",
    "subtopic": "Game Theory",
    "tags": [
      "Dynamic Programming",
      "Game Theory"
    ],
    "input_format": "An integer n representing the number of coins.",
    "output_format": "A boolean value indicating whether the first player can guarantee a win.",
    "constraints": [
      "1 <= n <= 10^5"
    ],
    "examples": [
      {
        "input": "n = 5",
        "output": "true",
        "explanation": "If the first player takes 1 coin, 4 remain. The second player will then take either 1 or 2 coins, leaving 3 or 2 for the first player, allowing them to win."
      },
      {
        "input": "n = 4",
        "output": "false",
        "explanation": "Whichever move the first player makes (taking either 1 or 2 coins), the second player can always take the remaining coins to win."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider dynamic programming approach to keep track of winning and losing states.",
      "Think about the possible moves at each state and how they influence the next player's choice."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "House Robber",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected. If two adjacent houses were broken into, the security system will automatically contact the police. Given an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "topic": "Dynamic Programming",
    "subtopic": "1D Dynamic Programming",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers nums, where nums[i] represents the amount of money stashed in the i-th house.",
    "output_format": "An integer representing the maximum amount of money you can rob.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 400"
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 9, 3, 1]",
        "output": "12",
        "explanation": "Robbing house 1 (2) and house 3 (9) gives us 11, but robbing house 2 (7) and house 4 (3) gives us 10, so robbing house 2 (7) and house 5 (1) gives us 8. The best option is to rob house 1 (2) and house 3 (9) totaling 11."
      },
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "4",
        "explanation": "Robbing house 1 (1) and house 3 (3) gives us 4. If we rob house 2 (2) and house 4 (1), we get 3, so the best option is 1 + 3 = 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to build up the solution.",
      "Think about how to decide whether to rob a house or skip it."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Rotate Image",
    "description": "You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). You have to rotate the image in place, meaning you have to do it with O(1) extra space.",
    "topic": "Matrix",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Matrix",
      "In-place",
      "Array"
    ],
    "input_format": "An n x n matrix represented as a list of lists of integers.",
    "output_format": "The matrix rotated 90 degrees clockwise in place.",
    "constraints": [
      "1 <= n <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]",
        "explanation": "Rotating the matrix clockwise gives the new arrangement."
      },
      {
        "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
        "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
        "explanation": "After rotating, the rows and columns are rearranged."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try transposing the matrix first, then reverse each row.",
      "Consider using nested loops for swapping elements."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order. The spiral order starts from the top-left corner of the matrix and proceeds to the right, then downwards, left, and upwards, before repeating the process until all elements have been collected.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral"
    ],
    "input_format": "A 2D list of integers representing the matrix.",
    "output_format": "A list of integers representing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "m * n <= 10^5",
      "-10^5 <= matrix[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The elements are traversed in the order: 1 -> 2 -> 3 -> 6 -> 9 -> 8 -> 7 -> 4 -> 5."
      },
      {
        "input": "matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]",
        "output": "[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]",
        "explanation": "The elements are traversed in the spiral order: 1 -> 2 -> 3 -> 4 -> 8 -> 12 -> 11 -> 10 -> 9 -> 5 -> 6 -> 7."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the four boundaries of the matrix and adjust them as you collect the elements."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Lucky Numbers in a Matrix",
    "description": "A 'lucky number' in a matrix is defined as an element that is the minimum in its row and the maximum in its column. Given a 2D matrix of integers, return all the lucky numbers in it.",
    "topic": "Matrix",
    "subtopic": "Matrix Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Search"
    ],
    "input_format": "A 2D list of integers matrix where 1 <= matrix.length, matrix[i].length <= 50 and -10^5 <= matrix[i][j] <= 10^5.",
    "output_format": "A list of integers representing the lucky numbers found in the matrix.",
    "constraints": [
      "1 <= matrix.length, matrix[i].length <= 50",
      "-10^5 <= matrix[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "matrix = [[3,7,8],[9,11,13],[15,16,17]]",
        "output": "[15]",
        "explanation": "15 is the minimum in its row (15, 16, 17) and the maximum in its column (3, 9, 15)."
      },
      {
        "input": "matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]",
        "output": "[12]",
        "explanation": "12 is the minimum in its row (12) and the maximum in its column (2, 7, 12)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Check each element to see if it is the minimum of its row.",
      "Verify if it is also the maximum of its column."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Stone Game",
    "description": "Alice and Bob are playing a game with heaps of stones. They take turns removing stones from either the leftmost or the rightmost heap. They both want to maximize the number of stones they can collect. Given an array representing the number of stones in each heap, determine who will win the game, assuming both players play optimally. Return 'Alice' if Alice can collect more stones than Bob, 'Bob' if Bob can collect more stones than Alice, or 'Tie' if they collect the same amount.",
    "topic": "Dynamic Programming",
    "subtopic": "Game Theory",
    "tags": [
      "Dynamic Programming",
      "Game Theory",
      "Greedy"
    ],
    "input_format": "An array of integers stones, where stones[i] represents the number of stones in the i-th heap.",
    "output_format": "A string, either 'Alice', 'Bob', or 'Tie'.",
    "constraints": [
      "1 <= stones.length <= 100",
      "1 <= stones[i] <= 1000"
    ],
    "examples": [
      {
        "input": "[5, 3, 4, 5]",
        "output": "Alice",
        "explanation": "Alice can start by picking the leftmost 5 stones, and then regardless of Bob's move, she can ensure to collect more than Bob by optimal play."
      },
      {
        "input": "[3, 7, 2, 3]",
        "output": "Bob",
        "explanation": "Bob can always play optimally to ensure that he collects more stones than Alice."
      },
      {
        "input": "[1, 2, 3, 4, 5, 6]",
        "output": "Tie",
        "explanation": "Both can collect stones in a way that results in them having the same total."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider dynamic programming to store intermediate results.",
      "Think about how to maximize the score based on possible moves."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Fizz Buzz",
    "description": "Write a program that prints the numbers from 1 to n. But for multiples of three, print 'Fizz' instead of the number, and for the multiples of five, print 'Buzz'. For numbers which are multiples of both three and five, print 'FizzBuzz'.",
    "topic": "Math",
    "subtopic": "Iterative Logic",
    "tags": [
      "Math",
      "String Manipulation",
      "Iteration"
    ],
    "input_format": "An integer n (1 <= n <= 10^4) representing the upper limit of the range.",
    "output_format": "A list of strings representing the Fizz Buzz output.",
    "constraints": [
      "1 <= n <= 10^4"
    ],
    "examples": [
      {
        "input": "n = 15",
        "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]",
        "explanation": "The numbers 1 to 15 translate to 'Fizz' for 3, 'Buzz' for 5, and 'FizzBuzz' for 15."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a loop to iterate through numbers from 1 to n.",
      "Check the divisibility of each number by 3 and 5 to determine what to print."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "LRU Cache",
    "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) Cache. It should support the following operations: get(key) and put(key, value). The get operation retrieves the value of the specified key if the key exists in the cache, otherwise returns -1. The put operation will update the value of the key if it already exists, and if the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item.",
    "topic": "Data Structure",
    "subtopic": "Cache",
    "tags": [
      "Cache",
      "Data Structure",
      "Design"
    ],
    "input_format": "The cache will be initialized with a positive capacity. The operations 'get' and 'put' take integer key and/or value parameters.",
    "output_format": "The output for the get operation is the value associated with the key or -1 if not found. For put operation, there is no output.",
    "constraints": [
      "The number of operations will not exceed 2 * 10^4.",
      "The capacity of the cache is a positive integer.",
      "Keys and values are integers."
    ],
    "examples": [
      {
        "input": "cache = LRUCache(2);\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);",
        "output": "1",
        "explanation": "Cache is {1=1, 2=2}. Returns 1."
      },
      {
        "input": "cache.put(3, 3);\ncache.get(2);",
        "output": "-1",
        "explanation": "Cache is {1=1, 3=3}. 2 was the least recently used and should be evicted."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a combination of a hashmap and a doubly linked list.",
      "Keep track of the order of accessed items."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Number of Valid Words in a Sentence",
    "description": "Given a sentence represented as a string, return the number of valid words in the sentence. A valid word is defined as one that consists only of lowercase letters and may contain hyphens or apostrophes, but should not start or end with them. Additionally, valid words cannot have consecutive hyphens or apostrophes.",
    "topic": "String",
    "subtopic": "Validation",
    "tags": [
      "String",
      "Validation",
      "Count"
    ],
    "input_format": "A string representing a sentence.",
    "output_format": "An integer representing the number of valid words in the sentence.",
    "constraints": [
      "1 <= sentence.length <= 1000"
    ],
    "examples": [
      {
        "input": "Hello, world! It's a beautiful day.",
        "output": "5",
        "explanation": "The valid words are 'Hello', 'world', 'It', 's', 'a', 'beautiful', and 'day'. (Although 'It's' is valid, 'It' and 's' are considered separate words.)"
      },
      {
        "input": "A quick-brown fox jumps over the lazy dog.",
        "output": "9",
        "explanation": "All words in the sentence are valid."
      },
      {
        "input": "This is a test--to check validity.",
        "output": "6",
        "explanation": "The valid words are 'This', 'is', 'a', 'test', 'to', and 'check'. 'test--to' is invalid due to consecutive hyphens."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Check each word for allowed characters.",
      "Use regular expressions to validate words."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. An interval is defined by a pair of integers representing the start and end points. The result should contain all the merged intervals sorted by their starting point.",
    "topic": "Array",
    "subtopic": "Sorting and Merging",
    "tags": [
      "Array",
      "Sorting",
      "Intervals"
    ],
    "input_format": "A list of intervals, where each interval is represented as a pair of integers [start, end].",
    "output_format": "A list of merged intervals, where each interval is represented as a pair of integers [start, end].",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Intervals [1,3] and [2,6] overlap, so they are merged into [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "Intervals [1,4] and [4,5] overlap at 4, so they merge into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals by their starting points.",
      "Use a temporary list to store the merged intervals."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Maximum Difference Between Increasing Elements",
    "description": "Given an array of integers, find the maximum difference between two elements in the array such that the larger element comes after the smaller element. If no such pair exists, return -1.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Maximum Difference"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum difference between two elements with the larger one coming after the smaller one. Return -1 if it's not possible.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "The maximum difference is between 1 and 6 (6 - 1 = 5)."
      },
      {
        "input": "nums = [9, 5, 1]",
        "output": "-1",
        "explanation": "No pair exists such that the larger element comes after the smaller one."
      },
      {
        "input": "nums = [1, 2, 90, 10, 110]",
        "output": "109",
        "explanation": "The maximum difference is between 1 and 110 (110 - 1 = 109)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Track the minimum number encountered so far while iterating the array.",
      "Calculate the difference with each element and update the maximum difference."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Find Third Transaction",
    "description": "You are given a list of transactions represented by integers, where each integer indicates the amount involved in each transaction. Your task is to find the value of the third transaction in the list. If there are fewer than three transactions, return -1.",
    "topic": "Array",
    "subtopic": "Indexing",
    "tags": [
      "Array",
      "Searching",
      "Indexing"
    ],
    "input_format": "An array of integers transactions.",
    "output_format": "An integer representing the third transaction amount, or -1 if it does not exist.",
    "constraints": [
      "1 <= transactions.length <= 10^5",
      "-10^6 <= transactions[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "transactions = [100, 200, 300, 400]",
        "output": "300",
        "explanation": "The third transaction is 300."
      },
      {
        "input": "transactions = [50, 100]",
        "output": "-1",
        "explanation": "There are only two transactions, so we return -1."
      },
      {
        "input": "transactions = []",
        "output": "-1",
        "explanation": "The list is empty, so we return -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use the index directly to access the third element if it exists."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Snakes and Ladders",
    "description": "You are given a board game represented as a 2D grid with `n` rows and `n` columns. The game consists of 1 through n^2 squares numbered consecutively, starting from the top left corner at (0,0) and going row-wise to the bottom right corner at (n-1,n-1). The players start at square 1 and need to reach square n^2. Some squares contain ladders that allow players to jump to a higher square, while others contain snakes that bring players down to a lower square. The objective is to determine the minimum number of moves required to reach the last square, or return -1 if it's not possible.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "Board Game"
    ],
    "input_format": "A 2D array of integers board, where board[i][j] represents the square number at position (i, j). The value can be either a ladder (positive integer) or a snake (negative integer), or 0 (no ladder/snake).",
    "output_format": "An integer representing the minimum number of moves to reach square n^2, or -1 if it's not possible.",
    "constraints": [
      "1 <= n <= 10",
      "The number on the board is between -1 and n^2, and does not contain duplicates."
    ],
    "examples": [
      {
        "input": "board = [[-1,-1,-1,-1],[15,-1,-1,-1],[-1,-1,-1,-1],[-1,7,-1,-1]]",
        "output": "4",
        "explanation": "The shortest path involves moving to squares 1, 2, 3, 4 with the ladders, reaching the end in 4 moves."
      },
      {
        "input": "board = [[-1,-1],[3,-1]]",
        "output": "2",
        "explanation": "You can jump from square 1 to square 2 and then directly to square 4 in 2 moves."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use breadth-first search (BFS) to explore possible moves.",
      "Track visited nodes to avoid cycles.",
      "Consider the effects of ladders and snakes when moving."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Word Search II",
    "description": "Given a 2D board and a list of words, find all words in the board. Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a single word. Return all words found in the board.",
    "topic": "Backtracking",
    "subtopic": "Trie",
    "tags": [
      "Backtracking",
      "Trie",
      "Depth-First Search"
    ],
    "input_format": "A 2D array of characters board and a list of strings words.",
    "output_format": "A list of strings consisting of all the words that can be found in the board.",
    "constraints": [
      "1 <= board.length, board[i].length <= 12",
      "1 <= words.length <= 10^4",
      "1 <= words[i].length <= 10"
    ],
    "examples": [
      {
        "input": {
          "board": [
            [
              "o",
              "a",
              "a",
              "n"
            ],
            [
              "e",
              "t",
              "a",
              "e"
            ],
            [
              "i",
              "h",
              "k",
              "r"
            ],
            [
              "i",
              "f",
              "l",
              "v"
            ]
          ],
          "words": [
            "oath",
            "pea",
            "eat",
            "rain"
          ]
        },
        "output": [
          "eat",
          "oath"
        ],
        "explanation": "The words 'eat' and 'oath' can be found in the board."
      },
      {
        "input": {
          "board": [
            [
              "a",
              "b"
            ],
            [
              "c",
              "d"
            ]
          ],
          "words": [
            "abcb"
          ]
        },
        "output": [],
        "explanation": "No words can be formed from the board."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a trie to facilitate quick word lookups.",
      "Perform a depth-first search (DFS) starting from each cell in the board.",
      "Mark cells as visited during the DFS to avoid reusing them."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Minimum Cost to Make Array Equal",
    "description": "You are given an array of integers 'nums'. Your task is to make all elements of the array equal in minimum cost. The cost to change any element 'nums[i]' to 'x' is given by the absolute difference |nums[i] - x|. Find the minimum total cost to make all elements of the array equal.",
    "topic": "Array",
    "subtopic": "Cost Calculation",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers nums, where 1 <= nums.length <= 2 * 10^4 and -10^4 <= nums[i] <= 10^4.",
    "output_format": "An integer representing the minimum total cost to make all elements equal.",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "2",
        "explanation": "We can change the array to all elements being 2, which costs |1-2| + |2-2| + |3-2| = 1 + 0 + 1 = 2."
      },
      {
        "input": "nums = [1, 10, 100]",
        "output": "198",
        "explanation": "Changing all elements to 10 will cost |1-10| + |10-10| + |100-10| = 9 + 0 + 90 = 99. Changing to 100 would cost 198."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the properties of absolute differences.",
      "Finding a target value to minimize the cost may involve median calculations."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Find the Largest Area of Square Inside Two Rectangles",
    "description": "Given two rectangles defined by their lower-left and upper-right corners in a 2D plane, find the largest area of a square that can fit inside both rectangles. The rectangles can overlap or be entirely separate. Return the area of the largest square that can fit inside both rectangles.",
    "topic": "Geometry",
    "subtopic": "Rectangle Area",
    "tags": [
      "Geometry",
      "Rectangle",
      "Area",
      "Math"
    ],
    "input_format": "Two rectangles are defined by their coordinates: rectangle1 represented as (x1, y1, x2, y2) and rectangle2 as (a1, b1, a2, b2), where (x1, y1) and (x2, y2) are the lower-left and upper-right corners of the first rectangle, and (a1, b1) and (a2, b2) are for the second rectangle.",
    "output_format": "An integer representing the area of the largest fitting square.",
    "constraints": [
      "-10^4 <= x1 < x2 <= 10^4",
      "-10^4 <= y1 < y2 <= 10^4",
      "-10^4 <= a1 < a2 <= 10^4",
      "-10^4 <= b1 < b2 <= 10^4"
    ],
    "examples": [
      {
        "input": "rectangle1 = (1, 1, 4, 4), rectangle2 = (2, 2, 5, 5)",
        "output": "4",
        "explanation": "The largest square that can fit inside both rectangles is of side length 2, hence area = 2 * 2 = 4."
      },
      {
        "input": "rectangle1 = (0, 0, 3, 3), rectangle2 = (3, 3, 6, 6)",
        "output": "0",
        "explanation": "Both rectangles do not overlap, hence no square can fit inside both."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the maximum side length of the square based on the overlapping area.",
      "Think about how the corners of the rectangles can constrain the size of the square."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Sum of k-Mirror Numbers",
    "description": "A k-mirror number is a number that is both a palindrome in its decimal representation and in its k-base representation. Given two integers n and k, your task is to find the sum of the first n k-mirror numbers. For example, if n = 5 and k = 2, the first 5 k-mirror numbers are 1, 3, 5, 7, and 9, and their sum is 25. If there are fewer than n k-mirror numbers, return the sum of all the k-mirror numbers you can find.",
    "topic": "Mathematics",
    "subtopic": "Palindromes and Bases",
    "tags": [
      "Mathematics",
      "Palindromes",
      "Base Conversion",
      "Summation"
    ],
    "input_format": "Two integers n (1 <= n <= 10^4) and k (2 <= k <= 10).",
    "output_format": "An integer representing the sum of the first n k-mirror numbers.",
    "constraints": [
      "1 <= n <= 10^4",
      "2 <= k <= 10"
    ],
    "examples": [
      {
        "input": "n = 5, k = 2",
        "output": "25",
        "explanation": "The first 5 k-mirror numbers are 1, 3, 5, 7, and 9. Their sum is 1 + 3 + 5 + 7 + 9 = 25."
      },
      {
        "input": "n = 10, k = 3",
        "output": "131",
        "explanation": "The first 10 k-mirror numbers in base 3 are 1, 2, 4, 5, 6, 7, 8, 9, 10, and 11. Their sum is 131."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "To check if a number is a palindrome, convert it to a string and check if it reads the same forwards and backwards.",
      "You may need to convert numbers into the k-base representation to check for k-mirror numbers.",
      "Consider using a helper function to check palindromic conditions."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Kadane's Algorithm"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum sum of the contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The contiguous subarray [4,-1,2,1] has the largest sum = 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The only subarray is [1], which has the maximum sum of 1."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The contiguous subarray [5,4,-1,7,8] has the largest sum = 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Kadane's algorithm for an efficient solution.",
      "Keep track of the maximum sum found so far."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Check if Binary String Has at Most One Segment of Ones",
    "description": "Given a binary string s, check if it contains at most one contiguous segment of ones. A segment of ones is defined as a series of adjacent '1's that are not separated by '0's. Return true if there is at most one segment of ones; otherwise, return false.",
    "topic": "String",
    "subtopic": "Binary String",
    "tags": [
      "String",
      "Binary",
      "Contiguous Segment"
    ],
    "input_format": "A binary string s consisting of characters '0' and '1'.",
    "output_format": "A boolean value, true if there is at most one segment of ones, otherwise false.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s[i] is either '0' or '1'."
    ],
    "examples": [
      {
        "input": "s = \"10001\"",
        "output": "false",
        "explanation": "This string has two segments of ones: '1' at index 0 and '1' at index 4."
      },
      {
        "input": "s = \"110\"",
        "output": "true",
        "explanation": "This string has one segment of ones: '11' at indices 0 and 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Count the number of segments of ones.",
      "You can check transitions between '0's and '1's."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Implement Router",
    "description": "You are tasked with building a simple router that can handle GET requests. The router should match a given path to registered routes and return the corresponding response. The router should support dynamic paths with parameters, such as '/user/:id'. Implement a function `route(path: string) -> str` that takes a path as input and returns the registered response for that path. If the path does not match any registered routes, return '404 Not Found'.",
    "topic": "Design",
    "subtopic": "Routing",
    "tags": [
      "Design",
      "Router",
      "String Matching"
    ],
    "input_format": "A string representing the path of the request.",
    "output_format": "A string representing the response for the matched path, or '404 Not Found' if no match is found.",
    "constraints": [
      "Paths may contain alphanumeric characters, '/', and ':' for parameters.",
      "The maximum length of a path is 100 characters."
    ],
    "examples": [
      {
        "input": "/user/123",
        "output": "User details for 123",
        "explanation": "The path '/user/123' matches the route registered for user details."
      },
      {
        "input": "/invalid/path",
        "output": "404 Not Found",
        "explanation": "There is no route matching the path '/invalid/path'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dictionary to store routes and handler functions.",
      "Utilize regular expressions for pattern matching with parameters."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Number of Equal Count Substrings",
    "description": "Given a string s consisting of only lowercase letters, your task is to count the number of substrings such that the count of each character in the substring is the same. For example, in the substring 'abab', the count of 'a' and 'b' are both 2. Implement a function that will return the total number of such equal count substrings in the string.",
    "topic": "String",
    "subtopic": "Substring Counting",
    "tags": [
      "String",
      "Substrings",
      "Counting"
    ],
    "input_format": "A single string s of lowercase letters.",
    "output_format": "An integer representing the number of equal count substrings in the string.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only lowercase letters"
    ],
    "examples": [
      {
        "input": "abab",
        "output": "6",
        "explanation": "The equal count substrings are: 'a', 'b', 'ab', 'ba', 'abab', and 'a' + 'b' in any order."
      },
      {
        "input": "ccc",
        "output": "3",
        "explanation": "The equal count substrings are: 'c', 'cc', and 'ccc'."
      },
      {
        "input": "abc",
        "output": "3",
        "explanation": "The equal count substrings are: 'a', 'b', and 'c'. Each character count is equal to 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a frequency map to track character counts.",
      "Explore all possible substrings efficiently."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Happy Number",
    "description": "A happy number is defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle that does not include 1. Those numbers for which this process ends in 1 are happy numbers. Write a function to determine if a given positive integer is a happy number.",
    "topic": "Math",
    "subtopic": "Number Theory",
    "tags": [
      "Math",
      "Number Theory",
      "Recursion"
    ],
    "input_format": "A single positive integer n.",
    "output_format": "A boolean value indicating whether the number is a happy number (true) or not (false).",
    "constraints": [
      "1 <= n <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "n = 19",
        "output": "true",
        "explanation": "1^2 + 9^2 = 82, 8^2 + 2^2 = 68, 6^2 + 8^2 = 100, 1^2 + 0^2 + 0^2 = 1, so 19 is a happy number."
      },
      {
        "input": "n = 2",
        "output": "false",
        "explanation": "2 leads to a cycle of [4, 16, 37, 58, 89, 145, 42, 20] and does not reach 1, hence it is not a happy number."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a set to track already seen numbers.",
      "Sum the squares of the digits to generate the next number."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers that add up to target.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "0 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash map to store the difference between the target and the current number."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Max Points on a Line",
    "description": "Given an array of points where points[i] = [xi, yi] represents a point on a 2D plane, return the maximum number of points that lie on the same straight line.",
    "topic": "Geometry",
    "subtopic": "Line Representation",
    "tags": [
      "Math",
      "Geometry",
      "Line",
      "Points"
    ],
    "input_format": "An array of points, where each point is represented as an array of two integers [x, y].",
    "output_format": "An integer representing the maximum number of points on a single straight line.",
    "constraints": [
      "1 <= points.length <= 300",
      "-10^4 <= points[i][0], points[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "points = [[1,1],[2,2],[3,3]]",
        "output": "3",
        "explanation": "All three points lie on the line y = x."
      },
      {
        "input": "points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]",
        "output": "4",
        "explanation": "The maximum number of points on a line is 4, which can be achieved with the points [1,1], [2,3], [3,2], and [4,1]."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use the slope-intercept form to determine if points are collinear.",
      "Consider using a hashmap to count occurrences of slopes.",
      "Vertical lines have an undefined slope; handle this case separately."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Cherry Pickup",
    "description": "You are given a square grid of cherries, where some cells contain cherries (represented by `1`) and others are empty (represented by `0`). You start at the top-left corner of the grid (0, 0) and can move either right or down to reach the bottom-right corner of the grid (n-1, n-1). After reaching the bottom-right corner, you can backtrack to the top-left corner, and your goal is to collect as many cherries as possible during this journey, counting the number of cherries you collect from both trips. Note that you cannot revisit any cell once you have collected cherries from it. Return the maximum number of cherries you can collect.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Cherries"
    ],
    "input_format": "A 2D list of integers grid where each integer is either 0 or 1.",
    "output_format": "An integer representing the maximum number of cherries that can be collected.",
    "constraints": [
      "1 <= grid.length == grid[i].length <= 50",
      "grid[i][j] is either 0 or 1"
    ],
    "examples": [
      {
        "input": "grid = [[0,1,0],[1,1,1],[0,1,0]]",
        "output": "5",
        "explanation": "From (0,0) to (2,2), you can collect 3 cherries and backtrack to (0,0) to collect 2 more cherries."
      },
      {
        "input": "grid = [[1,0,0],[0,1,1],[0,0,1]]",
        "output": "4",
        "explanation": "Collect cherries from the path (0,0) -> (1,1) -> (2,2) yielding 3, then backtrack to (0,0) for the additional cherry at (0,0)."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Think about how to represent your state.",
      "Consider using dynamic programming to track the maximum cherries collected."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers height representing the elevation map.",
    "output_format": "An integer representing the total amount of trapped rainwater.",
    "constraints": [
      "0 <= height.length <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The water is trapped between the bars of heights 1 and 2. The total amount is 6."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The water is trapped between the heights of 4 and 5. The total amount is 9."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the water that can be trapped above each bar.",
      "Use a two-pointer approach to calculate the trapped water more efficiently."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is considered valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A single string s consisting of the characters '(', ')', '{', '}', '[' and ']'",
    "output_format": "Return true if the input string is valid, otherwise return false.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses characters only."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The parentheses are correctly matched."
      },
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "All types of brackets are correctly matched."
      },
      {
        "input": "s = '(]",
        "output": "false",
        "explanation": "Mismatched brackets."
      },
      {
        "input": "s = '([)]'",
        "output": "false",
        "explanation": "The brackets are not in the correct order."
      },
      {
        "input": "s = '{[]}'",
        "output": "true",
        "explanation": "All types of brackets are correctly matched."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "Make sure the closing bracket matches the top of the stack.",
      "Check if the stack is empty at the end."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices representing the stock prices on different days.",
    "output_format": "An integer indicating the maximum profit that can be achieved.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Track the minimum price seen so far.",
      "Calculate potential profit at each step and update the maximum profit."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters. The substring must consist of contiguous characters in the string, and no character should appear more than once in that substring.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A single string s consisting of uppercase and lowercase English letters, digits, and symbols.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 10^5",
      "s consists of printable ASCII characters."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"abc\", which has a length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The longest substring without repeating characters is \"b\", with a length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"wke\", which has a length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window approach to track characters and their positions.",
      "Consider using a HashMap to store the most recent index of each character."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Decode String",
    "description": "Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. You may assume that the input string is always valid; no extra white spaces, square brackets are well-formed, etc. Also, you can assume that the integer k is always positive. Note that the input string is guaranteed to be of length less than 100.",
    "topic": "String",
    "subtopic": "Decoding",
    "tags": [
      "String",
      "Decoding",
      "Stack"
    ],
    "input_format": "A string s representing the encoded string.",
    "output_format": "A string representing the decoded output.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of digits, lowercase English letters, and square brackets."
    ],
    "examples": [
      {
        "input": "s = \"3[a2[c]]\"",
        "output": "accaccacc",
        "explanation": "The decoded string is 'a2[c]' which gives 'acc', and repeating it 3 times results in 'accaccacc'."
      },
      {
        "input": "s = \"2[abc]3[cd]ef\"",
        "output": "abcabccdcdcdef",
        "explanation": "The decoded string is 'abc' repeated 2 times followed by 'cd' repeated 3 times and then 'ef'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to keep track of the counts and characters.",
      "Iterate through each character and build the decoded string."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Remove Boxes",
    "description": "You are given an integer array boxes, where boxes[i] represents the number of boxes of type i. You need to remove all boxes of a particular type while maximizing the score. The score for removing boxes of type i is calculated by the formula: (number of boxes of type i) * (number of boxes of type i) + the score obtained from removing the remaining boxes. The score is calculated recursively. Implement a function to return the maximum score possible.",
    "topic": "Dynamic Programming",
    "subtopic": "Memoization",
    "tags": [
      "Dynamic Programming",
      "Memoization",
      "Recursion"
    ],
    "input_format": "An integer array boxes where 1 <= boxes.length <= 100 and 1 <= boxes[i] <= 100.",
    "output_format": "An integer representing the maximum score obtainable.",
    "constraints": [
      "1 <= boxes.length <= 100",
      "1 <= boxes[i] <= 100"
    ],
    "examples": [
      {
        "input": "boxes = [1, 2, 3]",
        "output": "9",
        "explanation": "Removing all boxes yields a score of 1^2 + 2^2 + 3^2 = 1 + 4 + 9 = 14."
      },
      {
        "input": "boxes = [1, 1, 1]",
        "output": "3",
        "explanation": "Removing any box scores 1^2 = 1. Therefore, the maximum score is 3."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a 3D DP array to keep track of remaining boxes.",
      "Think about how the score changes as you remove boxes."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Strange Printer",
    "description": "You have a strange printer with the following two special properties: \n1. The printer can only print a sequence of the same character, and it takes one unit of time to print each character. \n2. To print different characters, the printer costs an additional unit of time for each distinct character that was not printed in the previous sequence. \nGiven a string `s`, return the minimum time to print the string using the strange printer.",
    "topic": "Dynamic Programming",
    "subtopic": "Matrix DP",
    "tags": [
      "Dynamic Programming",
      "String",
      "Matrix"
    ],
    "input_format": "A string s consisting of lowercase English letters.",
    "output_format": "An integer representing the minimum time required to print the string.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = \"aaabbb\"",
        "output": "2",
        "explanation": "The printer can first print 'aaa' in 1 unit of time and then print 'bbb' in another unit of time."
      },
      {
        "input": "s = \"aba\"",
        "output": "2",
        "explanation": "The printer can print 'a' in 1 unit, then 'b' in 1 unit (costly because it was different), and then 'a' again (same as last printed)."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider a dynamic programming approach to solve this problem.",
      "Think about how segments of the same character can be optimized."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Note that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Hash Table"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A list of unique triplets that sum up to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that sum up to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no elements in the input array."
      },
      {
        "input": "nums = [0, 1, 1]",
        "output": "[]",
        "explanation": "There are no triplets that can sum up to zero."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the array first to make it easier to avoid duplicates.",
      "Use a two-pointer technique to find triplets.",
      "Skip the same elements to avoid duplicate triplets in the result."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Merge Sorted Array",
    "description": "You are given two integer arrays, nums1 and nums2, sorted in non-decreasing order. Merge nums2 into nums1 as one sorted array. Note that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The elements in nums1 should be merged in place and should not be returned. The resulting array after merging should also be sorted.",
    "topic": "Array",
    "subtopic": "Merging",
    "tags": [
      "Array",
      "Sorting",
      "In-place"
    ],
    "input_format": "Two arrays nums1 and nums2, where nums1 has a size of m + n, initialized with m elements followed by n zeros, and nums2 has size n.",
    "output_format": "The merged and sorted array is stored in nums1.",
    "constraints": [
      "0 <= m, n <= 200",
      "1 <= m + n <= 200",
      "-10^9 <= nums1[i], nums2[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3",
        "output": "[1, 2, 2, 3, 5, 6]",
        "explanation": "After merging the two arrays, nums1 becomes [1, 2, 2, 3, 5, 6]."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "Since nums2 is empty, nums1 remains unchanged."
      },
      {
        "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
        "output": "[1]",
        "explanation": "Since nums1 has no elements, it becomes [1] after merging."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Start merging from the end of both arrays to avoid overwriting.",
      "Consider using two pointers to track the position of elements in both arrays."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Move Zeroes",
    "description": "Given an array of integers, move all the zeroes to the end of it while maintaining the relative order of the non-zero elements. You must do this in-place without making a copy of the array.",
    "topic": "Array",
    "subtopic": "In-place Operations",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "The modified array with all zeroes at the end.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [0, 1, 0, 3, 12]",
        "output": "[1, 3, 12, 0, 0]",
        "explanation": "The non-zero elements 1, 3, and 12 are moved to the front, maintaining their relative order."
      },
      {
        "input": "nums = [0, 0, 1]",
        "output": "[1, 0, 0]",
        "explanation": "The non-zero element 1 is moved to the front."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a two-pointer technique to keep track of the non-zero elements."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Linked List Cycle",
    "description": "Given a linked list, determine if it has a cycle in it. A cycle is defined as a situation where a node's next pointer points back to a previous node in the list. You should implement an algorithm that runs in O(n) time complexity and uses O(1) space complexity.",
    "topic": "Linked List",
    "subtopic": "Cycle Detection",
    "tags": [
      "Linked List",
      "Cycle Detection",
      "Two Pointers"
    ],
    "input_format": "A singly linked list's head node.",
    "output_format": "Return true if the linked list has a cycle. Otherwise, return false.",
    "constraints": [
      "The number of nodes in the linked list is in the range [0, 10^4].",
      "The value of each node is between -10^5 and 10^5."
    ],
    "examples": [
      {
        "input": "head = [3, 2, 0, -4], pos = 1",
        "output": "true",
        "explanation": "The linked list has a cycle, where the tail connects back to the second node (value 2)."
      },
      {
        "input": "head = [1, 2], pos = 0",
        "output": "true",
        "explanation": "The linked list has a cycle, where the tail connects back to the first node (value 1)."
      },
      {
        "input": "head = [1], pos = -1",
        "output": "false",
        "explanation": "The linked list has no cycle."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to traverse the list.",
      "If the fast pointer catches up with the slow pointer, there is a cycle."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Letter Combinations of a Phone Number",
    "description": "Given a string containing digits from 2-9, return all possible letter combinations that the number could represent. A mapping of digits to letters is similar to that of a telephone keypad, where each digit maps to a set of letters as follows: 2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz'. The task is to return all the combinations in any order.",
    "topic": "Backtracking",
    "subtopic": "Combination Generation",
    "tags": [
      "Backtracking",
      "String",
      "Recursion"
    ],
    "input_format": "A string digits, where 0 <= digits.length <= 4.",
    "output_format": "A list of all possible letter combinations as strings.",
    "constraints": [
      "0 <= digits.length <= 4",
      "digits[i] is a digit from '2' to '9'."
    ],
    "examples": [
      {
        "input": "digits = '23'",
        "output": "[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]",
        "explanation": "The digits '2' and '3' map to 'abc' and 'def', respectively. The combinations are formed from each letter of 'abc' paired with each letter of 'def'."
      },
      {
        "input": "digits = '2'",
        "output": "[\"a\", \"b\", \"c\"]",
        "explanation": "The digit '2' corresponds directly to the letters 'a', 'b', and 'c'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about using recursion to generate combinations.",
      "Consider using a mapping of digits to their corresponding letters.",
      "Base case should handle the situation when the input is empty."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count how many islands are present in the grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "Matrix"
    ],
    "input_format": "A 2D binary grid grid where grid[i][j] is either '1' or '0'.",
    "output_format": "An integer representing the number of islands in the grid.",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[i].length <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "grid = [['1','1','1','1','0'], ['1','1','0','1','0'], ['0','0','0','0','0'], ['0','1','1','0','1']]",
        "output": "3",
        "explanation": "The grid contains three islands."
      },
      {
        "input": "grid = [['0','0','0','0','0'], ['0','0','0','0','0'], ['0','0','0','0','0']]",
        "output": "0",
        "explanation": "The grid contains no islands as all cells are water."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth-First Search (DFS) to explore the grid.",
      "Mark visited cells to avoid counting them more than once."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Longest Consecutive Sequence",
    "description": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Consecutive Sequence"
    ],
    "input_format": "An unsorted array of integers nums.",
    "output_format": "An integer representing the length of the longest consecutive elements sequence.",
    "constraints": [
      "0 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [100, 4, 200, 1, 3, 2]",
        "output": "4",
        "explanation": "The longest consecutive sequence is [1, 2, 3, 4], which has length 4."
      },
      {
        "input": "nums = [0, -1]",
        "output": "2",
        "explanation": "The longest consecutive sequence is [-1, 0], which has length 2."
      },
      {
        "input": "nums = []",
        "output": "0",
        "explanation": "There are no elements, so the longest consecutive sequence length is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a set to store numbers for O(1) access.",
      "Check for the start of a sequence by looking for n-1.",
      "Count consecutive elements by checking for n+1, n+2, and so on."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Search a 2D Matrix",
    "description": "Write an efficient algorithm that searches for a target value in an m x n integer matrix. This matrix has the following properties: 1) Integers in each row are sorted in ascending from left to right, and 2) Integers in each column are sorted in ascending from top to bottom. Return true if the target exists in the matrix, otherwise return false.",
    "topic": "Matrix",
    "subtopic": "Search",
    "tags": [
      "Matrix",
      "Binary Search",
      "Search"
    ],
    "input_format": "A 2D list of integers `matrix` and an integer `target`.",
    "output_format": "A boolean value indicating whether the target exists in the matrix.",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 100",
      "-10^4 <= matrix[i][j], target <= 10^4"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [12, 14, 16]], target = 9",
        "output": "true",
        "explanation": "The target value 9 is present in the matrix."
      },
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [12, 14, 16]], target = 10",
        "output": "false",
        "explanation": "The target value 10 is not present in the matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "You can apply binary search between rows and columns.",
      "Consider the properties of the sorted matrix to narrow down the search."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Expressive Words",
    "description": "Given a string s and an array of strings words, you need to determine how many of the strings in the words array can be considered expressive equivalents of the string s. A word is considered expressive if it can be formed by expanding the letters in s. Expansion means that consecutive repeated characters in word can be replaced by the same character repeated at least three times. For example, 'heeellooo' is an expressive equivalent of 'hello'.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Counting",
      "Pattern Matching"
    ],
    "input_format": "A string s followed by an array of strings words.",
    "output_format": "An integer representing the number of expressive words.",
    "constraints": [
      "1 <= s.length <= 100",
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 100",
      "s and each word consist of lowercase English letters only."
    ],
    "examples": [
      {
        "input": "s = 'heeelloo', words = ['hello', 'hi', 'helo']",
        "output": "1",
        "explanation": "'hello' is an expressive equivalent of 'heeelloo'; 'hi' and 'helo' are not."
      },
      {
        "input": "s = 'zzzzzy', words = ['zzyy', 'zy', 'zyy']",
        "output": "3",
        "explanation": "All words can be derived from 'zzzzzy' by considering expansions."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Compare character frequencies and their counts between s and each word.",
      "Use a helper function to check if each word can be formed by expanding s."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of k linked-lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. The fast solution should be designed with a time complexity better than O(n log n), where n is the total number of nodes in all k lists combined.",
    "topic": "Linked List",
    "subtopic": "Merge",
    "tags": [
      "Linked List",
      "Sorting",
      "Heap"
    ],
    "input_format": "An array of k linked-lists, where each linked-list node contains an integer value and a pointer to the next node.",
    "output_format": "A linked list that represents the merged sorted linked-list.",
    "constraints": [
      "k == lists.length",
      "0 <= k <= 10^4",
      "0 <= lists[i].length <= 500",
      "-10^4 <= lists[i][j] <= 10^4",
      "The values of the nodes in the linked-lists are in ascending order."
    ],
    "examples": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]",
        "explanation": "The merged linked list is 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6."
      },
      {
        "input": "lists = []",
        "output": "[]",
        "explanation": "Since there are no lists to merge, the output is an empty list."
      },
      {
        "input": "lists = [[-1,5,11],[2,6],[3]]",
        "output": "[-1,2,3,5,6,11]",
        "explanation": "The merged linked list is -1 -> 2 -> 3 -> 5 -> 6 -> 11."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a priority queue to keep track of the smallest head node.",
      "If the linked-lists are empty, return an empty result."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List",
    "description": "Given the head of a singly linked list, reverse the list and return the reversed list's head.",
    "topic": "Linked List",
    "subtopic": "Reversing a Linked List",
    "tags": [
      "Linked List",
      "Reversal",
      "Data Structure"
    ],
    "input_format": "The head of the linked list given as a ListNode.",
    "output_format": "The head of the reversed linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 5000]",
      "-5000 <= Node.val <= 5000"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5]",
        "output": "[5, 4, 3, 2, 1]",
        "explanation": "Reversing the list [1 -> 2 -> 3 -> 4 -> 5] gives [5 -> 4 -> 3 -> 2 -> 1]."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "An empty list reversed is still an empty list."
      },
      {
        "input": "head = [1]",
        "output": "[1]",
        "explanation": "A single-element list reversed is the same as the original list."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use pointers to track the previous and current nodes.",
      "Iterate through the list and adjust the pointers accordingly.",
      "The last node processed becomes the new head."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Gas Station",
    "description": "There are n gas stations along a circular route, where the amount of gas at the i-th gas station is gas[i]. The cost of travel from the i-th gas station to (i + 1)-th gas station is cost[i]. You have to travel around the circuit once, and you want to know if you can start at a gas station and make a complete circuit. If you can, return the starting gas station's index; otherwise, return -1. Note that the solution is guaranteed to be unique.",
    "topic": "Greedy",
    "subtopic": "Gas Station Problem",
    "tags": [
      "Greedy",
      "Array",
      "Math"
    ],
    "input_format": "Two integer arrays gas and cost of size n.",
    "output_format": "An integer representing the starting gas station's index, or -1 if it is not possible.",
    "constraints": [
      "n == gas.length == cost.length",
      "1 <= n <= 10^5",
      "0 <= gas[i], cost[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "[1,2,3,4,5], [3,4,5,1,2]",
        "output": "3",
        "explanation": "Start at index 3 with 4 gas, go to index 4 with 3 gas, then to index 0 with 5 gas, and complete the circuit."
      },
      {
        "input": "[2,3,4], [3,4,3]",
        "output": "-1",
        "explanation": "Not enough gas to complete the circuit, starting at any gas station results in running out of gas."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "If you cannot reach the next gas station, you'll never be able to do the complete circuit starting from the previous stations."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Single Number",
    "description": "Given an array of integers, every element appears twice except for one. Find that single one. Implement a solution that has a linear runtime complexity and uses constant space.",
    "topic": "Array",
    "subtopic": "Bit Manipulation",
    "tags": [
      "Array",
      "Bit Manipulation",
      "Single Number"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the single number that appears once in the array.",
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-3 * 10^4 <= nums[i] <= 3 * 10^4",
      "There will be exactly one number that appears only once."
    ],
    "examples": [
      {
        "input": "nums = [2, 2, 1]",
        "output": "1",
        "explanation": "The number 1 appears only once, while 2 appears twice."
      },
      {
        "input": "nums = [4, 1, 2, 1, 2]",
        "output": "4",
        "explanation": "The number 4 appears only once, while 1 and 2 appear twice."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The number 1 appears only once."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use XOR operation to eliminate duplicate numbers."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "topic": "String",
    "subtopic": "Sorting and Hashing",
    "tags": [
      "String",
      "Hashing",
      "Sorting"
    ],
    "input_format": "An array of strings, strs, where 1 <= strs.length <= 10^4 and 0 <= strs[i].length <= 100.",
    "output_format": "A list of lists of grouped anagrams.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100"
    ],
    "examples": [
      {
        "input": "strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
        "output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
        "explanation": "The output groups the anagrams together. 'eat', 'tea', and 'ate' are anagrams, while 'tan' and 'nat' are another group, and 'bat' stands alone."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "The input contains only one string which is an empty string, thus it forms its own group."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "Similar to the previous case, the single character 'a' forms its own group."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to store groups of anagrams.",
      "Sort each string to create a standard representation for its anagrams."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array",
    "description": "Given a sorted array of integers, you need to remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. After removing the duplicates, return the new length of the array. Note that you must not use any extra space for another array.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An array of integers nums, where the length of nums is n.",
    "output_format": "An integer representing the new length of the array after duplicates have been removed.",
    "constraints": [
      "1 <= n <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums is sorted in ascending order."
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "2",
        "explanation": "The array after removing duplicates is [1, 2]. The length of this array is 2."
      },
      {
        "input": "nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]",
        "output": "5",
        "explanation": "The array after removing duplicates is [0, 1, 2, 3, 4]. The length of this array is 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to keep track of unique elements.",
      "Only modify the elements that differ from the previous unique element."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Meeting Rooms II",
    "description": "Given an array of meeting time intervals where intervals[i] = [start_i, end_i], return the minimum number of conference rooms required to hold all meetings. A meeting room can only hold one meeting at a time and must be free by the time the next meeting starts.",
    "topic": "Array",
    "subtopic": "Sorting and Greedy Algorithms",
    "tags": [
      "Array",
      "Greedy",
      "Sorting"
    ],
    "input_format": "An array of meeting time intervals represented as a list of pairs, where each pair consists of two integers [start, end].",
    "output_format": "An integer representing the minimum number of conference rooms required.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "0 <= start_i < end_i <= 10^6"
    ],
    "examples": [
      {
        "input": "intervals = [[0, 30], [5, 10], [15, 20]]",
        "output": "2",
        "explanation": "We need two meeting rooms; first meeting overlaps with the second and the third."
      },
      {
        "input": "intervals = [[7, 10], [2, 4]]",
        "output": "1",
        "explanation": "We only need one room as the meetings do not overlap."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the intervals by their start times.",
      "Use a min-heap to track the end times of ongoing meetings."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Permutation in String",
    "description": "Given two strings s1 and s2, write a function to determine if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.",
    "topic": "String",
    "subtopic": "Substring",
    "tags": [
      "String",
      "Permutation",
      "Substring"
    ],
    "input_format": "The input will consist of two strings, s1 and s2, where 1 <= s1.length <= 100 and 1 <= s2.length <= 10^4.",
    "output_format": "Return true if s2 contains the permutation of s1, otherwise return false.",
    "constraints": [
      "1 <= s1.length <= 100",
      "1 <= s2.length <= 10^4",
      "s1 and s2 consist of lowercase English letters only."
    ],
    "examples": [
      {
        "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
        "output": "true",
        "explanation": "s2 contains one permutation of s1 ('ba')."
      },
      {
        "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
        "output": "false",
        "explanation": "No permutation of s1 is present in s2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window technique.",
      "Count the frequency of characters in s1.",
      "Check the current window in s2 against the character counts of s1."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Valid Palindrome",
    "description": "Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring case. A palindrome is a word, phrase, number, or other sequences of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).",
    "topic": "String",
    "subtopic": "Two Pointers",
    "tags": [
      "String",
      "Palindrome",
      "Two Pointers"
    ],
    "input_format": "A single string s.",
    "output_format": "A boolean indicating whether the string is a palindrome.",
    "constraints": [
      "1 <= s.length <= 2 * 10^5",
      "s consists only of printable ASCII characters."
    ],
    "examples": [
      {
        "input": "s = \"A man, a plan, a canal: Panama\"",
        "output": "true",
        "explanation": "When we ignore the non-alphanumeric characters and case, the string reads 'amanaplanacanalpanama', which is the same forwards and backwards."
      },
      {
        "input": "s = \"race a car\"",
        "output": "false",
        "explanation": "After ignoring non-alphanumeric characters, the string reads 'raceacar', which is not the same forwards and backwards."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers to check for palindromic characters.",
      "Normalize the string by filtering out non-alphanumeric characters."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Find Servers That Handled Most Number of Requests",
    "description": "In a network of servers, each server has a unique ID and can handle a certain number of requests. Your task is to identify which server(s) handled the most requests based on given input data. The input consists of an array where each element represents a server's ID and its corresponding number of handled requests. Output the ID(s) of the server(s) that handled the maximum number of requests. If there is a tie, return all server IDs in ascending order.",
    "topic": "Hash Table",
    "subtopic": "Counting Frequencies",
    "tags": [
      "Hash Table",
      "Counting",
      "Sorting"
    ],
    "input_format": "An array of integers, where each integer represents a server ID.",
    "output_format": "An array of integers representing the server IDs that handled the most requests, sorted in ascending order.",
    "constraints": [
      "1 <= servers.length <= 10^5",
      "1 <= servers[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "[1, 2, 2, 3, 1, 1]",
        "output": "[1]",
        "explanation": "Server 1 handled the most requests (3 times) compared to other servers."
      },
      {
        "input": "[5, 5, 6, 6]",
        "output": "[5, 6]",
        "explanation": "Both servers 5 and 6 handled the maximum number of requests (2 times each)."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a hash map to count the number of requests each server handled.",
      "Keep track of the maximum count as you process the requests."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Word Search",
    "description": "Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where 'adjacent' cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "topic": "Backtracking",
    "subtopic": "Graph Search",
    "tags": [
      "Backtracking",
      "DFS",
      "Matrix"
    ],
    "input_format": "A 2D board represented as a list of lists, and a string word.",
    "output_format": "Return true if the word exists in the grid, otherwise return false.",
    "constraints": [
      "1 <= board.length, board[i].length <= 200",
      "board[i][j] consists of English letters.",
      "1 <= word.length <= 100"
    ],
    "examples": [
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "ABCCED"
        },
        "output": "true",
        "explanation": "The word can be found by moving adjacent cells down, right, up and back."
      },
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "SEE"
        },
        "output": "true",
        "explanation": "The word 'SEE' can be constructed by moving adjacent cells."
      },
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "ABCB"
        },
        "output": "false",
        "explanation": "The word 'ABCB' cannot be constructed without reusing the letter 'B'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using depth-first search (DFS) to explore the board.",
      "Keep track of visited cells to avoid using the same letter more than once.",
      "Consider the four possible directions to move from the current cell."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. The addition should be done digit-by-digit, just like how you would do it manually - start from the head (least significant digit) and carry over any value greater than 9.",
    "topic": "Linked List",
    "subtopic": "Addition",
    "tags": [
      "Linked List",
      "Math",
      "Two Pointers"
    ],
    "input_format": "Two linked lists l1 and l2, where each linked list represents a non-negative integer.",
    "output_format": "A linked list representing the sum of the two integers.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= node.val <= 9",
      "It is guaranteed that the input values do not contain any leading zero."
    ],
    "examples": [
      {
        "input": "l1 = [2, 4, 3], l2 = [5, 6, 4]",
        "output": "[7, 0, 8]",
        "explanation": "The numbers represented by the linked lists are 342 and 465. Their sum is 807, which is represented as [7, 0, 8] in reverse order."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "Both numbers are 0. Their sum is also 0, represented as [0] in reverse order."
      },
      {
        "input": "l1 = [9, 9, 9, 9, 9, 9, 9], l2 = [9, 9, 9, 9]",
        "output": "[8, 9, 9, 9, 0, 0, 1]",
        "explanation": "The numbers represented by the linked lists are 9999999 and 9999. Their sum is 10009998, represented as [8, 9, 9, 9, 0, 0, 1] in reverse order."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a variable to keep track of the carry over.",
      "Iterate through both linked lists simultaneously."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Insert Delete GetRandom O(1)",
    "description": "Design a data structure that supports the following operations in average O(1) time complexity: insert(value), remove(value), and getRandom(). The insert operation will add an item to the collection, remove will delete an item, and getRandom will return a random element from the current set of elements. Your implementation should use an array or a list for storage.",
    "topic": "Data Structure",
    "subtopic": "Array and Hashing",
    "tags": [
      "Data Structure",
      "Array",
      "Hashing",
      "Random"
    ],
    "input_format": "A series of operations, where each operation is either 'insert x', 'remove x', or 'getRandom'.",
    "output_format": "For every 'getRandom' operation, return the randomly chosen element.",
    "constraints": [
      "1 <= number of operations <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "examples": [
      {
        "input": "insert(1), insert(2), insert(3), getRandom(), remove(2), getRandom()",
        "output": "1 or 3, 1 or 3",
        "explanation": "After inserting 1, 2, 3, we can get either 1 or 3 randomly. After removing 2, we can only get 1 or 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a list/array to store the elements.",
      "Use a hash map for fast lookup and deletion.",
      "Ensure you handle the resizing of the list when removing elements."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Palindromic Substrings",
    "description": "Given a string s, return the number of distinct palindromic substrings in s. A palindrome is a string that reads the same backward as forward. A substring is a contiguous sequence of characters within the string. If a substring appears more than once but is the same, it is only counted once.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Palindrome",
      "Dynamic Programming"
    ],
    "input_format": "A single string s of length n.",
    "output_format": "An integer representing the number of distinct palindromic substrings.",
    "constraints": [
      "1 <= n <= 1000",
      "s consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = \"abc\"",
        "output": "3",
        "explanation": "The palindromic substrings are \"a\", \"b\", \"c\"."
      },
      {
        "input": "s = \"aa\"",
        "output": "1",
        "explanation": "The only distinct palindromic substring is \"a\"."
      },
      {
        "input": "s = \"aaa\"",
        "output": "3",
        "explanation": "The distinct palindromic substrings are \"a\", \"aa\", and \"aaa\"."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding around each character to find palindromes.",
      "You can also use dynamic programming to store palindromic results."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Permutations",
    "description": "Given an array of distinct integers, return all the possible permutations. You can return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Permutations",
      "DFS"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "A list of lists containing all the possible permutations of the input array.",
    "constraints": [
      "1 <= nums.length <= 6",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": "All the possible permutations of the array [1, 2, 3] are listed."
      },
      {
        "input": "nums = [0, 1]",
        "output": "[[0,1],[1,0]]",
        "explanation": "The permutations for the array [0, 1] are [0, 1] and [1, 0]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to build permutations.",
      "Use a boolean array to track visited elements."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Top K Frequent Elements",
    "description": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. The frequency of an element is the number of times it appears in the array.",
    "topic": "Array",
    "subtopic": "Hash Map",
    "tags": [
      "Hash Map",
      "Sorting",
      "Heap"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An array of the k most frequent elements.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "k is in the range [1, the number of unique elements in the array]"
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3], k = 2",
        "output": "[1,2]",
        "explanation": "1 is the most frequent element and 2 is the second most frequent element."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "There is only one element, which is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map to count the frequency of each element.",
      "You might need a data structure to keep track of the top k elements efficiently."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Burst Balloons",
    "description": "You are given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons. If you burst balloon `i`, you will get `nums[i-1] * nums[i] * nums[i+1]` coins. If `i-1` or `i+1` is out of bounds, then treat it as `1`. Return the maximum coins you can collect by bursting the balloons wisely. Note that you cannot burst two adjacent balloons in one operation.",
    "topic": "Dynamic Programming",
    "subtopic": "Memoization",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Recursion"
    ],
    "input_format": "An integer array `nums`, representing the numbers on the balloons.",
    "output_format": "An integer representing the maximum coins that can be collected.",
    "constraints": [
      "1 <= nums.length <= 300",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [3, 1, 5, 8]",
        "output": "167",
        "explanation": "Bursting balloons in the order of 1, 0, 3, gives you a total of 167 coins."
      },
      {
        "input": "nums = [1, 5]",
        "output": "10",
        "explanation": "Bursting the balloon 1 first gives you 5 coins, and bursting balloon 0 next gives you 5 coins."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Try to use a recursive approach with memoization.",
      "Consider how many coins you earn for bursting each balloon."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Kth Smallest Element in a BST",
    "description": "Given a binary search tree (BST), write a function to find the kth smallest element in it. You may assume that the input tree is non-empty and that k is always valid (1 \u2264 k \u2264 number of nodes in the tree).",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Traversal"
    ],
    "input_format": "The root of a binary search tree and an integer k.",
    "output_format": "An integer representing the kth smallest element in the BST.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 10^4].",
      "0 <= Node.val <= 10^5",
      "1 <= k <= number of nodes in the tree"
    ],
    "examples": [
      {
        "input": "root = [3,1,4,null,2], k = 1",
        "output": "1",
        "explanation": "The sorted order of elements in the BST is [1, 2, 3, 4]. The 1st smallest element is 1."
      },
      {
        "input": "root = [5,3,6,2,4,null,null,1], k = 3",
        "output": "3",
        "explanation": "The sorted order of elements in the BST is [1, 2, 3, 4, 5, 6]. The 3rd smallest element is 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use in-order traversal to retrieve elements in sorted order.",
      "Consider using a stack to simulate the in-order traversal iteratively."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Subarray Sum Equals K",
    "description": "Given an array of integers and an integer k, return the number of contiguous subarrays whose sum equals to k. A subarray is a contiguous part of an array.",
    "topic": "Array",
    "subtopic": "Subarray Sum",
    "tags": [
      "Array",
      "Subarray",
      "Hashmap"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An integer representing the count of subarrays whose sum equals k.",
    "constraints": [
      "1 <= nums.length <= 20,000",
      "-1000 <= nums[i] <= 1000",
      "-10^7 <= k <= 10^7"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 1], k = 2",
        "output": "2",
        "explanation": "The subarrays [1, 1] (first two elements) and [1, 1] (last two elements) both sum to 2."
      },
      {
        "input": "nums = [1, 2, 3], k = 3",
        "output": "2",
        "explanation": "The subarrays [3] and [1, 2] both sum to 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hashmap to keep track of the sum frequencies.",
      "Consider the cumulative sum to find the number of valid subarrays."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Product of Array Except Self",
    "description": "Given an integer array nums, return an array result such that result[i] is equal to the product of all the elements of nums except nums[i]. You must write an algorithm that runs in O(n) time and without using the division operation.",
    "topic": "Array",
    "subtopic": "Product",
    "tags": [
      "Array",
      "Product",
      "Math"
    ],
    "input_format": "An array of integers nums, where 2 <= nums.length <= 10^5.",
    "output_format": "An array of integers representing the product of all elements except self.",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-30 <= nums[i] <= 30"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "[24, 12, 8, 6]",
        "explanation": "The result is calculated as follows: result[0] = 2*3*4 = 24, result[1] = 1*3*4 = 12, result[2] = 1*2*4 = 8, result[3] = 1*2*3 = 6."
      },
      {
        "input": "nums = [-1, 1, 0, -3, 3]",
        "output": "[0, 0, 9, 0, 0]",
        "explanation": "The result is calculated as follows: result[0] = 1*0*(-3)*3 = 0, result[1] = -1*0*(-3)*3 = 0, result[2] = -1*1*(-3)*3 = 9, and others are 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider maintaining two separate products, one for elements to the left and another for elements to the right."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Compare Version Numbers",
    "description": "You are tasked with comparing two version numbers version1 and version2. The version numbers are strings that consist of numeric segments separated by dots. For example, '1.0.1' is a valid version number. You need to compare version1 and version2 to see which one is greater. If version1 is greater than version2, return 1. If version1 is less than version2, return -1. If they are equal, return 0. Each version number may have leading zeros, which do not affect their value.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Comparison",
      "Version Control"
    ],
    "input_format": "Two strings version1 and version2, representing the version numbers to compare.",
    "output_format": "An integer: 1 if version1 > version2, -1 if version1 < version2, 0 if they are equal.",
    "constraints": [
      "1 <= version1.length, version2.length <= 15",
      "version1 and version2 are composed only of digits and '.'",
      "Leading zeros in the version segments are to be ignored."
    ],
    "examples": [
      {
        "input": "version1 = '1.01', version2 = '1.001'",
        "output": "0",
        "explanation": "Both version numbers are equivalent when ignoring leading zeros."
      },
      {
        "input": "version1 = '0.1', version2 = '1.1'",
        "output": "-1",
        "explanation": "Version 0.1 is less than version 1.1."
      },
      {
        "input": "version1 = '1.0.1', version2 = '1'",
        "output": "1",
        "explanation": "Version 1.0.1 is considered greater than version 1.0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Split the version numbers by '.' to compare each segment.",
      "Convert the segments to integers for accurate comparison."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Unique Paths",
    "description": "A robot is located at the top-left corner of a m x n grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. How many unique paths are there for the robot to reach the bottom-right corner?",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Path Counting"
    ],
    "input_format": "Two integers m and n, representing the number of rows and columns in the grid.",
    "output_format": "An integer representing the number of unique paths to reach the bottom-right corner.",
    "constraints": [
      "1 <= m, n <= 100"
    ],
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": "There are 28 unique paths from the top-left corner to the bottom-right corner."
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "There are 3 unique paths from the top-left corner to the bottom-right corner."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dynamic programming approach.",
      "Think about how many ways you can reach a cell based on its neighboring cells."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Find Minimum in Rotated Sorted Array",
    "description": "You are given a rotated sorted array `nums` where the original array was sorted in increasing order. The array may contain duplicates. Write a function to find the minimum element in this array. You must write an algorithm with a time complexity of O(log n).",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Minimum"
    ],
    "input_format": "An integer array nums of length n.",
    "output_format": "An integer representing the minimum element in the array.",
    "constraints": [
      "1 <= n <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [3, 4, 5, 1, 2]",
        "output": "1",
        "explanation": "The minimum element in the array is 1."
      },
      {
        "input": "nums = [2, 2, 2, 0, 1, 2]",
        "output": "0",
        "explanation": "The minimum element in the array is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how the pivot point in a rotated array helps determine the minimum.",
      "Use binary search to efficiently find the minimum element."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Missing Number",
    "description": "Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one number that is missing from the array.",
    "topic": "Array",
    "subtopic": "Search",
    "tags": [
      "Array",
      "Math",
      "Bit Manipulation"
    ],
    "input_format": "An array of integers nums of length n.",
    "output_format": "An integer representing the missing number.",
    "constraints": [
      "0 <= nums.length <= 10000",
      "0 <= nums[i] <= nums.length",
      "All numbers in nums are distinct."
    ],
    "examples": [
      {
        "input": "nums = [3, 0, 1]",
        "output": "2",
        "explanation": "The numbers in the range 0 to 3 are 0, 1, 2, 3. The missing number is 2."
      },
      {
        "input": "nums = [0, 1]",
        "output": "2",
        "explanation": "The numbers in the range 0 to 2 are 0, 1, 2. The missing number is 2."
      },
      {
        "input": "nums = [9,6,4,2,3,5,7,0,1]",
        "output": "8",
        "explanation": "The numbers in the range 0 to 9 are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. The missing number is 8."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider the sum of the first n natural numbers.",
      "You can also use XOR to find the missing number."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Can Place Flowers",
    "description": "You have a flowerbed in which some plots are planted and some are not. However, flowers cannot be planted in adjacent plots. Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Simulation"
    ],
    "input_format": "An array of integers flowerbed and an integer n.",
    "output_format": "A boolean value indicating if n flowers can be planted.",
    "constraints": [
      "1 <= flowerbed.length <= 2 * 10^4",
      "flowerbed[i] is 0 or 1",
      "0 <= n <= flowerbed.length"
    ],
    "examples": [
      {
        "input": "flowerbed = [1,0,0,0,1], n = 1",
        "output": "true",
        "explanation": "We can plant a flower in the second plot. So, it becomes [1,1,0,0,1]."
      },
      {
        "input": "flowerbed = [1,0,0,0,1], n = 2",
        "output": "false",
        "explanation": "It's not possible to plant 2 flowers as they would be adjacent."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how to check for adjacent empty plots.",
      "You may need to iterate through the flowerbed array."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Largest Rectangle in Histogram",
    "description": "Given an array of integers representing the heights of bars in a histogram, find the area of the largest rectangle that can be formed within the histogram. The rectangle must align with the bars and can extend across multiple bars of varying heights.",
    "topic": "Array",
    "subtopic": "Stack",
    "tags": [
      "Array",
      "Stack",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers heights where heights[i] represents the height of the ith bar.",
    "output_format": "An integer representing the area of the largest rectangle that can be formed.",
    "constraints": [
      "1 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [2, 1, 5, 6, 2, 3]",
        "output": "10",
        "explanation": "The largest rectangle has an area of 10 with height 5 and width 2."
      },
      {
        "input": "heights = [2, 4]",
        "output": "4",
        "explanation": "The largest rectangle can be formed by the second bar with height 4 and width 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to keep track of indexes of the bars.",
      "Pop from the stack to calculate area when a smaller bar is found."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Rising Temperature",
    "description": "Given an array of daily temperatures, return an array such that input[i] is the number of days you have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.",
    "topic": "Array",
    "subtopic": "Monotonic Stack",
    "tags": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "input_format": "An array of integers, temperatures, where 1 <= temperatures.length <= 30000 and 30 <= temperatures[i] <= 100.",
    "output_format": "An array of integers representing the number of days until a warmer temperature.",
    "constraints": [
      "1 <= temperatures.length <= 30000",
      "30 <= temperatures[i] <= 100"
    ],
    "examples": [
      {
        "input": "temperatures = [73, 74, 75, 71, 69, 72, 76, 73]",
        "output": "[1, 1, 4, 2, 1, 1, 0, 0]",
        "explanation": "For each day, we find the number of days until a warmer temperature. For day index 0 (73 degrees), we wait 1 day for 74 degrees, and so on."
      },
      {
        "input": "temperatures = [30, 40, 50, 60]",
        "output": "[1, 1, 1, 0]",
        "explanation": "Each day is warmer than the previous one, so we have to wait 1 day for each of the first three days, and 0 for the last day."
      },
      {
        "input": "temperatures = [100, 90, 80, 70]",
        "output": "[0, 0, 0, 0]",
        "explanation": "There are no warmer days, thus the output is all zeros."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of the indices of the temperatures.",
      "Pop elements from the stack when you find a warmer temperature."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Edit Distance",
    "description": "Given two strings s1 and s2, return the minimum number of operations required to convert s1 to s2. The allowed operations are insert a character, delete a character, or replace a character.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "Strings",
      "Edit Distance"
    ],
    "input_format": "Two strings, s1 and s2, where 0 <= |s1|, |s2| <= 1000.",
    "output_format": "An integer representing the minimum edit distance between s1 and s2.",
    "constraints": [
      "0 <= s1.length, s2.length <= 1000",
      "s1 and s2 consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s1 = 'horse', s2 = 'ros'",
        "output": "3",
        "explanation": "The minimum operations to convert 'horse' to 'ros' are: 'horse' -> 'rose' (replace 'h' with 'r') -> 'ros' (remove 'e')."
      },
      {
        "input": "s1 = 'intention', s2 = 'execution'",
        "output": "5",
        "explanation": "The minimum operations to convert 'intention' to 'execution' are: 'intention' -> 'exintention' (insert 'ex') -> 'exectention' (replace 'n' with 'e') -> 'executention' (replace 'n' with 'u') -> 'execution' (remove 't')."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to solve the problem.",
      "Use a 2D array to track the minimum operations for substrings."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Remove K Digits",
    "description": "Given a non-negative integer num represented as a string and an integer k, remove k digits from the number to create the smallest possible number. The result should not have leading zeros unless the final result is '0'.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Greedy",
      "Stack"
    ],
    "input_format": "A string num representing a non-negative integer and an integer k.",
    "output_format": "A string representing the smallest possible number after removing k digits.",
    "constraints": [
      "1 <= num.length <= 10^5",
      "0 <= k < num.length"
    ],
    "examples": [
      {
        "input": "num = \"1432219\", k = 3",
        "output": "\"1219\"",
        "explanation": "Removing the digits '4', '3', and '2' gives us '1219', which is the smallest number possible."
      },
      {
        "input": "num = \"10200\", k = 1",
        "output": "\"200\"",
        "explanation": "Removing '1' leaves us with '0200'. Removing leading zeros gives us '200'."
      },
      {
        "input": "num = \"10\", k = 1",
        "output": "\"0\"",
        "explanation": "Removing '1' or '0' results in an empty string, which is treated as '0'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to help determine the order of digits.",
      "Consider removing digits when a larger digit precedes a smaller one."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Design Browser History",
    "description": "Implement a simple browser history management system that can support the following operations: visiting a new URL, going back a specified number of pages, and going forward a specified number of pages. You need to create a class `BrowserHistory` that supports these operations efficiently.",
    "topic": "Design",
    "subtopic": "Data Structure",
    "tags": [
      "Design",
      "Data Structure",
      "Linked List"
    ],
    "input_format": "The input consists of operations to be performed on the BrowserHistory class.",
    "output_format": "The result of the 'back' and 'forward' operations, represented as a string for the current URL.",
    "constraints": [
      "At most 1000 operations will be performed.",
      "The initial URL will be a valid URL.",
      "Back and forward operations should not exceed the bounds of the history."
    ],
    "examples": [
      {
        "input": [
          "BrowserHistory(\"leetcode.com\")",
          "visit(\"google.com\")",
          "visit(\"facebook.com\")",
          "visit(\"youtube.com\")",
          "back(1)",
          "back(1)",
          "forward(1)",
          "visit(\"linkedin.com\")",
          "forward(2)",
          "back(2)",
          "back(7)"
        ],
        "output": [
          "facebook.com",
          "google.com",
          "linkedin.com",
          "leetcode.com"
        ],
        "explanation": "At each step, we maintain the current URL and handle the back and forward operations using a simple list."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a data structure that allows for efficient back and forward navigation.",
      "A doubly linked list could be beneficial for this task."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Min Stack",
    "description": "Design a stack that supports the following operations in constant time: push, pop, top, and retrieve the minimum element. Implement a MinStack class with the following methods: \n1. void push(int x): Pushes the element x onto the stack. \n2. void pop(): Removes the element on the top of the stack. \n3. int top(): Gets the top element of the stack. \n4. int getMin(): Retrieves the minimum element in the stack.",
    "topic": "Stack",
    "subtopic": "Data Structure Design",
    "tags": [
      "Stack",
      "Data Structures",
      "Design"
    ],
    "input_format": "Each operation is provided as a method call.",
    "output_format": "The output for top() and getMin() methods should return an integer value.",
    "constraints": [
      "The number of calls to push, pop, top, and getMin is at most 1000.",
      "All the calls to pop and top are valid."
    ],
    "examples": [
      {
        "input": [
          "MinStack obj = new MinStack();",
          "obj.push(-2);",
          "obj.push(0);",
          "obj.push(-3);",
          "obj.getMin();   // return -3",
          "obj.pop();",
          "obj.top();      // return 0",
          "obj.getMin();   // return -2"
        ],
        "output": "[-3, 0, -2]",
        "explanation": "After pushing -2, 0, and -3, the minimum is -3. After popping -3, the top is 0 and the minimum becomes -2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use an additional stack to keep track of minimum values.",
      "Push the current minimum to the min stack whenever you push an element."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Restore IP Addresses",
    "description": "Given a string s containing only digits, restore it by returning all possible valid IP address combinations. A valid IP address consists of four numbers (each between 0 and 255), separated by dots. Leading zeros are not allowed in any part of the IP address.",
    "topic": "Backtracking",
    "subtopic": "String Manipulation",
    "tags": [
      "Backtracking",
      "String",
      "IP Address"
    ],
    "input_format": "A string s representing a sequence of digits.",
    "output_format": "A list of valid IP address combinations.",
    "constraints": [
      "0 < s.length <= 20",
      "s only contains digits."
    ],
    "examples": [
      {
        "input": "s = \"25525511135\"",
        "output": "[\"255.255.11.135\", \"255.255.111.35\"]",
        "explanation": "The valid IP addresses formed from the string are 255.255.11.135 and 255.255.111.35."
      },
      {
        "input": "s = \"0000\"",
        "output": "[\"0.0.0.0\"]",
        "explanation": "The only valid IP address formed from the string is 0.0.0.0."
      },
      {
        "input": "s = \"1111\"",
        "output": "[\"1.1.1.1\"]",
        "explanation": "The only valid IP address formed from the string is 1.1.1.1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how the segments of the address can be formed.",
      "Explore segments of different lengths for each part of the IP."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Validate IP Address",
    "description": "Write a function that takes a string input and determines whether it is a valid IPv4 or IPv6 address. An IPv4 address consists of four octets separated by dots, where each octet is a decimal number between 0 and 255. An IPv6 address consists of eight groups of four hexadecimal digits, separated by colons.",
    "topic": "String",
    "subtopic": "Validation",
    "tags": [
      "String",
      "Validation",
      "IP Address"
    ],
    "input_format": "A string representing the IP address.",
    "output_format": "A string: 'IPv4' if it's a valid IPv4 address, 'IPv6' if it's a valid IPv6 address, or 'Neither' if it isn't valid.",
    "constraints": [
      "The input string can have a length between 1 and 39 characters."
    ],
    "examples": [
      {
        "input": "192.168.1.1",
        "output": "IPv4",
        "explanation": "This is a valid IPv4 address as it has four octets and each octet is between 0 and 255."
      },
      {
        "input": "2001:0db8:85a3:0000:0000:8a2e:0370:7334",
        "output": "IPv6",
        "explanation": "This is a valid IPv6 address as it consists of eight groups of four hexadecimal digits."
      },
      {
        "input": "256.100.50.25",
        "output": "Neither",
        "explanation": "This is neither a valid IPv4 nor IPv6 address as the first octet exceeds 255."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using regex to validate the format.",
      "IPv4 could be checked by splitting on '.' and ensuring conditions for each part."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Reverse Words in a String",
    "description": "Given an input string, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in the output string should be separated by a single space, and there should not be any leading or trailing spaces.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Reverse"
    ],
    "input_format": "A string 's' containing words separated by spaces.",
    "output_format": "A string representing the words of 's' in reverse order.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of English letters, digits, punctuation, and spaces."
    ],
    "examples": [
      {
        "input": "s = 'Hello World'",
        "output": "'World Hello'",
        "explanation": "The words 'Hello' and 'World' are reversed."
      },
      {
        "input": "s = '  Goodbye   John  '",
        "output": "'John Goodbye'",
        "explanation": "Leading and trailing spaces are removed, and words are reversed."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Trim the input string first.",
      "Split the string by spaces to get individual words.",
      "Reverse the list of words and join them to get the result."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Pascal's Triangle",
    "description": "Given a non-negative integer numRows, generate the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it. For example, the first few rows are:\n\n```\n     1\n    1 1\n   1 2 1\n  1 3 3 1\n 1 4 6 4 1\n```\nThe triangle can be constructed iteratively, where each row has one more element than the previous row.",
    "topic": "Array",
    "subtopic": "Building Structures",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Triangle"
    ],
    "input_format": "A single integer numRows representing the number of rows to generate.",
    "output_format": "A list of lists of integers representing the rows of Pascal's triangle.",
    "constraints": [
      "0 <= numRows <= 30"
    ],
    "examples": [
      {
        "input": "numRows = 5",
        "output": "[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
        "explanation": "The first 5 rows of Pascal's triangle is as follows:\n1\n1 1\n1 2 1\n1 3 3 1\n1 4 6 4 1."
      },
      {
        "input": "numRows = 1",
        "output": "[[1]]",
        "explanation": "The first row of Pascal's triangle contains only the number 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Each row's first and last elements are always 1.",
      "Use the previous row to calculate the current row."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Jump Game",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length from that position. Your goal is to determine if you can reach the last index starting from the first index. Return true if you can reach the last index, otherwise return false.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "A boolean value indicating whether it is possible to reach the last index.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "true",
        "explanation": "You can jump 2 steps to reach index 1, then jump 2 steps to the last index."
      },
      {
        "input": "nums = [3, 2, 1, 0, 4]",
        "output": "false",
        "explanation": "You will always get stuck at index 3, since you cannot jump to index 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Keep track of the farthest position you can reach.",
      "If at any index you can reach the end, return true."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Unique Paths II",
    "description": "A robot is located at the top-left corner of a m x n grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. However, some cells in the grid are obstacles that the robot cannot pass through. Given an m x n grid where 0 represents a free cell and 1 represents an obstacle, return the number of unique paths the robot can take to reach the bottom-right corner.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Path Counting"
    ],
    "input_format": "A 2D grid represented as a list of lists, where grid[i][j] is either 0 (free) or 1 (obstacle).",
    "output_format": "An integer representing the number of unique paths from the top-left to the bottom-right corner.",
    "constraints": [
      "1 <= m, n <= 100",
      "grid[i][j] is 0 or 1.",
      "The starting cell grid[0][0] and the ending cell grid[m-1][n-1] will not be obstacles."
    ],
    "examples": [
      {
        "input": "grid = [[0,0,0],[0,1,0],[0,0,0]]",
        "output": "2",
        "explanation": "There are two unique paths to reach the bottom-right corner: down -> down -> right -> right and right -> right -> down -> down."
      },
      {
        "input": "grid = [[0,1],[0,0]]",
        "output": "1",
        "explanation": "There is only one unique path: down -> right."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dynamic programming table to store the number of paths to each cell.",
      "If a cell is an obstacle, there are no paths through that cell.",
      "You can only arrive at a cell from the left or above."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Subsequence",
    "description": "Given a string s, find the length of the longest subsequence that is a palindrome. A subsequence is a sequence derived by deleting some or no elements without changing the order of the remaining elements. A palindrome is a string that reads the same forward and backward.",
    "topic": "Dynamic Programming",
    "subtopic": "Subsequence",
    "tags": [
      "Dynamic Programming",
      "String",
      "Palindrome"
    ],
    "input_format": "A string s with length n.",
    "output_format": "An integer representing the length of the longest palindromic subsequence.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only uppercase and lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = \"bbbab\"",
        "output": "4",
        "explanation": "One possible longest palindromic subsequence is \"bbbb\" which has a length of 4."
      },
      {
        "input": "s = \"cbbd\"",
        "output": "2",
        "explanation": "One possible longest palindromic subsequence is \"bb\" which has a length of 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to solve the problem.",
      "The problem can be reduced to finding the longest common subsequence."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Count of Integers",
    "description": "You are given an integer array nums and an integer target. Your task is to count how many integers in the array are equal to the target. This count should take into account all occurrences of the target in the array. If the target does not exist in the array, return 0.",
    "topic": "Array",
    "subtopic": "Counting Elements",
    "tags": [
      "Array",
      "Counting",
      "Search"
    ],
    "input_format": "An integer array nums followed by an integer target.",
    "output_format": "An integer representing the count of occurrences of the target in the array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i], target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 2, 2], target = 2",
        "output": "3",
        "explanation": "The number 2 appears three times in the array."
      },
      {
        "input": "nums = [1, 1, 1, 1, 1], target = 5",
        "output": "0",
        "explanation": "The number 5 does not appear in the array, hence the count is 0."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a loop to iterate through the array.",
      "A counter variable can help track the occurrences."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Beautiful Arrangement",
    "description": "A beautiful arrangement is an arrangement of numbers from 1 to N such that for each number i at the ith position, either i is divisible by the number at that position or the number at that position is divisible by i. Given an integer N, return the total number of different beautiful arrangements that can be formed using these numbers.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Permutations",
      "Counting"
    ],
    "input_format": "An integer N (1 <= N <= 15), the total numbers to arrange.",
    "output_format": "An integer representing the total number of beautiful arrangements.",
    "constraints": [
      "1 <= N <= 15"
    ],
    "examples": [
      {
        "input": "N = 2",
        "output": "2",
        "explanation": "The two arrangements are: [1, 2] and [2, 1]. Both satisfy the beautiful arrangement condition."
      },
      {
        "input": "N = 1",
        "output": "1",
        "explanation": "Only one way to arrange [1], hence the count is 1."
      },
      {
        "input": "N = 3",
        "output": "3",
        "explanation": "The arrangements are [1, 2, 3], [1, 3, 2] and [2, 1, 3]. All satisfy the conditions."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to use backtracking to explore all possible arrangements.",
      "Use recursion to generate permutations and check the beautiful arrangement conditions."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase that has n steps. You can either take 1 step or 2 steps at a time. Given n, how many distinct ways can you climb to the top of the staircase?",
    "topic": "Dynamic Programming",
    "subtopic": "Fibonacci Sequence",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Fibonacci"
    ],
    "input_format": "An integer n representing the number of steps in the staircase.",
    "output_format": "An integer representing the number of distinct ways to climb to the top.",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb the staircase: take 1 step + 1 step or take 2 steps at once."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb the staircase: (1, 1, 1), (1, 2), (2, 1)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider the last step when you reach the top.",
      "The number of ways to reach the nth step is the sum of the ways to reach the (n-1)th and (n-2)th steps."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Number of 1 Bits",
    "description": "Given an integer n, return the number of '1' bits it has (also known as the Hamming weight). Note that the input must be treated as an unsigned integer.",
    "topic": "Bit Manipulation",
    "subtopic": "Counting Bits",
    "tags": [
      "Bit Manipulation",
      "Counting",
      "Hamming Weight"
    ],
    "input_format": "An integer n (0 <= n <= 2^31 - 1).",
    "output_format": "An integer representing the number of '1' bits in the binary representation of n.",
    "constraints": [
      "0 <= n <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "n = 11",
        "output": "3",
        "explanation": "The binary representation of 11 is '1011', which has three '1' bits."
      },
      {
        "input": "n = 128",
        "output": "1",
        "explanation": "The binary representation of 128 is '10000000', which has one '1' bit."
      },
      {
        "input": "n = 7",
        "output": "3",
        "explanation": "The binary representation of 7 is '111', which has three '1' bits."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Check each bit using bitwise operations.",
      "You can use n & 1 to check if the last bit is '1'."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Maximum Product of Two Elements in an Array",
    "description": "Given an integer array nums, return the maximum product of any two distinct elements in the array. The product of two integers x and y is defined as x * y.",
    "topic": "Array",
    "subtopic": "Mathematics",
    "tags": [
      "Array",
      "Mathematics",
      "Product"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum product of any two distinct elements in the array.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-1000 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [3, 5, 1, 7]",
        "output": "35",
        "explanation": "The maximum product is 5 * 7 = 35."
      },
      {
        "input": "nums = [-10, -3, 5, 6]",
        "output": "60",
        "explanation": "The maximum product is 5 * 6 = 30. Negative numbers yield a product when paired."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider the two largest numbers to find the maximum product.",
      "If negative numbers are present, consider the product of the two smallest numbers."
    ],
    "company": "Cisco"
  },
  {
    "question_id": "",
    "title": "Sliding Window Maximum",
    "description": "Given an array of integers nums and an integer k, return the maximum sliding window of size k over the array. A sliding window is defined as a contiguous subarray of size k. The maximum value within the window should be returned for each position of the sliding window as it moves from left to right.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Queue"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An array of integers representing the maximum values in each sliding window.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3",
        "output": "[3, 3, 5, 5, 6, 7]",
        "explanation": "The sliding windows of size 3 are [1, 3, -1], [3, -1, -3], [-1, -3, 5], [-3, 5, 3], [5, 3, 6], [3, 6, 7]. The maximums are 3, 3, 5, 5, 6, and 7."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "There's only one element in the array, which is also the maximum."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a data structure that allows you to efficiently find the maximum.",
      "Think about the properties of the sliding window and how elements enter and exit the window."
    ],
    "company": "Cisco"
  }
]