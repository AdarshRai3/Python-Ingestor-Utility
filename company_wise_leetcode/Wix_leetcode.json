[
  {
    "question_id": "",
    "title": "Integer to Roman",
    "description": "Given an integer, convert it to a roman numeral. Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. For example, the integer 3 is represented as 'III' in Roman numeral, just as 58 is represented as 'LVIII', and 1994 is represented as 'MCMXCIV'. You need to convert the given integer into its corresponding Roman numeral representation.",
    "topic": "Mathematics",
    "subtopic": "String Conversion",
    "tags": [
      "Math",
      "Strings",
      "Conversion"
    ],
    "input_format": "An integer num (1 <= num <= 3999).",
    "output_format": "A string representing the Roman numeral equivalent of the given integer.",
    "constraints": [
      "1 <= num <= 3999"
    ],
    "examples": [
      {
        "input": "num = 3",
        "output": "III",
        "explanation": "3 is represented as 'III' in Roman numeral."
      },
      {
        "input": "num = 58",
        "output": "LVIII",
        "explanation": "58 is represented as 'LVIII' in Roman numeral. (L = 50, V = 5, III = 3)"
      },
      {
        "input": "num = 1994",
        "output": "MCMXCIV",
        "explanation": "1994 is represented as 'MCMXCIV' in Roman numeral. (M = 1000, CM = 900, XC = 90, IV = 4)"
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Break down numbers into Roman numeral components.",
      "Use subtraction for numbers like 4 and 9."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. For example, if the input is [[1,3],[2,6],[8,10],[15,18]], the output should be [[1,6],[8,10],[15,18]] since the intervals [1,3] and [2,6] overlap and can be merged into [1,6].",
    "topic": "Array",
    "subtopic": "Sorting and Merging",
    "tags": [
      "Array",
      "Sorting",
      "Intervals"
    ],
    "input_format": "A list of intervals, where each interval is represented as a pair of integers [start, end].",
    "output_format": "A list of merged intervals, represented as pairs of integers.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^5"
    ],
    "examples": [
      {
        "input": "[[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "The intervals [1,3] and [2,6] overlap and can be merged into [1,6]."
      },
      {
        "input": "[[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "The intervals [1,4] and [4,5] touch but are considered overlapping."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on the starting points.",
      "Use a loop to check for overlaps, merging intervals as necessary."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "DFS",
      "Graph",
      "Matrix"
    ],
    "input_format": "A 2D binary grid represented as a list of lists where each element is either '0' or '1'.",
    "output_format": "An integer representing the number of islands.",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[0].length <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "[['1','1','1','1','0'], ['1','1','0','1','0'], ['1','1','0','0','0'], ['0','0','0','0','0']]",
        "output": "1",
        "explanation": "The grid forms a single island."
      },
      {
        "input": "[['1','1','0','0','0'], ['1','1','0','0','0'], ['0','0','1','0','0'], ['0','0','0','1','1']]",
        "output": "3",
        "explanation": "The grid contains three islands."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use Depth-First Search (DFS) to explore the island.",
      "Mark visited land as water to avoid counting the same island multiple times."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A substring is a contiguous sequence of characters within the string. A palindrome is a string that reads the same backward as forward.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A single string s, where 1 <= s.length <= 1000.",
    "output_format": "A string representing the longest palindromic substring.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only digits and English letters."
    ],
    "examples": [
      {
        "input": "babad",
        "output": "bab",
        "explanation": "Both 'bab' and 'aba' are valid longest palindromic substrings. The output can be either."
      },
      {
        "input": "cbbd",
        "output": "bb",
        "explanation": "'bb' is the longest palindromic substring in this case."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding around potential centers of palindromes.",
      "Remember that palindromes can be even or odd in length."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with the x-axis form a container, such that the container contains the most water. Note that you may not slant the container.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Mathematics"
    ],
    "input_format": "An array of non-negative integers representing the heights of the lines.",
    "output_format": "An integer representing the maximum area of water the container can hold.",
    "constraints": [
      "2 <= height.length <= 10^5",
      "0 <= height[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The lines at index 1 and index 8 form the container with most water."
      },
      {
        "input": "height = [1,1]",
        "output": "1",
        "explanation": "The only container formed by the two lines both at height 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using two pointers to find the maximum area efficiently.",
      "The area is determined by the shorter line."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contains a single digit. Add the two numbers and return it as a linked list. The result should be returned in the same reverse order format.",
    "topic": "Linked List",
    "subtopic": "Addition",
    "tags": [
      "Linked List",
      "Addition",
      "Mathematics"
    ],
    "input_format": "Two linked lists, l1 and l2, representing the two numbers.",
    "output_format": "A linked list representing the sum of the two numbers.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the input lists are non-empty."
    ],
    "examples": [
      {
        "input": "l1 = [2,4,3], l2 = [5,6,4]",
        "output": "[7,0,8]",
        "explanation": "The numbers are 342 and 465. Their sum is 807, represented as [7,0,8] in reverse order."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "Both numbers are 0, so the sum is also 0, represented as [0]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a carry variable to handle sums greater than 9.",
      "Iterate through both lists until you reach the end of both."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Unique Email Addresses",
    "description": "Every email consists of a local name and a domain name, separated by the '@' sign. For example, in 'alice@leetcode.com', 'alice' is the local name, and 'leetcode.com' is the domain name. There are some rules for processing email addresses: 1. A local name can be an empty string or may contain letters, digits, and certain special characters ('.', '+'). 2. The '+' sign is used to indicate that anything after it should be ignored, and the '.' characters are ignored as well. For instance, 'alice.z@leetcode.com' and 'alicez@leetcode.com' both represent the same local name 'alicez'. Your task is to count the number of unique email addresses after applying the above rules.",
    "topic": "String Manipulation",
    "subtopic": "Email Processing",
    "tags": [
      "String",
      "Set",
      "HashMap"
    ],
    "input_format": "A list of strings representing email addresses.",
    "output_format": "An integer representing the count of unique email addresses.",
    "constraints": [
      "1 <= emails.length <= 1000",
      "Each email is guaranteed to be a valid email address."
    ],
    "examples": [
      {
        "input": "emails = [\"test.email+alex@leetcode.com\", \"test.e.mail+bob@yahoo.com\", \"testemail+david@lee.tcode.com\"]",
        "output": "2",
        "explanation": "The processed unique email addresses are 'testemail@leetcode.com' and 'testemail@yahoo.com'."
      },
      {
        "input": "emails = [\"a@leetcode.com\", \"b@leetcode.com\", \"c@leetcode.com\"]",
        "output": "3",
        "explanation": "All email addresses are unique."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "You can use a set to store unique email addresses.",
      "Make sure to correctly handle '+' and '.' in the local name."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Binary Tree Maximum Path Sum",
    "description": "Given a non-empty binary tree, find the maximum path sum. The path may start and end at any node in the tree. The path must contain at least one node and does not need to go through the root.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "DFS",
      "Divide and Conquer"
    ],
    "input_format": "A binary tree represented as a root node of type TreeNode, where each TreeNode has an integer value and left and right children.",
    "output_format": "An integer representing the maximum path sum.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 3 * 10^4].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [-10,9,20,null,null,15,7]",
        "output": "42",
        "explanation": "The maximum path sum is 15 + 20 + 7 = 42."
      },
      {
        "input": "root = [1,2,3]",
        "output": "6",
        "explanation": "The maximum path sum is 2 + 1 + 3 = 6."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Think about how to calculate the maximum path sum by combining subproblems.",
      "Consider using a recursive approach to explore each node."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "All Nodes Distance K in Binary Tree",
    "description": "Given the root of a binary tree, the value of a target node, and an integer K, return the values of all nodes that are K distance away from the target node. You can assume that there are no duplicate values in the binary tree. The distance between two nodes is the number of edges in the path connecting them.",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Binary Tree",
      "Depth-First Search",
      "Breadth-First Search"
    ],
    "input_format": "The first input is a binary tree represented by its root node and the second input is an integer target denoting the value of the target node, and the third input is an integer K.",
    "output_format": "A list of integers representing the values of all nodes that are K distance away from the target node.",
    "constraints": [
      "The binary tree has at most 1000 nodes.",
      "Each node's value is unique.",
      "0 <= K <= the maximum depth of the tree."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, 4, 5, null, 6], target = 2, K = 1",
        "output": "[1, 4, 5]",
        "explanation": "The nodes that are 1 distance away from the target node 2 are 1 (its parent), 4 (its left child), and 5 (its left child's sibling)."
      },
      {
        "input": "root = [1], target = 1, K = 0",
        "output": "[1]",
        "explanation": "The only node is the target itself, and it's 0 distance away."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use DFS or BFS to traverse the tree.",
      "Keep track of the parent nodes to find nodes at distance K.",
      "Consider edge cases like leaf nodes and the root node."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Clone Graph",
    "description": "Given a reference to a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors. The graph is guaranteed to be connected, and there are no cycles. In the cloned graph, the value of each node and its neighbors should be the same as the original graph.",
    "topic": "Graph",
    "subtopic": "Graph Traversal",
    "tags": [
      "Depth First Search",
      "Breadth First Search",
      "Graph"
    ],
    "input_format": "A reference to a node in the graph.",
    "output_format": "A reference to the cloned graph's node.",
    "constraints": [
      "1 <= Node.val <= 100",
      "Node.val is unique for each node in the graph.",
      "The graph is guaranteed to be connected.",
      "The number of nodes in the graph is between 1 and 100."
    ],
    "examples": [
      {
        "input": "adjacent list: [[2,4],[1,3],[2,4],[1,3]]",
        "output": "A clone of the input graph.",
        "explanation": "The graph has 4 nodes. The first node has neighbors 2 and 4. The output should return a new graph that replicates the structure of the original."
      },
      {
        "input": "[[1],[1]]",
        "output": "A clone of the input graph.",
        "explanation": "The graph is a simple case where there are two nodes connected to each other. The output should notably have the same structure and values."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to track copied nodes.",
      "Consider using DFS or BFS for traversal.",
      "Make sure to clone each node's neighbors."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Is Subsequence",
    "description": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.",
    "topic": "Strings",
    "subtopic": "Subsequence",
    "tags": [
      "String",
      "Two Pointers",
      "Subsequence"
    ],
    "input_format": "Two strings s and t.",
    "output_format": "A boolean value: true if s is a subsequence of t, false otherwise.",
    "constraints": [
      "0 <= s.length <= 100",
      "0 <= t.length <= 10^4",
      "s and t consist only of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = \"abc\", t = \"ahbgdc\"",
        "output": "true",
        "explanation": "The characters 'a', 'b', and 'c' can be found in t in the same order, hence s is a subsequence of t."
      },
      {
        "input": "s = \"axc\", t = \"ahbgdc\"",
        "output": "false",
        "explanation": "Although 'a' and 'c' are present in t, they are not in the correct order, hence s is not a subsequence of t."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers to traverse both strings.",
      "If a character in s matches the current character in t, move to the next character in s."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Employees Earning More Than Their Managers",
    "description": "You are given a database of employee records, where each record contains the employee's id, salary, and their manager's id. Your task is to find all employees who earn more than their managers. The result should return the ids of these employees in any order.",
    "topic": "Database",
    "subtopic": "SQL Queries",
    "tags": [
      "SQL",
      "Database",
      "Join"
    ],
    "input_format": "A table named Employees with three columns: id (int), salary (int), manager_id (int).",
    "output_format": "A list of integers representing the ids of employees who earn more than their managers.",
    "constraints": [
      "1 <= id <= 10^5",
      "0 <= salary <= 10^6",
      "manager_id is either a valid employee id or NULL"
    ],
    "examples": [
      {
        "input": "Employees = [[1, 1000, 2], [2, 2000, NULL], [3, 1500, 2]]",
        "output": "[1, 3]",
        "explanation": "Employee 1 earns 1000 and their manager (id 2) earns 2000, so employee 1 does not qualify. Employee 3 earns 1500 and their manager (id 2) earns 2000, so employee 3 does not qualify either. Therefore, the only employee who meets the criteria is employee 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a JOIN operation to relate employees to their managers.",
      "Filter the results where the employee's salary is greater than the manager's salary."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Verifying an Alien Dictionary",
    "description": "In an alien language, there is a unique order of characters. Given a list of words sorted lexicographically by the alien language, validate whether the given words are sorted correctly based on the alien character order.",
    "topic": "String",
    "subtopic": "Sorting",
    "tags": [
      "String",
      "Sorting",
      "Validation"
    ],
    "input_format": "A string representing the order of characters in the alien language, followed by a list of words to be checked for their sorted order.",
    "output_format": "A boolean value indicating whether the words are sorted based on the alien dictionary order.",
    "constraints": [
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 100",
      "The order string contains no duplicates and includes all unique characters of the input words."
    ],
    "examples": [
      {
        "input": "order = \"hlabcdefgijkmnopqrstuvwxyz\", words = [\"hello\", \"leetcode\"]",
        "output": "true",
        "explanation": "The word 'hello' comes before 'leetcode' in the alien dictionary."
      },
      {
        "input": "order = \"worldabcefghijkmnpqtuvwxyz\", words = [\"word\", \"world\", \"row\"]",
        "output": "false",
        "explanation": "The word 'world' should come after 'word', hence the order is incorrect."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Create a mapping of characters to their ranks based on the given order.",
      "Compare the words character by character to determine their order."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Binary Tree Right Side View",
    "description": "Given the root of a binary tree, imagine you can view the tree from the right side. Return the values of the nodes you can see ordered from top to bottom.",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Binary Tree",
      "DFS",
      "BFS"
    ],
    "input_format": "A binary tree node represented as root.",
    "output_format": "A list of integers representing the values of the nodes visible from the right side.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, null, 5, null, 4]",
        "output": "[1, 3, 4]",
        "explanation": "From the right side, we can see nodes 1, 3, and 4."
      },
      {
        "input": "root = [1, null, 3]",
        "output": "[1, 3]",
        "explanation": "From the right side, we can see nodes 1 and 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to perform level order traversal.",
      "Keep track of the last node in each level to determine visibility."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Longest String Chain",
    "description": "Given a list of words, find the length of the longest possible string chain. A string chain is defined such that each word in the chain is formed by adding one letter to the previous word, and the words must exist in the given list. For example, if 'a' is a valid word, then 'ab' can follow 'a' if it exists in the list.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Memoization"
    ],
    "input_format": "An array of strings words, where 1 <= words.length <= 1000.",
    "output_format": "An integer representing the length of the longest string chain.",
    "constraints": [
      "1 <= words[i].length <= 16",
      "The total number of characters in all words combined does not exceed 2000."
    ],
    "examples": [
      {
        "input": "words = ['a', 'b', 'ba', 'bca', 'bda', 'bdca']",
        "output": "5",
        "explanation": "The longest chain is 'a' -> 'ba' -> 'bda' -> 'bdca', which has a length of 5."
      },
      {
        "input": "words = ['xbc', 'b', 'xbcde', 'abc', 'ab', 'a']",
        "output": "4",
        "explanation": "The longest chain is 'a' -> 'ab' -> 'abc' -> 'xbc', which has a length of 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hashmap to store the longest chain ending at each word.",
      "Sort the words by length to build chains progressively."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Lowest Common Ancestor of a Binary Tree",
    "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: \"The lowest common ancestor is defined between two nodes p and q as the lowest node in the tree that has both p and q as descendants (where we allow a node to be a descendant of itself).\"",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "DFS"
    ],
    "input_format": "The input consists of the root of the binary tree and two nodes p and q.",
    "output_format": "Return the lowest common ancestor of nodes p and q.",
    "constraints": [
      "The number of nodes in the tree is in the range [2, 10^5].",
      "All node values are unique.",
      "p and q are values of nodes in the binary tree."
    ],
    "examples": [
      {
        "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1",
        "output": "3",
        "explanation": "The LCA of nodes 5 and 1 is 3."
      },
      {
        "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4",
        "output": "5",
        "explanation": "The LCA of nodes 5 and 4 is 5 because 5 is an ancestor of 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use depth-first search to traverse the tree.",
      "If you find either p or q, return that node.",
      "If both nodes are found in different subtrees, the current node is the LCA."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Shortest Word Distance",
    "description": "Given a list of words and two words 'word1' and 'word2', return the shortest distance between the indices of 'word1' and 'word2'. If either word does not exist in the list, return -1. The distance is defined as the absolute difference between their indices in the list.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "String"
    ],
    "input_format": "A list of strings 'words', and two strings 'word1' and 'word2'.",
    "output_format": "An integer representing the shortest distance between 'word1' and 'word2'.",
    "constraints": [
      "1 <= words.length <= 1000",
      "1 <= words[i].length <= 100",
      "words[i] consists of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"coding\", word2 = \"practice\"",
        "output": "3",
        "explanation": "The indices of 'coding' is 3 and 'practice' is 0. The distance is |3 - 0| = 3."
      },
      {
        "input": "words = [\"hello\", \"world\", \"hello\", \"LeetCode\"], word1 = \"hello\", word2 = \"world\"",
        "output": "1",
        "explanation": "The indices of 'hello' are 0 and 2, while 'world' is at index 1. The minimum distance is |0 - 1| = 1."
      },
      {
        "input": "words = [\"a\", \"b\", \"c\", \"a\"], word1 = \"a\", word2 = \"d\"",
        "output": "-1",
        "explanation": "Since 'd' is not in the list, the output is -1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash map to store the indices of the words.",
      "Iterate through the list to find the indices of the words."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "K Closest Points to Origin",
    "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, and an integer K, return the K closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance, which can be calculated using the formula: distance = sqrt((x2 - x1)^2 + (y2 - y1)^2). However, for the purpose of finding the K closest points, you can compare the squared distance to avoid the computational cost of the square root function. The output should be in any order.",
    "topic": "Heap",
    "subtopic": "Priority Queue",
    "tags": [
      "Heap",
      "Sorting",
      "Geometry"
    ],
    "input_format": "An array of points, where each point is represented as an array of two integers, and an integer K.",
    "output_format": "An array of K points that are closest to the origin.",
    "constraints": [
      "1 <= K <= points.length <= 10^4",
      "-10^4 <= xi, yi <= 10^4"
    ],
    "examples": [
      {
        "input": "points = [[1, 3], [-2, 2], [5, 8], [0, 1]], K = 2",
        "output": "[[-2, 2], [1, 3]]",
        "explanation": "The distances from the origin are sqrt(1^2 + 3^2) = sqrt(10), sqrt((-2)^2 + 2^2) = sqrt(8), sqrt(5^2 + 8^2) = sqrt(89), and sqrt(0^2 + 1^2) = 1. The 2 closest points are [-2, 2] and [1, 3]."
      },
      {
        "input": "points = [[3, 3], [5, -1], [-2, 4]], K = 1",
        "output": "[[3, 3]]",
        "explanation": "The distance from the origin for point [3, 3] is sqrt(18), [5, -1] is sqrt(26), and [-2, 4] is sqrt(20). The closest point is [3, 3]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a priority queue (heap) to keep track of the K closest points.",
      "You can use the squared distance for comparisons to avoid floating-point arithmetic."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Invalid Transactions",
    "description": "A transaction is considered invalid if it meets any of the following criteria: \n1. The amount of the transaction exceeds $1000. \n2. The transaction occurs at a location that is more than 60 minutes away from a previous transaction by the same user. \nGiven a list of transactions, return a list of transactions that are invalid. Each transaction is represented by a string in the format 'name, amount, time, location'. \nThe transactions are sorted by time. \n\nYou should compare the locations using distance to determine if they are 'too far' or within a 60-minute window.",
    "topic": "String",
    "subtopic": "Processing and Validation",
    "tags": [
      "String",
      "Validation",
      "Transaction"
    ],
    "input_format": "A list of strings representing transactions.",
    "output_format": "A list of strings representing invalid transactions.",
    "constraints": [
      "1 <= transactions.length <= 1000",
      "Each transaction is a string formatted as 'name, amount, time, location', where name is non-empty, amount is a positive integer, time is a non-negative integer, and location is a non-empty string."
    ],
    "examples": [
      {
        "input": "[\"alice,1000,2021-12-31T23:59:59,location1\", \"alice,1001,2021-12-31T23:59:59,location2\", \"bob,500,2021-12-31T23:58:00,location3\"]",
        "output": "[\"alice,1001,2021-12-31T23:59:59,location2\"]",
        "explanation": "The transaction by Alice for amount 1001 exceeds the limit of $1000."
      },
      {
        "input": "[\"alice,500,2021-12-31T23:59:59,location1\", \"alice,200,2022-01-01T00:01:00,location2\", \"alice,1000,2022-01-01T00:02:00,location3\"]",
        "output": "[]",
        "explanation": "All transactions by Alice are valid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Keep track of the last transaction time and its location for each user.",
      "Use a data structure to efficiently find transactions by user."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Group Shifted Strings",
    "description": "Given a list of strings, you need to group the strings that can be shifted to form each other. Two strings can be shifted if you can shift the characters of the first string to form the second string (for example, 'abc' and 'bca'). Return the grouped strings in a list of lists, where each sublist contains strings that are shifted versions of each other.",
    "topic": "String",
    "subtopic": "Grouping",
    "tags": [
      "String",
      "Group",
      "Shifted"
    ],
    "input_format": "A list of strings, where each string consists of lowercase English letters.",
    "output_format": "A list of lists, where each sublist contains strings that are shifted versions of each other.",
    "constraints": [
      "1 <= strings.length <= 10^4",
      "1 <= strings[i].length <= 100"
    ],
    "examples": [
      {
        "input": "strings = ['abc', 'bca', 'acb', 'xyz', 'zyx']",
        "output": "[['abc', 'bca', 'acb'], ['xyz', 'zyx']]",
        "explanation": "The first three strings can be shifted to form each other and the last two can also be shifted to form each other."
      },
      {
        "input": "strings = ['a', 'b', 'c']",
        "output": "[['a'], ['b'], ['c']]",
        "explanation": "All strings are unique and cannot be shifted to form each other."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the character shifts in terms of their ASCII values.",
      "A helper function might be useful to determine if two strings are shifts of each other.",
      "Grouping can be done using a hash map for efficiency."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Search Suggestions System",
    "description": "You are given a list of strings 'products' representing the names of products in a store and a string 'searchWord'. You need to return a list of suggested products for each prefix of 'searchWord'. Each suggested list should contain up to 3 products that have the prefix of the respective search prefix. The suggestions should be sorted lexicographically. If there are fewer than 3 products, return all that match. If no products match the prefix, return an empty list.",
    "topic": "String",
    "subtopic": "Autocomplete",
    "tags": [
      "String",
      "Sorting",
      "Trie"
    ],
    "input_format": "A list of strings 'products' and a string 'searchWord'.",
    "output_format": "A list of lists of strings representing the suggestions for each prefix of 'searchWord'.",
    "constraints": [
      "1 <= products.length <= 1000",
      "1 <= products[i].length <= 100",
      "1 <= searchWord.length <= 100",
      "All strings in products are unique."
    ],
    "examples": [
      {
        "input": {
          "products": [
            "mobile",
            "mouse",
            "moneypot",
            "monitor",
            "mousepad"
          ],
          "searchWord": "mouse"
        },
        "output": [
          [
            "mobile",
            "moneypot",
            "monitor"
          ],
          [
            "mouse",
            "mousepad"
          ],
          [
            "mouse",
            "mousepad"
          ],
          [
            "mouse",
            "mousepad"
          ],
          [
            "mouse",
            "mousepad"
          ]
        ],
        "explanation": "The suggestions for the prefixes of 'mouse' are provided in each step."
      },
      {
        "input": {
          "products": [
            "havana"
          ],
          "searchWord": "havana"
        },
        "output": [
          [
            "havana"
          ],
          [
            "havana"
          ],
          [
            "havana"
          ],
          [
            "havana"
          ],
          [
            "havana"
          ]
        ],
        "explanation": "All suggestions point to the only available product."
      },
      {
        "input": {
          "products": [
            "bags",
            "baggage",
            "banner",
            "box",
            "cloths"
          ],
          "searchWord": "bags"
        },
        "output": [
          [
            "bags",
            "baggage",
            "banner"
          ],
          [
            "bags",
            "baggage",
            "banner"
          ],
          [
            "bags",
            "baggage",
            "banner"
          ],
          [
            "bags"
          ]
        ],
        "explanation": "All prefixes yield the three suggestions until the last character."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a Trie for efficient prefix matching.",
      "Sort the products initially before processing.",
      "Keep track of only the first three matching products."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Copy List with Random Pointer",
    "description": "You are given a linked list with the following characteristics: each node contains a value and a random pointer that may point to any node in the list or may be null. Your task is to create a deep copy of the list. Each node in the new list should have the same value as the corresponding node in the original list, and the random pointers should also be correctly assigned.",
    "topic": "Linked List",
    "subtopic": "Deep Copy",
    "tags": [
      "Linked List",
      "Deep Copy",
      "Pointers"
    ],
    "input_format": "A head node of a linked list where each node contains 'val', 'next', and 'random' pointers.",
    "output_format": "A head node of the new linked list that is a deep copy of the original list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 100].",
      "Each node's value is in the range [-10^4, 10^4]."
    ],
    "examples": [
      {
        "input": "Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "output": "Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "explanation": "The list has nodes that have random pointers pointing to other nodes in the original list, and the returned list represents the deep copy."
      },
      {
        "input": "Input: head = [[1,1],[2,1]]",
        "output": "Output: [[1,1],[2,1]]",
        "explanation": "In this case, both nodes point to the first node, and the deep copy correctly reflects this."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to store the mapping between original nodes and their copies.",
      "Carefully handle the random pointers while copying."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Validate Binary Search Tree",
    "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: the left subtree of a node contains only nodes with keys less than the node's key, the right subtree of a node contains only nodes with keys greater than the node's key, and both the left and right subtrees must also be binary search trees.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "The input consists of a root node of a binary tree.",
    "output_format": "Return true if the binary tree is a valid binary search tree, otherwise return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 104].",
      "-2^31 <= Node.val <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "root = [2,1,3]",
        "output": "true",
        "explanation": "The given tree is a valid binary search tree."
      },
      {
        "input": "root = [5,1,4,null,null,3,6]",
        "output": "false",
        "explanation": "The given tree is not a valid binary search tree because 3 is in the right subtree of 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use recursion to check the left and right subtrees.",
      "Maintain a range to validate the node values.",
      "In a DFS manner, check if every node satisfies the BST properties."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Design HashSet",
    "description": "Design a HashSet without using any built-in hash table libraries. To implement the HashSet, you should have functions such as add, remove, and contains. Your implementation should perform these operations with an average time complexity of O(1).",
    "topic": "Data Structures",
    "subtopic": "Hash Table",
    "tags": [
      "HashSet",
      "Data Structures",
      "Hash Table"
    ],
    "input_format": "The input consists of operations to be performed on the HashSet. Each operation is a string representing either 'add', 'remove', or 'contains' followed by an integer value.",
    "output_format": "For 'contains' operation, output true if the value is present in the HashSet, otherwise false.",
    "constraints": [
      "The number of operations will not exceed 1000.",
      "-10^6 <= value <= 10^6"
    ],
    "examples": [
      {
        "input": "add(1), add(2), contains(1), contains(3), remove(2), contains(2)",
        "output": "[true, false, false]",
        "explanation": "After adding 1 and 2, 'contains(1)' returns true, 'contains(3)' returns false. After removing 2, 'contains(2)' returns false."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a list or an array to store keys.",
      "Think about handling collisions for your hash table."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Intersection of Two Arrays",
    "description": "Given two arrays of integers, return an array that contains only the elements that are present in both arrays, without duplicates. You may assume that the arrays are unsorted and may contain repeated elements.",
    "topic": "Array",
    "subtopic": "Set Operations",
    "tags": [
      "Array",
      "Set",
      "Intersection"
    ],
    "input_format": "Two arrays of integers nums1 and nums2.",
    "output_format": "An array of integers representing the intersection of the two arrays, containing unique elements.",
    "constraints": [
      "1 <= nums1.length, nums2.length <= 10^4",
      "-10^9 <= nums1[i], nums2[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]",
        "output": "[2]",
        "explanation": "The only common element between the two arrays is 2."
      },
      {
        "input": "nums1 = [4, 9, 5], nums2 = [9, 4, 9, 8, 4]",
        "output": "[9, 4]",
        "explanation": "The common elements are 4 and 9."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a set to store the elements of the first array.",
      "You can then check membership of elements from the second array."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "An integer array nums.",
    "output_format": "A list of lists containing all unique triplets that sum up to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that sum up to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "No triplets can be formed from an empty array."
      },
      {
        "input": "nums = [0, 1, 1]",
        "output": "[]",
        "explanation": "No triplets are possible as there are not enough distinct numbers."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array to make it easier to avoid duplicates.",
      "Use two pointers approach to check for the pairs."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Merge Two Sorted Lists",
    "description": "You are given the heads of two sorted linked lists. Merge the two lists into one sorted linked list. The merged list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
    "topic": "Linked List",
    "subtopic": "Merging Lists",
    "tags": [
      "Linked List",
      "Merge",
      "Sorting"
    ],
    "input_format": "The input consists of two linked lists represented by their head nodes.",
    "output_format": "The output is the head of the merged linked list.",
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50].",
      "-100 <= Node.val <= 100",
      "Both lists are already sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "list1 = 1 -> 2 -> 4, list2 = 1 -> 3 -> 4",
        "output": "1 -> 1 -> 2 -> 3 -> 4 -> 4",
        "explanation": "Merging the two sorted lists results in a single sorted list."
      },
      {
        "input": "list1 = [], list2 = 0",
        "output": "0",
        "explanation": "When one list is empty, the result is the non-empty list."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a dummy node to simplify the merge process.",
      "You can compare the head nodes of both lists and attach the smaller node to the merged list."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Move Zeroes",
    "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "The modified array with all zeroes moved to the end.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [0, 1, 0, 3, 12]",
        "output": "[1, 3, 12, 0, 0]",
        "explanation": "The non-zero elements are 1, 3, and 12 which maintain their order. All zeroes are moved to the end."
      },
      {
        "input": "nums = [0, 0, 1]",
        "output": "[1, 0, 0]",
        "explanation": "Only one non-zero element, so it stays at the beginning."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to track positions for non-zero elements.",
      "You can iterate through the array and shift non-zero values."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Diameter of Binary Tree",
    "description": "Given a binary tree, find the length of the diameter of the tree. The diameter of a binary tree is defined as the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth First Search"
    ],
    "input_format": "The root node of a binary tree.",
    "output_format": "An integer representing the diameter of the binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, 4, 5]",
        "output": "3",
        "explanation": "The longest path is between node 4 and node 5, which consists of 3 edges."
      },
      {
        "input": "root = [1, 2]",
        "output": "1",
        "explanation": "The longest path is between node 2 and node 1, which consists of 1 edge."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider the height of the left and right subtrees.",
      "The diameter can be computed as the sum of left and right subtree heights."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Minimum Distance Between BST Nodes",
    "description": "Given a Binary Search Tree (BST), find the minimum absolute difference between the values of any two nodes in the tree. The minimum difference is defined as the absolute value of the difference between the values of two nodes that can be reached by either a direct connection or through their parent nodes.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "BST",
      "Minimum Difference"
    ],
    "input_format": "The root node of a Binary Search Tree (BST).",
    "output_format": "An integer representing the minimum absolute difference between values of any two nodes in the BST.",
    "constraints": [
      "The number of nodes in the tree is in the range [2, 100].",
      "0 <= Node.val <= 10^5"
    ],
    "examples": [
      {
        "input": "root = [4, 2, 6, 1, 3]",
        "output": "1",
        "explanation": "The minimum absolute difference is between nodes with values 2 and 3."
      },
      {
        "input": "root = [1, 0, 48, null, null, 12, 49]",
        "output": "1",
        "explanation": "The minimum absolute difference is between nodes with values 48 and 49."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "In a BST, in-order traversal gives sorted node values.",
      "Keep track of the previous node value and update the minimum difference during traversal."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of bars, compute how much water it can trap after raining. For example, if the height of the bars is represented by an array, the water can only be trapped between the bars, considering the height of the tallest bars on both sides.",
    "topic": "Array",
    "subtopic": "Two Pointer Technique",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Two Pointers"
    ],
    "input_format": "An array of non-negative integers representing the heights of the bars.",
    "output_format": "An integer representing the total units of trapped rainwater.",
    "constraints": [
      "0 <= height.length <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The water can be trapped in the valleys between the bars, resulting in 6 units of water."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "Water can be trapped above heights 0 and 2, resulting in a total of 9 units."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how the height of bars on both ends influences the water level.",
      "Use two pointers to explore the array."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Alien Dictionary",
    "description": "Given a list of words sorted lexicographically based on an alien language's alphabet, return the order of the characters in the alien language. The order is determined by the words' sequential characters, and you must derive this order from the provided list. A valid order must include all unique characters present in the input words.",
    "topic": "Graph",
    "subtopic": "Topological Sorting",
    "tags": [
      "Graph",
      "Topological Sort",
      "String"
    ],
    "input_format": "An array of strings `words` representing the sorted words in the alien language.",
    "output_format": "A string representing the order of characters in the alien language. If no valid order exists, return an empty string.",
    "constraints": [
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 100",
      "All characters in `words` are lowercase English letters"
    ],
    "examples": [
      {
        "input": "words = ['za', 'zb', 'ca', 'cb']",
        "output": "zabc",
        "explanation": "From the words, it\u2019s clear that 'z' appears before 'a' and 'b', and 'c' comes after 'a' and 'b'. Thus the order is 'z', 'a', 'b', 'c'."
      },
      {
        "input": "words = ['abc', 'ab']",
        "output": "",
        "explanation": "The second word is shorter and appears after the first word, indicating an invalid order."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider creating a graph to represent the relationships between characters.",
      "After constructing the graph, perform a topological sort to determine the character order."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Pow(x, n)",
    "description": "Implement a function to calculate x raised to the power of n, where x is a floating point number and n is an integer. The solution should handle both positive and negative values of n and be efficient without directly using the power operator or built-in functions.",
    "topic": "Mathematics",
    "subtopic": "Exponential",
    "tags": [
      "Math",
      "Recursion",
      "Binary Exponentiation"
    ],
    "input_format": "Two values: a floating point number x and an integer n.",
    "output_format": "A floating point number representing x raised to the power of n.",
    "constraints": [
      "-10^4 <= x <= 10^4",
      "-10^9 <= n <= 10^9",
      "n is guaranteed to be an integer."
    ],
    "examples": [
      {
        "input": "x = 2.00000, n = 10",
        "output": "1024.00000",
        "explanation": "2 raised to the power of 10 equals 1024."
      },
      {
        "input": "x = 2.10000, n = 3",
        "output": "9.26100",
        "explanation": "2.1 raised to the power of 3 equals 9.261."
      },
      {
        "input": "x = 2.00000, n = -2",
        "output": "0.25000",
        "explanation": "2 raised to the power of -2 equals 0.25 (which is 1/(2^2))."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion for efficient computation.",
      "You can split the problem into smaller parts using properties of exponents."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Unique Morse Code Words",
    "description": "International Morse code encodes each letter into a sequence of dots and dashes. For example, 'a' is '.-', 'b' is '-...', and 'c' is '-.-.'. Given a list of words, you need to determine how many unique Morse code representations exist among them. Each word is translated into Morse code using the standard mapping of alphabets to Morse code. Return the number of unique Morse code representations of the words.",
    "topic": "String",
    "subtopic": "Transformation",
    "tags": [
      "String",
      "Morse Code",
      "Hash Set"
    ],
    "input_format": "An array of strings words representing the list of words.",
    "output_format": "An integer representing the count of unique Morse code representations.",
    "constraints": [
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 12"
    ],
    "examples": [
      {
        "input": "words = [\"gin\", \"zen\", \"gig\", \"msg\"]",
        "output": "2",
        "explanation": "The Morse code representation for 'gin' is '--...-.', for 'zen' is '--...'. 'gig' is the same as 'gin' and 'msg' is '--...--.'. Thus, there are two unique representations."
      },
      {
        "input": "words = [\"a\"]",
        "output": "1",
        "explanation": "There's only one word 'a', which has a unique Morse code representation."
      },
      {
        "input": "words = [\"z\", \"y\", \"x\", \"w\"]",
        "output": "4",
        "explanation": "Each of these letters has a distinct Morse code representation. Hence, the count is 4."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a set to store unique codes.",
      "Think about how to translate each character to Morse code efficiently."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Subdomain Visit Count",
    "description": "A website (domain) may have multiple subdomains. For example, 'example.com' has 'shop.example.com' and 'blog.example.com' as subdomains. You are given a list of string representing the count of page views for various subdomains. Your task is to calculate the total count of visits for each subdomain, including its parent domains. Return a list of strings, where each string is of the format 'count domain' sorted by the domain in lexicographical order.",
    "topic": "String",
    "subtopic": "Hash Table",
    "tags": [
      "String",
      "Hash Table",
      "Counting"
    ],
    "input_format": "A list of strings representing page views, where each string is in the format 'count domain'.",
    "output_format": "A list of strings representing total views for each subdomain in the format 'count domain' sorted lexically.",
    "constraints": [
      "1 <= views.length <= 1000",
      "1 <= count <= 1000",
      "domain is alphanumeric and may contain dots"
    ],
    "examples": [
      {
        "input": [
          "9001 discuss.leetcode.com",
          "50 yahoo.com",
          "1 intel.mail.com",
          "5 wiki.org"
        ],
        "output": [
          "9016 discuss.leetcode.com",
          "50 yahoo.com",
          "5 wiki.org",
          "1 mail.com",
          "1 intel.mail.com"
        ],
        "explanation": "The total views for 'discuss.leetcode.com' is 9001 + 5 from 'wiki.org' which includes its parent 'leetcode.com'."
      },
      {
        "input": [
          "200 sports.yahoo.com",
          "200 news.yahoo.com",
          "250 yahoo.com"
        ],
        "output": [
          "250 news.yahoo.com",
          "250 sports.yahoo.com",
          "700 yahoo.com"
        ],
        "explanation": "The total views for 'yahoo.com' is 200 + 200 + 250."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to accumulate counts for each subdomain.",
      "Split the domain by '.' to get the subdomains."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Palindrome Pairs",
    "description": "Given a list of unique words, find all pairs of distinct indices (i, j) such that the concatenation of the two words at indices i and j forms a palindrome. A palindrome reads the same forward and backward. The answer should be presented as a list of pairs of indices.",
    "topic": "String",
    "subtopic": "Palindrome",
    "tags": [
      "String",
      "Palindrome",
      "Hash Table"
    ],
    "input_format": "A list of unique words, each represented as a string.",
    "output_format": "A list of pairs of indices that form palindromes when the words are concatenated.",
    "constraints": [
      "1 <= words.length <= 10^4",
      "1 <= words[i].length <= 200",
      "All words consist of lowercase letters."
    ],
    "examples": [
      {
        "input": "words = [\"bat\", \"tab\", \"cat\"]",
        "output": "[[0, 1], [1, 0]]",
        "explanation": "The pairs (0, 1) and (1, 0) form the palindrome 'battab'."
      },
      {
        "input": "words = [\"abcd\", \"dcba\", \"lls\", \"s\", \"sssll\"]",
        "output": "[[0, 1], [1, 0], [2, 4], [3, 2]]",
        "explanation": "The pairs (0, 1) and (1, 0) form 'abcddcba', (2, 4) forms 'llssssll', and (3, 2) forms 'slls'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a hash table for fast look-up of words.",
      "Check for empty strings as they can form palindromes with others."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Power of Four",
    "description": "Given an integer n, determine if it is a power of four. An integer n is a power of four if there exists an integer x such that n == 4^x.",
    "topic": "Mathematics",
    "subtopic": "Exponents",
    "tags": [
      "Mathematics",
      "Exponents",
      "Power"
    ],
    "input_format": "An integer n.",
    "output_format": "A boolean value indicating whether n is a power of four.",
    "constraints": [
      "0 <= n <= 10^12"
    ],
    "examples": [
      {
        "input": "n = 16",
        "output": "true",
        "explanation": "16 is 4^2, hence it is a power of four."
      },
      {
        "input": "n = 5",
        "output": "false",
        "explanation": "5 is not a power of four."
      },
      {
        "input": "n = 1",
        "output": "true",
        "explanation": "1 is 4^0, hence it is a power of four."
      },
      {
        "input": "n = 0",
        "output": "false",
        "explanation": "0 is not a power of four."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider the binary representation of powers of four.",
      "Check if n > 0 and if n can be expressed as 4^x."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array.",
    "topic": "Dynamic Programming",
    "subtopic": "Kadane's Algorithm",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Kadane's Algorithm"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the largest sum of a contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The largest subarray is the element itself: [1]."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The subarray [5,4,-1,7,8] has the largest sum 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a variable to track the current maximum sum.",
      "Reset the current sum if it becomes negative."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log(min(m,n))). You may assume nums1 and nums2 can't be both empty.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Sorting"
    ],
    "input_format": "Two sorted arrays of integers nums1 and nums2.",
    "output_format": "A single floating-point number representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= nums1.length <= 1000",
      "0 <= nums2.length <= 1000",
      "-10^6 <= nums1[i], nums2[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.0",
        "explanation": "The combined sorted array is [1, 2, 3], the median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.5",
        "explanation": "The combined sorted array is [1, 2, 3, 4], the median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a binary search on the smaller array.",
      "Think about partitioning the arrays to find the median."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Rotting Oranges",
    "description": "You are given a grid of integers where each cell can have one of three values: 0 (empty), 1 (fresh orange), or 2 (rotten orange). In one minute, any fresh orange adjacent (horizontally or vertically) to a rotten orange will turn rotten. Return the minimum number of minutes that must elapse until no fresh oranges remain. If it is impossible for all oranges to rot, return -1.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "Graph",
      "Breadth-First Search",
      "Matrix"
    ],
    "input_format": "A 2D grid of integers representing the state of the oranges.",
    "output_format": "An integer representing the minimum time required for all oranges to rot, or -1 if not all can rot.",
    "constraints": [
      "1 <= grid.length <= 10",
      "1 <= grid[i].length <= 10",
      "grid[i][j] is 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
        "output": "4",
        "explanation": "It takes 4 minutes for all fresh oranges to rot."
      },
      {
        "input": "grid = [[2,1,1],[0,1,1],[1,0,2]]",
        "output": "-1",
        "explanation": "Fresh oranges in this case cannot rot as they are isolated."
      },
      {
        "input": "grid = [[0,2]]",
        "output": "0",
        "explanation": "There are no fresh oranges, so the time required is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to perform BFS for rot propagation.",
      "Count initial fresh oranges to check completion.",
      "Consider edge cases with isolated fresh oranges."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Decode String",
    "description": "Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. You may assume that the input string is always valid; no extra white spaces, square brackets are well-formed, etc.",
    "topic": "String",
    "subtopic": "Decoding",
    "tags": [
      "String",
      "Decoding",
      "Stack"
    ],
    "input_format": "A single string s, which represents the encoded string.",
    "output_format": "A string representing the decoded result.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of digits, lowercase English letters, and square brackets.",
      "The input string is guaranteed to be valid."
    ],
    "examples": [
      {
        "input": "s = \"3[a2[c]]\"",
        "output": "accaccacc",
        "explanation": "The string \"a2[c]\" expands to \"acc\", and when multiplied by 3, it becomes \"accaccacc\"."
      },
      {
        "input": "s = \"2[abc]3[cd]ef\"",
        "output": "abcabccdcdcdef",
        "explanation": "The string \"2[abc]\" expands to \"abcabc\", and \"3[cd]\" expands to \"cdcdcd\", concatenated with \"ef\"."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack for managing nested structures.",
      "Keep track of the number of times to repeat a substring."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Subsets",
    "description": "Given an integer array nums, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.",
    "topic": "Backtracking",
    "subtopic": "Subsets Generation",
    "tags": [
      "Backtracking",
      "Subsets",
      "Array"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A list of lists representing all possible subsets.",
    "constraints": [
      "0 <= nums.length <= 10",
      "-10 <= nums[i] <= 10",
      "The solution set must not contain duplicate subsets."
    ],
    "examples": [
      {
        "input": "nums = [1,2,2]",
        "output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
        "explanation": "The subsets of [1, 2, 2] include the empty set, single elements, and multiple combinations."
      },
      {
        "input": "nums = [0]",
        "output": "[[],[0]]",
        "explanation": "The only subsets of [0] are the empty set and the set containing 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a backtracking approach to generate subsets.",
      "Make sure to handle duplicates in the input gracefully."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Word Search II",
    "description": "Given a 2D board and a list of words, find all words in the board. Each word can be constructed from letters of sequentially adjacent cells, where 'adjacent' cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Return the list of words found on the board, ensuring that each word appears only once in the output.",
    "topic": "Backtracking",
    "subtopic": "Trie",
    "tags": [
      "Backtracking",
      "Trie",
      "Matrix"
    ],
    "input_format": "A 2D board represented by a list of strings and a list of words.",
    "output_format": "A list of words found on the board.",
    "constraints": [
      "1 <= board.length <= 200",
      "1 <= board[i].length <= 200",
      "1 <= words.length <= 3000",
      "1 <= words[i].length <= 10"
    ],
    "examples": [
      {
        "input": {
          "board": [
            [
              "o",
              "a",
              "a",
              "n"
            ],
            [
              "e",
              "t",
              "a",
              "e"
            ],
            [
              "i",
              "h",
              "k",
              "r"
            ],
            [
              "i",
              "f",
              "l",
              "v"
            ]
          ],
          "words": [
            "oath",
            "pea",
            "eat",
            "rain"
          ]
        },
        "output": [
          "eat",
          "oath"
        ],
        "explanation": "The words 'eat' and 'oath' can be constructed from the board."
      },
      {
        "input": {
          "board": [
            [
              "a",
              "b"
            ],
            [
              "c",
              "d"
            ]
          ],
          "words": [
            "abcb"
          ]
        },
        "output": [],
        "explanation": "No words from the list can be found on the board."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a Trie to store the list of words.",
      "Use backtracking to explore each cell in the board."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Roman to Integer",
    "description": "Given a string representing a Roman numeral, convert it to an integer. The Roman numeral system uses the following symbols: I (1), V (5), X (10), L (50), C (100), D (500), and M (1000). Roman numerals are usually written largest to smallest from left to right. However, there are exceptions where smaller numbers precede larger ones to indicate subtraction. For example, the number four is represented as IV, because I (1) is before V (5), indicating 5 - 1. The number nine is represented as IX, and so on. Do not forget the rules of the Roman numeral representations while converting.",
    "topic": "String",
    "subtopic": "Conversion",
    "tags": [
      "String",
      "Conversion",
      "Math"
    ],
    "input_format": "A string s representing a Roman numeral.",
    "output_format": "An integer representing the equivalent value of the Roman numeral.",
    "constraints": [
      "1 <= s.length <= 15",
      "s consists of valid Roman numeral characters: I, V, X, L, C, D, M"
    ],
    "examples": [
      {
        "input": "s = 'III'",
        "output": "3",
        "explanation": "III is 1 + 1 + 1 = 3."
      },
      {
        "input": "s = 'IV'",
        "output": "4",
        "explanation": "IV is 5 - 1 = 4."
      },
      {
        "input": "s = 'IX'",
        "output": "9",
        "explanation": "IX is 10 - 1 = 9."
      },
      {
        "input": "s = 'LVIII'",
        "output": "58",
        "explanation": "L is 50, V is 5, and III is 1 + 1 + 1 = 3. So, 50 + 5 + 3 = 58."
      },
      {
        "input": "s = 'MCMXCIV'",
        "output": "1994",
        "explanation": "M is 1000, CM is 900, XC is 90, and IV is 4. So, 1000 + 900 + 90 + 4 = 1994."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how you can handle the subtraction cases.",
      "Use a dictionary to map the Roman characters to their integer values."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Reconstruct Original Digits from English",
    "description": "Given a string containing the digits 0-9 written as words (e.g., 'zero', 'one', 'two'), return a string representing the digits in ascending order. You must reconstruct the original numbers from these English words uniquely mapping to digits.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "HashMap",
      "Counting"
    ],
    "input_format": "A string 's' that contains words representing digits.",
    "output_format": "A string representing the unique digits in ascending order.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s only contains lowercase English letters."
    ],
    "examples": [
      {
        "input": "nineeightsevensixfivefourthreeonetwozerotwo",
        "output": "0123456789",
        "explanation": "The string includes words for all digits, and when sorted, the digits are '0123456789'."
      },
      {
        "input": "owoztneoer",
        "output": "012",
        "explanation": "The words 'zero' (0), 'one' (1), and 'two' (2) are represented in the string."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Count the occurrences of letters and find a unique way to identify each digit.",
      "Use the letters that are unique to certain digits to deduce the others."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Strong Password Checker",
    "description": "Given a string password, return whether it is a strong password. A strong password is defined as follows: it must be at least 8 characters long, and must contain at least one lowercase letter, one uppercase letter, one digit, and one special character from the set ['!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '-', '_', '=', '+']. Furthermore, it must not contain three repeating characters in a row (e.g., 'aaa' is bad, but 'aaA' is good).",
    "topic": "String",
    "subtopic": "Validation",
    "tags": [
      "String",
      "Validation",
      "Password"
    ],
    "input_format": "A single string password.",
    "output_format": "A boolean value indicating whether the password is strong or not.",
    "constraints": [
      "1 <= password.length <= 100",
      "password consists of printable ASCII characters."
    ],
    "examples": [
      {
        "input": "password = 'A1b2@c'",
        "output": "false",
        "explanation": "The password is less than 8 characters long."
      },
      {
        "input": "password = 'AstrongPassword123!'",
        "output": "true",
        "explanation": "The password meets all the criteria for being strong."
      },
      {
        "input": "password = 'Aaa123!@'",
        "output": "false",
        "explanation": "The password contains three repeating characters 'aaa'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Check the length of the password first.",
      "Maintain flags for each character type to verify inclusion.",
      "Use a loop to check for three repeating characters."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Escape The Ghosts",
    "description": "You are given the positions of a person and a number of ghosts on a 2D grid. The position of the person is represented by coordinates (x, y), and each ghost's position is represented by coordinates (gx, gy). The person can escape to any point in the grid, but he wants to avoid getting caught by any ghost. A ghost can catch him if it can reach the person's position faster than or at the same time as the person can escape. The person can move to an adjacent cell (up, down, left, right) in one unit of time. Determine if the person can escape from all the ghosts.",
    "topic": "Geometry",
    "subtopic": "Distance Calculation",
    "tags": [
      "Geometry",
      "Distance",
      "Grid",
      "BFS"
    ],
    "input_format": "An array of integers [px, py] representing the person's position and a list of lists (or array) of integers [[gx1, gy1], [gx2, gy2], ...] representing the ghosts' positions.",
    "output_format": "A boolean value: return true if the person can escape, false otherwise.",
    "constraints": [
      "The input coordinates for the person and ghosts are integers within the range of -10000 to 10000.",
      "The number of ghosts is at most 100."
    ],
    "examples": [
      {
        "input": "[0, 0], [[1, 1], [2, 2]]",
        "output": "false",
        "explanation": "The ghost at (1, 1) can reach the person (0, 0) in 2 units of time, while the person can only escape to the same position, thus he gets caught."
      },
      {
        "input": "[0, 0], [[2, 0]]",
        "output": "true",
        "explanation": "The ghost at (2, 0) takes 2 units of time to reach the person, while the person can escape to (1, 1) in just 2 units of time without being caught."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Calculate the Manhattan distance between the person and each ghost.",
      "Use a loop to check if any ghost can reach the person before him."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Word Search",
    "description": "Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where 'adjacent' cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "topic": "Backtracking",
    "subtopic": "Grid Search",
    "tags": [
      "Backtracking",
      "DFS",
      "Matrix"
    ],
    "input_format": "A 2D board of characters and a string word.",
    "output_format": "A boolean value indicating whether the word exists in the grid.",
    "constraints": [
      "m == board.length",
      "n == board[i].length",
      "1 <= m, n <= 6",
      "1 <= word.length <= 15"
    ],
    "examples": [
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "ABCCED"
        },
        "output": "true",
        "explanation": "The word 'ABCCED' can be constructed from the board."
      },
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "SEE"
        },
        "output": "true",
        "explanation": "The word 'SEE' can be constructed from the board."
      },
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "ABCB"
        },
        "output": "false",
        "explanation": "The word 'ABCB' cannot be constructed from the board."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use depth-first search (DFS) to explore the board.",
      "Make sure to keep track of visited cells."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Count and Say",
    "description": "The 'Count and Say' sequence is a series of integers defined as follows: Starting with the integer '1', each subsequent term is generated by describing the previous term. For example, the first few terms are: '1', '11', '21', '1211', '111221', '312211', and so on. Each term is constructed by reading the previous term, counting consecutive digits, and saying the counts followed by the digits. Write a function that takes an integer n and returns the nth term of the 'Count and Say' sequence.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Recursion",
      "Count and Say"
    ],
    "input_format": "An integer n where 1 <= n <= 30.",
    "output_format": "A string representing the nth term of the 'Count and Say' sequence.",
    "constraints": [
      "1 <= n <= 30"
    ],
    "examples": [
      {
        "input": "1",
        "output": "1",
        "explanation": "The first term is '1'."
      },
      {
        "input": "4",
        "output": "1211",
        "explanation": "The third term is '21', which is read as one '2' and one '1', thus the fourth term is '1211'."
      },
      {
        "input": "5",
        "output": "111221",
        "explanation": "The fourth term is '1211', which is read as one '1', one '2', and two '1's, resulting in '111221'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to process the digits in groups.",
      "Use a loop to construct each term based on the previous one."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Find Peak Element",
    "description": "You are given an array of integers nums. A peak element is an element that is greater than its neighbors. An array element is considered to be a peak if it is not smaller than its neighbors. Your task is to find one peak element in the array and return its index. You may assume that the input array is non-empty and that there exists at least one peak element.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Binary Search",
      "Peak Element"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the index of a peak element.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "2",
        "explanation": "The element at index 2 (which is 3) is greater than its neighbors (2 and 1)."
      },
      {
        "input": "nums = [1, 2, 1, 3, 5, 6, 4]",
        "output": "1",
        "explanation": "The element at index 1 (which is 2) is greater than its neighbors (1 and 1)."
      },
      {
        "input": "nums = [1, 2, 3, 4, 5]",
        "output": "4",
        "explanation": "In this ascending array, the last element (5) is a peak since it has no right neighbor."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use binary search to find a peak efficiently.",
      "Check the middle element and compare it with its neighbors."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Pascal's Triangle",
    "description": "Given an integer numRows, return the first numRows of Pascal's triangle. In Pascal's triangle, each row is represented by an array, where the value of each element is the sum of the two elements directly above it in the previous row. The triangle starts with a single row that contains only the number 1.",
    "topic": "Dynamic Programming",
    "subtopic": "Array Generation",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Matrix"
    ],
    "input_format": "An integer numRows that indicates the number of rows of Pascal's triangle to generate.",
    "output_format": "A list of lists, where each inner list represents a row in Pascal's triangle.",
    "constraints": [
      "1 <= numRows <= 30"
    ],
    "examples": [
      {
        "input": "numRows = 5",
        "output": "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
        "explanation": "The first 5 rows of Pascal's triangle are: 1, [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]."
      },
      {
        "input": "numRows = 1",
        "output": "[[1]]",
        "explanation": "The first row of Pascal's triangle is simply [1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Think about how each element is calculated based on previous rows.",
      "Consider starting with a list that contains the first row."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if the brackets are closed in the correct order. Note that an empty string is also considered valid.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Brackets",
      "Validation"
    ],
    "input_format": "A string s consisting of the characters '(', ')', '{', '}', '[' and ']'",
    "output_format": "A boolean value indicating whether the string is valid (true) or not (false).",
    "constraints": [
      "0 <= s.length <= 10^4",
      "s consists of parentheses only."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The parentheses are correctly matched and nested."
      },
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "Each type of bracket is correctly matched and nested."
      },
      {
        "input": "s = '(]'",
        "output": "false",
        "explanation": "The brackets are not correctly matched."
      },
      {
        "input": "s = '([)]'",
        "output": "false",
        "explanation": "The brackets are closed in the wrong order."
      },
      {
        "input": "s = '{[]}'",
        "output": "true",
        "explanation": "The brackets are correctly matched and nested."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "When you see a closing bracket, check if it matches the top of the stack.",
      "At the end, the stack should be empty for the string to be valid."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Lowest Common Ancestor of a Binary Tree III",
    "description": "Given two nodes in a binary tree, find their lowest common ancestor (LCA). The LCA is defined as the deepest node that is an ancestor of both nodes. An ancestor of a node is any predecessor node on the path from the root to that node. If one of the nodes is not present in the tree, return null.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Lowest Common Ancestor"
    ],
    "input_format": "The input will include the root of the binary tree and two nodes (p and q) as references to the nodes in the tree.",
    "output_format": "Return the lowest common ancestor of the two nodes if present, otherwise return null.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 10^5].",
      "All nodes' values are unique.",
      "p and q are different nodes and both exist in the binary tree."
    ],
    "examples": [
      {
        "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1",
        "output": "3",
        "explanation": "The lowest common ancestor of nodes 5 and 1 is 3."
      },
      {
        "input": "root = [1,2], p = 1, q = 2",
        "output": "1",
        "explanation": "The lowest common ancestor of nodes 1 and 2 is 1, since 1 is the parent of 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Traverse the tree while maintaining the path to the nodes.",
      "Use a recursive approach to explore potential ancestors."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers, return the indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An integer array `nums` and an integer `target`.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] = 2 + 7 = 9, we return [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "Because nums[1] + nums[2] = 2 + 4 = 6, we return [1, 2]."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] = 3 + 3 = 6, we return [0, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash table to store the difference between the target and the current number."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Minimum Time Takes to Reach Destination Without Drowning",
    "description": "You are a rescue worker attempting to reach a flooded area to save survivors. You have a limited amount of time to navigate through a grid where some paths are submerged in water. Each cell in the grid can either be a land tile (represented as 0) or a water tile (represented as 1). The goal is to find the minimum time (in seconds) required to reach the destination cell from the starting cell without stepping on water tiles. You can only move up, down, left, or right. If it is impossible to reach the destination, return -1.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "Graph",
      "BFS",
      "Pathfinding"
    ],
    "input_format": "A square grid of size n x n where each cell is either 0 or 1.",
    "output_format": "An integer representing the minimum time required to reach the destination cell, or -1 if it is impossible.",
    "constraints": [
      "1 <= n <= 100",
      "grid[i][j] is either 0 or 1",
      "The starting cell is grid[0][0] and the destination cell is grid[n-1][n-1]."
    ],
    "examples": [
      {
        "input": "grid = [[0,0,0],[0,1,0],[0,0,0]]",
        "output": "4",
        "explanation": "The path from (0,0) to (2,2) takes 4 seconds: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2)."
      },
      {
        "input": "grid = [[0,0,1],[1,0,1],[1,0,0]]",
        "output": "4",
        "explanation": "The path from (0,0) to (2,2) is: (0,0) -> (0,1) -> (1,1) -> (2,1) -> (2,2) taking 4 seconds."
      },
      {
        "input": "grid = [[0,1],[1,0]]",
        "output": "-1",
        "explanation": "It's impossible to reach (1,1) from (0,0) due to being surrounded by water."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using BFS for exploring paths.",
      "Keep track of visited cells to avoid cycles.",
      "Think about edge cases where there might be no available paths."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "Shortest Distance from All Buildings",
    "description": "You are given a 2D grid of size m x n representing a map where each cell can be either a building, an obstacle, or empty land. A building is represented by 1, an obstacle is represented by 2, and empty land is represented by 0. Your task is to find the shortest distance from any empty land cell to all buildings in the grid. The distance is defined as the sum of the Manhattan distances to all buildings. If there is no empty land that can reach all buildings, return -1.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "Graph",
      "BFS",
      "Shortest Path",
      "Matrix"
    ],
    "input_format": "A 2D grid (list of lists) where each element is either 0, 1, or 2.",
    "output_format": "An integer representing the shortest distance from any empty land to all buildings, or -1 if not possible.",
    "constraints": [
      "1 <= m, n <= 100",
      "The number of buildings will be at least 1 and at most 100."
    ],
    "examples": [
      {
        "input": "grid = [[0, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 1, 0, 2, 0]]",
        "output": "7",
        "explanation": "The shortest distance from the empty land to all buildings is 7."
      },
      {
        "input": "grid = [[1, 0]]",
        "output": "-1",
        "explanation": "There is no empty land cell."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use BFS to explore distances from each building.",
      "Keep track of the number of buildings reached for each empty land.",
      "Calculate the total distance for each empty land cell."
    ],
    "company": "Wix"
  },
  {
    "question_id": "",
    "title": "As Far from Land as Possible",
    "description": "You are given a grid representing a map where land cells are denoted by '1' and water cells are denoted by '0'. Your task is to find the maximum distance from any land cell to the nearest water cell. Return the maximum distance (in terms of cell count) to the nearest water cell for any land cell, or -1 if it is not possible to reach any water cell.",
    "topic": "Matrix",
    "subtopic": "BFS",
    "tags": [
      "Matrix",
      "BFS",
      "Distance"
    ],
    "input_format": "A 2D grid of integers where each integer is either 0 (water) or 1 (land).",
    "output_format": "An integer representing the maximum distance from any land cell to the nearest water cell.",
    "constraints": [
      "1 <= grid.length, grid[0].length <= 100",
      "grid[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "[[1,0,0],[0,0,0],[0,0,1]]",
        "output": "2",
        "explanation": "The maximum distance from a land cell (1 at coordinates (0, 0)) to the nearest water cell is 2."
      },
      {
        "input": "[[0,0,0],[0,1,0],[0,0,0]]",
        "output": "1",
        "explanation": "The land cell (1 at coordinates (1, 1)) is at most 1 cell away from any water cell."
      },
      {
        "input": "[[1]]",
        "output": "-1",
        "explanation": "There are no water cells present, so the output is -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using BFS to explore distances from land to water.",
      "Initialize a queue with all land cells as starting points."
    ],
    "company": "Wix"
  }
]