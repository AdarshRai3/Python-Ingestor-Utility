[
  {
    "question_id": "",
    "title": "Simple Bank System",
    "description": "Design a simple bank system that allows for the creation of bank accounts, deposits, withdrawals, and balance inquiries. Each account has a unique account number and a balance that starts at zero. Implement the operations to handle deposits and withdrawals while ensuring that the balance does not go negative. Additionally, provide a method to check the account balance.",
    "topic": "Design",
    "subtopic": "Object-Oriented Design",
    "tags": [
      "Design",
      "OOP",
      "Bank System"
    ],
    "input_format": "Operations include 'create_account(account_number)', 'deposit(account_number, amount)', 'withdraw(account_number, amount)', and 'get_balance(account_number)'.",
    "output_format": "For deposit and withdraw operations, return true if successful, false if not. The get_balance operation returns the current balance as a float.",
    "constraints": [
      "1 <= account_number <= 10^6",
      "0 <= amount <= 10^6"
    ],
    "examples": [
      {
        "input": "create_account(1), deposit(1, 100), withdraw(1, 50), get_balance(1)",
        "output": "50.0",
        "explanation": "Account 1 is created with a balance of 0. After depositing 100, the balance becomes 100. Withdrawing 50 results in a balance of 50."
      },
      {
        "input": "create_account(2), deposit(2, 200), withdraw(2, 250)",
        "output": "false",
        "explanation": "Account 2 has a balance of 200. Attempting to withdraw 250 exceeds the current balance, so the operation fails."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dictionary to store account balances.",
      "Ensure that withdrawals do not allow negative balances."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Find Duplicate File in System",
    "description": "Given a list of directory paths in the format 'directory/file1(content1) directory/file2(content2) ...', your task is to identify all duplicate files in the system. A file is considered duplicate if it has the same content, which is represented by the part in parentheses after the filename. Return a list of lists, where each list contains the full paths of duplicate files.",
    "topic": "Hash Table",
    "subtopic": "String Manipulation",
    "tags": [
      "Hash Table",
      "String",
      "File System"
    ],
    "input_format": "A list of strings paths, where each string represents a directory and its files.",
    "output_format": "A list of lists of strings, each inner list contains paths of duplicate files.",
    "constraints": [
      "1 <= paths.length <= 2000",
      "1 <= paths[i].length <= 3000",
      "The total number of files across all directories will not exceed 10^5."
    ],
    "examples": [
      {
        "input": "[\"dir1/fil1.txt(content1)\", \"dir2/fil2.txt(content2)\", \"dir1/fil3.txt(content1)\"]",
        "output": "[[\"dir1/fil1.txt\", \"dir1/fil3.txt\"]]",
        "explanation": "Both dir1/fil1.txt and dir1/fil3.txt have the same content 'content1', hence they are duplicates."
      },
      {
        "input": "[\"root/a 1.txt(content)\", \"root/c/b 2.txt(content)\", \"root/c/d 3.txt(content)\", \"root/a 4.txt(content)\"]",
        "output": "[[\"root/a 1.txt\", \"root/a 4.txt\"]]",
        "explanation": "Both root/a 1.txt and root/a 4.txt contain the same content 'content', making them duplicates."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to store file contents and their corresponding paths.",
      "Iterate through each path and extract the filenames along with their contents.",
      "Only keep paths of duplicate files in the final result."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Game of Life",
    "description": "The Game of Life is a cellular automaton devised by mathematician John Conway. The game is played on a 2D grid where each cell can be alive (1) or dead (0). The state of the grid evolves in discrete time steps. The next state of a cell is determined by the following rules: 1) Any live cell with fewer than two live neighbors dies (underpopulation). 2) Any live cell with two or three live neighbors lives on to the next generation. 3) Any live cell with more than three live neighbors dies (overpopulation). 4) Any dead cell with exactly three live neighbors becomes a live cell (reproduction). Given the current state of the board, return the state after one update according to the rules above.",
    "topic": "Simulation",
    "subtopic": "Game of Life",
    "tags": [
      "Simulation",
      "Matrix",
      "Game"
    ],
    "input_format": "A 2D array representing the current state of the board.",
    "output_format": "A 2D array representing the state of the board after one update.",
    "constraints": [
      "The board is a rectangular grid with dimensions m x n where 1 <= m, n <= 25.",
      "Each cell can be either 0 (dead) or 1 (alive)."
    ],
    "examples": [
      {
        "input": "board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
        "output": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]",
        "explanation": "In this case, the live cells evolve to the next state based on their neighbors."
      },
      {
        "input": "board = [[1,1],[1,0]]",
        "output": "[[0,1],[1,1]]",
        "explanation": "The alive cells will change according to the Game of Life rules."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to count live neighbors efficiently.",
      "Consider using an auxiliary array to store the next state."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Web Crawler",
    "description": "Design a web crawler that can fetch all URLs from a given starting URL. The crawler should recursively visit each URL found on the page and retrieve additional URLs until a specified depth is reached or no new URLs are found. Your implementation should ensure that no duplicate URLs are fetched and that URLs outside of the allowed domain are not considered.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "Web Crawler"
    ],
    "input_format": "A string startingUrl representing the initial URL to crawl and an integer depth representing the maximum depth of scanning.",
    "output_format": "A list of strings representing all unique URLs fetched by the crawler within the allowed depth.",
    "constraints": [
      "1 <= startingUrl.length <= 100",
      "1 <= depth <= 10",
      "The URLs are well-formed and belong to the same domain."
    ],
    "examples": [
      {
        "input": "startingUrl = 'https://example.com', depth = 2",
        "output": "['https://example.com/page1', 'https://example.com/page2', 'https://example.com/page3']",
        "explanation": "From the starting URL, the crawler fetches three unique URLs within the specified depth."
      },
      {
        "input": "startingUrl = 'https://anotherdomain.com', depth = 1",
        "output": "['https://anotherdomain.com/home']",
        "explanation": "The crawler finds only the home page as no further links are available."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about using a set to track visited URLs.",
      "Consider how to handle HTTP requests and responses.",
      "Depth-first search can be implemented using a stack or recursion."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Web Crawler Multithreaded",
    "description": "Design a multithreaded web crawler that fetches data from a list of URLs. Your crawler should be able to handle up to a specified maximum number of concurrent requests to gather the content of the web pages and store the results. The crawler should also manage retries for failed requests and avoid crawling the same URL multiple times.",
    "topic": "Concurrency",
    "subtopic": "Multithreading",
    "tags": [
      "Concurrency",
      "Multithreading",
      "Web Crawling"
    ],
    "input_format": "A list of URLs to crawl and an integer representing the maximum number of concurrent requests.",
    "output_format": "A dictionary where the keys are URLs and the values are the content fetched from those URLs.",
    "constraints": [
      "1 <= urls.length <= 1000",
      "1 <= max_concurrent_requests <= 20",
      "Each URL is a valid string."
    ],
    "examples": [
      {
        "input": {
          "urls": [
            "http://example.com",
            "http://example.org"
          ],
          "max_concurrent_requests": 2
        },
        "output": {
          "http://example.com": "Example Domain Content",
          "http://example.org": "Example Org Content"
        },
        "explanation": "The crawler fetches content from both URLs concurrently."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Utilize threading or async I/O for concurrent requests.",
      "Consider using a semaphore to limit the number of active threads."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Word Pattern II",
    "description": "Given a string pattern and a string s, return true if s follows the same pattern. Here follows means a full match such that there is a bijection between a letter in pattern and a non-empty word in s. A bijection is a one-to-one mapping between two sets. For example, 'abba' and 'dog cat cat dog' follow the same pattern, but 'abba' and 'dog cat cat fish' do not.",
    "topic": "String",
    "subtopic": "Pattern Matching",
    "tags": [
      "String",
      "Pattern Matching",
      "Backtracking"
    ],
    "input_format": "A string pattern and a string s, separated by a space.",
    "output_format": "A boolean value indicating whether s follows the same pattern as provided.",
    "constraints": [
      "1 <= pattern.length <= 300",
      "1 <= s.length <= 3000",
      "s contains only lowercase letters and spaces.",
      "The words in s are separated by a single space."
    ],
    "examples": [
      {
        "input": "pattern = 'abab', s = 'dog cat dog cat'",
        "output": "true",
        "explanation": "'a' is mapped to 'dog' and 'b' is mapped to 'cat'."
      },
      {
        "input": "pattern = 'aaaa', s = 'dog cat cat dog'",
        "output": "false",
        "explanation": "'a' cannot be mapped to multiple different words."
      },
      {
        "input": "pattern = 'abba', s = 'red blue blue red'",
        "output": "true",
        "explanation": "'a' is mapped to 'red' and 'b' is mapped to 'blue'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map for the bijection between characters and words.",
      "Check for the uniqueness of mappings as you iterate through the pattern."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Minimize Malware Spread II",
    "description": "In a network of nodes, each node can be infected by malware. Given a graph representing the network, each node is connected by edges, and you are provided with an array of nodes that initially contain malware. Your goal is to minimize the spread of malware by selecting one node to remove from the network. After removing that node, you need to return the node which, when removed, will result in the smallest number of nodes being infected. In case of a tie, return the node with the smallest index.",
    "topic": "Graph",
    "subtopic": "Graph Traversal",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Minimization"
    ],
    "input_format": "A 2D array graph representing the connections between nodes, and an array of integers initial indicating the nodes that initially contain malware.",
    "output_format": "An integer representing the node that, when removed, minimizes the spread of malware.",
    "constraints": [
      "1 <= graph.length <= 300",
      "0 <= graph[i][j] <= 1",
      "1 <= initial.length <= 300",
      "0 <= initial[i] < graph.length"
    ],
    "examples": [
      {
        "input": "[[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]",
        "output": "0",
        "explanation": "Removing node 0 results in nodes 1 and 2 being left. Node 1 can still infect node 0, but no other nodes will be infected. Thus, we return 0."
      },
      {
        "input": "[[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]",
        "output": "0",
        "explanation": "Removing node 0 will isolate the remaining nodes 1 and 2 and minimizes connection. Thus, we return 0."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a DFS or BFS approach to explore the graph.",
      "Count the number of connected components that can be formed after the removal of a node."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Minimize Malware Spread",
    "description": "You are given an undirected graph represented as a list of edges, where each edge connects two nodes (users). Initially, each user is infected with malware. Your task is to determine how to minimize the spread of malware by removing the minimum number of nodes. You need to return the lexicographically smallest node that can be removed to achieve this goal. If it's not possible to contain the spread by removing a single node, return -1.",
    "topic": "Graph",
    "subtopic": "Graph Traversal",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Greedy"
    ],
    "input_format": "A 2D array edges where each element is a pair [u, v] representing an edge between nodes u and v.",
    "output_format": "A string representing the lexicographically smallest user that can be removed to minimize malware spread, or '-1' if not possible.",
    "constraints": [
      "1 <= edges.length <= 10^4",
      "1 <= u, v <= 10^5",
      "The graph is connected."
    ],
    "examples": [
      {
        "input": "edges = [[1, 2], [2, 3], [4, 2], [3, 5]]",
        "output": "2",
        "explanation": "Removing user 2 would stop the spread to nodes 1, 3, and 4."
      },
      {
        "input": "edges = [[1, 2], [2, 3], [3, 1], [4, 5]]",
        "output": "1",
        "explanation": "Removing user 1 stops the spread completely and 1 is lexicographically smaller than 2 or 3."
      },
      {
        "input": "edges = [[1, 2], [2, 3], [3, 1], [3, 4]]",
        "output": "1",
        "explanation": "Either node 1, 2, or 3 can be removed, but 1 is the lexicographically smallest option."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the connected components of the graph.",
      "Use BFS or DFS to explore the graph.",
      "Keep track of the number of infections."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Seat Reservation Manager",
    "description": "A cinema has a certain number of seats in a row, and you are tasked with managing the seat reservations. Implement a SeatReservationManager class to keep track of the seats. The class should support the following operations: 1. `reserve(int seatNumber)`: Reserve a seat by its number. If the seat is already reserved, return false. 2. `cancel(int seatNumber)`: Cancel the reservation for a seat by its number. If the seat was not reserved, return false. 3. `availableSeats()`: Return the list of unreserved seats. The seats are numbered from 1 to n, where n is the total number of seats. Create a constructor that initializes the number of seats.",
    "topic": "Design",
    "subtopic": "Object-Oriented Design",
    "tags": [
      "Design",
      "Object-Oriented",
      "Reservation"
    ],
    "input_format": "The input for the constructor is an integer n indicating the total number of seats.",
    "output_format": "For each method, return a boolean for reserve and cancel operations, and return a list of integers for availableSeats.",
    "constraints": [
      "1 <= n <= 10^4",
      "1 <= seatNumber <= n"
    ],
    "examples": [
      {
        "input": "SeatReservationManager manager = new SeatReservationManager(5); manager.reserve(1); manager.reserve(2); manager.availableSeats();",
        "output": "[3, 4, 5]",
        "explanation": "Seats 1 and 2 are reserved, so available seats are 3, 4, and 5."
      },
      {
        "input": "manager.cancel(1); manager.availableSeats();",
        "output": "[1, 3, 4, 5]",
        "explanation": "After canceling seat 1, it becomes available along with seats 3, 4, and 5."
      },
      {
        "input": "manager.reserve(2);",
        "output": "false",
        "explanation": "Seat 2 is already reserved."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a set to track reserved seats.",
      "Consider methods for adding and removing elements efficiently."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Design Hit Counter",
    "description": "Design a hit counter which counts the number of hits received in the past 5 minutes. Each call to the hit method will represent a hit at the current timestamp (in seconds). Implement the following methods: \n- `hit(int timestamp)`: Records a hit at the given timestamp (in seconds).\n- `getHits(int timestamp)`: Returns the number of hits in the past 5 minutes (300 seconds) from the given timestamp (inclusive).\nThe function should be able to handle a large number of hits efficiently.",
    "topic": "Design",
    "subtopic": "Data Structure",
    "tags": [
      "Design",
      "Data Structure",
      "Queue"
    ],
    "input_format": "Two method calls, hit(int timestamp) and getHits(int timestamp), where timestamp is an integer in seconds.",
    "output_format": "The output of getHits(int timestamp) should return an integer representing the number of hits in the past 5 minutes.",
    "constraints": [
      "0 <= timestamp <= 2 * 10^9",
      "The number of calls to `hit` and `getHits` will be at most 10000 each."
    ],
    "examples": [
      {
        "input": "hit(1); hit(2); hit(3); getHits(4);",
        "output": "3",
        "explanation": "All three hits are within the last 5 minutes."
      },
      {
        "input": "hit(300); getHits(300); hit(301); getHits(300);",
        "output": "1\n2",
        "explanation": "The first getHits only counts the hit at timestamp 300. The second getHits counts hits at timestamps 300 and 301."
      },
      {
        "input": "hit(600); getHits(600);",
        "output": "1",
        "explanation": "Only one hit is counted at timestamp 600."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a queue to manage the timestamps of the hits.",
      "You might need to remove timestamps that are older than 5 minutes from the queue.",
      "Think about the time complexity of your solution."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Check If It Is a Good Array",
    "description": "You are given an integer array nums. An array is called a 'good array' if you can make every element equal to the same integer by performing an arbitrary number of operations. In one operation, you can select any two elements x and y in the array, and replace one of them with x + y. Return true if the array is good, otherwise return false.",
    "topic": "Array",
    "subtopic": "Mathematics",
    "tags": [
      "Array",
      "Mathematics",
      "Greatest Common Divisor"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A Boolean value indicating whether the array is good.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "1 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [3, 6, 9]",
        "output": "true",
        "explanation": "The GCD of the array is 3, which means we can make all elements equal to 3."
      },
      {
        "input": "nums = [1, 2, 3]",
        "output": "true",
        "explanation": "The GCD of the array is 1, which means we can make all elements equal to 1."
      },
      {
        "input": "nums = [12, 15, 10]",
        "output": "false",
        "explanation": "The GCD of the array is 1, which is just a coincidence; they can't be made equal through the operations."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "The GCD of the entire array is a useful value.",
      "If the GCD of the array is greater than 1, check the possible values.",
      "Consider the operations allowed on the numbers."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Design a Text Editor",
    "description": "Design a text editor that supports various commands for manipulating text. The editor should support the following operations:\n\n1. **Insert**: Insert a character at the current cursor position.\n2. **Delete**: Delete the character at the current cursor position.\n3. **Move**: Move the cursor left or right by a specified number of positions.\n4. **Undo**: Undo the last operation performed.\n5. **Get**: Get the character at the current cursor position.\n\nYour implementation should handle commands efficiently and correctly maintain the state of the text and cursor.",
    "topic": "Design",
    "subtopic": "Text Editor",
    "tags": [
      "Design",
      "Text Processing",
      "Stack"
    ],
    "input_format": "A series of commands for the text editor, where each command is represented as a string. The commands may be:\n- `insert c`: Insert character `c` at the current cursor position.\n- `delete`: Delete the character at the current cursor position.\n- `move L x`: Move the cursor left by `x` positions.\n- `move R x`: Move the cursor right by `x` positions.\n- `undo`: Undo the last operation.\n- `get`: Return the character at the current cursor position.",
    "output_format": "For each `get` command, return the character at the current cursor position. For all other commands, return nothing.",
    "constraints": [
      "1 <= total commands <= 10^5",
      "Each command string is at most 10 characters long."
    ],
    "examples": [
      {
        "input": [
          "insert a",
          "insert b",
          "move R 1",
          "insert c",
          "get",
          "undo",
          "get"
        ],
        "output": [
          "c",
          "b"
        ],
        "explanation": "We insert 'a' and 'b', move right and insert 'c'. The 'get' returns 'c'. After undo, 'c' is removed, so the next 'get' returns 'b'."
      },
      {
        "input": [
          "insert x",
          "insert y",
          "move L 1",
          "delete",
          "get"
        ],
        "output": [
          "x"
        ],
        "explanation": "Insert 'x' and 'y', move left to 'x', delete it. The 'get' now returns 'x' since it was not deleted."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Utilize a stack to handle undo operations efficiently.",
      "Keep track of the current position of the cursor."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Two Pointers"
    ],
    "input_format": "An array of integers `nums` and an integer `target`.",
    "output_format": "A list of two integers representing the indices of the two numbers in the array.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "target is a valid integer."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "You can use a dictionary to store the difference between target and each element."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Median"
    ],
    "input_format": "Two sorted arrays nums1 and nums2.",
    "output_format": "A float representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= m <= 1000",
      "0 <= n <= 1000",
      "m + n > 0",
      "Both nums1 and nums2 are sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.0",
        "explanation": "The merged array is [1, 2, 3], and the median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.5",
        "explanation": "The merged array is [1, 2, 3, 4], and the median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Try to use binary search to find the partitions.",
      "Ensure that all elements on the left are less than or equal to the elements on the right."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Word Pattern",
    "description": "Given a string pattern and a string s, you need to determine if s follows the same pattern. A string follows a pattern if there is a bijection between a letter in the pattern and a non-empty word in s. For example, 'abba' matches 'dog cat cat dog' but not 'dog cat cat fish'.",
    "topic": "String",
    "subtopic": "Pattern Matching",
    "tags": [
      "String",
      "Pattern Matching",
      "Hash Map"
    ],
    "input_format": "A string pattern followed by a space and then a string s.",
    "output_format": "A boolean value indicating whether s follows the same pattern as pattern.",
    "constraints": [
      "1 <= pattern.length <= 300",
      "1 <= s.length <= 3000",
      "pattern contains only lowercase English letters.",
      "s contains lowercase English letters and spaces."
    ],
    "examples": [
      {
        "input": "pattern = 'abba', s = 'dog cat cat dog'",
        "output": "true",
        "explanation": "Each letter in the pattern corresponds to a unique word in s."
      },
      {
        "input": "pattern = 'abba', s = 'dog cat cat fish'",
        "output": "false",
        "explanation": "The last word 'fish' does not match the expected pattern."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a hash map to store character-to-word mappings.",
      "Check for word uniqueness while mapping each character."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Number of Valid Words for Each Puzzle",
    "description": "Given a list of words and a list of puzzles, you need to find how many valid words can be formed for each puzzle. A word is considered valid for a puzzle if it contains the first letter of the puzzle, and all the letters in the word are contained within the set of letters used in the puzzle.",
    "topic": "String",
    "subtopic": "Word Matching",
    "tags": [
      "String",
      "HashMap",
      "Counting"
    ],
    "input_format": "A list of strings 'words' and a list of strings 'puzzles'.",
    "output_format": "A list of integers where each integer represents the count of valid words for the corresponding puzzle.",
    "constraints": [
      "1 <= words.length <= 10^5",
      "1 <= puzzles.length <= 10^4",
      "1 <= words[i].length, puzzles[j].length <= 7",
      "All letters in words and puzzles are lowercase English letters."
    ],
    "examples": [
      {
        "input": {
          "words": [
            "aaaa",
            "asas",
            "able",
            "ability",
            "actt",
            "bat"
          ],
          "puzzles": [
            "aaaaaaa",
            "aaaaaaab",
            "aaaaaaac",
            "aaaaaaa"
          ]
        },
        "output": [
          3,
          2,
          0,
          3
        ],
        "explanation": "For puzzle 'aaaaaaa', valid words are 'aaaa', 'asas', and 'able'; for 'aaaaaaab', valid words are 'aaaa', 'asas'; for 'aaaaaaac', there are no valid words; and for 'aaaaaaa', valid words are 'aaaa', 'asas', and 'able'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a bitmask to represent the letters in words and puzzles.",
      "Check if the first character of the puzzle is contained in the word."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Word Break II",
    "description": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note that the same word in the dictionary may be reused multiple times in the segmentation.",
    "topic": "Dynamic Programming",
    "subtopic": "Backtracking",
    "tags": [
      "Dynamic Programming",
      "Backtracking",
      "String"
    ],
    "input_format": "A string s and a list of strings wordDict representing the dictionary.",
    "output_format": "A list of all possible sentences formed by the words in the dictionary.",
    "constraints": [
      "1 <= s.length <= 20",
      "1 <= wordDict.length <= 1000",
      "1 <= wordDict[i].length <= 10",
      "s and wordDict[i] consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": {
          "s": "catsanddog",
          "wordDict": [
            "cat",
            "cats",
            "and",
            "sand",
            "dog"
          ]
        },
        "output": [
          "cats and dog",
          "cat sand dog"
        ],
        "explanation": "The string can be segmented into 'cats and dog' or 'cat sand dog'."
      },
      {
        "input": {
          "s": "pineapplepenapple",
          "wordDict": [
            "apple",
            "pen",
            "applepen",
            "pine",
            "pineapple"
          ]
        },
        "output": [
          "pine apple pen apple",
          "pineapple pen apple",
          "pine applepen apple"
        ],
        "explanation": "The string can be segmented into multiple valid sentences."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use backtracking to explore all combinations.",
      "Utilize memoization to store results of subproblems."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Grid Illumination",
    "description": "You are given a grid of size n x n, initially all cells are turned off. You will receive a series of lamp toggle commands, and your task is to determine which cells are illuminated after all commands have been processed. A lamp at position (x, y) illuminates all cells in row x and column y. When toggling a lamp at (x, y), it will turn off if it was on, and turn on if it was off. Your goal is to identify if a specific cell (query_x, query_y) is illuminated after processing all commands.",
    "topic": "Grid",
    "subtopic": "Simulation",
    "tags": [
      "Grid",
      "Simulation",
      "Toggle"
    ],
    "input_format": "The first line contains an integer n (1 <= n <= 1000). The second line contains an integer m (0 <= m <= 10000) representing the number of toggle commands. The next m lines contain two integers x, y (0 <= x, y < n) for each toggle command. The last line contains two integers query_x, query_y (0 <= query_x, query_y < n) for the query.",
    "output_format": "Output 'YES' if the cell (query_x, query_y) is illuminated, otherwise output 'NO'.",
    "constraints": [
      "1 <= n <= 1000",
      "0 <= m <= 10000",
      "0 <= x, y < n"
    ],
    "examples": [
      {
        "input": "3\n3\n0 0\n0 1\n1 1\n1 0",
        "output": "YES",
        "explanation": "The lamp at (0, 0) illuminates row 0 and column 0. The lamp at (0, 1) illuminates row 0 and column 1. The lamp at (1, 1) illuminates row 1 and column 1 resulting in (1,0) being illuminated by row 0."
      },
      {
        "input": "2\n2\n0 1\n1 0\n1 1",
        "output": "NO",
        "explanation": "After the last toggle, the only illuminated cells are (0,1) and (1,0), and (1,1) itself is not illuminated."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Keep track of toggled lamps using a set.",
      "Use row and column counters to track illuminations."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Letter Combinations of a Phone Number",
    "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. The mapping is as follows:\n\n2 -> 'abc'\n3 -> 'def'\n4 -> 'ghi'\n5 -> 'jkl'\n6 -> 'mno'\n7 -> 'pqrs'\n8 -> 'tuv'\n9 -> 'wxyz'\n\nFor example, input '23' should return 'ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf'.",
    "topic": "Backtracking",
    "subtopic": "Recursive Combination Generation",
    "tags": [
      "Backtracking",
      "Recursion",
      "String"
    ],
    "input_format": "A string containing digits from 2-9.",
    "output_format": "A list of strings representing all possible letter combinations.",
    "constraints": [
      "0 <= digits.length <= 4",
      "digits[i] is a digit in the range ['2', '9']."
    ],
    "examples": [
      {
        "input": "digits = \"23\"",
        "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
        "explanation": "The letters represented by 2 are 'abc' and by 3 are 'def'. Thus, we have 9 combinations."
      },
      {
        "input": "digits = \"\"",
        "output": "[]",
        "explanation": "An empty input returns an empty list."
      },
      {
        "input": "digits = \"2\"",
        "output": "[\"a\",\"b\",\"c\"]",
        "explanation": "The only digit maps directly to 'abc'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a backtracking approach to generate combinations.",
      "You can use a mapping array or a dictionary for digit-letter mapping."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Max Area of Island",
    "description": "You are given a 2D grid of '1's (land) and '0's (water). An island is formed by connecting adjacent lands horizontally or vertically. You need to return the maximum area of an island in the given grid. If there is no island, return 0.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "DFS",
      "Graph",
      "Matrix"
    ],
    "input_format": "A 2D grid represented as a list of lists where each inner list contains integers 0 or 1.",
    "output_format": "An integer representing the maximum area of an island.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 50",
      "grid[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "grid = [[0,0,0,0,0],[0,1,1,1,0],[0,1,0,0,0],[0,0,0,1,1]]",
        "output": "5",
        "explanation": "The maximum area is formed by the island of '1's at coordinates (1,1), (1,2), (1,3), (2, 1), and (2, 3)."
      },
      {
        "input": "grid = [[0,0,0],[0,0,0]]",
        "output": "0",
        "explanation": "There are no islands present in the grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use Depth-First Search (DFS) to explore the islands.",
      "Keep track of the visited coordinates to prevent counting them multiple times."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Guess the Word",
    "description": "You are given a list of words and a secret word. Your task is to guess the secret word using a limited number of attempts. Each guess will provide feedback on how many letters match with the secret word's letters in the correct positions. Given the words and the number of guessing attempts, determine if it is possible to guess the secret word correctly within the given attempts.",
    "topic": "Strings",
    "subtopic": "String Matching",
    "tags": [
      "Strings",
      "Game",
      "Guessing"
    ],
    "input_format": "A list of strings 'words' representing possible guesses, a string 'secret' that represents the secret word, and an integer 'max_attempts' that represents the maximum number of attempts allowed.",
    "output_format": "A boolean value: true if the secret word can be guessed within 'max_attempts', otherwise false.",
    "constraints": [
      "1 <= words.length <= 1000",
      "1 <= words[i].length == secret.length <= 10",
      "All words have the same length as the secret word."
    ],
    "examples": [
      {
        "input": {
          "words": [
            "abc",
            "def",
            "ghi",
            "jkl"
          ],
          "secret": "abc",
          "max_attempts": 3
        },
        "output": "true",
        "explanation": "The secret word 'abc' can be guessed in the first attempt."
      },
      {
        "input": {
          "words": [
            "xyz",
            "pqr",
            "stu"
          ],
          "secret": "abc",
          "max_attempts": 2
        },
        "output": "false",
        "explanation": "None of the words match the secret word in any of the attempts."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the maximum number of attempts when analyzing the words.",
      "Keep track of the letters guessed to find a strategy that ensures winning.",
      "Focus on the feedback received for each guess to maximize your guessing efficiency."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Top K Frequent Elements",
    "description": "Given a non-empty array of integers, return the k most frequent elements. You may return the answer in any order. Your algorithm should have a better than O(n log n) runtime complexity.",
    "topic": "Hash Table",
    "subtopic": "Frequency Counting",
    "tags": [
      "Hash Table",
      "Sorting",
      "Heap"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An array of the k most frequent elements.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "k is guaranteed to be less than or equal to the number of unique elements in the array."
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3], k = 2",
        "output": "[1,2]",
        "explanation": "The number 1 appears 3 times and the number 2 appears 2 times. The two most frequent elements are 1 and 2."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "Only one element, which is the most frequent."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash table to count the frequency of elements.",
      "Consider using a heap to retrieve the top k elements.",
      "The quickest way might be to use bucket sort."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. An interval is defined as a pair of integers (start, end), where start <= end. The resulting output should be a collection of non-overlapping intervals that cover all the intervals in the input.",
    "topic": "Array",
    "subtopic": "Sorting and Merging",
    "tags": [
      "Array",
      "Sorting",
      "Merging"
    ],
    "input_format": "A list of intervals, where each interval is represented as a pair of integers [start, end].",
    "output_format": "A list of merged intervals, where each interval is represented as a pair of integers [start, end].",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "[[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Intervals [1,3] and [2,6] overlap, they can be merged to [1,6]."
      },
      {
        "input": "[[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "The intervals [1,4] and [4,5] are touching, so they can be merged into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on the start time.",
      "Use a temporary list to keep track of the merged intervals."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water.",
    "topic": "Graph",
    "subtopic": "Depth First Search",
    "tags": [
      "DFS",
      "BFS",
      "Graph",
      "Matrix"
    ],
    "input_format": "A 2D grid represented as a list of lists containing '1's and '0's.",
    "output_format": "An integer representing the number of islands.",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[i].length <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "[['1','1','1','1','0'], ['1','1','0','1','0'], ['1','1','0','0','0'], ['0','0','0','0','0']]",
        "output": "1",
        "explanation": "There is one island formed by the connected '1's."
      },
      {
        "input": "[['1','1','0','0','0'], ['1','0','0','1','1'], ['0','0','0','1','0'], ['0','1','0','0','0']]",
        "output": "3",
        "explanation": "There are three separate islands in the grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth First Search (DFS) or Breadth First Search (BFS) to explore the islands.",
      "You may need to mark visited cells to prevent counting the same island multiple times."
    ],
    "company": "Dropbox"
  },
  {
    "question_id": "",
    "title": "Number of Islands II",
    "description": "You are given a 2D grid of '0's (water) and '1's (land). You can perform multiple island additions, where an island is defined as a group of '1's connected vertically or horizontally. Each operation consists of adding a single '1' to the grid at a specified coordinate. Your task is to return the number of islands in the grid after each addition operation. An island is formed when one or more adjacent land cells are connected. You need to implement a function that handles these operations and returns the state of the island count after each operation.",
    "topic": "Graph",
    "subtopic": "Union Find",
    "tags": [
      "Graph",
      "Union Find",
      "Count Islands"
    ],
    "input_format": "The first input is a 2D binary grid representing the initial state of the islands followed by a list of addition operations, each represented by a pair of integers (x, y) indicating the row and column of the cell to be filled with '1'.",
    "output_format": "A list of integers, where each integer represents the number of islands after each addition operation.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 100",
      "0 <= x < grid.length",
      "0 <= y < grid[i].length",
      "The addition coordinates do not go out of bounds."
    ],
    "examples": [
      {
        "input": "grid = [[0,1],[0,0]]\noperations = [[0,0],[0,1],[1,1],[1,0]]",
        "output": "[1, 1, 1, 2]",
        "explanation": "Initially, there is one island. The first operation adds a new '1' at (0,0) making it one island. The second operation does not change the island count. The third operation adds another '1' at (1,1) still resulting in one island. The fourth operation adds a '1' at (1,0) connecting all cells into two islands."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using Union-Find to manage islands efficiently.",
      "You may need to check for neighboring land when adding a new '1'."
    ],
    "company": "Dropbox"
  }
]