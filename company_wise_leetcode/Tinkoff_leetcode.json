[
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters. A substring is defined as a contiguous sequence of characters within the string.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Hash Table"
    ],
    "input_format": "A single string s consisting of uppercase and lowercase English letters, digits, symbols, and spaces.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 5 * 10^4",
      "s consists of English letters, digits, symbols, and spaces."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"abc\", which has a length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The longest substring without repeating characters is \"b\", which has a length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"wke\", which has a length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window to keep track of the characters seen.",
      "Utilize a hash set to quickly check for duplicates.",
      "Adjust the starting point of the window when a duplicate is found."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Min Stack",
    "description": "Design a stack that supports the following operations: push, pop, top, and retrieving the minimum element. Implement the MinStack class:\n\n- MinStack() initializes the stack object.\n- void push(int val) pushes the element val onto the stack.\n- void pop() removes the element on the top of the stack.\n- int top() gets the top element of the stack.\n- int getMin() retrieves the minimum element in the stack.\n\nAll operations should be done in constant time.",
    "topic": "Data Structure",
    "subtopic": "Stack",
    "tags": [
      "Stack",
      "Design",
      "Data Structure"
    ],
    "input_format": "A series of operations to perform on the stack.",
    "output_format": "The minimum element retrieved on calling getMin() and the results of top() calls.",
    "constraints": [
      "All values in push are integers.",
      "The number of operations will not exceed 1000."
    ],
    "examples": [
      {
        "input": "MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();\nminStack.pop();\nminStack.top();\nminStack.getMin();",
        "output": "-3\n0\n-2",
        "explanation": "After pushing -2, 0, and -3, the minimum is -3. After popping -3, top is 0 and the new minimum is -2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use an auxiliary stack to keep track of the minimums.",
      "Consider how to maintain the minimum even when popping elements."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers such that they add up to the target.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "target is within the range of the sum of two numbers in the array."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 2 + 7 = 9."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "nums[1] + nums[2] = 2 + 4 = 6."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 3 + 3 = 6."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash map to store the difference between the target and each number."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Rotate Image",
    "description": "You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). You have to rotate the image in place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.",
    "topic": "Matrix",
    "subtopic": "In-place Operations",
    "tags": [
      "Matrix",
      "In-place",
      "Rotation"
    ],
    "input_format": "A 2D list of integers representing the n x n matrix.",
    "output_format": "The same 2D list representing the rotated matrix.",
    "constraints": [
      "1 <= n <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]",
        "explanation": "The original matrix is rotated 90 degrees clockwise resulting in the new matrix."
      },
      {
        "input": "matrix = [[5]]",
        "output": "[[5]]",
        "explanation": "Rotating a 1x1 matrix does not change it."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how rows and columns transform during the rotation.",
      "You can visualize the rotation by layers from the outermost to innermost."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Keys and Rooms",
    "description": "You have n rooms labeled from 0 to n - 1. Each room has a distinct key that can open another room. Initially, you start in room 0 and have access to all the keys in that room. You can use these keys to open other rooms. Your task is to determine if you can access all the rooms starting from room 0. Return true if you can access all rooms, otherwise return false.",
    "topic": "Graph",
    "subtopic": "Depth-first Search",
    "tags": [
      "Graph",
      "DFS",
      "BFS"
    ],
    "input_format": "A list of lists, where each inner list contains the keys available in that room.",
    "output_format": "A boolean value indicating whether all rooms can be accessed.",
    "constraints": [
      "1 <= rooms.length <= 100",
      "0 <= rooms[i].length <= 100",
      "The keys are valid room numbers."
    ],
    "examples": [
      {
        "input": "rooms = [[1],[2],[3],[]]",
        "output": "true",
        "explanation": "Starting from room 0, we access room 1, then room 2, and finally room 3, thus accessing all rooms."
      },
      {
        "input": "rooms = [[1,3],[3,0,1],[2],[0]]",
        "output": "false",
        "explanation": "Starting from room 0, we can access room 1 and room 3, but we cannot access room 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a graph traversal algorithm to explore the rooms.",
      "Keep track of the rooms that have already been visited."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A substring is a contiguous sequence of characters within the string. The palindrome is a string that reads the same forward and backward.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A single string s, where 1 <= s.length <= 1000.",
    "output_format": "A single string representing the longest palindromic substring.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only digits and English letters."
    ],
    "examples": [
      {
        "input": "s = 'babad'",
        "output": "'bab'",
        "explanation": "Both 'bab' and 'aba' are valid longest palindromic substrings."
      },
      {
        "input": "s = 'cbbd'",
        "output": "'bb'",
        "explanation": "The longest palindromic substring is 'bb'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a two-pointer technique to expand around potential centers.",
      "You can find palindromes with both odd and even lengths."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Find First and Last Position of Element in Sorted Array",
    "description": "Given a sorted array of integers, nums, and an integer target, return the starting and ending position of target in nums. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Interval"
    ],
    "input_format": "An array of integers nums sorted in ascending order, followed by an integer target.",
    "output_format": "An array of two integers representing the first and last positions of target. If not found, return [-1, -1].",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9",
      "nums is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 8",
        "output": "[3, 4]",
        "explanation": "The target 8 appears at indices 3 and 4."
      },
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 6",
        "output": "[-1, -1]",
        "explanation": "The target 6 is not present in the array."
      },
      {
        "input": "nums = [], target = 0",
        "output": "[-1, -1]",
        "explanation": "The array is empty, so the target cannot be found."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use binary search to find the first occurrence.",
      "Once the first occurrence is found, continue searching to find the last occurrence."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Simplify Path",
    "description": "Given a string representing an absolute path for a file (Unix-style), simplify it. Remove all unnecessary components and return the simplified canonical path. The path could contain '.' (current directory), '..' (parent directory), and redundant slashes ('/').",
    "topic": "String",
    "subtopic": "Path Manipulation",
    "tags": [
      "String",
      "Path",
      "Manipulation"
    ],
    "input_format": "A string path, which represents the absolute path to a file.",
    "output_format": "A string representing the simplified canonical path.",
    "constraints": [
      "1 <= path.length <= 3000",
      "path consists of English letters, digits, '/', '.', and '..'.",
      "The path is a valid absolute path."
    ],
    "examples": [
      {
        "input": "/a/./b/../../c/",
        "output": "/c",
        "explanation": "The path goes to 'a', then to current directory 'b', then goes back two directories to root, and finally moves to 'c'."
      },
      {
        "input": "/../",
        "output": "/",
        "explanation": "From root, moving to parent directory results in no change, so the canonical path remains the root."
      },
      {
        "input": "/home//foo/",
        "output": "/home/foo",
        "explanation": "Redundant slashes are removed, leaving the clean path."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to manage the components of the path.",
      "Skip components that are empty, or a single '.'.",
      "Handle '..' by popping the last valid component off the stack."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Backspace String Compare",
    "description": "Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character. Note that after backspacing an empty text, the text will continue empty.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Backspace",
      "Comparison"
    ],
    "input_format": "Two strings s and t.",
    "output_format": "A boolean value indicating whether the processed strings are equal.",
    "constraints": [
      "1 <= s.length, t.length <= 200",
      "s and t contain only lowercase letters and '#' characters."
    ],
    "examples": [
      {
        "input": "s = 'ab#c', t = 'ad#c'",
        "output": "true",
        "explanation": "Both strings become 'ac' after processing backspaces."
      },
      {
        "input": "s = 'ab##', t = 'c#d#'",
        "output": "true",
        "explanation": "Both strings become '' (empty) after processing backspaces."
      },
      {
        "input": "s = 'a#c', t = 'b'",
        "output": "false",
        "explanation": "After processing, s becomes 'c' and t is 'b' which are not equal."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a stack to process the characters.",
      "Simulate the backspace by skipping the last character when '#' is encountered."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Form Smallest Number From Two Digit Arrays",
    "description": "You are given two arrays containing distinct two-digit integers. Your task is to form the smallest possible integer by selecting one number from each array. The smallest integer should be formed by concatenating the selected numbers from both arrays in ascending order. If no valid combination exists, return -1.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Strings"
    ],
    "input_format": "Two arrays of integers, arr1 and arr2, each containing distinct two-digit integers.",
    "output_format": "A string representing the smallest possible integer, or '-1' if no valid combination exists.",
    "constraints": [
      "1 <= arr1.length, arr2.length <= 100",
      "10 <= arr1[i], arr2[i] <= 99",
      "All integers in arr1 and arr2 are distinct."
    ],
    "examples": [
      {
        "input": "arr1 = [12, 23, 34], arr2 = [45, 56, 67]",
        "output": "1245",
        "explanation": "The smallest number can be formed by taking 12 from arr1 and 45 from arr2."
      },
      {
        "input": "arr1 = [90, 91], arr2 = [80, 89]",
        "output": "8090",
        "explanation": "The smallest number can be formed by taking 80 from arr2 and 90 from arr1."
      },
      {
        "input": "arr1 = [99], arr2 = [88]",
        "output": "8899",
        "explanation": "Only one combination exists, which is 88 and 99."
      },
      {
        "input": "arr1 = [20], arr2 = [40, 60]",
        "output": "2040",
        "explanation": "The smallest number can be formed by taking 20 from arr1 and 40 from arr2."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider sorting the two arrays to easily find the smallest combinations.",
      "Remember to handle cases with only one element in either array."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Depth-First Search",
    "subtopic": "Graph Traversal",
    "tags": [
      "DFS",
      "Graph",
      "Matrix"
    ],
    "input_format": "A 2D grid (list of lists) with '1's and '0's.",
    "output_format": "An integer representing the number of islands in the grid.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "[['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]",
        "output": "1",
        "explanation": "There is one island in the given grid."
      },
      {
        "input": "[['1','1','0','0','0'],['1','0','0','1','1'],['0','0','0','1','0'],['0','1','0','0','1']]",
        "output": "5",
        "explanation": "There are five islands in the given grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth-First Search (DFS) to traverse the islands.",
      "Mark visited cells to avoid counting them more than once."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Battleships in a Board",
    "description": "Given a 2D board representing a battleship field where 'X' represents a battleship and '.' represents water, count how many battleships are present on the board. Each battleship can be made up of multiple adjacent 'X's and can be placed either horizontally or vertically. You need to ensure that you count each battleship only once, meaning that if two 'X's are adjacent, they are part of the same battleship.",
    "topic": "Matrix",
    "subtopic": "Counting",
    "tags": [
      "Matrix",
      "Counting",
      "Depth-First Search"
    ],
    "input_format": "A 2D character array board where each element is either 'X' or '.'.",
    "output_format": "An integer representing the number of battleships on the board.",
    "constraints": [
      "1 <= board.length, board[i].length <= 200",
      "board[i][j] is either 'X' or '.'"
    ],
    "examples": [
      {
        "input": "[['X', '.', 'X'], ['.', '.', 'X'], ['X', 'X', '.']]",
        "output": "5",
        "explanation": "There are 5 battleships on the board: One vertical battleship (first row) and two horizontal battleships (third row)."
      },
      {
        "input": "[['X', 'X', 'X', '.', 'X'], ['.', '.', 'X', '.', 'X'], ['X', '.', '.', 'X', 'X']]",
        "output": "6",
        "explanation": "Each 'X' on the board represents a battleship segment, giving a total of 6 distinct battleships."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using DFS or marking the segments of battleships in a single pass."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Find All Numbers Disappeared in an Array",
    "description": "Given an array of integers where 1 \u2264 a[i] \u2264 n (n is the size of the array), some elements appear twice and others appear once. Your task is to find all the elements of [1, n] inclusive that do not appear in this array. Return the answer in any order.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Frequency"
    ],
    "input_format": "An array of integers nums of length n.",
    "output_format": "A list of integers representing all the numbers that are missing.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "1 <= nums[i] <= n"
    ],
    "examples": [
      {
        "input": "nums = [4,3,2,7,8,2,3,1]",
        "output": "[5, 6]",
        "explanation": "The numbers 5 and 6 are missing from the range 1 to 8."
      },
      {
        "input": "nums = [1, 1, 2, 2]",
        "output": "[3, 4]",
        "explanation": "The numbers 3 and 4 are missing from the range 1 to 4."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Try to use the array itself to track the presence of numbers."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Search a 2D Matrix",
    "description": "Write an efficient algorithm that searches for a target value in an m x n integer matrix. The matrix has the following properties: 1. Integers in each row are sorted in ascending from left to right. 2. Integers in each column are sorted in ascending from top to bottom. Return true if the target is found in the matrix; otherwise, return false.",
    "topic": "Matrix",
    "subtopic": "Search Algorithm",
    "tags": [
      "Matrix",
      "Binary Search",
      "Search"
    ],
    "input_format": "An m x n matrix of integers and an integer target.",
    "output_format": "A boolean value indicating whether the target is found in the matrix.",
    "constraints": [
      "1 <= m, n <= 100",
      "-10^4 <= matrix[i][j], target <= 10^4"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [12, 14, 16]], target = 9",
        "output": "true",
        "explanation": "The number 9 is found in the matrix."
      },
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6]], target = 7",
        "output": "false",
        "explanation": "The number 7 is not found in the matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a binary search strategy.",
      "Start searching from the top-right corner of the matrix."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Longest Subarray of 1's After Deleting One Element",
    "description": "Given a binary array nums, you can delete one element from the array. Your task is to find the length of the longest contiguous subarray that contains only 1's after deleting one element. You can assume that the array will have at least one 0 in it.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Binary Array"
    ],
    "input_format": "An array of integers nums where nums[i] is either 0 or 1.",
    "output_format": "An integer representing the length of the longest contiguous subarray of 1's after deleting one element.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "nums[i] is either 0 or 1"
    ],
    "examples": [
      {
        "input": "nums = [1,1,0,1,1,1]",
        "output": "5",
        "explanation": "By deleting the 0, we can achieve the longest subarray of 1's which is 1,1,1,1,1 with a length of 5."
      },
      {
        "input": "nums = [0,0,0,0]",
        "output": "1",
        "explanation": "We can delete any one of the 0's to get a contiguous subarray of length 1."
      },
      {
        "input": "nums = [1,1,1,0,1,0,1,1,1]",
        "output": "7",
        "explanation": "By deleting one of the 0's, we can achieve the longest subarray of 1's which has a length of 7."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window approach to keep track of the number of 0's in the window.",
      "Expand the window until you have more than one 0, then shrink it."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "You are given an integer array 'nums' that is sorted in ascending order and then rotated at an unknown pivot index. Given the array and an integer 'target', return the index of 'target' in 'nums'. If 'target' is not in 'nums', return -1. You must write an algorithm with a runtime complexity of O(log n).",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An integer representing the index of target in nums or -1 if not found.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "nums is guaranteed to be rotated at some pivot.",
      "All integers in nums are unique.",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [4, 5, 6, 7, 0, 1, 2], target = 0",
        "output": "4",
        "explanation": "The target 0 is found at index 4 in the rotated array."
      },
      {
        "input": "nums = [4, 5, 6, 7, 0, 1, 2], target = 3",
        "output": "-1",
        "explanation": "The target 3 is not found in the array, hence the output is -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how the array changes its properties after the rotation.",
      "Use binary search and identify which part of the array to search next."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Minimum Difference Between Highest and Lowest of K Scores",
    "description": "Given an array of integers representing scores, your task is to find the minimum difference between the highest and lowest scores when considering any subset of K scores from the array. You must return the minimum possible difference among all subsets of size K.",
    "topic": "Array",
    "subtopic": "Sorting and Sliding Window",
    "tags": [
      "Array",
      "Sorting",
      "Sliding Window"
    ],
    "input_format": "An array of integers scores and an integer K representing the number of scores to consider.",
    "output_format": "An integer that represents the minimum difference between the highest and lowest scores of any K-sized subset.",
    "constraints": [
      "1 <= scores.length <= 1000",
      "0 <= scores[i] <= 10^9",
      "1 <= K <= scores.length"
    ],
    "examples": [
      {
        "input": "scores = [1, 3, 6, 10, 15], K = 3",
        "output": "6",
        "explanation": "The subset [3, 6, 10] has the maximum score of 10 and the minimum score of 3. The difference is 10 - 3 = 7. The subset [6, 10, 15] has 10 and 6, the difference is 15 - 6 = 9. The minimum difference found is 6."
      },
      {
        "input": "scores = [10, 100, 300, 200, 150, 400], K = 4",
        "output": "200",
        "explanation": "The subset [100, 200, 300, 400] shows the lowest max-min difference as 400 - 100 = 300 compared to other subsets."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider sorting the scores first.",
      "Use a sliding window approach to find minimum differences."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Count Square Submatrices with All Ones",
    "description": "Given a binary matrix, return the number of square submatrices that have all ones. A square submatrix of size k x k is said to be valid if every element in that submatrix is 1. For example, in a matrix where only some elements are 1, you should count how many square submatrices of all 1's can fit within the matrix boundaries.",
    "topic": "Dynamic Programming",
    "subtopic": "Matrix",
    "tags": [
      "Dynamic Programming",
      "Matrix",
      "Count"
    ],
    "input_format": "A binary matrix represented as a list of lists, where each sublist contains only 0's and 1's.",
    "output_format": "An integer representing the total count of square submatrices with all ones.",
    "constraints": [
      "1 <= matrix.length <= 100",
      "1 <= matrix[i].length <= 100",
      "matrix[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "[[1,0,1],[1,1,1],[1,0,1]]",
        "output": "13",
        "explanation": "There are 13 square submatrices with all 1's: 1x1 (9), 2x2 (4) and 3x3 (0)."
      },
      {
        "input": "[[0,1],[1,1]]",
        "output": "5",
        "explanation": "There are 5 square submatrices with all 1's: 1x1 (3), 2x2 (1)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store results of smaller subproblems.",
      "For each cell in the matrix, determine the maximum size of the square submatrix ending at that cell."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Decode String",
    "description": "Given an encoded string, return its decoded version. The encoding rule is that each segment of the string is of the form 'k[encoded_string]', where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is a positive integer. You may assume that the input string is well-formed and does not contain any extra spaces.",
    "topic": "String",
    "subtopic": "Decoding Strings",
    "tags": [
      "String",
      "Decoding",
      "Stack"
    ],
    "input_format": "A single string s which represents the encoded string.",
    "output_format": "A string which is the decoded version of the input string.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of digits, lowercase English letters, and square brackets."
    ],
    "examples": [
      {
        "input": "s = '3[a2[c]]'",
        "output": "accaccacc",
        "explanation": "The decoded string is 'acc' repeated three times."
      },
      {
        "input": "s = '2[abc]3[cd]ef'",
        "output": "abcabccdcdcdef",
        "explanation": "The decoded string is 'abc' repeated twice followed by 'cd' repeated thrice followed by 'ef'."
      },
      {
        "input": "s = '10[a]'",
        "output": "aaaaaaaaaa",
        "explanation": "The string 'a' is repeated ten times."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to help with the nesting of brackets.",
      "Keep track of numbers and characters separately."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Is Subsequence",
    "description": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., 'ace' is a subsequence of 'abcde' while 'aec' is not).",
    "topic": "String",
    "subtopic": "Subsequence",
    "tags": [
      "String",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "input_format": "Two strings s and t where 0 <= s.length <= 100 and 0 <= t.length <= 10^4.",
    "output_format": "A boolean value indicating whether s is a subsequence of t.",
    "constraints": [
      "0 <= s.length <= 100",
      "0 <= t.length <= 10^4",
      "s and t consist only of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = \"abc\", t = \"ahbgdc\"",
        "output": "true",
        "explanation": "'abc' is a subsequence of 'ahbgdc'."
      },
      {
        "input": "s = \"axc\", t = \"ahbgdc\"",
        "output": "false",
        "explanation": "'axc' is not a subsequence of 'ahbgdc'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to iterate through both strings.",
      "If characters match, move the pointer in string s.",
      "Check if all characters of s were found in t."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Event Emitter",
    "description": "Design an EventEmitter class that allows you to subscribe to events, emit events, and unsubscribe from events. The class should support the following methods: \n\n1. `on(event: string, listener: Function): void` - Register a listener for the specified event.\n2. `emit(event: string, ...args: any[]): void` - Call all the registered listeners for the specified event, passing any arguments to the listeners.\n3. `off(event: string, listener: Function): void` - Unregister a listener from the specified event.\n\nAn EventEmitter can have multiple listeners for the same event, and they should be invoked in the order they were added. If the event has no listeners, the emit call should do nothing.",
    "topic": "Design",
    "subtopic": "Event Handling",
    "tags": [
      "Design",
      "EventEmitter",
      "JavaScript"
    ],
    "input_format": "You will be instantiating an EventEmitter object and calling methods on it.",
    "output_format": "The output should be the side effects of the listeners executed during the emit call.",
    "constraints": [
      "Methods will be called in the sequence defined in the problem description.",
      "The listener functions will not have side effects other than their specified behavior."
    ],
    "examples": [
      {
        "input": "const emitter = new EventEmitter();\nconst listener = (data) => console.log(data);\nemitter.on('event1', listener);\nemitter.emit('event1', 'Hello, World!');",
        "output": "Hello, World!",
        "explanation": "The listener was registered for 'event1'. When 'event1' was emitted with 'Hello, World!', the listener logged the message."
      },
      {
        "input": "const emitter = new EventEmitter();\nconst listener1 = () => console.log('Listener 1');\nconst listener2 = () => console.log('Listener 2');\nemitter.on('event1', listener1);\nemitter.on('event1', listener2);\nemitter.emit('event1');",
        "output": "Listener 1\nListener 2",
        "explanation": "Both listeners were registered for 'event1'. They are invoked in the order they were added."
      },
      {
        "input": "const emitter = new EventEmitter();\nconst listener = (data) => console.log(data);\nemitter.on('event1', listener);\nemitter.off('event1', listener);\nemitter.emit('event1', 'Hello!');",
        "output": "",
        "explanation": "The listener was removed using the off method. Thus, no output was produced when 'event1' was emitted."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a map to store events and their associated listeners.",
      "Make sure to handle multiple listeners for the same event appropriately."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Maximize Distance to Closest Person",
    "description": "You are given an array representing seats and empty chairs in a row. '1' represents a person sitting in a seat, and '0' represents an empty chair. Your task is to find the maximum distance that can be achieved by sitting a new person in an empty chair, given that the maximum distance is defined as the distance to the closest person already seated. If there are multiple optimal positions, return the maximum distance that can be achieved.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Binary Search"
    ],
    "input_format": "An array of integers seats containing only 0s and 1s.",
    "output_format": "An integer representing the maximum distance to the closest person.",
    "constraints": [
      "1 <= seats.length <= 10^5",
      "seats[i] is either 0 or 1",
      "There is at least one seat occupied."
    ],
    "examples": [
      {
        "input": "seats = [1, 0, 0, 0, 1, 0, 1]",
        "output": "2",
        "explanation": "The maximum distance is 2 which can be achieved by sitting a new person at the 3rd or 4th position."
      },
      {
        "input": "seats = [0, 1]",
        "output": "1",
        "explanation": "The maximum distance is 1 which can be achieved by sitting a new person at position 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the edges of the array when calculating distances.",
      "The distance to the closest person involves checking empty chair segments."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Meeting Rooms II",
    "description": "Given a list of meeting time intervals represented as start and end times, determine the minimum number of meeting rooms required to hold all the meetings without overlap. Each meeting is represented as an interval [start, end].",
    "topic": "Interval",
    "subtopic": "Meeting Scheduling",
    "tags": [
      "Interval",
      "Greedy",
      "Sorting"
    ],
    "input_format": "A list of intervals, where each interval is represented as a pair of integers [start, end].",
    "output_format": "An integer representing the minimum number of meeting rooms required.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "0 <= start < end <= 10^6"
    ],
    "examples": [
      {
        "input": "[[0, 30], [5, 10], [15, 20]]",
        "output": "2",
        "explanation": "Meetings [0, 30] and [5, 10] overlap, so two meeting rooms are required."
      },
      {
        "input": "[[7, 10], [2, 4]]",
        "output": "1",
        "explanation": "Meetings [7, 10] and [2, 4] do not overlap, so only one meeting room is needed."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on start time.",
      "Use a priority queue to track the end times of meetings."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Squares of a Sorted Array",
    "description": "Given an array of integers sorted in non-decreasing order, you need to return an array of the squares of each number, also sorted in non-decreasing order.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Squares"
    ],
    "input_format": "An array of integers nums, sorted in non-decreasing order.",
    "output_format": "An array of integers representing the squares of each number in sorted order.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-4, -1, 0, 3, 10]",
        "output": "[0, 1, 9, 16, 100]",
        "explanation": "The squares are [16, 1, 0, 9, 100] which when sorted gives [0, 1, 9, 16, 100]."
      },
      {
        "input": "nums = [-7, -3, 2, 3, 11]",
        "output": "[4, 9, 9, 49, 121]",
        "explanation": "The squares are [49, 9, 4, 9, 121] which when sorted gives [4, 9, 9, 49, 121]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers to traverse the array from both ends."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Subarray Sums Divisible by K",
    "description": "Given an integer array nums and an integer k, return the number of non-empty subarrays whose sum is divisible by k. A subarray is a contiguous part of the array.",
    "topic": "Array",
    "subtopic": "Subarray",
    "tags": [
      "Array",
      "Subarray",
      "Prefix Sum"
    ],
    "input_format": "An integer array nums and an integer k.",
    "output_format": "An integer representing the number of subarrays whose sum is divisible by k.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= k <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [4, 5, 0, -2, -3, 1], k = 5",
        "output": "7",
        "explanation": "The subarrays that are divisible by 5 are: [4], [5], [0], [5, 0, -2, -3], [0, -2, -3], [5, 0, -2, -3, 1], and [4, 5, 0, -2, -3]."
      },
      {
        "input": "nums = [1, 2, 3], k = 3",
        "output": "2",
        "explanation": "The subarrays that are divisible by 3 are: [3] and [1, 2]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a prefix sum and a hash map to store counts of remainders."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Department Highest Salary",
    "description": "You are tasked with finding the highest salary in each department from an array of employee records. Each record contains an employee's ID, their department, and their salary. Return the highest salary from each department. If there are no employees in a department, return 'NULL' for that department.",
    "topic": "Database",
    "subtopic": "Aggregation",
    "tags": [
      "SQL",
      "Aggregation",
      "Group By"
    ],
    "input_format": "An array of employee records, each represented as a tuple with (employee_id, department, salary).",
    "output_format": "An array of tuples, each containing the department name and the highest salary or 'NULL'.",
    "constraints": [
      "1 <= employee_records.length <= 10^4",
      "employee_id is unique and is a positive integer.",
      "department is a non-empty string.",
      "salary is a non-negative integer."
    ],
    "examples": [
      {
        "input": "[ (1, 'HR', 5000), (2, 'Engineering', 7000), (3, 'HR', 6000), (4, 'Engineering', 8000) ]",
        "output": "[ ('HR', 6000), ('Engineering', 8000) ]",
        "explanation": "The highest salary in HR is 6000, and in Engineering is 8000."
      },
      {
        "input": "[ (1, 'Sales', 3000), (2, 'Sales', 4000), (3, 'Marketing', 2000) ]",
        "output": "[ ('Sales', 4000), ('Marketing', 2000) ]",
        "explanation": "The highest salary in Sales is 4000 and in Marketing is 2000."
      },
      {
        "input": "[ ]",
        "output": "[ ]",
        "explanation": "There are no employee records, hence no departments."
      },
      {
        "input": "[ (1, 'Accounting', 5000), (2, 'HR', 5000), (3, 'HR', 6000), (4, 'Accounting', 3000) ]",
        "output": "[ ('Accounting', 5000), ('HR', 6000) ]",
        "explanation": "The highest salary in Accounting is 5000 and in HR is 6000."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Group the records by department and calculate the maximum salary for each group.",
      "Use a suitable data structure to keep track of the maximum salary during iteration."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Line Reflection",
    "description": "Given a set of points in a 2D plane, you need to write a function that determines whether these points can be reflected over a vertical line such that the reflected points coincide with the original points. The line can be drawn anywhere on the x-axis. You must consider that points can be duplicated and some may be collinear.",
    "topic": "Geometry",
    "subtopic": "Line Reflection",
    "tags": [
      "Geometry",
      "Line Intersection",
      "Reflection"
    ],
    "input_format": "A list of points, where each point is represented as a tuple (x, y).",
    "output_format": "A boolean value indicating whether reflection over a vertical line is possible.",
    "constraints": [
      "1 <= points.length <= 1000",
      "-10^4 <= points[i][0], points[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "points = [[1, 1], [2, 2], [3, 3]]",
        "output": "false",
        "explanation": "The points cannot be reflected on a vertical line because their positions do not allow for symmetry."
      },
      {
        "input": "points = [[1, 1], [-1, 1]]",
        "output": "true",
        "explanation": "The points can be reflected over the vertical line x = 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Calculate the midline for the x-coordinates and ensure symmetry.",
      "Use a hashmap to count occurrences of points for efficient checks."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Isomorphic Strings",
    "description": "Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
    "topic": "String",
    "subtopic": "String Matching",
    "tags": [
      "String",
      "Hash Map",
      "Two Pointers"
    ],
    "input_format": "Two strings s and t, each consisting of lowercase English letters.",
    "output_format": "A boolean value indicating whether the strings are isomorphic.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "1 <= t.length <= 10^5",
      "s and t consist of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = \"egg\", t = \"add\"",
        "output": "true",
        "explanation": "The character 'e' maps to 'a' and 'g' maps to 'd'."
      },
      {
        "input": "s = \"foo\", t = \"bar\"",
        "output": "false",
        "explanation": "The character 'f' maps to 'b' but 'o' cannot map to both 'a' and 'r'."
      },
      {
        "input": "s = \"paper\", t = \"title\"",
        "output": "true",
        "explanation": "The character 'p' maps to 't', 'a' to 'i', 'e' to 'l', and 'r' to 'e'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two hash maps to track the mapping of characters.",
      "Check for one-to-one mapping between characters of both strings."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Subarray Sum Equals K",
    "description": "Given an array of integers nums and an integer k, return the number of continuous subarrays whose sum equals to k.",
    "topic": "Array",
    "subtopic": "Sliding Window / Prefix Sum",
    "tags": [
      "Array",
      "HashMap",
      "Prefix Sum"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An integer representing the number of continuous subarrays whose sum equals k.",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-1000 <= nums[i] <= 1000",
      "-10^7 <= k <= 10^7"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 1], k = 2",
        "output": "2",
        "explanation": "There are two subarrays whose sum equals 2: [1, 1] (indices 0 to 1) and [1, 1] (indices 1 to 2)."
      },
      {
        "input": "nums = [1, 2, 3], k = 3",
        "output": "2",
        "explanation": "The subarrays that sum to 3 are [1, 2] (indices 0 to 1) and [3] (index 2)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hashmap to store the cumulative sum and its frequencies.",
      "Every time you find a cumulative sum that equals k, you found a valid subarray.",
      "Try to optimize space and time complexity."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Paint House",
    "description": "In this problem, you are given a row of houses, where each house can be painted in one of three colors: Red, Green, or Blue. The cost of painting each house in each color is represented by a 2D array costs, where costs[i][j] is the cost of painting the i-th house with the j-th color. You need to find the minimum cost to paint all houses such that no two adjacent houses have the same color.",
    "topic": "Dynamic Programming",
    "subtopic": "Minimum Cost Path",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "A 2D array costs where costs[i][j] represents the cost to paint the i-th house with the j-th color.",
    "output_format": "An integer representing the minimum cost to paint all houses.",
    "constraints": [
      "1 <= costs.length <= 100",
      "costs[i].length == 3",
      "0 <= costs[i][j] <= 20"
    ],
    "examples": [
      {
        "input": "costs = [[17, 2, 17], [16, 16, 5], [14, 3, 19]]",
        "output": "10",
        "explanation": "The optimal way is to paint house 0 with color 1 (cost 2), house 1 with color 2 (cost 5), and house 2 with color 1 (cost 3). Total cost = 2 + 5 + 3 = 10."
      },
      {
        "input": "costs = [[7, 6, 2], [2, 3, 5], [8, 1, 10]]",
        "output": "5",
        "explanation": "The optimal way is to paint house 0 with color 2 (cost 2) and house 1 with color 0 (cost 2) then house 2 with color 1 (cost 1). Total cost = 2 + 2 + 1 = 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to keep track of the minimum cost up to each house.",
      "Use a 2D array to store the costs of painting each house with each color."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Valid Palindrome",
    "description": "Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring case. An input string is a palindrome if it reads the same backward as forward.",
    "topic": "String",
    "subtopic": "Two Pointers",
    "tags": [
      "String",
      "Two Pointers",
      "Palindrome"
    ],
    "input_format": "A single string s consisting of ASCII characters.",
    "output_format": "A boolean value true if s is a palindrome, otherwise false.",
    "constraints": [
      "0 <= s.length <= 2 * 10^5",
      "s can contain any printable ASCII characters."
    ],
    "examples": [
      {
        "input": "s = 'A man, a plan, a canal: Panama'",
        "output": "true",
        "explanation": "Ignoring case and non-alphanumeric characters, we get 'amanaplanacanalpanama' which is the same forwards and backwards."
      },
      {
        "input": "s = 'race a car'",
        "output": "false",
        "explanation": "Ignoring case and non-alphanumeric characters, we get 'raceacar', which is not the same forwards and backwards."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to compare characters from both ends of the string.",
      "Skip non-alphanumeric characters and handle case conversion."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Find the Longest Balanced Substring of a Binary String",
    "description": "Given a binary string consisting of '0's and '1's, your task is to find the length of the longest substring that contains equal numbers of '0's and '1's. A balanced substring is one where the count of '0's is equal to the count of '1's.",
    "topic": "String",
    "subtopic": "Substring",
    "tags": [
      "String",
      "Substring",
      "Count"
    ],
    "input_format": "A binary string s consisting of characters '0' and '1'.",
    "output_format": "An integer representing the length of the longest balanced substring.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s[i] is either '0' or '1'."
    ],
    "examples": [
      {
        "input": "s = \"00110011\"",
        "output": "8",
        "explanation": "The longest balanced substrings are \"0011\" and \"1100\", both of length 4, giving a total length of 8."
      },
      {
        "input": "s = \"101010\"",
        "output": "6",
        "explanation": "The entire string is balanced with an equal number of '0's and '1's, yielding a length of 6."
      },
      {
        "input": "s = \"111000\"",
        "output": "0",
        "explanation": "There are no balanced substrings since the counts of '1's and '0's are not equal."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a hashmap to track counts.",
      "Look for pairs of indices where counts match."
    ],
    "company": "Tinkoff"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List",
    "description": "Given the head of a singly linked list, reverse the list and return the reversed list.",
    "topic": "Linked List",
    "subtopic": "Reversing Linked List",
    "tags": [
      "Linked List",
      "Reversal",
      "Two Pointers"
    ],
    "input_format": "A singly linked list represented by its head node.",
    "output_format": "The head node of the reversed linked list.",
    "constraints": [
      "The number of nodes in the linked list is in the range [0, 5000].",
      "-5000 <= Node.val <= 5000"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5]",
        "output": "[5, 4, 3, 2, 1]",
        "explanation": "The linked list is reversed from 1 -> 2 -> 3 -> 4 -> 5 to 5 -> 4 -> 3 -> 2 -> 1."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "An empty linked list remains unchanged when reversed."
      },
      {
        "input": "head = [1]",
        "output": "[1]",
        "explanation": "A single-node linked list remains unchanged when reversed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a previous pointer to keep track of the last reversed node.",
      "Iterate through the list while reversing the pointers.",
      "Consider the edge cases like empty or single-node lists."
    ],
    "company": "Tinkoff"
  }
]