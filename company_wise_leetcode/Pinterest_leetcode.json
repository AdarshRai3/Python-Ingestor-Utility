[
  {
    "question_id": "",
    "title": "Count and Say",
    "description": "The 'Count and Say' sequence is a sequence of digit strings defined by the recursive formula: countAndSay(1) = '1'. To generate the next term in the sequence, we describe the previous term. For example, the second term is generated by describing the first term: one '1' \u2192 '11'. The third term describes the second term: two '1s' \u2192 '21', and so on. Implement a function that takes an integer n and returns the nth term of the Count and Say sequence.",
    "topic": "String",
    "subtopic": "Sequence Generation",
    "tags": [
      "String",
      "Recursion",
      "Sequence"
    ],
    "input_format": "An integer n (1 <= n <= 30), the term of the sequence to generate.",
    "output_format": "A string representing the nth term of the Count and Say sequence.",
    "constraints": [
      "1 <= n <= 30"
    ],
    "examples": [
      {
        "input": "n = 1",
        "output": "1",
        "explanation": "The first term in the sequence is '1'."
      },
      {
        "input": "n = 4",
        "output": "1211",
        "explanation": "The terms are: 1 -> 11 -> 21 -> 1211. The fourth term is '1211'."
      },
      {
        "input": "n = 5",
        "output": "111221",
        "explanation": "The terms are 1 -> 11 -> 21 -> 1211 -> 111221. The fifth term is '111221'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to describe the previous term.",
      "Consider using a loop or recursion to build the term."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Reconstruct Itinerary",
    "description": "You are given a list of airline tickets represented as pairs of departure and arrival airports. Each ticket is represented as a list [from, to]. Your task is to reconstruct the itinerary in such a way that it uses all the tickets exactly once, and the itinerary must begin with 'JFK'. If there are multiple valid itineraries, return the one that goes alphabetically first.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "Depth First Search",
      "Backtracking"
    ],
    "input_format": "A list of lists, where each inner list contains two strings representing the departure and arrival airports.",
    "output_format": "A list of strings representing the ordered itinerary.",
    "constraints": [
      "1 <= tickets.length <= 300",
      "Each ticket's departure and arrival airport is represented by three capital letters.",
      "All tickets are unique."
    ],
    "examples": [
      {
        "input": "[['MUC', 'LHR'], ['JFK', 'MUC'], ['SFO', 'SJC'], ['LHR', 'SFO'], ['JFK', 'AAA']]",
        "output": "[ 'JFK', 'MUC', 'LHR', 'SFO', 'SJC' ]",
        "explanation": "The itinerary starts at JFK and must use all tickets exactly once."
      },
      {
        "input": "[['JFK', 'KUL'], ['JFK', 'NRT'], ['NRT', 'JFK']]",
        "output": "[ 'JFK', 'NRT', 'JFK', 'KUL' ]",
        "explanation": "Although there are multiple valid itineraries, the lexicographically smallest one is chosen."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a depth-first search to explore possible itineraries.",
      "You may need to sort the tickets before processing them."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Shortest Path in a Grid with Obstacles Elimination",
    "description": "Given a m x n grid, where each cell can either be an obstacle (1) or free (0), you can move up, down, left, or right from a cell to an adjacent cell. You are also allowed to eliminate at most k obstacles. Your goal is to find the shortest path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1). If there is no way to reach the bottom-right corner, return -1.",
    "topic": "Graph",
    "subtopic": "Shortest Path",
    "tags": [
      "Graph",
      "BFS",
      "Shortest Path"
    ],
    "input_format": "A grid represented as a 2D list of integers grid, and an integer k representing the maximum number of obstacles you can eliminate.",
    "output_format": "An integer representing the length of the shortest path, or -1 if there is no valid path.",
    "constraints": [
      "1 <= m, n <= 100",
      "0 <= k <= m * n",
      "grid[i][j] is 0 or 1."
    ],
    "examples": [
      {
        "input": {
          "grid": [
            [
              0,
              0,
              0
            ],
            [
              1,
              1,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          "k": 1
        },
        "output": 4,
        "explanation": "The path (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) can be taken while eliminating one obstacle at (1,1)."
      },
      {
        "input": {
          "grid": [
            [
              0,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              0,
              0
            ]
          ],
          "k": 1
        },
        "output": -1,
        "explanation": "There is no valid path to reach (2, 2) even after eliminating one obstacle."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using BFS to explore paths.",
      "Keep track of eliminated obstacles at each cell.",
      "Use a priority queue to minimize the length of the path."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Optimal Account Balancing",
    "description": "You are given a list of transactions between a group of friends, where each transaction indicates how much one friend owes another. Your task is to minimize the number of transactions required to settle all debts among the friends. Each friend starts with a balance that can be negative (indicating they owe money) or positive (indicating they are owed money). The goal is to find the minimum number of transactions needed to balance all accounts while ensuring that each transaction is between exactly two friends.",
    "topic": "Graph",
    "subtopic": "Minimum Transactions",
    "tags": [
      "Graph",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "An array of transactions, where each transaction is represented as a pair of integers [debtor, creditor].",
    "output_format": "An integer representing the minimum number of transactions required to settle all debts.",
    "constraints": [
      "1 <= transactions.length <= 10^5",
      "-10^5 <= transactions[i][0], transactions[i][1] <= 10^5"
    ],
    "examples": [
      {
        "input": "transactions = [[0, 1], [1, 2], [2, 0]]",
        "output": "1",
        "explanation": "The total debts can be settled with one transaction from any of the friends to another, reducing the transfers to just one."
      },
      {
        "input": "transactions = [[0, 1], [1, 2], [0, 2]]",
        "output": "2",
        "explanation": "Two transactions are needed: one from friend 0 to friend 1 and another from friend 1 to friend 2."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a hashmap to track the balances of each friend.",
      "Negative balances represent creditors while positive balances represent debtors."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Count Subarrays With Score Less Than K",
    "description": "You are given an integer array 'nums' and an integer 'k'. A subarray is defined as a contiguous part of the array. The score of a subarray is defined as the sum of all its elements. Your task is to count the number of contiguous subarrays whose score is strictly less than 'k'.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Sum"
    ],
    "input_format": "The first line contains an integer n (1 <= n <= 10^5), the length of the array. The second line contains n space-separated integers representing the elements of 'nums'. The third line contains an integer k.",
    "output_format": "Return an integer representing the number of contiguous subarrays whose score is less than k.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5",
      "1 <= k <= 10^9"
    ],
    "examples": [
      {
        "input": "5\n1 2 3 4 5\n10",
        "output": "7",
        "explanation": "The valid subarrays are: [1], [1,2], [1,2,3], [2], [2,3], [3], [4], [5]. All of these have sums less than 10."
      },
      {
        "input": "3\n5 1 4\n5",
        "output": "2",
        "explanation": "The valid subarrays are: [1], [1,4]. Both have sums less than 5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Try using a sliding window approach to efficiently count the valid subarrays."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Maximum Profit in Job Scheduling",
    "description": "You are given a list of jobs where each job is represented by a tuple (start_time, end_time, profit). You need to find the maximum profit you can achieve by scheduling non-overlapping jobs. A job can only be scheduled if it starts after the last scheduled job has ended. Return the maximum profit obtainable. Each job takes one unit of time, and you can only work on one job at a time.",
    "topic": "Dynamic Programming",
    "subtopic": "Job Scheduling",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Interval Scheduling"
    ],
    "input_format": "A list of tuples where each tuple contains three integers representing (start_time, end_time, profit).",
    "output_format": "An integer representing the maximum profit from non-overlapping jobs.",
    "constraints": [
      "1 <= jobs.length <= 1000",
      "0 <= start_time < end_time <= 10^5",
      "0 <= profit <= 1000"
    ],
    "examples": [
      {
        "input": "jobs = [(1, 2, 50), (3, 5, 20), (6, 19, 100), (2, 100, 200)]",
        "output": "250",
        "explanation": "Select jobs (1, 2, 50) and (6, 19, 100) to achieve the maximum profit of 50 + 200 = 250."
      },
      {
        "input": "jobs = [(1, 3, 10), (3, 4, 20), (4, 6, 30)]",
        "output": "60",
        "explanation": "Select all jobs to achieve a maximum profit of 10 + 20 + 30 = 60."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Sort the jobs based on their end times.",
      "Use dynamic programming to store the maximum profit until each job.",
      "Consider binary search to find the previous job that does not overlap."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Expression Add Operators",
    "description": "Given a string that contains only digits 0-9 and a target value, you need to insert the operators '+' and '-' (or no operator) between the digits to form an expression that evaluates to the target value. Return all possible combinations of expressions that evaluate to the target value.",
    "topic": "Backtracking",
    "subtopic": "Expression Evaluation",
    "tags": [
      "Backtracking",
      "String",
      "Recursion"
    ],
    "input_format": "A string representing the digits and an integer for the target value.",
    "output_format": "A list of strings representing all valid expressions that evaluate to the target value.",
    "constraints": [
      "1 <= digits.length <= 10",
      "-1000 <= target <= 1000"
    ],
    "examples": [
      {
        "input": "digits = '123', target = 6",
        "output": "['1+2+3', '1*2*3']",
        "explanation": "Both '1+2+3' and '1*2*3' evaluate to 6."
      },
      {
        "input": "digits = '232', target = 8",
        "output": "['2*3+2', '2+3*2']",
        "explanation": "'2*3+2' gives 8 and '2+3*2' also gives 8."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider backtracking to explore all combinations of operators.",
      "Use recursion to build expressions and evaluate their results."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Bus Routes",
    "description": "You are given a list of bus routes, where each route is represented as a list of stops. You are also given two bus stops: start and end. Your task is to find the minimum number of bus transfers required to go from the start stop to the end stop. A transfer is defined as changing from one bus route to another. You may assume that you cannot stay on one bus route after it has reached its destination stop. If it's not possible to reach the end stop from the start stop, return -1.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "Breadth-First Search"
    ],
    "input_format": "A list of bus routes, where each route is represented by an array of integers. Two integers representing the start and end bus stops.",
    "output_format": "An integer representing the minimum number of bus transfers required, or -1 if it is impossible to reach the end stop.",
    "constraints": [
      "1 <= routes.length <= 500",
      "1 <= routes[i].length <= 100",
      "1 <= start, end <= 10^6"
    ],
    "examples": [
      {
        "input": {
          "routes": [
            [
              1,
              2,
              7
            ],
            [
              3,
              6,
              7
            ]
          ],
          "start": 1,
          "end": 6
        },
        "output": 2,
        "explanation": "You can go from stop 1 to stop 7 via the first route and then transfer to the second route to reach stop 6."
      },
      {
        "input": {
          "routes": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ]
          ],
          "start": 1,
          "end": 6
        },
        "output": -1,
        "explanation": "There is no route that connects stop 1 to stop 6."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a graph to represent the bus routes.",
      "Consider using BFS to find the shortest path."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Find Median from Data Stream",
    "description": "The median is the middle value in a list of numbers. If the list is even-sized, it\u2019s the average of the two middle numbers. Design a data structure that supports the following operations: 1) addNum(int num): Add a integer number from the data stream to the data structure. 2) findMedian(): Retrieve the median of all elements so far. Your solution should be efficient both in terms of time and space.",
    "topic": "Design",
    "subtopic": "Data Structure",
    "tags": [
      "Design",
      "Data Structure",
      "Heap"
    ],
    "input_format": "A stream of integers consisting of a series of addNum operations followed by a findMedian operation.",
    "output_format": "A float representing the median of the current data stream.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= num <= 10^5"
    ],
    "examples": [
      {
        "input": "addNum(1); addNum(2); findMedian();",
        "output": "1.5",
        "explanation": "The data stream is [1, 2], and the median is (1 + 2) / 2 = 1.5."
      },
      {
        "input": "addNum(3); findMedian();",
        "output": "2.0",
        "explanation": "The data stream is [1, 2, 3], and the median is 2."
      },
      {
        "input": "addNum(4); addNum(5); findMedian();",
        "output": "3.0",
        "explanation": "The data stream is [1, 2, 3, 4, 5], and the median is 3."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using two heaps to maintain the smaller and larger halves of the numbers.",
      "The max heap can store the lower half, while the min heap can store the upper half."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Shortest Way to Form String",
    "description": "Given two strings 'source' and 'target', return the minimum number of operations required to transform 'source' into 'target'. You can perform the following operations: 1. Append a character from 'source' to 'target', or 2. Remove a character from 'target'. It is guaranteed that only characters from 'source' can be appended to 'target'. If 'target' can be formed without any operations, return 0.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Dynamic Programming",
      "Transformation"
    ],
    "input_format": "Two strings, source and target, given as input.",
    "output_format": "An integer representing the minimum number of operations required.",
    "constraints": [
      "1 <= source.length, target.length <= 1000",
      "source and target consist of lowercase letters."
    ],
    "examples": [
      {
        "input": "source = 'abc', target = 'ac'",
        "output": "1",
        "explanation": "You can remove 'c' from 'ac' to form 'a', and then append 'b' to get 'abc'. Therefore, it takes 1 operation."
      },
      {
        "input": "source = 'xyz', target = 'yxz'",
        "output": "2",
        "explanation": "You can remove 'y' and append 'y' to get 'xyz', hence 2 operations."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dynamic programming approach to track transformations.",
      "Think about how to efficiently check characters from source against target."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Is Subsequence",
    "description": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., 'ace' is a subsequence of 'abcde' while 'aec' is not).",
    "topic": "String",
    "subtopic": "Subsequence",
    "tags": [
      "String",
      "Two Pointers",
      "Subsequence"
    ],
    "input_format": "Two strings s and t where 0 <= s.length <= 100 and 0 <= t.length <= 10^4.",
    "output_format": "A boolean value, true if s is a subsequence of t, otherwise false.",
    "constraints": [
      "0 <= s.length <= 100",
      "0 <= t.length <= 10^4"
    ],
    "examples": [
      {
        "input": "s = \"abc\", t = \"ahbgdc\"",
        "output": "true",
        "explanation": "The characters 'a', 'b', and 'c' can be found in 'ahbgdc' in the same order."
      },
      {
        "input": "s = \"axc\", t = \"ahbgdc\"",
        "output": "false",
        "explanation": "Although 'a' and 'c' are in 'ahbgdc', they are not in the correct order."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to iterate through both strings.",
      "If you reach the end of s, it means s is a subsequence of t."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Reorganize String",
    "description": "Given a string s, rearrange the characters of s so that no two adjacent characters are the same. Return any possible rearrangement of the string or return an empty string if it is not possible.",
    "topic": "String",
    "subtopic": "Rearrangement",
    "tags": [
      "String",
      "Rearrangement",
      "Greedy"
    ],
    "input_format": "A string s consisting of lowercase English letters.",
    "output_format": "A rearranged string where no two adjacent characters are the same, or an empty string if no such arrangement is possible.",
    "constraints": [
      "1 <= s.length <= 500",
      "s consists of lowercase English letters only."
    ],
    "examples": [
      {
        "input": "s = \"aabbcc\"",
        "output": "abcabc",
        "explanation": "One possible rearrangement is 'abcabc'. No two adjacent characters are the same."
      },
      {
        "input": "s = \"aaab\"",
        "output": "",
        "explanation": "It's not possible to rearrange the string so that no two adjacent characters are the same."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider counting the occurrence of each character.",
      "Use a max heap to always place the most frequent character next."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Design Search Autocomplete System",
    "description": "Implement a search autocomplete system that suggests words based on a given prefix from a list of words. The system should support adding words to the dictionary and retrieving autocomplete suggestions efficiently. The suggestions should be ranked by their frequency of usage, and if two suggestions have the same frequency, they should be sorted lexicographically.",
    "topic": "Trie",
    "subtopic": "Data Structure Design",
    "tags": [
      "Trie",
      "Design",
      "Autocomplete",
      "Search"
    ],
    "input_format": "The system receives multiple operations: adding a word and suggesting words based on a prefix. Each operation is represented by a string: 'addWord(word)' for adding a word and 'autocomplete(prefix)' for getting suggestions.",
    "output_format": "For the autocomplete operation, return a list of the top 3 suggested words as an array of strings.",
    "constraints": [
      "1 <= word.length <= 100",
      "The input words contain only lowercase letters.",
      "The number of words added will not exceed 10^4."
    ],
    "examples": [
      {
        "input": "addWord('apple'); addWord('app'); autocomplete('app')",
        "output": "['app', 'apple']",
        "explanation": "Both 'app' and 'apple' match the prefix 'app'. They are returned, with 'app' coming first as it's the shortest."
      },
      {
        "input": "addWord('banana'); addWord('band'); addWord('bandana'); autocomplete('ban')",
        "output": "['band', 'banana', 'bandana']",
        "explanation": "The words that match the prefix 'ban' are 'band', 'banana', and 'bandana', ranked by their usage frequency."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a Trie for efficient prefix searching.",
      "Maintain a frequency count for each word to help with ranking."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Longest Word in Dictionary",
    "description": "Given an array of strings representing a dictionary and a string representing a sequence, return the longest word from the dictionary that can be formed by deleting some characters of the sequence without rearranging the order of the remaining characters. If there are multiple candidates, return the one that appears first in the dictionary. If no such word exists, return an empty string.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "Two inputs: an array of strings `dictionary` and a string `sequence`.",
    "output_format": "A string representing the longest word that can be formed from the sequence.",
    "constraints": [
      "1 <= dictionary.length <= 10^4",
      "1 <= dictionary[i].length <= 100",
      "1 <= sequence.length <= 100"
    ],
    "examples": [
      {
        "input": "dictionary = [\"ale\", \"apple\", \"monkey\", \"plea\"], sequence = \"abpcplea\"",
        "output": "\"apple\"",
        "explanation": "The longest word that can be formed from the sequence is 'apple'."
      },
      {
        "input": "dictionary = [\"a\", \"b\", \"c\"], sequence = \"abpcplea\"",
        "output": "\"a\"",
        "explanation": "The longest word is 'a' since it can be formed from 'abpcplea'."
      },
      {
        "input": "dictionary = [\"xyz\", \"apple\", \"app\"], sequence = \"aappl\"",
        "output": "\"app\"",
        "explanation": "The longest word that can be formed is 'app'."
      },
      {
        "input": "dictionary = [\"x\", \"y\", \"z\"], sequence = \"a\"",
        "output": "\"\"",
        "explanation": "No words can be formed, hence the result is an empty string."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a two-pointer technique to check if a word can be formed from the sequence.",
      "Remember to keep track of the longest valid word found."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Find Median Given Frequency of Numbers",
    "description": "You are given an array of integers representing the frequency of different numbers in a range from 1 to n. Your task is to calculate the median of these numbers based on their frequencies. The median is defined as the middle value in an ordered list of numbers. If the list has an even number of elements, the median is the average of the two middle numbers.",
    "topic": "Mathematics",
    "subtopic": "Statistics and Probability",
    "tags": [
      "Math",
      "Median",
      "Statistics"
    ],
    "input_format": "An array of integers freq where freq[i] represents the frequency of the number (i + 1). The length of freq will be n, where 1 <= n <= 10^5.",
    "output_format": "A floating-point number representing the median of the numbers based on their frequencies.",
    "constraints": [
      "1 <= freq.length <= 10^5",
      "0 <= freq[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "freq = [1, 3, 2]",
        "output": "2.0",
        "explanation": "The numbers represented are 1 (1 time), 2 (3 times), and 3 (2 times). The combined list is [1, 2, 2, 2, 3, 3]. The median is 2."
      },
      {
        "input": "freq = [0, 0, 3, 5, 2]",
        "output": "4.0",
        "explanation": "The numbers represented are 3 (3 times), 4 (5 times), and 5 (2 times). The combined list is [3, 4, 4, 4, 4, 4, 5, 5]. The median is 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Count the numbers based on frequencies and find the midpoint.",
      "Use a prefix sum to determine the middle elements efficiently."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Jump Game III",
    "description": "You are given an array of integers arr and an integer start. You can jump from index i to index i + arr[i] or i - arr[i], respectively. Your goal is to reach any index with an arr value of 0. Write a function to determine if you can reach an index with a value of 0 starting from index start.",
    "topic": "Array",
    "subtopic": "Graph Traversal",
    "tags": [
      "Array",
      "DFS",
      "BFS",
      "Graph"
    ],
    "input_format": "An array of integers arr where 1 <= arr.length <= 10^4 and an integer start where 0 <= start < arr.length.",
    "output_format": "Return true if you can reach an index with a value of 0, otherwise return false.",
    "constraints": [
      "1 <= arr.length <= 10^4",
      "-10000 <= arr[i] <= 10000"
    ],
    "examples": [
      {
        "input": "arr = [4, 2, 3, 0, 3, 1, 2], start = 5",
        "output": "True",
        "explanation": "From index 5, you can jump to index 4. From there, you can jump to index 3, which has a value of 0."
      },
      {
        "input": "arr = [3, 0, 2, 1, 2], start = 2",
        "output": "False",
        "explanation": "From index 2, you can only jump to index 4 (value of 2), and then to index 2 or 1. No way to reach index 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a set to track visited indices.",
      "Consider using BFS or DFS to explore the indices."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Find K-th Smallest Pair Distance",
    "description": "Given an array of integers and a number k, find the k-th smallest distance among all pairs from the array. The distance between a pair (a, b) is defined as |a - b|. Your task is to implement an efficient algorithm to determine this distance without having to compute all pairwise distances explicitly, which could be computationally expensive.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Sorting"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An integer representing the k-th smallest pair distance.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^6",
      "1 <= k <= (nums.length * (nums.length - 1)) / 2"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 1], k = 1",
        "output": "0",
        "explanation": "The pairs and their distances are (1,1) -> 0, (1,3) -> 2, (3,1) -> 2. The smallest distance is 0."
      },
      {
        "input": "nums = [1, 1, 1], k = 2",
        "output": "0",
        "explanation": "All pairs have a distance of 0. The 2nd smallest distance is also 0."
      },
      {
        "input": "nums = [1, 6, 1], k = 3",
        "output": "5",
        "explanation": "The pairs and their distances are (1,6) -> 5, (6,1) -> 5, (1,1) -> 0. The distances sorted are [0, 5]. Hence, the 3rd smallest is 5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using binary search on the answer for efficiency.",
      "Count how many pairs have a distance less than or equal to a mid value."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Coin Change",
    "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. You want to determine the fewest number of coins that you need to make up that amount. If that amount cannot be made up by any combination of the coins, return -1.",
    "topic": "Dynamic Programming",
    "subtopic": "Coin Change Problem",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Backtracking"
    ],
    "input_format": "An integer array coins followed by an integer amount.",
    "output_format": "An integer representing the minimum number of coins needed to make up the amount, or -1 if not possible.",
    "constraints": [
      "1 <= coins.length <= 12",
      "1 <= coins[i] <= 2^31 - 1",
      "0 <= amount <= 10^4"
    ],
    "examples": [
      {
        "input": "coins = [1, 2, 5], amount = 11",
        "output": "3",
        "explanation": "11 can be made by using two 5s and one 1, totaling 3 coins."
      },
      {
        "input": "coins = [2], amount = 3",
        "output": "-1",
        "explanation": "It is impossible to make the amount 3 with only coin of denomination 2."
      },
      {
        "input": "coins = [1], amount = 0",
        "output": "0",
        "explanation": "No coins are needed to make the amount 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dynamic programming approach to solve this problem.",
      "Use an array to store the minimum coins needed for each amount."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "String Compression",
    "description": "Given a string s, use the counts of consecutive repeating characters to compress the string. The resulting compressed string should be the original string with each character followed by its count. If the compressed string is not smaller than the original string, return the original string. You must solve the problem in-place without using extra space.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Compression",
      "In-place"
    ],
    "input_format": "A string s consisting of uppercase and lowercase English letters.",
    "output_format": "A compressed string if it is shorter than s, otherwise the original string.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only letters (upper and lower case)."
    ],
    "examples": [
      {
        "input": "s = \"aabcccccaaa\"",
        "output": "a2b1c5a3",
        "explanation": "The string can be compressed to 'a2b1c5a3', which is shorter than the original string."
      },
      {
        "input": "s = \"abbccd\"",
        "output": "abbccd",
        "explanation": "The compressed string 'a1b2c2d1' is longer than the original string, so we return 'abbccd'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Iterate through the string while keeping track of the current character and its count.",
      "Consider using a StringBuilder to construct the compressed string."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Sparse Matrix Multiplication",
    "description": "Given two sparse matrices A and B, return the result of multiplying them. You may assume that A's column number is equal to B's row number. The resulting matrix C should have a size of (A's row number) x (B's column number). A sparse matrix is represented as a list of lists, where each inner list represents a row and contains only non-zero elements at their respective columns.",
    "topic": "Matrix",
    "subtopic": "Matrix Multiplication",
    "tags": [
      "Matrix",
      "Multiplication",
      "Sparse"
    ],
    "input_format": "Two 2D lists (matrix A and matrix B) where each list contains lists of integers.",
    "output_format": "A 2D list representing the resultant matrix C after multiplication.",
    "constraints": [
      "1 <= A.length, B.length <= 100",
      "1 <= A[i].length, B[i].length <= 100",
      "0 <= A[i][j], B[i][j] <= 100",
      "Both matrices contain only non-negative integers."
    ],
    "examples": [
      {
        "input": "A = [[1, 0, 0], [0, 0, 2], [0, 3, 0]], B = [[7, 0, 0], [0, 0, 3], [0, 4, 0]]",
        "output": "[[7, 0, 0], [0, 0, 6], [21, 0, 0]]",
        "explanation": "The resultant matrix is computed as follows: (1*7, 0*3, 0*4), (0*7, 0*3 + 2*4, 0*0), and (0*7 + 3*0, 0*3, 3*4)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of sparse matrices to optimize the multiplication.",
      "Only multiply non-zero elements to reduce computation time."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Meeting Rooms III",
    "description": "You are given a list of meeting intervals where intervals[i] = [start_i, end_i]. Each interval represents a meeting's start and end time. You need to determine the minimum number of meeting rooms required to hold all meetings without conflicts. Additionally, consider that some meetings may start at the same time, and they will require separate rooms.",
    "topic": "Interval",
    "subtopic": "Greedy",
    "tags": [
      "Intervals",
      "Greedy",
      "Sorting"
    ],
    "input_format": "A list of intervals, where each interval is represented by a list of two integers [start, end].",
    "output_format": "An integer representing the minimum number of meeting rooms required.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "0 <= start_i < end_i <= 10^6"
    ],
    "examples": [
      {
        "input": "intervals = [[0, 30],[5, 10],[15, 20]]",
        "output": "2",
        "explanation": "The meetings [0,30] and [5,10] overlap, so at least 2 rooms are required."
      },
      {
        "input": "intervals = [[7, 10],[2, 4]]",
        "output": "1",
        "explanation": "The meetings do not overlap, so only 1 room is needed."
      },
      {
        "input": "intervals = [[1, 3],[2, 4],[3, 5]]",
        "output": "2",
        "explanation": "Meetings [1,3] and [2,4] overlap, thus requiring 2 rooms."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider sorting the intervals by their start times.",
      "Use a priority queue to track end times of meetings."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Target Sum",
    "description": "Given an integer array nums and an integer target, return the number of unique ways to add up numbers in nums to achieve the target sum. Each number in nums can be used any number of times.",
    "topic": "Dynamic Programming",
    "subtopic": "Combination Sum",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "DFS"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An integer representing the number of unique ways to achieve the target sum.",
    "constraints": [
      "1 <= nums.length <= 20",
      "0 <= target <= 500",
      "0 <= nums[i] <= 50"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3], target = 4",
        "output": "7",
        "explanation": "The unique combinations are: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [1, 3], [3, 1]."
      },
      {
        "input": "nums = [2, 3, 5], target = 8",
        "output": "5",
        "explanation": "The unique combinations are: [2, 2, 2, 2], [2, 3, 3], [3, 5], [5, 3], [2, 3, 3]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming for optimal solutions.",
      "Think about how you can build the target sum incrementally."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Unique Paths II",
    "description": "A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram). Now consider some obstacles placed in the grid. The value 1 represents an obstacle and the value 0 represents a free cell. The robot cannot walk through obstacles. Given the grid, return the number of unique paths from the top-left corner to the bottom-right corner.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Obstacle",
      "Pathfinding"
    ],
    "input_format": "A 2D integer array grid where grid[i][j] is 0 or 1.",
    "output_format": "An integer representing the number of unique paths to reach the bottom-right corner.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 100",
      "grid[i][j] is 0 or 1.",
      "The start point is always grid[0][0] and the end point is always grid[m-1][n-1]."
    ],
    "examples": [
      {
        "input": "grid = [[0,0,0],[0,1,0],[0,0,0]]",
        "output": "2",
        "explanation": "There are two unique paths to reach the bottom-right corner: right -> down -> down and down -> down -> right."
      },
      {
        "input": "grid = [[0,1],[0,0]]",
        "output": "1",
        "explanation": "There is only one unique path: down -> right."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use dynamic programming to find the number of unique paths.",
      "You can store the number of ways to reach each cell in a separate matrix.",
      "Consider edge cases like the start or end being an obstacle."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "The Number of Weak Characters in the Game",
    "description": "In a game, characters are represented by their attack and defense values. A character is considered weak if there exists another character with both a higher attack value and a higher defense value than it. Given an array of characters, where each character is represented as an array of two integers (attack, defense), you need to find the number of weak characters in the game.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Count"
    ],
    "input_format": "A 2D array where each sub-array represents a character's [attack, defense].",
    "output_format": "An integer representing the number of weak characters.",
    "constraints": [
      "1 <= characters.length <= 10^5",
      "1 <= characters[i][0], characters[i][1] <= 10^5"
    ],
    "examples": [
      {
        "input": "[[5, 5], [6, 3], [3, 6]]",
        "output": "0",
        "explanation": "No character is weak since no character has both attack and defense values lower than another."
      },
      {
        "input": "[[2, 2], [3, 3], [4, 4]]",
        "output": "2",
        "explanation": "The first two characters are weak because there are characters with higher attack and higher defense."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the characters based on attack in descending order.",
      "Use a variable to track the maximum defense seen so far while iterating."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Employee Free Time",
    "description": "Alice and Bob are coworkers in a company. They have their own schedules consisting of various meetings throughout the day. Each meeting is represented by a time interval. Alice wants to find out the common free time between her meeting schedule and Bob's meeting schedule, calculated as the intervals where neither of them has meetings. Your task is to find the common free time intervals between them and return these intervals.",
    "topic": "Interval Scheduling",
    "subtopic": "Merge Intervals",
    "tags": [
      "Intervals",
      "Scheduling",
      "Arrays"
    ],
    "input_format": "Two arrays of intervals, each represented by a pair of integers [start, end], where start and end are the start and end times of a meeting.",
    "output_format": "An array of intervals representing the free time periods where neither Alice nor Bob has any meetings.",
    "constraints": [
      "1 <= Alice's meeting count, Bob's meeting count <= 10^4",
      "0 <= start < end <= 10^9"
    ],
    "examples": [
      {
        "input": "Alice = [[1, 3], [6, 7]], Bob = [[2, 4]]",
        "output": "[[4, 6], [7, 10^9]]",
        "explanation": "Alice has meetings from 1 to 3 and from 6 to 7. Bob has a meeting from 2 to 4. The free time is from 4 to 6 and after 7."
      },
      {
        "input": "Alice = [[1, 2]], Bob = [[2, 3]]",
        "output": "[[0, 1], [3, 10^9]]",
        "explanation": "Alice has a meeting from 1 to 2 and Bob has a meeting from 2 to 3. The free time is before 1 and after 3."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider merging both schedules to identify overlapping intervals.",
      "Keep track of the end of the last meeting processed."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Unique Paths III",
    "description": "You are given a grid of size m x n, where each cell can be empty (0), a wall (-1), or the starting point (1) or ending point (2). You need to find all the unique paths from the start point to the end point such that you traverse all the non-wall cells exactly once. Return the number of unique paths that satisfy these criteria.",
    "topic": "Graph",
    "subtopic": "Backtracking",
    "tags": [
      "Graph",
      "Backtracking",
      "DFS"
    ],
    "input_format": "A 2D grid represented as a list of lists where each list contains integers: 0, -1, 1, or 2.",
    "output_format": "An integer representing the number of unique paths from the start point to the end point using all non-wall cells exactly once.",
    "constraints": [
      "1 <= m, n <= 20",
      "The grid will have exactly one starting point and one ending point.",
      "The number of non-wall cells will not exceed 15."
    ],
    "examples": [
      {
        "input": "[[1,0,0,0],[0,0,0,0],[0,0,-1,2]]",
        "output": "2",
        "explanation": "There are two unique paths: First path is to go right, down, down, left, left, up; Second path is to go down, down, left, left, up, right."
      },
      {
        "input": "[[1,0,0],[0,-1,2],[0,0,0]]",
        "output": "1",
        "explanation": "There is only one unique path: move down, right, right, up to traverse all reachable cells."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using backtracking to find all paths.",
      "You can use a depth-first search (DFS) approach."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Is Graph Bipartite?",
    "description": "Given an undirected graph, determine if it is possible to color the vertices of the graph using two colors such that no two adjacent vertices share the same color. A graph is called bipartite if you can do this. You can represent the graph using an adjacency list or an edge list.",
    "topic": "Graph",
    "subtopic": "Bipartiteness",
    "tags": [
      "Graph",
      "Bipartite",
      "DFS",
      "BFS"
    ],
    "input_format": "An integer n representing the number of vertices and a list of edges where each edge is represented as a pair of integers [u, v] that connect vertices u and v.",
    "output_format": "Return true if the graph is bipartite, otherwise return false.",
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= edges.length <= 10^4",
      "0 <= edges[i][0], edges[i][1] < n"
    ],
    "examples": [
      {
        "input": "n = 4, edges = [[0, 1], [1, 2], [0, 3], [3, 2]]",
        "output": "false",
        "explanation": "The graph contains a cycle of odd length (3), therefore it is not bipartite."
      },
      {
        "input": "n = 5, edges = [[0, 1], [0, 2], [1, 3], [2, 4]]",
        "output": "true",
        "explanation": "The graph can be colored using two colors. This is a bipartite graph."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using BFS or DFS to color the graph.",
      "If you find two adjacent vertices with the same color, the graph is not bipartite."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Accounts Merge",
    "description": "You are given a list of accounts, where each account is a list that contains a person's name followed by their emails. A person's accounts can be merged if they share at least one email. You need to return the merged accounts in any order. Each account must be unique, and the emails in each account must also be unique. Each account's name should appear only once, followed by its emails sorted in lexicographical order.",
    "topic": "Graph",
    "subtopic": "Union Find",
    "tags": [
      "Graph",
      "Union Find",
      "String"
    ],
    "input_format": "A list of lists, where each inner list contains a string (name) followed by strings (emails).",
    "output_format": "A list of lists, where each inner list contains a unique name followed by sorted emails.",
    "constraints": [
      "1 <= accounts.length <= 100",
      "1 <= accounts[i].length <= 100",
      "accounts[i][0] is the name and it is not empty.",
      "The emails are guaranteed to be in lowercase and unique within a single account."
    ],
    "examples": [
      {
        "input": "[['John', 'johnsmith@mail.com', 'john00@mail.com'], ['John', 'johnnybravo@mail.com'], ['John', 'johnsmith@mail.com', 'john_newyork@mail.com']]",
        "output": "[['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], ['John', 'johnnybravo@mail.com']]",
        "explanation": "The first and third accounts can be merged because they share the email 'johnsmith@mail.com'."
      },
      {
        "input": "[['Mary', 'mary@mail.com'], ['John', 'john@mail.com', 'mary@mail.com']]",
        "output": "[['John', 'john@mail.com', 'mary@mail.com'], ['Mary', 'mary@mail.com']]",
        "explanation": "The second account contains an email that matches the first account, thus they can be merged."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a graph structure to represent accounts and emails.",
      "Consider using a Union-Find (Disjoint Set Union) approach to merge accounts."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Combination Sum",
    "description": "Given an array of distinct integers 'candidates' and an integer 'target', return all the unique combinations of 'candidates' where the chosen numbers sum to 'target'. You may use the same number from 'candidates' an unlimited number of times. You may return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Combination Sum",
    "tags": [
      "Backtracking",
      "Combination",
      "Sum"
    ],
    "input_format": "An array of distinct integers 'candidates' and an integer 'target'.",
    "output_format": "A 2D array of integers representing all unique combinations of 'candidates' that sum to 'target'.",
    "constraints": [
      "1 <= candidates.length <= 30",
      "1 <= candidates[i] <= 200",
      "All elements of candidates are distinct.",
      "0 <= target <= 500"
    ],
    "examples": [
      {
        "input": "candidates = [2,3,6,7], target = 7",
        "output": "[[7], [2,2,3]]",
        "explanation": "The valid combinations that sum to 7 are [7] and [2,2,3]."
      },
      {
        "input": "candidates = [2,3,5], target = 8",
        "output": "[[2,2,2,2], [2,3,3], [3,5]]",
        "explanation": "The valid combinations that sum to 8 are [2,2,2,2], [2,3,3], and [3,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you will track the current combination and the remaining target.",
      "Try using a recursive function to explore combinations."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Multiply Strings",
    "description": "Given two non-negative integers represented as strings, return the product of these numbers, also represented as a string. Note that you should not use any built-in BigInteger library or convert the inputs to integers directly.",
    "topic": "String",
    "subtopic": "Mathematical Operations",
    "tags": [
      "String",
      "Math",
      "BigInteger"
    ],
    "input_format": "Two strings num1 and num2 representing the non-negative integers.",
    "output_format": "A string representing the product of the two integers.",
    "constraints": [
      "1 <= num1.length, num2.length <= 200",
      "num1 and num2 consist of digits only and do not contain any leading zeros, except for the number '0' itself."
    ],
    "examples": [
      {
        "input": "num1 = \"123\", num2 = \"456\"",
        "output": "56088",
        "explanation": "123 * 456 = 56088."
      },
      {
        "input": "num1 = \"2\", num2 = \"3\"",
        "output": "6",
        "explanation": "2 * 3 = 6."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to multiply each digit and handle carries.",
      "Think about the position of each digit in the multiplication."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Top K Frequent Elements",
    "description": "Given a non-empty array of integers, return the k most frequent elements. You may assume that the answer is guaranteed to be unique, and order does not matter.",
    "topic": "Hash Table",
    "subtopic": "Frequency Counting",
    "tags": [
      "Hash Table",
      "Counting",
      "Sorting"
    ],
    "input_format": "An integer array nums, followed by an integer k (1 <= k <= number of unique elements in nums).",
    "output_format": "An array of the k most frequent elements.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "k is in the range [1, the number of unique elements]"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 1, 2, 2, 3], k = 2",
        "output": "[1, 2]",
        "explanation": "The number 1 appears 3 times and the number 2 appears 2 times. Therefore, the top 2 frequent elements are 1 and 2."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "Only one element exists, which is the top frequent element."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to count frequencies.",
      "Consider using a heap or bucket sort for the final selection."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Letter Combinations of a Phone Number",
    "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters is given below. Note that 1 does not map to any letters.\n\n- 2: 'abc'\n- 3: 'def'\n- 4: 'ghi'\n- 5: 'jkl'\n- 6: 'mno'\n- 7: 'pqrs'\n- 8: 'tuv'\n- 9: 'wxyz'\n\nThe combinations should be returned in lexicographic order.",
    "topic": "Backtracking",
    "subtopic": "Combinatorial Backtracking",
    "tags": [
      "Backtracking",
      "Combinations",
      "String"
    ],
    "input_format": "A string digits, where 1 <= digits.length <= 4.",
    "output_format": "A list of strings representing all possible letter combinations.",
    "constraints": [
      "digits is a string of length from 1 to 4.",
      "Each digit in digits is between '2' and '9'."
    ],
    "examples": [
      {
        "input": "digits = '23'",
        "output": "[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]",
        "explanation": "The digit '2' maps to 'abc' and '3' maps to 'def', resulting in combinations of each letter."
      },
      {
        "input": "digits = '2'",
        "output": "[\"a\", \"b\", \"c\"]",
        "explanation": "The digit '2' maps directly to its corresponding letters."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a mapping for the digits to letter combinations.",
      "Use backtracking to explore all combinations."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Possible Bipartition",
    "description": "You are given a graph represented as a 2D array of integers, where each integer represents an edge between two nodes. Your task is to determine if it is possible to split the graph's nodes into two groups such that no two nodes within the same group are adjacent. If it is possible to do so, return true; otherwise, return false.",
    "topic": "Graph",
    "subtopic": "Bipartite Graph",
    "tags": [
      "Graph",
      "Bipartite",
      "DFS",
      "BFS"
    ],
    "input_format": "A 2D integer array edges where edges[i] is a pair of nodes representing an undirected edge.",
    "output_format": "A boolean indicating whether it is possible to bipartition the graph.",
    "constraints": [
      "1 <= edges.length <= 10^4",
      "1 <= edges[i][0], edges[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "[[1,2],[1,3],[2,4]]",
        "output": "true",
        "explanation": "The graph can be divided into two groups: {1, 4} and {2, 3}."
      },
      {
        "input": "[[1,2],[1,3],[2,3]]",
        "output": "false",
        "explanation": "The graph cannot be split into two groups since nodes 2 and 3 are connected."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using BFS or DFS to explore the graph.",
      "Track the color of each node to determine group assignments."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Single Element in a Sorted Array",
    "description": "You are given a sorted array consisting of integers where every element appears exactly twice, except for one element which appears exactly once. Your task is to find that single element which appears only once.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Unique Element"
    ],
    "input_format": "An array of integers nums where each element appears twice except for one.",
    "output_format": "An integer representing the single element that appears only once.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= nums[i] <= 10^5",
      "The input array is sorted."
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2, 2, 3, 3, 4, 4, 5]",
        "output": "5",
        "explanation": "All elements appear twice except for 5, which appears once."
      },
      {
        "input": "nums = [0, 0, 1, 1, 2, 2, 3, 4, 4, 5, 5]",
        "output": "3",
        "explanation": "All elements appear twice except for 3, which appears once."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to find the single element efficiently.",
      "The position of the single element can give insights into which half of the array to search next."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Meeting Rooms II",
    "description": "Given an array of meeting time intervals where intervals[i] = [start_i, end_i], return the minimum number of conference rooms required to hold all meetings. You may assume that the meetings do not overlap in a way that allows them to be in the same room.",
    "topic": "Greedy",
    "subtopic": "Interval Scheduling",
    "tags": [
      "Greedy",
      "Interval",
      "Minimization"
    ],
    "input_format": "An array of arrays, where each inner array consists of two integers representing the start and end times of a meeting.",
    "output_format": "An integer representing the minimum number of conference rooms required.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "0 <= start_i < end_i <= 10^6"
    ],
    "examples": [
      {
        "input": "intervals = [[0, 30],[5, 10],[15, 20]]",
        "output": "2",
        "explanation": "Two meetings (0-30 and 5-10) overlap, requiring two rooms."
      },
      {
        "input": "intervals = [[7, 10],[2, 4]]",
        "output": "1",
        "explanation": "The meetings do not overlap, requiring only one room."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a min-heap to track the end times of meetings."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Split Array Largest Sum",
    "description": "Given an array of integers 'nums' and an integer 'k', your task is to split 'nums' into 'k' non-empty continuous subarrays. The goal is to minimize the largest sum among these subarrays. Write a function that returns this minimized largest sum.",
    "topic": "Dynamic Programming",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Binary Search"
    ],
    "input_format": "An array of integers 'nums' and an integer 'k'.",
    "output_format": "An integer representing the minimized largest sum after splitting the array.",
    "constraints": [
      "1 <= k <= nums.length <= 1000",
      "0 <= nums[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [7, 2, 5, 10, 8], k = 2",
        "output": "18",
        "explanation": "One way to split the array is [7, 2, 5] and [10, 8]. The largest sum is 18."
      },
      {
        "input": "nums = [1, 2, 3, 4, 5], k = 2",
        "output": "9",
        "explanation": "One possible split is [1, 2, 3] and [4, 5]. The largest sum is 9."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using binary search to find the minimum largest sum.",
      "The range for the binary search can be between the largest element and the sum of the array."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Snakes and Ladders",
    "description": "You are given a board represented as a 1D array where each index corresponds to a position on the board. The board consists of N squares numbered from 1 to N. Some of these squares contain snakes or ladders. If you land on a square with a ladder, you move to a higher square, and if you land on a square with a snake, you move down to a lower square. Your task is to determine the minimum number of dice rolls required to reach the last square. You start at square 1 and can roll a dice ranging from 1 to 6 on each turn.",
    "topic": "Graph",
    "subtopic": "Shortest Path",
    "tags": [
      "Graph",
      "BFS",
      "Board Game"
    ],
    "input_format": "An integer N representing the number of squares, followed by an array of size N where each element can either be 0 (no snake or ladder), or a positive integer indicating the square you move to if you land on that square.",
    "output_format": "An integer representing the minimum number of dice rolls required to reach the last square, or -1 if it is not possible.",
    "constraints": [
      "2 <= N <= 1000",
      "The values in the ladder and snake array should be between 0 and N."
    ],
    "examples": [
      {
        "input": "N = 10, board = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",
        "output": "2",
        "explanation": "You can reach square 10 in 2 rolls: 1 -> 2 -> 10."
      },
      {
        "input": "N = 10, board = [0, 0, 0, 0, 0, 0, 5, 0, 0, 0]",
        "output": "3",
        "explanation": "You can reach square 10 in 3 rolls: 1 -> 2 -> 3 -> 10, with no snakes and ladders affecting your moves."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think of the board as a graph.",
      "Use BFS to find the shortest path."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Shortest Path to Get All Keys",
    "description": "You are given a grid representing a maze where you can find doors and keys. Each cell is represented by a character: '#' for walls, '.' for open paths, 'K' for keys, and 'D' for doors. You need to determine the shortest path that collects all keys in the maze. A door can only be passed if you have the corresponding key. Return the minimum number of steps required to collect all keys. If it is impossible to collect all keys, return -1.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "Shortest Path",
      "Bitmask"
    ],
    "input_format": "A 2D grid represented as a list of strings.",
    "output_format": "An integer representing the minimum number of steps required to collect all keys.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 30",
      "The grid contains at most 10 keys.",
      "The grid contains only lowercase letters for keys, uppercase letters for doors, '.', and '#'."
    ],
    "examples": [
      {
        "input": [
          "@.a.#",
          "###.#",
          "b.A.B"
        ],
        "output": "8",
        "explanation": "The path is: Start at '@', collect key 'a', go to 'b', collect key 'b', and finally return."
      },
      {
        "input": [
          "@..aA",
          "..##.",
          "b..ac"
        ],
        "output": "6",
        "explanation": "The path allows collecting all keys while handling doors appropriately."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use BFS to explore the grid.",
      "Keep track of the collected keys using a bitmask."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "The Maze",
    "description": "Given a 2D grid representing a maze, where '0' represents an open path and '1' represents a wall, determine if there is a path from the top-left corner of the grid to the bottom-right corner. You can only move right, left, up, or down. The function should return true if such a path exists, otherwise return false.",
    "topic": "Graph",
    "subtopic": "Depth-first Search",
    "tags": [
      "Graph",
      "DFS",
      "Pathfinding"
    ],
    "input_format": "A 2D list grid (n x m) representing the maze.",
    "output_format": "A boolean indicating whether there is a path from the top-left to the bottom-right corner.",
    "constraints": [
      "1 <= n, m <= 100",
      "grid[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "grid = [[0,0,0],[1,0,1],[0,0,0]]",
        "output": "true",
        "explanation": "A path exists: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2)."
      },
      {
        "input": "grid = [[0,1,0],[1,1,0],[0,0,0]]",
        "output": "false",
        "explanation": "No path exists due to walls blocking the way."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using depth-first search (DFS) for traversal.",
      "Use a set to keep track of visited cells to avoid cycles."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Find the Celebrity",
    "description": "In a party of n people, there is a celebrity who is known by everyone but knows no one. Given a 2D array 'trust' where trust[i] = [a, b] means person a trusts person b, determine who the celebrity is. A celebrity is defined as someone who is trusted by everyone and trusts no one. You must solve the problem in O(n) time complexity.",
    "topic": "Graph",
    "subtopic": "Searching",
    "tags": [
      "Graph",
      "Searching",
      "Celebrity"
    ],
    "input_format": "An integer n representing the number of people and a 2D list trust.",
    "output_format": "An integer representing the celebrity's index. If no celebrity exists, return -1.",
    "constraints": [
      "0 <= trust.length <= 10^4",
      "0 <= trust[i][0], trust[i][1] < n"
    ],
    "examples": [
      {
        "input": "n = 3, trust = [[1, 2], [2, 3], [3, 1]]",
        "output": "-1",
        "explanation": "There is no celebrity as everyone trusts someone."
      },
      {
        "input": "n = 4, trust = [[1, 2], [2, 3], [3, 4], [4, 2]]",
        "output": "2",
        "explanation": "Person 2 is the celebrity as they are trusted by 1, 3, and 4 but trust no one."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use an array to keep track of trust counts.",
      "Iterate through the trust array to determine potential celebrities."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Find First and Last Position of Element in Sorted Array",
    "description": "Given an integer array nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the starting and ending position of the target.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9",
      "nums is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 8",
        "output": "[3, 4]",
        "explanation": "The target 8 starts at index 3 and ends at index 4."
      },
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 6",
        "output": "[-1, -1]",
        "explanation": "The target 6 is not present in the array."
      },
      {
        "input": "nums = [], target = 0",
        "output": "[-1, -1]",
        "explanation": "The array is empty, so the target cannot be found."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a modified binary search to find the first occurrence.",
      "Once you find the first occurrence, you can find the last occurrence in a similar way."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given an m x n 2D binary grid representing a map where '1' (land) and '0' (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Graph",
    "subtopic": "Flood Fill",
    "tags": [
      "BFS",
      "DFS",
      "Graph",
      "Matrix"
    ],
    "input_format": "A 2D binary grid grid of size m x n.",
    "output_format": "An integer representing the number of islands.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "grid = [[1,1,0,0,0],[1,1,0,0,1],[0,0,0,1,1],[0,0,0,0,0]]",
        "output": "3",
        "explanation": "There are 3 islands in the grid."
      },
      {
        "input": "grid = [[1,1,1,1,0],[1,1,0,1,0],[1,1,0,0,0],[0,0,0,0,0]]",
        "output": "1",
        "explanation": "There is 1 island in the grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using Depth-First Search (DFS) or Breadth-First Search (BFS) to traverse the islands.",
      "Mark visited land cells as water to avoid counting them multiple times."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Implement Trie (Prefix Tree)",
    "description": "A Trie (pronounced as 'try') is a special type of tree used to store associative data structures. A common application of a Trie is storing a predictive text or autocomplete dictionary. In this problem, you will implement a Trie class with the following methods: \n\n1. `insert(word: str)`: Inserts the word into the Trie.\n2. `search(word: str)`: Returns true if the word is in the Trie (i.e., if it was inserted before).\n3. `startsWith(prefix: str)`: Returns true if there is a previously inserted word that starts with the given prefix.",
    "topic": "Data Structure",
    "subtopic": "Trie",
    "tags": [
      "Trie",
      "Data Structure",
      "Tree"
    ],
    "input_format": "The input will consist of a sequence of operations to perform on the Trie, each represented as a list of strings. Each string can either be 'insert', 'search', or 'startsWith', followed by a word or prefix.",
    "output_format": "A list of boolean values representing the results of each `search` and `startsWith` operation.",
    "constraints": [
      "0 < word.length <= 200",
      "The input consists of lowercase English letters.",
      "The maximum number of operations will not exceed 10000."
    ],
    "examples": [
      {
        "input": "[['insert', 'apple'], ['search', 'apple'], ['search', 'app'], ['startsWith', 'app'], ['insert', 'app'], ['search', 'app']]",
        "output": "[true, false, true, true, true]",
        "explanation": "After inserting 'apple', searching for 'apple' returns true. Searching for 'app' returns false since it was not inserted. 'startsWith' returns true as 'app' is a prefix of 'apple'. After inserting 'app', searching for 'app' returns true."
      },
      {
        "input": "[['insert', 'car'], ['insert', 'cat'], ['search', 'car'], ['startsWith', 'ca']]",
        "output": "[true, true, true]",
        "explanation": "Both 'car' and 'cat' are inserted, and searching for 'car' confirms presence. 'startsWith' confirms presence of any word that starts with 'ca'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hashmap to represent children of nodes.",
      "Consider storing a boolean value at each node to indicate end of a word."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Candy Crush",
    "description": "You're given a 2D grid of integers where each integer represents candies of different types. Your goal is to eliminate groups of 3 or more adjacent candies of the same type. After a group is eliminated, all candies above the eliminated group will fall down to fill the empty spaces. Implement a function that simulates the candy crush operation until no more groups can be eliminated. Return the final grid configuration.",
    "topic": "Array",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "input_format": "A 2D array of integers grid representing the candies.",
    "output_format": "A 2D array of integers representing the final state of the grid after all possible crushes.",
    "constraints": [
      "1 <= grid.length <= 50",
      "1 <= grid[i].length <= 50",
      "0 <= grid[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "grid = [[1,1,1,0],[0,1,2,2],[3,2,2,3]]",
        "output": "[[0,0,0,0],[0,0,0,0],[3,0,0,3]]",
        "explanation": "The group of 1s in the first row gets eliminated and nothing else can be crushed."
      },
      {
        "input": "grid = [[1,1,2],[1,2,2],[2,2,2]]",
        "output": "[[0,0,0],[0,0,0],[0,0,0]]",
        "explanation": "All candies can be crushed, resulting in an empty grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth First Search (DFS) to find groups of adjacent candies.",
      "Keep track of the positions of candies that need to be crushed.",
      "After crushing candies, ensure to implement the gravity effect."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Dot Product of Two Sparse Vectors",
    "description": "Given two sparse vectors, implement a method to compute their dot product. A sparse vector is represented by a list of indices and a corresponding list of values, where each index-value pair indicates that value is present at that index in the vector. Your task is to implement the dot product function that takes two such sparse vectors and returns their dot product (scalar product).",
    "topic": "Mathematics",
    "subtopic": "Linear Algebra",
    "tags": [
      "Mathematics",
      "Sparse Vector",
      "Dot Product"
    ],
    "input_format": "Two sparse vectors represented as two pairs: two lists of indices and two lists of values.",
    "output_format": "An integer representing the dot product of the two sparse vectors.",
    "constraints": [
      "1 <= len(indices1), len(indices2) <= 1000",
      "0 <= indices1[i], indices2[j] <= 10^6",
      "values1[i] and values2[j] are non-negative integers."
    ],
    "examples": [
      {
        "input": {
          "indices1": [
            1,
            3
          ],
          "values1": [
            2,
            3
          ],
          "indices2": [
            3,
            1
          ],
          "values2": [
            4,
            5
          ]
        },
        "output": "23",
        "explanation": "Dot product = (2 * 5) + (3 * 4) = 10 + 12 = 22."
      },
      {
        "input": {
          "indices1": [
            0,
            2
          ],
          "values1": [
            1,
            3
          ],
          "indices2": [
            1,
            2
          ],
          "values2": [
            2,
            3
          ]
        },
        "output": "9",
        "explanation": "Dot product = (1 * 0) + (3 * 3) = 0 + 9 = 9."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hashmap to represent the sparse vector.",
      "The dot product is only calculated for matching indices."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. For example, if intervals [1,3] and [2,6] overlap, they should be merged into [1,6]. The result should be a list of merged intervals sorted in ascending order.",
    "topic": "Array",
    "subtopic": "Sorting and Merging",
    "tags": [
      "Array",
      "Sorting",
      "Interval"
    ],
    "input_format": "A list of intervals, where each interval is represented as a list of two integers [start, end].",
    "output_format": "A list of merged intervals, where each interval is represented in the same format as the input.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "The intervals [1,3] and [2,6] overlap and can be merged to produce [1,6]. The other intervals do not overlap."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "The intervals [1,4] and [4,5] touch at the point 4 and can be merged into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on their starting values.",
      "Use a stack or a list to keep track of the merged intervals.",
      "Only merge if the current interval overlaps with the last one in the merged list."
    ],
    "company": "Pinterest"
  },
  {
    "question_id": "",
    "title": "Sudoku Solver",
    "description": "Write a program to solve a Sudoku puzzle by filling the empty cells. A Sudoku is a 9x9 grid that is partially filled with digits from 1 to 9. The grid has to be filled in such a way that each column, each row, and each of the nine 3x3 subgrids contain all of the digits from 1 to 9 without repeating. The empty cells in the grid are represented by the character '.'",
    "topic": "Backtracking",
    "subtopic": "Sudoku",
    "tags": [
      "Backtracking",
      "Algorithm",
      "Puzzle"
    ],
    "input_format": "A 2D array of characters representing the Sudoku board where '.' represents empty cells.",
    "output_format": "The solved Sudoku board as a 2D array of characters.",
    "constraints": [
      "The input board is guaranteed to be valid.",
      "The Sudoku puzzle has a unique solution."
    ],
    "examples": [
      {
        "input": [
          [
            "5",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            ".",
            "2",
            "8",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": [
          [
            "5",
            "3",
            "4",
            "6",
            "7",
            "8",
            "9",
            "1",
            "2"
          ],
          [
            "6",
            "7",
            "2",
            "1",
            "9",
            "5",
            "3",
            "4",
            "8"
          ],
          [
            "1",
            "9",
            "8",
            "3",
            "4",
            "2",
            "5",
            "6",
            "7"
          ],
          [
            "8",
            "5",
            "9",
            "7",
            "6",
            "1",
            "4",
            "2",
            "3"
          ],
          [
            "4",
            "2",
            "6",
            "8",
            "5",
            "3",
            "7",
            "9",
            "1"
          ],
          [
            "7",
            "1",
            "3",
            "9",
            "2",
            "4",
            "8",
            "5",
            "6"
          ],
          [
            "9",
            "6",
            "1",
            "2",
            "3",
            "5",
            "2",
            "8",
            "4"
          ],
          [
            "2",
            "8",
            "7",
            "4",
            "1",
            "9",
            "6",
            "3",
            "5"
          ],
          [
            "3",
            "4",
            "5",
            "8",
            "6",
            "7",
            "1",
            "2",
            "9"
          ]
        ],
        "explanation": "The solved Sudoku board satisfies all the Sudoku constraints."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use backtracking to fill each empty cell and check if the placement is valid.",
      "A valid placement must respect the Sudoku rules: unique numbers in each row, column, and subgrid.",
      "You may need a helper function to check if placing a number is valid at a given position."
    ],
    "company": "Pinterest"
  }
]