[
  {
    "question_id": "",
    "title": "Minimum Number of Taps to Open to Water a Garden",
    "description": "You have a garden represented as a number line from 0 to n. In order to water the garden, you have several taps available, each of which can water a specific range of the garden. Your task is to determine the minimum number of taps that need to be opened to water the entire garden from 0 to n. If it is not possible to water the entire garden, return -1.",
    "topic": "Greedy",
    "subtopic": "Interval Coverage",
    "tags": [
      "Greedy",
      "Dynamic Programming",
      "Interval"
    ],
    "input_format": "An integer n representing the length of the garden, followed by an array of integers representing the ranges of each tap, where ranges[i] = the range of the i-th tap.",
    "output_format": "An integer representing the minimum number of taps needed to water the entire garden, or -1 if it is not possible.",
    "constraints": [
      "1 <= n <= 10^4",
      "ranges.length == n + 1",
      "0 <= ranges[i] <= 100"
    ],
    "examples": [
      {
        "input": "n = 5, ranges = [0, 2, 1, 1, 4, 0]",
        "output": "1",
        "explanation": "Opening the tap at the 4-th position can cover the entire garden from 0 to 5."
      },
      {
        "input": "n = 3, ranges = [0, 0, 0, 0]",
        "output": "-1",
        "explanation": "It is not possible to water the garden since all taps cover no range."
      },
      {
        "input": "n = 7, ranges = [1, 2, 1, 0, 2, 1, 0, 1]",
        "output": "3",
        "explanation": "You need to open the taps at positions 1, 4, and 7 to cover from 0 to 7."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how far each tap can reach based on its index.",
      "Greedily try to cover the maximum range with the minimum number of taps."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if the brackets are closed in the correct order. Every opening bracket has a corresponding closing bracket of the same type.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A string s consisting of characters '(', ')', '{', '}', '[' and ']' representing the brackets.",
    "output_format": "A boolean value indicating whether the input string is valid.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses characters only."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The string has paired brackets and is properly closed."
      },
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "All types of brackets are properly closed and nested."
      },
      {
        "input": "s = '(]')",
        "output": "false",
        "explanation": "The brackets are not closed in the correct order."
      },
      {
        "input": "s = '([)]'",
        "output": "false",
        "explanation": "The brackets are closed in the wrong order."
      },
      {
        "input": "s = '{[]}'",
        "output": "true",
        "explanation": "The brackets are properly nested and closed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "Check if the stack is empty after processing the string."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Most Profitable Path in a Tree",
    "description": "You are given a binary tree where each node represents a profit value. Your goal is to find the path from the root to any leaf node that maximizes the total profit. The path can only move from a node to its children. Your task is to return the maximum profit that can be obtained by following this path.",
    "topic": "Tree",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Tree",
      "Dynamic Programming",
      "Depth-First Search"
    ],
    "input_format": "The input consists of the root node of the binary tree.",
    "output_format": "An integer representing the maximum profit obtainable from the root to any leaf.",
    "constraints": [
      "The binary tree will have at most 1000 nodes.",
      "-10^4 <= node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, 4, 5, null, 6]",
        "output": "10",
        "explanation": "The path 1 -> 2 -> 4 gives the maximum profit of 7. The path 1 -> 3 -> 6 gives a profit of 10. Hence, the maximum profit is 10."
      },
      {
        "input": "root = [5, 11, 3, 4, 2]",
        "output": "20",
        "explanation": "The path 5 -> 11 -> 4 gives a maximum profit of 20."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using depth-first search for exploring all paths.",
      "Track the accumulated profit as you traverse down the tree."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Course Schedule II",
    "description": "There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, which means you have to take certain courses before you can take others. Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. If there are no valid order, return an empty array. You may assume that there are no duplicate prerequisites and that the input will always be valid in terms of prerequisites.",
    "topic": "Graph",
    "subtopic": "Topological Sorting",
    "tags": [
      "Graph",
      "Topological Sort",
      "DFS",
      "BFS"
    ],
    "input_format": "An integer n representing the number of courses, and a list of prerequisite pairs where each pair contains two integers indicating a prerequisite relationship.",
    "output_format": "An array of integers representing the order of courses to finish all courses.",
    "constraints": [
      "1 <= n <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= prerequisites[i][0], prerequisites[i][1] < n"
    ],
    "examples": [
      {
        "input": "n = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
        "output": "[0,1,2,3]",
        "explanation": "One possible ordering is taking course 0 first, then either 1 or 2, and finally course 3."
      },
      {
        "input": "n = 2, prerequisites = [[1,0]]",
        "output": "[0,1]",
        "explanation": "You need to take course 0 before course 1."
      },
      {
        "input": "n = 1, prerequisites = []",
        "output": "[0]",
        "explanation": "Only one course is available."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a graph to represent the courses and their prerequisites.",
      "Try using topological sorting to find a valid order.",
      "Consider using depth-first search (DFS) or breadth-first search (BFS)."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Maximum Product of Three Numbers",
    "description": "Given an integer array nums, you need to find the maximum product of any three distinct numbers in the array. Return this maximum product.",
    "topic": "Array",
    "subtopic": "Sorting and Product Calculation",
    "tags": [
      "Array",
      "Sorting",
      "Product",
      "Math"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum product of three distinct numbers.",
    "constraints": [
      "3 <= nums.length <= 1000",
      "-1000 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "24",
        "explanation": "The maximum product can be obtained by multiplying 2, 3, and 4, which gives 2 * 3 * 4 = 24."
      },
      {
        "input": "nums = [-10, -10, 5, 2]",
        "output": "500",
        "explanation": "The maximum product can be obtained by multiplying -10, -10, and 5, which gives -10 * -10 * 5 = 500."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider both negative and positive numbers for the maximum product.",
      "You might want to sort the array first."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "LRU Cache",
    "description": "Design and implement a data structure that follows the constraints of a Least Recently Used (LRU) Cache. It should support the following operations: get and put.\n\nThe get operation retrieves the value of the given key if the key exists in the cache, otherwise it returns -1.\n\nThe put operation will update the value of the key if it exists, or it will insert the key-value pair if it does not. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item.",
    "topic": "Data Structures",
    "subtopic": "Design",
    "tags": [
      "Cache",
      "Data Structures",
      "Design"
    ],
    "input_format": "The input consists of operations to perform on the LRU Cache: a list of strings for operations and corresponding parameters for put.",
    "output_format": "The output should return the value obtained from a get operation or indicate successful insertion for a put operation.",
    "constraints": [
      "The capacity of the cache is always positive.",
      "All keys will be unique.",
      "The number of operations performed will not exceed 1000."
    ],
    "examples": [
      {
        "input": "LRUCache cache = new LRUCache(2); cache.put(1, 1); cache.put(2, 2); cache.get(1); cache.put(3, 3); cache.get(2); cache.put(4, 4); cache.get(1); cache.get(3); cache.get(4);",
        "output": "[1, -1, -1, 4]",
        "explanation": "The sequence of operations shows how the cache evicts least recently used items."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to store key-value pairs for fast access.",
      "Consider using a doubly linked list to keep track of usage order."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Maximum Total Beauty of the Gardens",
    "description": "You are given an array of integers representing the beauty of different gardens. Your task is to determine the maximum total beauty you can achieve by selecting gardens while adhering to a specific rule: If you select a garden, you cannot select its neighboring gardens. Return the maximum total beauty you can obtain from the selections you make.",
    "topic": "Dynamic Programming",
    "subtopic": "1D DP",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers beauty representing the beauty values of the gardens.",
    "output_format": "An integer representing the maximum total beauty obtainable.",
    "constraints": [
      "1 <= beauty.length <= 10^4",
      "1 <= beauty[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "beauty = [3, 2, 5, 10, 7]",
        "output": "15",
        "explanation": "Select gardens with beauties 3, 10 (skip 2 and 5) for a total of 3 + 10 + 7 = 15."
      },
      {
        "input": "beauty = [1, 2, 9, 4, 5]",
        "output": "12",
        "explanation": "Select gardens with beauties 1, 9, and 2 (skip 4 and 5) for a total of 1 + 9 + 2 = 12."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to keep track of maximum beauty up to each garden.",
      "You can decide to take or skip the current garden. Think about the implications of each choice."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Maximum Difference Score in a Grid",
    "description": "You are given an n x n grid filled with integers. The score of the grid is defined as the maximum difference between any two cells in the grid. Your task is to calculate the maximum difference score based on the values present in the grid. The score is calculated as |grid[i][j] - grid[k][l]|, where (i, j) and (k, l) are the cell coordinates in the grid. You need to return this maximum score.",
    "topic": "Matrix",
    "subtopic": "Max and Min Values",
    "tags": [
      "Matrix",
      "Difference",
      "Score"
    ],
    "input_format": "A 2D array of integers representing the grid.",
    "output_format": "An integer representing the maximum difference score.",
    "constraints": [
      "1 <= n <= 100",
      "-1000 <= grid[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "8",
        "explanation": "The maximum value is 9 and the minimum value is 1. The difference is |9 - 1| = 8."
      },
      {
        "input": "grid = [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]",
        "output": "8",
        "explanation": "The maximum value is -1 and the minimum value is -9. The difference is |-1 - (-9)| = 8."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Look for the maximum and minimum values in the grid.",
      "Use a single pass to find the min and max values efficiently."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Make String Anti-palindrome",
    "description": "Given a string s, you need to rearrange the characters in such a way that no two adjacent characters are the same. If it is possible to rearrange the string this way, return the rearranged string. If not, return an empty string. An anti-palindrome is defined as a string where the i-th character is not equal to the (n-i-1)-th character for all valid i.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Rearrangement",
      "Greedy"
    ],
    "input_format": "A single string s consisting of lowercase English letters.",
    "output_format": "A string representing the rearranged string if possible, otherwise an empty string.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "aabbcc",
        "output": "abcabc",
        "explanation": "The rearrangement 'abcabc' satisfies both the adjacency and anti-palindrome requirements."
      },
      {
        "input": "aaa",
        "output": "",
        "explanation": "It's not possible to rearrange the string to satisfy the conditions."
      },
      {
        "input": "ab",
        "output": "ab",
        "explanation": "'ab' is already a valid anti-palindrome."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Count the frequency of each character.",
      "The character with the highest frequency should not exceed half the length of the string."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Destroy Sequential Targets",
    "description": "You are given an array of integers representing targets and an integer d. You can destroy any target from the array by choosing a target and its nearest d targets to the left and right, inclusive. Your goal is to find the maximum number of targets you can destroy in one operation. Return this maximum number.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Greedy"
    ],
    "input_format": "Two inputs: an array of integers targets and an integer d.",
    "output_format": "An integer representing the maximum number of targets that can be destroyed in one operation.",
    "constraints": [
      "1 <= targets.length <= 10^5",
      "0 <= d <= targets.length - 1",
      "1 <= targets[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "targets = [1, 2, 3, 4, 5], d = 1",
        "output": "3",
        "explanation": "Choosing target 2 destroys targets 1, 2, and 3. You can destroy a maximum of 3 targets."
      },
      {
        "input": "targets = [1, 3, 2, 4, 5], d = 2",
        "output": "5",
        "explanation": "Choosing target 3 can destroy all targets 1, 2, 3, 4, and 5. All 5 targets can be destroyed."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to optimize your search for the maximum number of targets destroyed.",
      "Think about the impact of d on your choices of targets."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Number of Substrings With Fixed Ratio",
    "description": "Given a string s consisting only of the characters 'A' and 'B', and an integer ratio, your task is to determine the number of substrings such that the ratio of 'A's to 'B's in those substrings is equal to the given ratio. You can assume that the ratio is in the form of a simplified fraction a/b, where a and b are positive integers.",
    "topic": "String",
    "subtopic": "Substring Count",
    "tags": [
      "String",
      "Substring",
      "Count",
      "Ratio"
    ],
    "input_format": "A string s and an integer ratio represented as a string in the form 'a/b'.",
    "output_format": "An integer representing the number of substrings with the specified ratio.",
    "constraints": [
      "1 <= s.length <= 1000",
      "1 <= a, b <= 1000",
      "The string s consists only of 'A' and 'B'."
    ],
    "examples": [
      {
        "input": "s = 'ABBAAB', ratio = '1/1'",
        "output": "8",
        "explanation": "The substrings are: 'AB', 'BA', 'AB', 'BA', 'ABBA', 'ABBAA', 'BBAA', 'ABBAAB'. All these substrings have equal numbers of 'A's and 'B's."
      },
      {
        "input": "s = 'AABAB', ratio = '2/1'",
        "output": "5",
        "explanation": "The valid substrings with the 2:1 ratio of 'A's to 'B's are: 'AAB', 'AABA', 'AABAB', 'AB', 'AABAB'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a prefix sum approach to count characters.",
      "Utilize a hashmap to store previously seen prefix sums to optimize the search.",
      "Simplify the ratio before calculating to avoid unnecessary complexity."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Length of the Longest Subsequence That Sums to Target",
    "description": "Given an integer array nums and an integer target, find the length of the longest subsequence of nums such that its sum is equal to target. A subsequence is defined as a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.",
    "topic": "Dynamic Programming",
    "subtopic": "Subsequence Problems",
    "tags": [
      "Dynamic Programming",
      "Subsequence",
      "Greedy"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An integer representing the length of the longest subsequence that sums to the target.",
    "constraints": [
      "1 <= nums.length <= 1000",
      "-1000 <= nums[i] <= 1000",
      "-10000 <= target <= 10000"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5], target = 5",
        "output": "2",
        "explanation": "The longest subsequence that sums to 5 is [2, 3] or [1, 4], both have length 2."
      },
      {
        "input": "nums = [1, -1, 2, -2, 3], target = 0",
        "output": "3",
        "explanation": "The longest subsequence that sums to 0 is [1, -1] or [-2, 2], both have length 2. The addition of 3 makes the length 3 overall."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to track sum lengths.",
      "A hashmap may help in mapping cumulative sums to their lengths.",
      "Think about how to build subsequences incrementally."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Max Area of Island",
    "description": "Given a 2D grid of 0s and 1s, where 1s represent land and 0s represent water, write a function to return the maximum area of an island in the grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four sides of the grid are surrounded by water.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "Matrix"
    ],
    "input_format": "A 2D list of integers grid where grid[i][j] is either 0 or 1.",
    "output_format": "An integer representing the maximum area of an island.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 50",
      "grid[i][j] is 0 or 1"
    ],
    "examples": [
      {
        "input": "grid = [[0,0,0,0,0],[0,1,1,1,0],[0,0,1,0,0],[0,1,1,0,0]]",
        "output": "5",
        "explanation": "The largest island is formed by the 1s in positions (1,1), (1,2), (1,3), (2,2), (3,1), (3,2). Its area is 5."
      },
      {
        "input": "grid = [[0,0,0],[0,0,0],[0,0,0]]",
        "output": "0",
        "explanation": "There are no islands, hence the maximum area is 0."
      },
      {
        "input": "grid = [[1,1,0],[0,1,1],[0,0,0]]",
        "output": "4",
        "explanation": "The largest island is formed by the 1s in positions (0,0), (0,1), (1,1), (1,2). Its area is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth-First Search (DFS) to explore the area.",
      "Keep track of the counted area to avoid counting it multiple times."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Basic Calculator IV",
    "description": "Implement a basic calculator capable of evaluating expressions that include addition, subtraction, multiplication, and division of integers. The expression may also include variables and should return the value of the variables along with evaluating the expression itself. The calculator should correctly handle operator precedence and parentheses. Support variables in the format 'var' with values assigned as 'var=value'. The expression will come in the form of a string, and variables can be referenced within the expression.",
    "topic": "Math",
    "subtopic": "Expression Evaluation",
    "tags": [
      "Math",
      "Calculator",
      "Expression Parsing",
      "Variables"
    ],
    "input_format": "A string expression representing a mathematical expression with variables, and a list of variables with their assigned values.",
    "output_format": "An integer result representing the evaluated expression.",
    "constraints": [
      "The expression is guaranteed to be valid and will not exceed 1000 characters.",
      "The number of variables will not exceed 50, and each variable name will be a non-empty string of letters only.",
      "Variable values will be integers in the range [-10^6, 10^6]."
    ],
    "examples": [
      {
        "input": {
          "expression": "a + b * (c - d)",
          "variables": {
            "a": 5,
            "b": 2,
            "c": 10,
            "d": 3
          }
        },
        "output": "19",
        "explanation": "Evaluating the expression: a + b * (c - d) = 5 + 2 * (10 - 3) = 5 + 14 = 19."
      },
      {
        "input": {
          "expression": "(x / y) + z * (u - v)",
          "variables": {
            "x": 20,
            "y": 5,
            "z": 4,
            "u": 10,
            "v": 2
          }
        },
        "output": "36",
        "explanation": "Evaluating the expression: (x / y) + z * (u - v) = (20 / 5) + 4 * (10 - 2) = 4 + 32 = 36."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a stack to handle operator precedence.",
      "Consider using a map to store variable values."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Number of Distinct Substrings in a String",
    "description": "Given a string s, return the number of distinct substrings in it. A substring is defined as a contiguous sequence of characters within the string. Return your answer modulo 10^9 + 7.",
    "topic": "String",
    "subtopic": "Substring",
    "tags": [
      "String",
      "Substring",
      "Hashing"
    ],
    "input_format": "A string s consisting of lowercase English letters.",
    "output_format": "An integer representing the number of distinct substrings in the string, modulo 10^9 + 7.",
    "constraints": [
      "1 <= s.length <= 10^6",
      "s consists of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "abc",
        "output": "6",
        "explanation": "The distinct substrings are: 'a', 'b', 'c', 'ab', 'bc', 'abc'. Total = 6."
      },
      {
        "input": "aaa",
        "output": "3",
        "explanation": "The distinct substrings are: 'a', 'aa', 'aaa'. Total = 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a suffix array and LCP array for efficient calculation.",
      "Think about how the length of the substrings can contribute to the count."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Sudoku Solver",
    "description": "Write a program to solve a Sudoku puzzle by filling the empty cells. A Sudoku solution must satisfy the following rules: Each number 1-9 must occur exactly once in each row, column, and 3x3 boxes. The input is a partially filled 9x9 grid representing the Sudoku puzzle, where empty cells are represented by '.' character. Your task is to fill the grid in place and return it.",
    "topic": "Backtracking",
    "subtopic": "Constraint Satisfaction Problems",
    "tags": [
      "Backtracking",
      "Array",
      "Matrix"
    ],
    "input_format": "A 9x9 character array board where each element is either a digit ('1'-'9') or '.' representing an empty cell.",
    "output_format": "A solved 9x9 Sudoku board represented as a character array.",
    "constraints": [
      "The input board is guaranteed to be a valid Sudoku puzzle.",
      "Only one solution exists for the given Sudoku.",
      "The solution can be submitted directly after modifying the input board in place."
    ],
    "examples": [
      {
        "input": [
          [
            "5",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            ".",
            "2",
            "8",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": [
          [
            "5",
            "3",
            "4",
            "6",
            "7",
            "8",
            "9",
            "1",
            "2"
          ],
          [
            "6",
            "7",
            "2",
            "1",
            "9",
            "5",
            "3",
            "4",
            "8"
          ],
          [
            "1",
            "9",
            "8",
            "3",
            "4",
            "2",
            "5",
            "6",
            "7"
          ],
          [
            "8",
            "5",
            "9",
            "7",
            "6",
            "1",
            "4",
            "2",
            "3"
          ],
          [
            "4",
            "2",
            "6",
            "8",
            "5",
            "3",
            "7",
            "9",
            "1"
          ],
          [
            "7",
            "1",
            "3",
            "9",
            "2",
            "4",
            "8",
            "5",
            "6"
          ],
          [
            "9",
            "6",
            "1",
            "5",
            "3",
            "7",
            "2",
            "8",
            "4"
          ],
          [
            "2",
            "8",
            "7",
            "4",
            "1",
            "9",
            "6",
            "3",
            "5"
          ],
          [
            "3",
            "4",
            "5",
            "2",
            "8",
            "6",
            "1",
            "7",
            "9"
          ]
        ],
        "explanation": "The provided input is a partially filled Sudoku grid. The output is the completed Sudoku grid that adheres to the Sudoku rules."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a backtracking approach.",
      "Try to fill numbers incrementally and backtrack upon finding an invalid state."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Rotting Oranges",
    "description": "In a given grid of n x m cells, each cell can be either empty (0), fresh orange (1), or rotten orange (2). Every minute, any fresh orange that is adjacent (up, down, left, right) to a rotten orange will become rotten. The process continues until no more fresh oranges can rot. Return the minimum number of minutes you need to wait until no fresh oranges remain. If it is impossible for all fresh oranges to become rotten, return -1.",
    "topic": "Graph",
    "subtopic": "Grid Traversal",
    "tags": [
      "BFS",
      "Grid",
      "Simulation"
    ],
    "input_format": "A 2D grid represented by a list of lists, where each element is either 0, 1, or 2.",
    "output_format": "An integer representing the minimum number of minutes until all fresh oranges become rotten, or -1 if not possible.",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[i].length <= 300",
      "grid[i][j] is 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "[[2,1,1],[1,1,0],[0,1,2]]",
        "output": "4",
        "explanation": "At minute 0, the rotten orange spreads to adjacent fresh oranges. By minute 4, all oranges are rotten."
      },
      {
        "input": "[[2,1,1],[0,1,1],[1,0,2]]",
        "output": "-1",
        "explanation": "Some fresh oranges cannot be reached by any rotten oranges."
      },
      {
        "input": "[[0,2]]",
        "output": "0",
        "explanation": "There are no fresh oranges present, so the result is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to help track the minutes as oranges rot.",
      "Think about how to expand from rotten oranges to find fresh ones."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Product of Array Except Self",
    "description": "Given an integer array nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. You must do this without using the division operation and in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Prefix and Suffix Product",
    "tags": [
      "Array",
      "Product",
      "Prefix Sum",
      "Suffix Product"
    ],
    "input_format": "An array of integers nums with length n.",
    "output_format": "An array of integers representing the product of all the elements except self.",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-30 <= nums[i] <= 30"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "[24, 12, 8, 6]",
        "explanation": "For the input array, the product except self for each index is calculated as follows: [2*3*4, 1*3*4, 1*2*4, 1*2*3]."
      },
      {
        "input": "nums = [-1, 1, 0, -3, 3]",
        "output": "[0, 0, 9, 0, 0]",
        "explanation": "All products are zero except for the product of the elements excluding the 0 which results in 9."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you can accumulate products from both directions.",
      "Using two passes can help in calculating prefix and suffix products."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Coin Change",
    "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. You want to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.",
    "topic": "Dynamic Programming",
    "subtopic": "Minimum Coin Change",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Count"
    ],
    "input_format": "An integer array coins and an integer amount.",
    "output_format": "An integer representing the fewest number of coins needed to make the amount, or -1 if it is not possible.",
    "constraints": [
      "1 <= coins.length <= 12",
      "1 <= coins[i] <= 2 * 10^4",
      "0 <= amount <= 10^4"
    ],
    "examples": [
      {
        "input": "coins = [1, 2, 5], amount = 11",
        "output": "3",
        "explanation": "11 can be made up of 5 + 5 + 1, which requires 3 coins."
      },
      {
        "input": "coins = [2], amount = 3",
        "output": "-1",
        "explanation": "It is not possible to make amount 3 using denominations of 2."
      },
      {
        "input": "coins = [1], amount = 0",
        "output": "0",
        "explanation": "No coins are needed to make amount 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dynamic programming approach to store results of subproblems.",
      "You can initialize an array to hold the minimum coins needed for each amount."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Plus One",
    "description": "You are given a non-empty array of digits representing a non-negative integer. The digits are stored such that the most significant digit is at the head of the array, and each element in the array is a single digit. You need to increment the integer by one and return the resulting array of digits.",
    "topic": "Array",
    "subtopic": "Math",
    "tags": [
      "Array",
      "Math",
      "Increment",
      "Simulation"
    ],
    "input_format": "An array of integers representing the digits of a non-negative integer.",
    "output_format": "An array of integers representing the digits of the incremented integer.",
    "constraints": [
      "1 <= digits.length <= 100",
      "0 <= digits[i] <= 9",
      "digits does not contain any leading zeros except for the number 0 itself."
    ],
    "examples": [
      {
        "input": "[1, 2, 3]",
        "output": "[1, 2, 4]",
        "explanation": "The number is 123. Incrementing by one gives 124, which is represented as [1, 2, 4]."
      },
      {
        "input": "[4, 3, 2, 1]",
        "output": "[4, 3, 2, 2]",
        "explanation": "The number is 4321. Incrementing by one gives 4322, which is represented as [4, 3, 2, 2]."
      },
      {
        "input": "[9]",
        "output": "[1, 0]",
        "explanation": "The number is 9. Incrementing by one gives 10, which is represented as [1, 0]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how to handle carrying over when a digit is 9."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers and a target integer, return the indices of the two numbers such that they add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two-Pointer"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "target is guaranteed to be the sum of two distinct elements in nums."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash map to store the difference between the target and each element."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Logger Rate Limiter",
    "description": "Design a logger system that receives messages. The logger should store messages and allow only one message per given time frame, specifically limiting them to one per second. If a message is received within the time frame, it should not be logged again. Implement the `shouldPrintMessage(timestamp, message)` method that returns true if the message should be printed at the given timestamp and false otherwise.",
    "topic": "Design",
    "subtopic": "Rate Limiting",
    "tags": [
      "design",
      "rate limiting",
      "system design"
    ],
    "input_format": "An integer timestamp and a string message.",
    "output_format": "A boolean value indicating if the message should be printed.",
    "constraints": [
      "0 <= timestamp <= 10^9",
      "1 <= message.length <= 100"
    ],
    "examples": [
      {
        "input": "timestamp = 1, message = \"foo\"",
        "output": "true",
        "explanation": "At timestamp 1, the message 'foo' is logged for the first time."
      },
      {
        "input": "timestamp = 2, message = \"bar\"",
        "output": "true",
        "explanation": "At timestamp 2, the message 'bar' is logged for the first time."
      },
      {
        "input": "timestamp = 3, message = \"foo\"",
        "output": "false",
        "explanation": "At timestamp 3, the message 'foo' has already been logged at timestamp 1. This message can only be logged again at timestamp 2."
      },
      {
        "input": "timestamp = 11, message = \"foo\"",
        "output": "true",
        "explanation": "At timestamp 11, the message 'foo' is logged again since more than 1 second has passed since its last logging."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Store the last timestamp a message was logged.",
      "Check if the current timestamp minus the last timestamp is greater than or equal to 1 second."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Word Break",
    "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicates and all the strings in the dictionary are lowercase.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "DP"
    ],
    "input_format": "A string s and a list of strings wordDict.",
    "output_format": "A boolean value indicating whether the string can be segmented.",
    "constraints": [
      "1 <= s.length <= 300",
      "1 <= wordDict.length <= 1000",
      "1 <= wordDict[i].length <= 20",
      "All strings in wordDict are lowercase."
    ],
    "examples": [
      {
        "input": "s = 'leetcode', wordDict = ['leet', 'code']",
        "output": "true",
        "explanation": "'leetcode' can be segmented as 'leet code'."
      },
      {
        "input": "s = 'applepenapple', wordDict = ['apple', 'pen']",
        "output": "true",
        "explanation": "'applepenapple' can be segmented as 'apple pen apple'."
      },
      {
        "input": "s = 'catsandog', wordDict = ['cats', 'dog', 'sand', 'and', 'cat']",
        "output": "false",
        "explanation": "There is no way to segment 'catsandog' into words from the dictionary."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store results of subproblems.",
      "Think about which prefixes of the string can lead to valid word segments."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. The spiral traversal starts from the top-left corner, continues to the right, proceeds downwards, then moves left, and finally upwards, repeating this process layer by layer until all elements have been traversed.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral"
    ],
    "input_format": "A 2D list of integers representing the matrix.",
    "output_format": "A list of integers representing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "m * n <= 10^6",
      "-10^5 <= matrix[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The elements are traversed along the spiral path starting from 1."
      },
      {
        "input": "matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]",
        "output": "[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]",
        "explanation": "The elements are traversed along the spiral path starting from 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about the order in which you will traverse the boundaries of the matrix.",
      "You can use four pointers to keep track of the boundaries."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of bars in a histogram, compute how much rain water can be trapped after raining. Each bar's height is represented by an element in the array, and the width of each bar is 1 unit.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers representing the heights of the bars.",
    "output_format": "An integer representing the total amount of rain water that can be trapped.",
    "constraints": [
      "0 <= heights.length <= 2 * 10^4",
      "0 <= heights[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "heights = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The structure forms a container that can trap 6 units of water."
      },
      {
        "input": "heights = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The bars can trap a total of 9 units of water."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the highest bars on both sides of the current position to calculate trapped water.",
      "Use a two-pointer approach to optimize the space and time complexity."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets (a, b, c) in the array which gives the sum of zero. Note that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Hash Table"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A list of lists containing all unique triplets that sum up to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that sum to zero are [-1, -1, 2] and [-1, 0, 1]. The order of the triplets does not matter."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no elements in the array, hence no triplets can be formed."
      },
      {
        "input": "nums = [0, 0, 0]",
        "output": "[[0, 0, 0]]",
        "explanation": "Only one unique triplet exists: [0, 0, 0]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the array first to simplify the search for triplets.",
      "Use a two-pointer approach to find pairs that sum to a target value."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "House Robber",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array 'nums' representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "topic": "Dynamic Programming",
    "subtopic": "1D Dynamic Programming",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers nums where 0 <= nums[i] <= 400.",
    "output_format": "An integer representing the maximum amount of money that can be robbed.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 400"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 2]",
        "output": "3",
        "explanation": "Robbing the second house (3) is optimal, as robbing the first and third houses would alert the police."
      },
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "4",
        "explanation": "Robbing the first (1) and third (3) houses is the best choice."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store maximum amounts.",
      "Think about the choices you have at each house."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Russian Doll Envelopes",
    "description": "You have a collection of envelopes, where each envelope has a width and a height. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other. Your task is to find the maximum number of envelopes you can Russian doll (nest) into each other.",
    "topic": "Dynamic Programming",
    "subtopic": "Longest Increasing Subsequence",
    "tags": [
      "Dynamic Programming",
      "Sorting",
      "Greedy"
    ],
    "input_format": "A list of pairs of integers, where each pair represents the width and height of an envelope.",
    "output_format": "An integer representing the maximum number of envelopes that can be nested.",
    "constraints": [
      "1 <= envelopes.length <= 5000",
      "envelopes[i][0] > 0",
      "envelopes[i][1] > 0"
    ],
    "examples": [
      {
        "input": "envelopes = [[5,4],[6,4],[6,7],[2,3]]",
        "output": "3",
        "explanation": "The longest sequence of nested envelopes is [[2,3], [5,4], [6,7]]."
      },
      {
        "input": "envelopes = [[1,1],[1,1],[1,1]]",
        "output": "1",
        "explanation": "All envelopes are of the same size, so only one can be taken."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use sorting to order the envelopes based on width and height.",
      "Consider using an array to track the increasing subsequence lengths."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Heaters",
    "description": "You are given an array of houses and an array of heaters. Each house can be represented by its position on a number line. Each heater can also be represented by its position. Your task is to determine for each house, the closest heater and return the distance from that house to the closest heater. A house is considered to be heated if the distance to the closest heater is less than or equal to a specified radius.",
    "topic": "Binary Search",
    "subtopic": "Searching",
    "tags": [
      "Binary Search",
      "Array",
      "Distance"
    ],
    "input_format": "Two arrays of integers, houses and heaters, followed by an integer radius.",
    "output_format": "An array of integers where each entry represents the distance from the corresponding house to the nearest heater.",
    "constraints": [
      "1 <= houses.length, heaters.length <= 10^4",
      "-10^9 <= houses[i], heaters[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "houses = [1, 2, 3, 4], heaters = [1, 4], radius = 1",
        "output": "[0, 0, 1, 0]",
        "explanation": "House 1 is at distance 0 from heater 1, house 2 is at distance 0 from heater 1, house 3 is at distance 1 from heater 4, and house 4 is at distance 0 from heater 4."
      },
      {
        "input": "houses = [1, 5, 10], heaters = [1, 3, 6], radius = 2",
        "output": "[0, 1, 4]",
        "explanation": "House 1 is at distance 0 from heater 1, house 5 is at distance 1 from heater 3, and house 10 is at distance 4 from heater 6."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the heaters array.",
      "Use binary search to find the closest heater efficiently.",
      "Calculate distances carefully to ensure you find the minimum distance."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Top K Frequent Elements",
    "description": "Given a non-empty array of integers, return the k most frequent elements. You may assume that the answer is guaranteed to be unique, and order does not matter.",
    "topic": "Hash Table",
    "subtopic": "Frequency Count",
    "tags": [
      "Hash Table",
      "Sorting",
      "Heap"
    ],
    "input_format": "An integer array nums and an integer k.",
    "output_format": "An array of the k most frequent elements.",
    "constraints": [
      "1 <= k <= unique elements in the array <= 10^5",
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3], k = 2",
        "output": "[1, 2]",
        "explanation": "1 is the most frequent element and 2 is the second most frequent."
      },
      {
        "input": "nums = [3,3,3,3,2,2,1,1,1,1,1], k = 3",
        "output": "[1, 3, 2]",
        "explanation": "The elements appear with frequencies: 3 appears 4 times, 1 appears 5 times, 2 appears 2 times."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hashmap to count the frequency of each element.",
      "Consider using a min-heap to find the top k elements efficiently."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Longest Increasing Subsequence",
    "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.",
    "topic": "Dynamic Programming",
    "subtopic": "Subsequence",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Subsequence"
    ],
    "input_format": "An integer array nums.",
    "output_format": "An integer representing the length of the longest increasing subsequence.",
    "constraints": [
      "1 <= nums.length <= 2500",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [10, 9, 2, 5, 3, 7, 101, 18]",
        "output": "4",
        "explanation": "The longest increasing subsequence is [2, 3, 7, 101], its length is 4."
      },
      {
        "input": "nums = [0, 1, 0, 3, 2, 3]",
        "output": "4",
        "explanation": "The longest increasing subsequence is [0, 1, 2, 3], its length is 4."
      },
      {
        "input": "nums = [7, 7, 7, 7, 7, 7, 7]",
        "output": "1",
        "explanation": "The longest increasing subsequence can only be [7], its length is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store the lengths of increasing subsequences.",
      "Try to build a solution by maintaining an array of the longest subsequence lengths."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Min Stack",
    "description": "Design a stack that supports the following operations: push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: \n- MinStack() initializes the stack object. \n- void push(int val) pushes the element val onto the stack. \n- void pop() removes the element on the top of the stack. \n- int top() gets the top element of the stack. \n- int getMin() retrieves the minimum element in the stack.",
    "topic": "Data Structures",
    "subtopic": "Stack",
    "tags": [
      "Stack",
      "Design",
      "Data Structures"
    ],
    "input_format": "Operations on the MinStack including the values to push.",
    "output_format": "Return the results of top() and getMin() operations.",
    "constraints": [
      "The number of operations performed is at most 10^4.",
      "-10^6 <= val <= 10^6"
    ],
    "examples": [
      {
        "input": "minStack = MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); minStack.pop(); minStack.top(); minStack.getMin();",
        "output": "[-3,0,-2]",
        "explanation": "After pushing -2, 0, and -3 onto the stack, the minimum is -3. After popping -3, the top is 0 and the minimum is -2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using an auxiliary stack to keep track of the minimum values."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Unique Email Addresses",
    "description": "Given a list of email addresses, your task is to determine the number of unique email addresses after applying the following rules: A valid email address consists of a local name and a domain name, separated by an '@' symbol. The local name can contain letters, digits, and the special characters '.', '+' and '-'. However, only the first occurrence of a '+' in the local name should be considered, as any characters following it will be ignored. Furthermore, '.' characters in the local name can be ignored. The domain name consists of only letters and dots, and it completely determines the destination mailbox. Your goal is to count the number of unique email addresses that can be generated from the given list following these rules.",
    "topic": "String",
    "subtopic": "Validation",
    "tags": [
      "String",
      "Email",
      "Unique"
    ],
    "input_format": "An array of strings representing the email addresses.",
    "output_format": "An integer representing the count of unique email addresses.",
    "constraints": [
      "1 <= emails.length <= 100",
      "1 <= emails[i].length <= 100"
    ],
    "examples": [
      {
        "input": "emails = [\"test.email+alex@leetcode.com\", \"test.e.mail+bob@lee.tcode.com\", \"testemail@leetcode.com\"]",
        "output": "2",
        "explanation": "The unique processed email addresses are 'testemail@leetcode.com' and 'testemail@lee.tcode.com'."
      },
      {
        "input": "emails = [\"a@leetcode.com\", \"b@leetcode.com\", \"c@leetcode.com\"]",
        "output": "3",
        "explanation": "Each email address is unique."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how to split the email address into local and domain parts.",
      "Remember to handle the '+' and '.' characters appropriately."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "132 Pattern",
    "description": "Given an array of n integers nums, return true if there exists a 132 pattern in the array, i.e., there exists indices i, j, k such that i < j < k and nums[i] < nums[k] < nums[j]. A 132 pattern is a subsequence of three elements where the first element is smaller than the third, and the third is smaller than the second, while maintaining their order in the array.",
    "topic": "Array",
    "subtopic": "Subsequence",
    "tags": [
      "Array",
      "Subsequence",
      "Stack"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A boolean value indicating whether a 132 pattern exists.",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 2 * 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "false",
        "explanation": "There are no three indices that satisfy the 132 pattern."
      },
      {
        "input": "nums = [3, 1, 4, 2]",
        "output": "true",
        "explanation": "The indices i = 0, j = 2, k = 3 satisfy the pattern since nums[0] < nums[3] < nums[2] (3 > 2 < 4)."
      },
      {
        "input": "nums = [-1, 3, 2, 0]",
        "output": "true",
        "explanation": "We have i = 0, j = 1, k = 2; -1 < 2 < 3 satisfies the condition."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to keep track of potential candidates for the 132 pattern.",
      "Traverse the array in reverse to find the third element (k)."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Dynamic Programming",
    "subtopic": "Array Manipulation",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices where 1 <= prices.length <= 10^5.",
    "output_format": "An integer representing the maximum profit.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate the potential profit at each price and keep a running maximum."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. An Anagram is defined as two strings having the same character counts when sorted. For example, 'eat' and 'tea' are anagrams of each other.",
    "topic": "String",
    "subtopic": "Hashing",
    "tags": [
      "String",
      "Hashing",
      "Group Anagrams"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A list of lists of strings, where each list contains strings that are anagrams of each other.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "explanation": "There are three groups of anagrams: ['bat'], ['nat', 'tan'], and ['ate', 'eat', 'tea']."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "The only element is an empty string, which is an anagram of itself."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "The only element is a single character string, which is an anagram of itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting each string to identify anagrams.",
      "Using a hash table can help group anagrams effectively.",
      "Think about using the character counts as keys."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Minimum Cost For Tickets",
    "description": "You are given an integer array 'days' that represents the days you plan to travel, and an integer array 'costs' where costs[0], costs[1], and costs[2] represent the cost of a 1-day, 7-day, and 30-day ticket, respectively. Your task is to determine the minimum cost for you to travel on the days listed in 'days'. You may purchase tickets that cover multiple days, but you cannot buy more than one ticket for the same day.",
    "topic": "Dynamic Programming",
    "subtopic": "Optimization",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers 'days' representing travel days, and an array of three integers 'costs' representing the cost of 1-day, 7-day, and 30-day tickets.",
    "output_format": "An integer representing the minimum cost to travel.",
    "constraints": [
      "1 <= days.length <= 365",
      "1 <= days[i] <= 365",
      "costs.length == 3",
      "1 <= costs[i] <= 1000"
    ],
    "examples": [
      {
        "input": "days = [1, 4, 6, 7, 8], costs = [2, 7, 15]",
        "output": "11",
        "explanation": "The optimal plan is to buy one 7-day ticket covering days 1 to 7 for 7 and another 1-day ticket for day 8 for 2. Total cost is 7 + 2 = 9."
      },
      {
        "input": "days = [1, 2, 3, 4, 5], costs = [2, 7, 15]",
        "output": "6",
        "explanation": "The optimal plan is to buy a 1-day ticket for each day, which totals to 2 * 5 = 10, but buying a 7-day ticket for 7 covers all the days for a total of 6."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store minimum costs.",
      "Look for overlapping subproblems regarding ticket usage.",
      "Try to determine the least cost for each travel day."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Daily Temperatures",
    "description": "Given an array of daily temperatures, return an array such that each element represents the number of days until a warmer temperature. If there is no future day for which this is possible, put 0 instead.",
    "topic": "Array",
    "subtopic": "Stack",
    "tags": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "input_format": "An array of integers temperatures where 1 <= temperatures.length <= 30000 and 30 <= temperatures[i] <= 100.",
    "output_format": "An array of integers representing the number of days until a warmer temperature for each day.",
    "constraints": [
      "1 <= temperatures.length <= 30000",
      "30 <= temperatures[i] <= 100"
    ],
    "examples": [
      {
        "input": "temperatures = [73, 74, 75, 71, 69, 72, 76, 73]",
        "output": "[1, 1, 4, 2, 1, 1, 0, 0]",
        "explanation": "The output represents the number of days until a warmer temperature for each day."
      },
      {
        "input": "temperatures = [30, 40, 50, 60]",
        "output": "[1, 1, 1, 0]",
        "explanation": "Each day has a warmer day following it until the last day."
      },
      {
        "input": "temperatures = [30, 30, 30]",
        "output": "[0, 0, 0]",
        "explanation": "There are no warmer days for any of the days."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to keep track of the indices of the temperatures.",
      "Pop elements from the stack until you find a temperature higher than the current one.",
      "Be mindful of the edge case when there are no higher temperatures."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Middle of the Linked List",
    "description": "Given a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. The linked list is zero-indexed and has at least one node.",
    "topic": "Linked List",
    "subtopic": "Finding Middle Element",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Middle Element"
    ],
    "input_format": "A singly linked list represented by its head node.",
    "output_format": "The middle node of the linked list.",
    "constraints": [
      "The number of nodes in the linked list is in the range [1, 100]",
      "1 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5]",
        "output": "[3]",
        "explanation": "The middle node is 3, as there are five nodes in total."
      },
      {
        "input": "head = [1, 2, 3, 4, 5, 6]",
        "output": "[4]",
        "explanation": "There are six nodes, and the two middle nodes are 3 and 4, so we return 4."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to find the middle of the list.",
      "Advance one pointer twice as fast as the other."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Decode String",
    "description": "Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. You may assume that the input string is always valid; no extra white spaces, square brackets are well-formed, etc. Note that k is guaranteed to be a positive integer.",
    "topic": "String",
    "subtopic": "Decoding",
    "tags": [
      "String",
      "Decoding",
      "Stack"
    ],
    "input_format": "A single string s which represents the encoded string.",
    "output_format": "A string representing the decoded result.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of digits, uppercase English letters, '[]' and will be a valid encoding."
    ],
    "examples": [
      {
        "input": "s = \"3[a2[c]]\"",
        "output": "accaccacc",
        "explanation": "The string 'a2[c]' is decoded to 'acc', and it is repeated 3 times."
      },
      {
        "input": "s = \"2[abc]3[cd]ef\"",
        "output": "abcabccdcdcdef",
        "explanation": "'abc' is repeated 2 times, and 'cd' is repeated 3 times, followed by 'ef'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to help in decoding the string.",
      "When encountering '[', push to the stack.",
      "When encountering ']', pop from the stack and repeat the string."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Course Schedule",
    "description": "You are given the number of courses you have to take, labeled from 0 to `numCourses - 1`. There are also prerequisites for some courses, which are represented as pairs of integers. Each pair [a, b] indicates that to take course a, you must first take course b. Write a function to determine if you can finish all courses. If you can finish all courses, return true; otherwise, return false.",
    "topic": "Graph",
    "subtopic": "Topological Sorting",
    "tags": [
      "Graph",
      "Topological Sort",
      "DFS",
      "BFS"
    ],
    "input_format": "An integer `numCourses` representing the total number of courses, and a list of integer pairs `prerequisites`.",
    "output_format": "A boolean indicating whether it is possible to finish all courses.",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2"
    ],
    "examples": [
      {
        "input": {
          "numCourses": 2,
          "prerequisites": [
            [
              1,
              0
            ]
          ]
        },
        "output": true,
        "explanation": "It is possible to take course 0 first, then course 1."
      },
      {
        "input": {
          "numCourses": 2,
          "prerequisites": [
            [
              1,
              0
            ],
            [
              0,
              1
            ]
          ]
        },
        "output": false,
        "explanation": "There is a cycle, making it impossible to finish all courses."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to detect cycles in the graph.",
      "Use Kahn's algorithm for topological sorting."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Kth Largest Element in an Array",
    "description": "Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. You must solve it in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Selection"
    ],
    "input_format": "An integer array nums and an integer k.",
    "output_format": "An integer representing the kth largest element in the array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 1, 5, 6, 4], k = 2",
        "output": "5",
        "explanation": "The second largest element in the sorted array [1, 2, 3, 4, 5, 6] is 5."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "1",
        "explanation": "There's only one element in the array, which is 1."
      },
      {
        "input": "nums = [3, 2, 3, 1, 2, 4, 5, 5, 6], k = 4",
        "output": "4",
        "explanation": "The fourth largest element in the sorted array [1, 2, 2, 3, 3, 4, 5, 5, 6] is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a priority queue for optimal performance.",
      "Remember that sorting the array may lead to O(n log n) complexity."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Zigzag Conversion",
    "description": "The string 'PAYPALISHIRING' is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better readability)\n\nP   A   H   N\nA P L S I I G\nY   I   A\n\nAnd then read line by line: 'PAHNAPLSIIGYAI'. Convert a given string to its zigzag conversion based on a specified number of rows. The conversion is done by writing the string in a zigzag pattern down and diagonally across rows, and then reading line by line.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Zigzag",
      "Manipulation"
    ],
    "input_format": "A string s (1 <= s.length <= 1000) and an integer numRows (1 <= numRows <= 1000).",
    "output_format": "A string representing the zigzag conversion of the input.",
    "constraints": [
      "1 <= s.length <= 1000",
      "1 <= numRows <= 1000"
    ],
    "examples": [
      {
        "input": {
          "s": "PAYPALISHIRING",
          "numRows": 3
        },
        "output": "PAHNAPLSIIGYI",
        "explanation": "The zigzag pattern for 3 rows is:\nP   A   H   N\nA P L S I I G\nY   I   A\nReading line by line gives 'PAHNAPLSIIGYI'."
      },
      {
        "input": {
          "s": "A",
          "numRows": 1
        },
        "output": "A",
        "explanation": "With only 1 row, the zigzag conversion is just 'A'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to use a loop to simulate the zigzag traversal.",
      "You might want to keep track of the current row in the zigzag pattern."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Maximal Rectangle",
    "description": "Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Matrix",
      "Dynamic Programming",
      "Area"
    ],
    "input_format": "A 2D binary matrix represented as a list of lists (matrix).",
    "output_format": "An integer representing the area of the largest rectangle containing only 1's.",
    "constraints": [
      "1 <= matrix.length <= 200",
      "1 <= matrix[i].length <= 200",
      "matrix[i][j] is either '0' or '1'"
    ],
    "examples": [
      {
        "input": "[[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]",
        "output": "6",
        "explanation": "The maximal rectangle of 1's has an area of 6."
      },
      {
        "input": "[[0]]",
        "output": "0",
        "explanation": "There are no 1's, hence area is 0."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using histograms to represent heights of consecutive 1's.",
      "Use a stack to maintain indexes of the bars in the histogram."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Reorganize String",
    "description": "Given a string s, rearrange the characters of the string so that no two adjacent characters are the same. Return any possible rearrangement of the string or return an empty string if it is not possible.",
    "topic": "String",
    "subtopic": "Rearrangement",
    "tags": [
      "String",
      "Rearrangement",
      "Greedy"
    ],
    "input_format": "A string s consisting of lowercase English letters.",
    "output_format": "A rearranged string that meets the requirement or an empty string if not possible.",
    "constraints": [
      "1 <= s.length <= 500",
      "s consists of lowercase English letters only."
    ],
    "examples": [
      {
        "input": "aabb",
        "output": "abab",
        "explanation": "Both 'abab' and 'baba' are valid rearrangements where no two adjacent characters are the same."
      },
      {
        "input": "aaab",
        "output": "",
        "explanation": "It is impossible to rearrange the string such that no two adjacent characters are the same."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a frequency counter to track occurrences of each character.",
      "Try to place the most frequent character first and alternate with others."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Palindrome Linked List",
    "description": "Given a singly linked list, determine if it is a palindrome. A linked list is called a palindrome if its elements read the same forward and backward.",
    "topic": "Linked List",
    "subtopic": "Two Pointers",
    "tags": [
      "Linked List",
      "Palindrome",
      "Two Pointers"
    ],
    "input_format": "A singly linked list with its head node.",
    "output_format": "A boolean value indicating whether the linked list is a palindrome.",
    "constraints": [
      "The number of nodes in the linked list is in the range [1, 10^5].",
      "The value of each node is an integer within the range [-10^5, 10^5]."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 2, 1]",
        "output": "true",
        "explanation": "The linked list reads the same forward and backward."
      },
      {
        "input": "head = [1, 2]",
        "output": "false",
        "explanation": "The linked list does not read the same forward and backward."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Try using a two-pointer technique to find the midpoint.",
      "Reverse the second half of the list and compare it to the first half."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Minimum Limit of Balls in a Bag",
    "description": "You have a bag that can hold a limited number of balls. Each ball has a weight associated with it. Your goal is to determine the minimum limit of the bag such that it can hold exactly 'k' balls. If it is not possible to take 'k' balls, return -1.",
    "topic": "Greedy Algorithm",
    "subtopic": "Sorting",
    "tags": [
      "Greedy",
      "Sorting",
      "Array"
    ],
    "input_format": "An integer array weights representing the weights of the balls and an integer k representing the number of balls to hold.",
    "output_format": "An integer representing the minimum limit of the bag, or -1 if it's not possible.",
    "constraints": [
      "1 <= weights.length <= 1000",
      "1 <= weights[i] <= 10^5",
      "1 <= k <= weights.length"
    ],
    "examples": [
      {
        "input": "weights = [1, 3, 5, 2, 8], k = 3",
        "output": "6",
        "explanation": "The minimum limit is 6, allowing a selection of weights 1, 2, and 3 or 3, 2, and 1 totaling to the limit."
      },
      {
        "input": "weights = [4, 5, 6, 7], k = 2",
        "output": "10",
        "explanation": "To hold 2 balls, the minimum limit would be the sum of the two lightest weights: 4 + 6 = 10."
      },
      {
        "input": "weights = [1, 1, 1], k = 4",
        "output": "-1",
        "explanation": "It's impossible to take 4 balls when there are only 3 available."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the weights.",
      "Try to minimize the selection of weights that sum to the limit."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Lowest Common Ancestor of a Binary Tree",
    "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. The lowest common ancestor is defined between two nodes p and q as the lowest node in the tree that has both p and q as descendants (where we allow a node to be a descendant of itself).",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth-First Search"
    ],
    "input_format": "The first line contains the root of the binary tree. The second line contains two nodes p and q.",
    "output_format": "Return the lowest common ancestor node of the two given nodes.",
    "constraints": [
      "The number of nodes in the tree is in the range [2, 10^5].",
      "All values of nodes p and q are unique.",
      "p and q should exist in the binary tree."
    ],
    "examples": [
      {
        "input": "root = [3, 5, 1, 6, 2, 0, 8], p = 5, q = 1",
        "output": "3",
        "explanation": "The LCA of nodes 5 and 1 is 3."
      },
      {
        "input": "root = [3, 5, 1, 6, 2, 0, 8], p = 5, q = 4",
        "output": "5",
        "explanation": "The LCA of node 5 and 4 is node 5 since 4 is not in the tree."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a recursive approach.",
      "Keep track of the parent nodes."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Next Permutation",
    "description": "Implement an algorithm to rearrange the numbers in an array into the lexicographically next greater permutation of integers. If such arrangement is not possible, rearrange it to the lowest possible order (i.e., sorted in ascending order). The modification must be done in-place and use only constant extra memory.",
    "topic": "Array",
    "subtopic": "Permutations",
    "tags": [
      "Array",
      "Permutation",
      "In-place",
      "Sorting"
    ],
    "input_format": "An array of integers 'nums' of size 'n'.",
    "output_format": "You need to modify 'nums' in-place to represent the next permutation of integers.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[1, 3, 2]",
        "explanation": "The next permutation of [1, 2, 3] is [1, 3, 2]."
      },
      {
        "input": "nums = [3, 2, 1]",
        "output": "[1, 2, 3]",
        "explanation": "The next permutation of [3, 2, 1] is the lowest possible order [1, 2, 3]."
      },
      {
        "input": "nums = [1, 1, 5]",
        "output": "[1, 5, 1]",
        "explanation": "The next permutation of [1, 1, 5] is [1, 5, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to find the rightmost ascent in the array.",
      "Swap the found item with the smallest element larger than it to the right.",
      "Reverse the elements to the right of the swapped position."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Unique Paths",
    "description": "A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish'). How many unique paths are there to reach the finish point?",
    "topic": "Dynamic Programming",
    "subtopic": "Combinatorial Paths",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Combinatorial"
    ],
    "input_format": "Two integers m and n representing the number of rows and columns in the grid.",
    "output_format": "An integer representing the number of unique paths from the top-left to the bottom-right corner.",
    "constraints": [
      "1 <= m, n <= 100"
    ],
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": "There are 28 unique paths from the top-left to the bottom-right corner in a 3x7 grid."
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "There are 3 unique paths from the top-left to the bottom-right corner in a 3x2 grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about the paths as combinations of moves.",
      "Consider using dynamic programming to store intermediate results."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Binary Tree Maximum Path Sum",
    "description": "Given a non-empty binary tree, find the maximum path sum. The path may start and end at any node in the tree. The path sum of a tree is the sum of the node values along the path. The maximum path sum is the highest possible path sum in the tree.",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Binary Tree",
      "DFS",
      "Dynamic Programming"
    ],
    "input_format": "A non-empty binary tree root node of type TreeNode.",
    "output_format": "An integer representing the maximum path sum.",
    "constraints": [
      "-10^4 <= node.val <= 10^4",
      "The number of nodes in the tree is in the range [1, 3000]"
    ],
    "examples": [
      {
        "input": "root = [-10, 9, 20, null, null, 15, 7]",
        "output": "42",
        "explanation": "The optimal path is 15 -> 20 -> 7, which gives us a sum of 15 + 20 + 7 = 42."
      },
      {
        "input": "root = [1, 2, 3]",
        "output": "6",
        "explanation": "The optimal path is 2 -> 1 -> 3, which gives us a sum of 2 + 1 + 3 = 6."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider a recursive function to calculate the maximum path sums for each node.",
      "Keep track of the maximum path sum found so far during the traversal.",
      "Evaluate paths that include both left and right children."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Move Zeroes",
    "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array.",
    "topic": "Array",
    "subtopic": "In-place Manipulation",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "The modified array with all 0's moved to the end.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [0, 1, 0, 3, 12]",
        "output": "[1, 3, 12, 0, 0]",
        "explanation": "The non-zero elements are 1, 3, and 12. After moving the zeros to the end, the result is [1, 3, 12, 0, 0]."
      },
      {
        "input": "nums = [0]",
        "output": "[0]",
        "explanation": "There are no non-zero elements, so the output remains [0]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to partition the array."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Flood Fill"
    ],
    "input_format": "A 2D grid represented as a list of lists, where each element is either '1' or '0'.",
    "output_format": "An integer representing the number of islands.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "grid = [['1','1','1','1','0'], ['1','1','0','1','0'], ['0','0','0','0','0'], ['0','1','1','0','1']]",
        "output": "2",
        "explanation": "The first island is formed by the top left '1's and the second island is isolated at the bottom right."
      },
      {
        "input": "grid = [['0']]",
        "output": "0",
        "explanation": "There are no islands since the only cell is water."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth-First Search (DFS) to traverse the islands.",
      "Keep track of visited nodes to avoid counting the same island multiple times."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Next Greater Element II",
    "description": "Given a circular array `nums` (i.e., the next element of the last element is the first element), find the next greater number for every element in the array. The next greater number of a number `x` is the first greater number to its traversing-clockwise next in the array. If it does not exist, return -1 for this number.",
    "topic": "Array",
    "subtopic": "Circular Array",
    "tags": [
      "Array",
      "Monotonic Stack",
      "Circular"
    ],
    "input_format": "An array of integers `nums` representing the circular array.",
    "output_format": "An array of integers where the i-th element is the next greater element for `nums[i]`, or -1 if it doesn't exist.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 1]",
        "output": "[2, -1, 2]",
        "explanation": "The next greater for 1 is 2, for 2 is -1 (no greater element), for last 1 is 2."
      },
      {
        "input": "nums = [3, 2, 1]",
        "output": "[-1, 3, 3]",
        "explanation": "The next greater for 3 is -1 (no greater element), for 2 is 3, for 1 is 3."
      },
      {
        "input": "nums = [5, 4, 3, 2, 1]",
        "output": "[-1, 5, 5, 5, 5]",
        "explanation": "All elements are less than 5, so their next greater is 5, except for the first 5, which has no greater."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to keep track of the indices.",
      "You can traverse the array up to two times for finding the next greater elements."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Number of Longest Increasing Subsequence",
    "description": "Given an integer array nums, return the number of longest increasing subsequences.",
    "topic": "Dynamic Programming",
    "subtopic": "Longest Increasing Subsequence",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Count",
      "Subsequence"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the number of longest increasing subsequences.",
    "constraints": [
      "1 <= nums.length <= 2000",
      "0 <= nums[i] <= 10^3"
    ],
    "examples": [
      {
        "input": "nums = [10, 9, 2, 5, 3, 7, 101, 18]",
        "output": "4",
        "explanation": "The longest increasing subsequences are [2], [3], [5], and [7], all of which can be extended to [2, 3, 7], [2, 5, 7], [2, 7], and [3, 7], which have a length of 4."
      },
      {
        "input": "nums = [3, 3, 3, 3, 3]",
        "output": "5",
        "explanation": "Each single element is a subsequence of length 1, making all 5 elements the longest increasing subsequences."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to build your solution.",
      "Maintain an array to store the lengths of the longest subsequences.",
      "Use another array to count the number of times you can form these lengths."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Serialize and Deserialize Binary Tree",
    "description": "Design a data structure that encodes a binary tree into a string and decodes a string back to the binary tree. Implement the functions `serialize(root)` and `deserialize(data)` where `serialize` converts the binary tree into a string, and `deserialize` reconstructs the binary tree from the string representation. The serialization format should be level-order traversal, and the tree nodes should be represented in a way that makes it easy to reconstruct the tree.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Serialization",
      "Deserialization"
    ],
    "input_format": "The function `serialize` takes the root of the binary tree as input, while `deserialize` takes a string representation of the binary tree.",
    "output_format": "The `serialize` function returns a string representation of the binary tree, and the `deserialize` function returns the root of the reconstructed binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "Node values are in the range of [-10^5, 10^5]."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, null, null, 4, 5]",
        "output": "'1,2,3,null,null,4,5'",
        "explanation": "The serialized string represents the level-order traversal of the binary tree."
      },
      {
        "input": "data = '1,2,3,null,null,4,5'",
        "output": "[1,2,3,null,null,4,5]",
        "explanation": "The deserialized binary tree should match the original structure represented by the serialization."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a queue for level-order traversal during serialization.",
      "For deserialization, you can split the string and reconstruct the tree node by node."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Longest Valid Parentheses",
    "description": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Stack"
    ],
    "input_format": "A string s consisting of characters '(' and ')'.",
    "output_format": "An integer representing the length of the longest valid parentheses substring.",
    "constraints": [
      "0 <= s.length <= 3 * 10^4",
      "s[i] is '(' or ')'"
    ],
    "examples": [
      {
        "input": "s = \"()()\"",
        "output": "4",
        "explanation": "The entire string is valid, thus the length is 4."
      },
      {
        "input": "s = \"(())\"",
        "output": "4",
        "explanation": "The entire string is valid, thus the length is 4."
      },
      {
        "input": "s = \")()())\"",
        "output": "4",
        "explanation": "The longest valid parentheses substring is \"()()\"."
      },
      {
        "input": "s = \"\"",
        "output": "0",
        "explanation": "An empty string has no valid parentheses."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to keep track of indices.",
      "You can maintain a variable to mark the last index of unmatched characters."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Largest Plus Sign",
    "description": "In a grid of size n x n, you have an integer array that represents the presence of mines in the grid. A '1' represents a mine and '0' represents an empty cell. Your task is to find the largest possible plus sign that can be formed in the grid. A plus sign consists of a center and extends in each of the four cardinal directions (up, down, left, right) with arms of equal length. Return the order of the largest plus sign, which is defined as the arm length plus one (the center cell). If no plus sign can be formed, return 0.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Matrix",
      "Searching"
    ],
    "input_format": "An integer n representing the size of the grid, and an array of arrays of integers representing the grid. The grid contains only '0's and '1's.",
    "output_format": "An integer representing the order of the largest plus sign.",
    "constraints": [
      "1 <= n <= 500",
      "grid[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "n = 5, mines = [[4, 2]]",
        "output": "1",
        "explanation": "The largest plus sign is formed with arm length of 1, thus the order is 2 (1 + 1)."
      },
      {
        "input": "n = 1, mines = []",
        "output": "1",
        "explanation": "The grid is 1x1 with no mines. The only plus sign has an arm length of 0, so the order is 1."
      },
      {
        "input": "n = 5, mines = [[0, 0], [0, 1], [1, 0], [2, 1], [2, 2], [3, 3]]",
        "output": "1",
        "explanation": "Only small plus signs can be formed with arm length of 1, whose order is thus 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to calculate the arm lengths from each cell.",
      "Store the left, right, up, and down counts in separate arrays."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Binary Tree Level Order Traversal",
    "description": "Given a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level). You may assume that the input binary tree is not empty.",
    "topic": "Tree",
    "subtopic": "Traversal",
    "tags": [
      "Tree",
      "BFS",
      "Level Order"
    ],
    "input_format": "The input is the root of a binary tree.",
    "output_format": "A list of lists of integers representing the level order traversal values.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[9,20],[15,7]]",
        "explanation": "The level order traversal is: first level has 3, second level has 9 and 20, and the third level has 15 and 7."
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": "The tree only has one node, so the level order traversal is just that node."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree results in an empty list."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to facilitate level order traversal.",
      "Consider storing nodes in a temporary list for each level."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Insert Delete GetRandom O(1)",
    "description": "Design a data structure that supports the following operations: insert, delete, and getRandom. All operations should be done in average O(1) time complexity.\n\nImplement the class RandomizedSet:\n\n- `bool insert(int val)`: Inserts an item val to the set. Returns true if the item was not already present.\n- `bool remove(int val)`: Removes an item val from the set. Returns true if the item was present.\n- `int getRandom()`: Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.\n\nYou must implement the solution with O(1) time complexity for the insert, remove, and getRandom operations.",
    "topic": "Design",
    "subtopic": "Data Structures",
    "tags": [
      "Random",
      "Hash Map",
      "Array"
    ],
    "input_format": "A sequence of operations on the RandomizedSet instance.",
    "output_format": "For insert and remove operations, return a boolean indicating success. For getRandom, return an integer from the elements in the set.",
    "constraints": [
      "All values for insert and remove will be unique positive integers.",
      "The number of operations will be at most 10^4."
    ],
    "examples": [
      {
        "input": "RandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1);\nrandomizedSet.remove(2);\nrandomizedSet.insert(2);\nrandomizedSet.getRandom();",
        "output": "1 or 2",
        "explanation": "Both 1 and 2 are in the set, either can be returned when calling getRandom."
      },
      {
        "input": "randomizedSet.remove(1);\nrandomizedSet.insert(2);\nrandomizedSet.getRandom();",
        "output": "2",
        "explanation": "Only 2 is now in the set, so 2 is returned."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a combination of a list and a hash map for efficient access."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Merge Sorted Arrays",
    "description": "You are given two sorted integer arrays nums1 and nums2. Your task is to merge the two arrays into a single sorted array nums3. The merged array should be in non-decreasing order. The function should modify nums1 in place and cannot use any additional array space except for a constant amount of extra space.",
    "topic": "Array",
    "subtopic": "Merging Arrays",
    "tags": [
      "Array",
      "Sorting",
      "In-place"
    ],
    "input_format": "Two sorted arrays nums1 and nums2, where nums1 has enough space to hold additional elements from nums2.",
    "output_format": "The merged sorted array nums1.",
    "constraints": [
      "1 <= nums1.length, nums2.length <= 10^4",
      "-10^5 <= nums1[i], nums2[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 3, 0, 0, 0], nums2 = [2, 5, 6]",
        "output": "[1, 2, 2, 3, 5, 6]",
        "explanation": "After merging nums1 and nums2, we have a sorted array: [1, 2, 2, 3, 5, 6]."
      },
      {
        "input": "nums1 = [1], nums2 = []",
        "output": "[1]",
        "explanation": "There is only one element in nums1 and nums2 is empty, so the merged array is simply [1]."
      },
      {
        "input": "nums1 = [0], nums2 = [1]",
        "output": "[0, 1]",
        "explanation": "We merge the arrays, resulting in [0, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers to compare elements from both arrays.",
      "Start from the end of nums1, since it has enough space."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A single input string s, consisting of English letters, digits, symbols, and spaces.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 10^5",
      "s consists of printable ASCII characters."
    ],
    "examples": [
      {
        "input": "abcabcbb",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'abc', with a length of 3."
      },
      {
        "input": "bbbbb",
        "output": "1",
        "explanation": "The longest substring without repeating characters is 'b', with a length of 1."
      },
      {
        "input": "pwwkew",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'wke', with a length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window approach to keep track of characters.",
      "A HashMap can help to remember the last position of each character.",
      "Adjust the start of the window as you find duplicates."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Task Scheduler",
    "description": "Given a list of tasks represented by uppercase letters and an integer n representing the cooling interval between the same tasks, return the least amount of time required to finish all tasks. The tasks that are the same must be separated by at least n units of time if possible. If not, fill in with idle time units as needed.",
    "topic": "Greedy",
    "subtopic": "Task Scheduling",
    "tags": [
      "Greedy",
      "Scheduling",
      "Array"
    ],
    "input_format": "A list of characters tasks and an integer n.",
    "output_format": "An integer representing the least amount of time required to finish all tasks.",
    "constraints": [
      "1 <= tasks.length <= 10^5",
      "1 <= n <= 10^3",
      "tasks[i] is an uppercase letter."
    ],
    "examples": [
      {
        "input": "tasks = ['A', 'A', 'A', 'B', 'B', 'B'], n = 2",
        "output": "8",
        "explanation": "One possible way to schedule tasks is to do: A -> B -> idle -> A -> B -> idle -> A -> B. This requires a total of 8 units of time."
      },
      {
        "input": "tasks = ['A', 'A', 'A', 'B', 'B', 'B'], n = 0",
        "output": "6",
        "explanation": "With n = 0, we can schedule A and B consecutively without any idle time: A -> A -> A -> B -> B -> B, totaling 6 units of time."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Count the frequency of each task.",
      "Use a max heap to keep track of the tasks.",
      "Calculate idle time based on the cooling interval."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Generate Parentheses",
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. The parentheses must be arranged such that for every opening parenthesis, there is a corresponding closing parenthesis. The combinations should be returned in any order.",
    "topic": "Backtracking",
    "subtopic": "Generating Combinations",
    "tags": [
      "Backtracking",
      "Recursion",
      "String"
    ],
    "input_format": "An integer n representing the number of pairs of parentheses.",
    "output_format": "A list of strings, each representing a valid combination of parentheses.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]",
        "explanation": "These are all the valid combinations of 3 pairs of parentheses."
      },
      {
        "input": "n = 1",
        "output": "[\"()\"]",
        "explanation": "There is only one combination for 1 pair of parentheses."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to build combinations by adding an opening or closing parenthesis recursively.",
      "Make sure you never add more closing parentheses than opening ones."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Merge Two Sorted Lists",
    "description": "You are given the heads of two sorted linked lists. Your task is to merge the two lists into one sorted list, which is also a linked list. The merged list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
    "topic": "Linked List",
    "subtopic": "Merging Lists",
    "tags": [
      "Linked List",
      "Sorting",
      "Merge"
    ],
    "input_format": "The input consists of two linked lists represented by their head nodes, list1 and list2.",
    "output_format": "Return the head node of the merged linked list.",
    "constraints": [
      "The input linked lists have a length in the range [0, 100].",
      "The values of the nodes are in the range [-100, 100]."
    ],
    "examples": [
      {
        "input": "list1 = 1 -> 2 -> 4, list2 = 1 -> 3 -> 4",
        "output": "1 -> 1 -> 2 -> 3 -> 4 -> 4",
        "explanation": "The nodes from both lists are merged in sorted order."
      },
      {
        "input": "list1 = , list2 = 0",
        "output": "0",
        "explanation": "Since list1 is empty, the merged list is just list2."
      },
      {
        "input": "list1 = 2 -> 5 -> 7, list2 = 1 -> 3 -> 4",
        "output": "1 -> 2 -> 3 -> 4 -> 5 -> 7",
        "explanation": "The nodes are merged in sorted order."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "You can use a dummy node to simplify the merging process.",
      "Compare the nodes of both lists and insert the smaller one into the merged list."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Shortest Path in Binary Matrix",
    "description": "Given an n x n binary grid, where 0 represents free cells and 1 represents obstacles, return the length of the shortest path from the top-left corner to the bottom-right corner. You can move in 8 directions: up, down, left, right, and the four diagonals. If there is no path, return -1.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "Graph",
      "BFS",
      "Matrix",
      "Shortest Path"
    ],
    "input_format": "A 2D binary grid represented as a list of lists, where each element is either 0 or 1.",
    "output_format": "An integer representing the length of the shortest path, or -1 if there is no path.",
    "constraints": [
      "1 <= n <= 100",
      "grid[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "grid = [[0, 0, 0], [1, 0, 1], [0, 0, 0]]",
        "output": "4",
        "explanation": "The shortest path is from (0,0) to (2,2): (0,0) -> (0,1) -> (1,1) -> (2,1) -> (2,2)."
      },
      {
        "input": "grid = [[0, 1], [1, 0]]",
        "output": "2",
        "explanation": "The shortest path is (0,0) -> (1,1)."
      },
      {
        "input": "grid = [[1, 0, 0], [1, 1, 0], [0, 0, 0]]",
        "output": "-1",
        "explanation": "There is no path from (0,0) to (2,2) due to blocked cells."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using BFS to explore the grid.",
      "Keep track of visited cells to avoid cycles.",
      "Check all 8 possible directions when moving."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Find All Anagrams in a String",
    "description": "Given a string `s` and a string `p`, return all the start indices of `p`'s anagrams in `s`. You may return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Hash Table"
    ],
    "input_format": "Two input strings `s` (the main string) and `p` (the pattern string).",
    "output_format": "A list of integers representing the starting indices of anagrams of `p` found in `s`.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "1 <= p.length <= 10^4",
      "s and p consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = 'cbaebabacd', p = 'abc'",
        "output": "[0, 6]",
        "explanation": "The substring starting at index 0 is 'cba', which is an anagram of 'abc'. The substring starting at index 6 is 'bac', which is also an anagram of 'abc'."
      },
      {
        "input": "s = 'abab', p = 'ab'",
        "output": "[0, 1, 2]",
        "explanation": "The substrings starting at indices 0, 1, and 2 are 'ab', 'ba', and 'ab' respectively, all of which are anagrams of 'ab'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window of length equal to the length of p.",
      "Maintain a count of characters in both s and p."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume that the arrays are non-empty. The median is the middle value in an ordered integer list. If the the size of the list is even, there is no middle value and the median is the average of the two middle values.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Median"
    ],
    "input_format": "Two integers arrays nums1 and nums2.",
    "output_format": "A single float representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= nums1.length, nums2.length <= 1000",
      "1 <= nums1.length + nums2.length <= 2000",
      "-10^6 <= nums1[i], nums2[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.00000",
        "explanation": "The combined sorted array is [1, 2, 3] and the median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.50000",
        "explanation": "The combined sorted array is [1, 2, 3, 4] and the median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider binary search to find the partition point.",
      "The median can be found using the concept of half partitions."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "topic": "Dynamic Programming",
    "subtopic": "Fibonacci Sequence",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Mathematics"
    ],
    "input_format": "An integer n, representing the total number of steps in the staircase.",
    "output_format": "An integer representing the number of distinct ways to reach the top.",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb 2 steps: (1 + 1) and (2)."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb 3 steps: (1 + 1 + 1), (1 + 2), and (2 + 1)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider breaking down the problem into subproblems.",
      "Use dynamic programming to store previously solved subproblems."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Number of Operations to Make Network Connected",
    "description": "You have n computers that are connected by some cables. The cables are undirected and do not have any weight. You want to connect all computers together, so you need to know the minimum number of additional cables needed to make all computers connected. A computer is connected to another computer if they are directly connected or if there is a path between them through other computers. Calculate the minimum number of operations required to connect all computers.",
    "topic": "Graph",
    "subtopic": "Connectivity",
    "tags": [
      "Graph",
      "Network",
      "Union Find"
    ],
    "input_format": "Two integers n (the number of computers) and an array connections where each connection is a pair of integers [a, b] representing a direct connection between computer a and computer b.",
    "output_format": "An integer representing the minimum number of additional cables needed to connect all computers.",
    "constraints": [
      "1 <= n <= 10^5",
      "0 <= connections.length <= 10^5",
      "connections[i].length == 2",
      "0 <= connections[i][0], connections[i][1] < n",
      "connections[i][0] != connections[i][1]"
    ],
    "examples": [
      {
        "input": "n = 6, connections = [[0, 1], [0, 2], [0, 3], [1, 4]]",
        "output": "2",
        "explanation": "There are 4 connected components in the network (0-1-2-3, 4, 5), hence we need 2 additional cables to connect the three components."
      },
      {
        "input": "n = 5, connections = [[0, 1], [0, 2], [0, 3], [1, 2]]",
        "output": "1",
        "explanation": "The computers are connected in a way that forms one component with 5 computers, thus only one additional cable is needed."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Disjoint Set Union (Union-Find) to track connected components.",
      "Count the number of connected components and subtract one from it to find the number of cables required."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Design Circular Queue",
    "description": "Your task is to implement a circular queue data structure. The circular queue should support the following operations: enqueue, dequeue, front, rear, and isEmpty. Your implementation should be able to properly handle wrap-around logic.",
    "topic": "Data Structures",
    "subtopic": "Queue",
    "tags": [
      "Queue",
      "Data Structures",
      "Circular Queue"
    ],
    "input_format": "Operations on the circular queue are represented as list of strings where each string can be one of the following commands: 'enqueue x', 'dequeue', 'front', 'rear', or 'isEmpty'. The argument 'x' in 'enqueue' is an integer to be added to the queue.",
    "output_format": "A list containing the results of executing the commands: for 'dequeue', 'front', and 'rear', return the appropriate value; for 'isEmpty', return a boolean value.",
    "constraints": [
      "1 <= capacity <= 1000",
      "The enqueue operation will only be called when the queue is not full.",
      "The dequeue, front, and rear operations will only be called when the queue is not empty."
    ],
    "examples": [
      {
        "input": "['enqueue 10', 'enqueue 20', 'front', 'rear', 'dequeue', 'isEmpty']",
        "output": "[10, 20, 10, false]",
        "explanation": "After enqueuing 10 and 20, front returns 10, rear returns 20. After dequeue, the queue only has 20 left, so isEmpty returns false."
      },
      {
        "input": "['enqueue 5', 'dequeue', 'isEmpty']",
        "output": "[5, 5, true]",
        "explanation": "After enqueueing 5, then dequeueing it, the queue becomes empty, so isEmpty returns true."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using an array to represent the queue.",
      "Use two pointers to track the front and rear of the queue.",
      "When the rear pointer reaches the end of the array, it should wrap around to the beginning."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Get the Maximum Score",
    "description": "You are given a list of integers representing scores achieved in various tasks. Your goal is to determine the maximum possible score that can be achieved by selecting a certain number of tasks with given constraints. Each task has a point value and can only be selected if the total number of tasks selected does not exceed a specific limit. Additionally, you can only select tasks that fall within a certain range, determined by the minimum and maximum acceptable scores.",
    "topic": "Dynamic Programming",
    "subtopic": "Knapsack Problem",
    "tags": [
      "Dynamic Programming",
      "Knapsack",
      "Greedy"
    ],
    "input_format": "A list of integers scores, an integer max_tasks, an integer min_score, and an integer max_score.",
    "output_format": "An integer representing the maximum score that can be achieved based on the inputs provided.",
    "constraints": [
      "1 <= scores.length <= 1000",
      "0 <= max_tasks <= 100",
      "1 <= min_score <= max_score <= 10^5"
    ],
    "examples": [
      {
        "input": "scores = [10, 20, 30, 40, 50], max_tasks = 3, min_score = 15, max_score = 45",
        "output": "90",
        "explanation": "Selecting scores 20, 30, and 40 gives a total of 20 + 30 + 40 = 90, which is within the score range and task limit."
      },
      {
        "input": "scores = [15, 25, 35, 10], max_tasks = 2, min_score = 20, max_score = 50",
        "output": "60",
        "explanation": "Selecting scores 25 and 35 gives 25 + 35 = 60, which is the maximum achievable score without exceeding the limits."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider iterating through the scores while maintaining a rolling sum.",
      "Utilize a dynamic programming approach to optimize task selection."
    ],
    "company": "Intuit"
  },
  {
    "question_id": "",
    "title": "Binary Tree Zigzag Level Order Traversal",
    "description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "BFS",
      "Binary Tree"
    ],
    "input_format": "A binary tree node represented as TreeNode where TreeNode.val is an integer and TreeNode.left and TreeNode.right are the left and right child nodes respectively.",
    "output_format": "A list of lists of integers, where each list represents the values of the nodes at that level in zigzag order.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000]",
      "-100 <= TreeNode.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[20,9],[15,7]]",
        "explanation": "Level 0 is [3]. Level 1 is [9,20] from left to right. Level 2 is [15,7] from right to left."
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": "Only root node present, its value is in a single list for level 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to perform level order traversal.",
      "Toggle the direction of adding nodes at each level."
    ],
    "company": "Intuit"
  }
]