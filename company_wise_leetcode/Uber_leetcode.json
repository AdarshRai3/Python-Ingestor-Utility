[
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Sum"
    ],
    "input_format": "An array of integers `nums` and an integer `target`.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] == 2 + 7 == 9, so return [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "nums[1] + nums[2] == 2 + 4 == 6, so return [1, 2]."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] == 3 + 3 == 6, so return [0, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash table to store the differences."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array where the ith element is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices where each element represents the stock price on a particular day.",
    "output_format": "An integer representing the maximum profit that can be achieved.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate potential profit for every day and keep track of the maximum profit."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Word Search",
    "description": "Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where adjacent cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "topic": "Backtracking",
    "subtopic": "Search",
    "tags": [
      "Backtracking",
      "DFS",
      "Matrix"
    ],
    "input_format": "A 2D board represented as an array of arrays of characters, and a string representing the word to search for.",
    "output_format": "A boolean value indicating whether the word exists in the grid.",
    "constraints": [
      "1 <= board.length, board[i].length <= 6",
      "1 <= word.length <= 15",
      "All input characters are lowercase English letters."
    ],
    "examples": [
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "ABCCED"
        },
        "output": "true",
        "explanation": "The word 'ABCCED' can be found in the grid by following the path through the cells."
      },
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "SEE"
        },
        "output": "true",
        "explanation": "The word 'SEE' can be found by traversing from the cell containing 'S' below to 'E' and then to another 'E'."
      },
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "ABCB"
        },
        "output": "false",
        "explanation": "The word 'ABCB' does not exist in the grid as we cannot use the same letter cell more than once."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using depth-first search to explore the paths.",
      "Keep track of visited cells to avoid reusing them."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Text Justification",
    "description": "Given an array of words and a length maxWidth, format the text such that each line has exactly maxWidth characters. You should pack your words in a greedy approach; that means fitting as many words as you can in each line. The extra spaces on the rightmost side of the line are to be distributed evenly. If the number of spaces is not evenly divisible by the number of gaps between words, the extra spaces should be distributed one per gap, starting from the left. Lines should be fully justified and should not exceed maxWidth in length.",
    "topic": "String",
    "subtopic": "Text Formatting",
    "tags": [
      "String",
      "Greedy",
      "Text Justification"
    ],
    "input_format": "An array of strings words containing the words to be formatted and an integer maxWidth representing the maximum line width.",
    "output_format": "An array of strings where each string represents a justified line of text.",
    "constraints": [
      "1 <= words.length <= 3000",
      "0 <= words[i].length <= 100",
      "1 <= maxWidth <= 100"
    ],
    "examples": [
      {
        "input": {
          "words": [
            "This",
            "is",
            "an",
            "example",
            "of",
            "text",
            "justification."
          ],
          "maxWidth": 16
        },
        "output": [
          "This    is    an",
          "example  of text",
          "justification.  "
        ],
        "explanation": "The first line is packed with 'This', 'is', and 'an' making a total of 16 characters. The second line consists of 'example' and 'of text', and the last line just contains 'justification.' with extra spaces."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Think about how to distribute spaces between words.",
      "Consider edge cases where the last line is not fully justified.",
      "Use a greedy approach to decide how many words to put in a line."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order. You should traverse the matrix clockwise in a spiral pattern starting from the top left corner.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral"
    ],
    "input_format": "An m x n matrix of integers.",
    "output_format": "A list of integers representing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "m * n <= 10^6",
      "-10^5 <= matrix[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The elements are traversed as follows: start from 1 (top-left), then move right to 3, down to 9, left to 7, and finally up to 5, resulting in [1, 2, 3, 6, 9, 8, 7, 4, 5]."
      },
      {
        "input": "matrix = [[1, 2], [3, 4]]",
        "output": "[1, 2, 4, 3]",
        "explanation": "The elements are traversed as: start from 1, move right to 2, down to 4, left to 3, giving [1, 2, 4, 3]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about the four boundary directions you need to cover: right, down, left, and up.",
      "Keep track of the boundaries of the matrix as you navigate through."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Roman to Integer",
    "description": "Given a string representing a Roman numeral, convert it to an integer. The Roman numerals are represented as follows: I=1, V=5, X=10, L=50, C=100, D=500, and M=1000. The input is guaranteed to be valid Roman numeral representation.",
    "topic": "String",
    "subtopic": "Conversion",
    "tags": [
      "String",
      "Conversion",
      "Roman Numerals"
    ],
    "input_format": "A string s representing a valid Roman numeral.",
    "output_format": "An integer representing the value of the Roman numeral.",
    "constraints": [
      "1 <= s.length <= 15",
      "s consists of the characters {'I', 'V', 'X', 'L', 'C', 'D', 'M'}"
    ],
    "examples": [
      {
        "input": "s = 'III'",
        "output": "3",
        "explanation": "The Roman numeral 'III' is equal to 1 + 1 + 1 = 3."
      },
      {
        "input": "s = 'IV'",
        "output": "4",
        "explanation": "The Roman numeral 'IV' represents 5 - 1 = 4."
      },
      {
        "input": "s = 'IX'",
        "output": "9",
        "explanation": "The Roman numeral 'IX' represents 10 - 1 = 9."
      },
      {
        "input": "s = 'LVIII'",
        "output": "58",
        "explanation": "The Roman numeral 'LVIII' is equal to 50 + 5 + 1 + 1 + 1 = 58."
      },
      {
        "input": "s = 'MCMXCIV'",
        "output": "1994",
        "explanation": "The Roman numeral 'MCMXCIV' is equal to 1000 + (1000 - 100) + (1000 - 10) + 5 = 1994."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a mapping from Roman numerals to integers.",
      "Iterate through the string and apply the subtraction rule when necessary."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "topic": "String",
    "subtopic": "Hashing",
    "tags": [
      "String",
      "Hashing",
      "Anagrams"
    ],
    "input_format": "An array of strings 'strs'.",
    "output_format": "A list of lists, where each list contains grouped anagrams.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase letters only."
    ],
    "examples": [
      {
        "input": "strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
        "output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
        "explanation": "The grouped anagrams are [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "Single empty string returns a group containing one empty string."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "Single character 'a' returns its own group."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash table to group words by their sorted characters.",
      "Consider using the character count as a key for grouping."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Letter Combinations of a Phone Number",
    "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. The mapping is as follows:\n\n2: ['a', 'b', 'c']\n3: ['d', 'e', 'f']\n4: ['g', 'h', 'i']\n5: ['j', 'k', 'l']\n6: ['m', 'n', 'o']\n7: ['p', 'q', 'r', 's']\n8: ['t', 'u', 'v']\n9: ['w', 'x', 'y', 'z']\n\nYou may return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "String Manipulation",
    "tags": [
      "Backtracking",
      "String",
      "Recursion"
    ],
    "input_format": "A string containing digits from 2 to 9.",
    "output_format": "A list of strings representing all possible combinations of letters.",
    "constraints": [
      "0 <= digits.length <= 4",
      "digits[i] is a digit from '2' to '9'."
    ],
    "examples": [
      {
        "input": "digits = \"23\"",
        "output": "[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]",
        "explanation": "The digit 2 maps to letters 'a', 'b', 'c', and the digit 3 maps to letters 'd', 'e', 'f'. Combining them gives all combinations."
      },
      {
        "input": "digits = \"\"",
        "output": "[]",
        "explanation": "An empty input string should return an empty list."
      },
      {
        "input": "digits = \"2\"",
        "output": "[\"a\", \"b\", \"c\"]",
        "explanation": "The digit 2 maps to letters 'a', 'b', 'c'. Hence, the output is a list of those letters."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think of using backtracking to explore all possible combinations.",
      "Use a hash map to store the mapping of digits to letters."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string. A common prefix is a substring that appears at the beginning of each string in the array.",
    "topic": "String",
    "subtopic": "Prefix",
    "tags": [
      "String",
      "Prefix",
      "Array"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A string representing the longest common prefix among the strings.",
    "constraints": [
      "0 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "All strings consist of only lowercase letters."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The longest common prefix is 'fl'."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among the strings."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider the first string as an initial prefix.",
      "Compare this prefix with each string and reduce it until it matches."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Generate Parentheses",
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. A combination of parentheses is considered well-formed if every opening parentheses has a corresponding closing parentheses in the correct order.",
    "topic": "Backtracking",
    "subtopic": "Generating Combinations",
    "tags": [
      "Backtracking",
      "Recursion",
      "String"
    ],
    "input_format": "An integer n representing the number of pairs of parentheses.",
    "output_format": "A list of strings containing all combinations of well-formed parentheses.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "['((()))', '(()())', '(())()', '()(())', '()()()']",
        "explanation": "The five combinations of well-formed parentheses for 3 pairs are: ((())), (()()), (())(), ()(()), and ()()."
      },
      {
        "input": "n = 1",
        "output": "['()']",
        "explanation": "For 1 pair of parentheses, the only well-formed combination is '()'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use backtracking to build the combinations.",
      "Keep track of the number of opening and closing parentheses used."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Minimum Window Substring",
    "description": "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\". The answer is guaranteed to be unique.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Hash Table"
    ],
    "input_format": "Two strings, s and t, where 1 <= s.length, t.length <= 10^5.",
    "output_format": "A string representing the minimum window substring of s that contains all characters of t.",
    "constraints": [
      "1 <= s.length, t.length <= 10^5",
      "s and t consist of English letters, digits, symbols, and spaces."
    ],
    "examples": [
      {
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
        "output": "\"BANC\"",
        "explanation": "The minimum window substring of s that contains all characters of t is \"BANC\"."
      },
      {
        "input": "s = \"a\", t = \"a\"",
        "output": "\"a\"",
        "explanation": "The only character in s is 'a', which is also in t."
      },
      {
        "input": "s = \"a\", t = \"aa\"",
        "output": "\"\"",
        "explanation": "s does not contain enough occurrences of 'a' to match t."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using two pointers for the sliding window technique.",
      "Use a count map to keep track of the characters in t.",
      "When expanding the window, check if all characters have been covered."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list.",
    "topic": "Linked List",
    "subtopic": "Addition",
    "tags": [
      "Linked List",
      "Addition",
      "Math"
    ],
    "input_format": "Each linked list is represented as a ListNode where ListNode.val is the digit and ListNode.next is the next node.",
    "output_format": "Return the sum as a linked list in the same reverse order format.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the input lists represent valid numbers."
    ],
    "examples": [
      {
        "input": "[2 -> 4 -> 3], [5 -> 6 -> 4]",
        "output": "[7 -> 0 -> 8]",
        "explanation": "The input represents the numbers 342 and 465. Adding them gives 807, represented as the linked list [7 -> 0 -> 8]."
      },
      {
        "input": "[0], [0]",
        "output": "[0]",
        "explanation": "Both numbers are 0, so the sum is also 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a carry variable when adding the digit values."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Merge Sorted Array",
    "description": "Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has a size equal to m + n, which means it has enough space to hold additional elements from nums2.",
    "topic": "Array",
    "subtopic": "Merging Arrays",
    "tags": [
      "Array",
      "Sorting",
      "Merge"
    ],
    "input_format": "Two integer arrays nums1 and nums2 where nums1 has a size of m + n and contains m initialized elements followed by n zeros.",
    "output_format": "The first array nums1, now containing all elements from both arrays in sorted order.",
    "constraints": [
      "0 <= m, n <= 200",
      "1 <= m + n <= 200",
      "-10^9 <= nums1[i], nums2[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3",
        "output": "[1, 2, 2, 3, 5, 6]",
        "explanation": "After merging nums2 into nums1, the sorted array will be [1, 2, 2, 3, 5, 6]."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "Since nums2 is empty, the result is simply nums1 itself: [1]."
      },
      {
        "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
        "output": "[1]",
        "explanation": "There is no initialized element in nums1, so nums2 is the merged result, which is [1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider merging elements from the end of each array to avoid overwriting elements.",
      "Use two pointers to traverse nums1 and nums2."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Rotate Image",
    "description": "You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). You have to rotate the image in place, which means you have to modify the input 2D matrix directly. Do not use an additional array or matrix.",
    "topic": "Array",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Array",
      "Matrix",
      "In-place"
    ],
    "input_format": "A 2D square matrix of size n x n where 1 <= n <= 20.",
    "output_format": "The matrix after being rotated by 90 degrees clockwise.",
    "constraints": [
      "1 <= matrix.length == matrix[i].length <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]",
        "explanation": "After rotating the matrix clockwise, the first row becomes the last column, the second row becomes the second column, and the last row becomes the first column."
      },
      {
        "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
        "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
        "explanation": "All elements are shifted to their new positions after 90 degrees clockwise rotation."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using the layering approach to rotate the matrix layer by layer.",
      "Swap elements in a cycle for each layer."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of bars in a histogram, compute how much water can be trapped after raining. The water trapped above a bar depends on the heights of the tallest bars on both its left and right sides.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers heights[] representing the heights of the bars.",
    "output_format": "An integer representing the total amount of water trapped.",
    "constraints": [
      "0 <= heights.length <= 2 * 10^4",
      "0 <= heights[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "heights = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "Water is trapped at indices 2, 4, 5, 6, totaling 6 units."
      },
      {
        "input": "heights = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "Water is trapped between the bars, totaling 9 units."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use two pointers to traverse from both ends of the array.",
      "Maintain the maximum height seen from both the left and right sides."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "You are given an integer array 'nums' sorted in ascending order, where the largest element is moved to the end of the array. Write a function to search for a target value in the rotated sorted array and return its index if found, or -1 if it is not found.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An integer representing the index of the target in the array or -1 if not found.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "\u221210^4 <= nums[i] <= 10^4",
      "All elements of nums are unique.",
      "nums is guaranteed to be rotated at some pivot."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "The target 0 is found at index 4 in the rotated sorted array."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "The target 3 is not found in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search as the array is sorted (with a twist).",
      "Identify the pivot point where the rotation occurs."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if the brackets are closed in the correct order. Every opening bracket must have a corresponding closing bracket of the same type.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A string s consisting of parentheses.",
    "output_format": "A boolean indicating whether the input string is valid.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses only."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The parentheses are correctly matched and nested."
      },
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "The parentheses are correctly matched and nested."
      },
      {
        "input": "s = '(]')",
        "output": "false",
        "explanation": "The brackets are not closing in the correct order."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening parentheses.",
      "Check if the stack is empty after processing all characters."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Remove Element",
    "description": "Given an array of integers nums and an integer val, you need to remove all instances of val in-place and return the new length of the array. Do not allocate extra space for another array. You must do this by modifying the input array directly.",
    "topic": "Array",
    "subtopic": "In-place Manipulation",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An array of integers nums and an integer val.",
    "output_format": "An integer representing the new length of the array after removal.",
    "constraints": [
      "0 <= nums.length <= 100",
      "-100 <= nums[i] <= 100",
      "val is guaranteed to be in nums."
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 2, 3], val = 3",
        "output": "2",
        "explanation": "After removing 3s, the array becomes [2, 2]. The new length is 2."
      },
      {
        "input": "nums = [0, 1, 2, 2, 3, 0, 4, 2], val = 2",
        "output": "5",
        "explanation": "After removing 2s, the array becomes [0, 1, 3, 0, 4]. The new length is 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to maintain the position of elements."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Hash Table"
    ],
    "input_format": "An integer array nums.",
    "output_format": "A list of unique triplets that sum up to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that sum to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no numbers to form triplets."
      },
      {
        "input": "nums = [0, 1, 1]",
        "output": "[]",
        "explanation": "There are no triplets that sum to zero."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the array first to simplify the problem.",
      "Use a two-pointer technique to find the pairs that sum to a target."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Merge Two Sorted Lists",
    "description": "You are given the heads of two sorted linked lists, list1 and list2. Merge the two lists into one sorted list. The merged list should be returned as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.",
    "topic": "Linked List",
    "subtopic": "Merging Lists",
    "tags": [
      "Linked List",
      "Sorting",
      "Merge"
    ],
    "input_format": "The input consists of two linked lists, list1 and list2.",
    "output_format": "Return the head of the merged sorted linked list.",
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50].",
      "-100 <= Node.val <= 100",
      "Both list1 and list2 are sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": "The merged list is 1 -> 1 -> 2 -> 3 -> 4 -> 4."
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]",
        "explanation": "The merged list will just be 0."
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]",
        "explanation": "Both lists are empty, so the merged list is also empty."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a dummy node to simplify merging.",
      "Compare the nodes of both lists and append the smaller one."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Decode Ways",
    "description": "A message containing letters from A-Z can be encoded into numbers using the following mapping: 'A' -> '1', 'B' -> '2', ..., 'Z' -> '26'. For example, the encoded message '12' may represent 'AB' (1 2), or 'L' (12). Given a string s consisting of digits, determine the total number of ways to decode it. Leading zeroes are not allowed, and an empty string is considered as having one way to decode it.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Recursion"
    ],
    "input_format": "A string s representing the encoded message, containing only digits.",
    "output_format": "An integer representing the total number of ways to decode the message.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of digits and may contain leading zeroes."
    ],
    "examples": [
      {
        "input": "s = '12'",
        "output": "2",
        "explanation": "It can be decoded as 'AB' (1 2) or 'L' (12)."
      },
      {
        "input": "s = '226'",
        "output": "3",
        "explanation": "It can be decoded as 'BBF' (2 2 6), 'BZ' (2 26), or 'VF' (22 6)."
      },
      {
        "input": "s = '06'",
        "output": "0",
        "explanation": "Leading zeroes are not allowed, thus it cannot be decoded."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to keep track of the number of ways to decode up to each index.",
      "Check for valid single-digit and two-digit encodings when iterating through the string."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Sqrt(x)",
    "description": "Implement a function that computes and returns the square root of a non-negative integer x. The return value should be the largest integer y such that y*y <= x. You must not use any built-in exponentiation or square root functions. Solve it using a binary search algorithm.",
    "topic": "Binary Search",
    "subtopic": "Mathematics",
    "tags": [
      "Binary Search",
      "Mathematics",
      "Square Root"
    ],
    "input_format": "A non-negative integer x (0 <= x <= 2^31 - 1).",
    "output_format": "An integer representing the floor value of the square root of x.",
    "constraints": [
      "0 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 4",
        "output": "2",
        "explanation": "The largest integer y such that y*y <= 4 is 2, since 2*2 = 4."
      },
      {
        "input": "x = 8",
        "output": "2",
        "explanation": "The largest integer y such that y*y <= 8 is 2, since 2*2 = 4 and 3*3 = 9."
      },
      {
        "input": "x = 0",
        "output": "0",
        "explanation": "The largest integer y such that y*y <= 0 is 0."
      },
      {
        "input": "x = 1",
        "output": "1",
        "explanation": "The largest integer y such that y*y <= 1 is 1, since 1*1 = 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using binary search to narrow down the possible values of the square root."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Median"
    ],
    "input_format": "Two sorted arrays nums1 and nums2.",
    "output_format": "A float representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= nums1.length <= 1000",
      "0 <= nums2.length <= 1000",
      "nums1 and nums2 are both sorted in ascending order."
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.0",
        "explanation": "The combined sorted array is [1, 2, 3], and the median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.5",
        "explanation": "The combined sorted array is [1, 2, 3, 4], and the median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use binary search to minimize the run time complexity.",
      "Consider edge cases where one of the arrays is empty."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Maximum Depth of Binary Tree",
    "description": "Given a binary tree, find the maximum depth of the tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "topic": "Tree",
    "subtopic": "Depth-First Search",
    "tags": [
      "Tree",
      "Depth",
      "Recursion"
    ],
    "input_format": "The input is the root node of a binary tree.",
    "output_format": "An integer representing the maximum depth of the tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "3",
        "explanation": "The longest path is from the root node to the leaf nodes 15 or 7, which involves 3 nodes (3 -> 20 -> 15/7)."
      },
      {
        "input": "root = [1,null,2]",
        "output": "2",
        "explanation": "The longest path is from the root node 1 to the leaf node 2, which involves 2 nodes (1 -> 2)."
      },
      {
        "input": "root = []",
        "output": "0",
        "explanation": "There are no nodes in the tree, so the maximum depth is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using recursion to explore the depth of the tree.",
      "The depth of an empty tree is 0."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Next Permutation",
    "description": "Implement the function next_permutation that rearranges the numbers in a given list of integers to the next lexicographically greater permutation of its integer. If such arrangement is not possible, it must rearrange it to the lowest possible order (i.e., sorted in ascending order). The function should modify the input list in place and not return anything.",
    "topic": "Array",
    "subtopic": "Permutation",
    "tags": [
      "Array",
      "Permutation",
      "In-place"
    ],
    "input_format": "A list of integers nums representing the current permutation.",
    "output_format": "The list of integers modified in place to the next permutation.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[1, 3, 2]",
        "explanation": "The next permutation of [1, 2, 3] is [1, 3, 2]."
      },
      {
        "input": "nums = [3, 2, 1]",
        "output": "[1, 2, 3]",
        "explanation": "As the current permutation is the highest, the next permutation is the lowest: [1, 2, 3]."
      },
      {
        "input": "nums = [1, 1, 5]",
        "output": "[1, 5, 1]",
        "explanation": "The next permutation of [1, 1, 5] is [1, 5, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Look for the first decrease when scanning from the end of the array.",
      "Find the next larger element from the end to swap with.",
      "Reverse the elements after the swap index."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Largest Rectangle in Histogram",
    "description": "Given an array of integers heights representing the heights of bars in a histogram, return the area of the largest rectangle that can be formed in the histogram. The rectangle must be made up of contiguous bars, and its area is defined as the width of the rectangle multiplied by its height.",
    "topic": "Stack",
    "subtopic": "Monotonic Stack",
    "tags": [
      "Stack",
      "Dynamic Programming",
      "Array"
    ],
    "input_format": "An array of integers heights where 1 <= heights.length <= 10^5 and 0 <= heights[i] <= 10^4.",
    "output_format": "An integer representing the area of the largest rectangle in the histogram.",
    "constraints": [
      "1 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [2, 1, 5, 6, 2, 3]",
        "output": "10",
        "explanation": "The largest rectangle can be formed between the heights 5 and 6, with an area of 5 * 2 = 10."
      },
      {
        "input": "heights = [2, 4]",
        "output": "4",
        "explanation": "The largest rectangle can be formed using the height of 4 directly."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how you can use a stack to track the indices of the bars.",
      "Calculate the area for every bar when a smaller bar is encountered."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of k linked lists, each linked list is sorted in ascending order. Merge all the linked lists into one sorted linked list and return it. The resulting list should be made by splicing together the nodes of the given k lists.",
    "topic": "Linked List",
    "subtopic": "Merging",
    "tags": [
      "Linked List",
      "Merge",
      "Sorting"
    ],
    "input_format": "An array of k linked list heads, where each linked list contains nodes in sorted order.",
    "output_format": "The head of the merged linked list sorted in ascending order.",
    "constraints": [
      "k == lists.length",
      "0 <= k <= 10^4",
      "0 <= lists[i].length <= 500",
      "-10^4 <= lists[i].j <= 10^4"
    ],
    "examples": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]",
        "explanation": "The merged linked list is 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6."
      },
      {
        "input": "lists = []",
        "output": "[]",
        "explanation": "Since the input lists are empty, the merged linked list is also empty."
      },
      {
        "input": "lists = [[-1, 5, 11],[2, 6],[3, 4]]",
        "output": "[-1, 2, 3, 4, 5, 6, 11]",
        "explanation": "The merged linked list is -1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 11."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a priority queue to efficiently get the minimum element.",
      "Merge two lists at a time to simplify the problem.",
      "Take advantage of the sorted property of the linked lists."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A palindrome is a string that reads the same backward as forward. If there are multiple longest palindromic substrings, return any one of them.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A string s with length n.",
    "output_format": "A string representing the longest palindromic substring.",
    "constraints": [
      "1 <= n <= 1000",
      "s consists of only digits and English letters."
    ],
    "examples": [
      {
        "input": "s = 'babad'",
        "output": "'bab' or 'aba'",
        "explanation": "Both 'bab' and 'aba' are valid longest palindromic substrings."
      },
      {
        "input": "s = 'cbbd'",
        "output": "'bb'",
        "explanation": "'bb' is the longest palindromic substring in 'cbbd'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding from the center of the palindrome.",
      "Keep track of the start and end indices of the longest palindrome found."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Longest Consecutive Sequence",
    "description": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence. You must implement a solution that runs in linear time.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Consecutive",
      "Sorting"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the length of the longest consecutive elements sequence.",
    "constraints": [
      "0 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [100, 4, 200, 1, 3, 2]",
        "output": "4",
        "explanation": "The longest consecutive sequence is [1, 2, 3, 4] which has a length of 4."
      },
      {
        "input": "nums = [0, 0, 1, 1, 2, 2, 3, 3, 4]",
        "output": "5",
        "explanation": "The longest consecutive sequence is [0, 1, 2, 3, 4] which has a length of 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash set to track elements.",
      "For each number, check if it's the start of a sequence.",
      "Count how many consecutive numbers follow."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Regular Expression Matching",
    "description": "Implement a function that determines if a string matches a given pattern. The pattern can include the special character '.' which matches any single character, and '*' which matches zero or more of the preceding element. The matching should cover the entire string (not partial).",
    "topic": "String",
    "subtopic": "Pattern Matching",
    "tags": [
      "String",
      "Regular Expression",
      "Matching"
    ],
    "input_format": "Two strings: 's' (the input string) and 'p' (the pattern).",
    "output_format": "A boolean value indicating whether the string matches the pattern.",
    "constraints": [
      "1 <= s.length <= 20",
      "1 <= p.length <= 20",
      "'s' and 'p' consist of only lowercase English letters, '.', and '*'.",
      "The character '*' cannot appear alone or at the beginning of the pattern."
    ],
    "examples": [
      {
        "input": "s = 'aab', p = 'c*a*b'",
        "output": "true",
        "explanation": "'c*' means zero or more 'c's and 'a*b' means 'a' followed by zero or more 'b's. So, it matches the string."
      },
      {
        "input": "s = 'mississippi', p = 'mis*is*p*.'",
        "output": "false",
        "explanation": "The pattern does not match the string due to the ordering and nature of the characters."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to solve the problem.",
      "Use a 2D table to keep track of matches."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Reverse Integer",
    "description": "Given a 32-bit signed integer, reverse its digits. The reversed integer should be dropped of any leading zeros. Note that the reversing process may cause overflow; if the reversed integer overflows, return 0.",
    "topic": "Math",
    "subtopic": "Integer Manipulation",
    "tags": [
      "Math",
      "Integer",
      "String Manipulation"
    ],
    "input_format": "A single 32-bit signed integer.",
    "output_format": "A 32-bit signed integer representing the reversed digits, or 0 if overflow occurs.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 123",
        "output": "321",
        "explanation": "Reversing 123 gives 321."
      },
      {
        "input": "x = -123",
        "output": "-321",
        "explanation": "Reversing -123 gives -321."
      },
      {
        "input": "x = 120",
        "output": "21",
        "explanation": "Reversing 120 gives 21, as leading zeros are removed."
      },
      {
        "input": "x = 1534236469",
        "output": "0",
        "explanation": "Reversing 1534236469 causes overflow, so the output is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to handle negative numbers.",
      "Watch out for overflow conditions while reversing."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Subsets",
    "description": "Given a set of distinct integers, nums, return all possible subsets (the power set). The solution set must not contain duplicate subsets. You may return the solution in any order.",
    "topic": "Backtracking",
    "subtopic": "Subsets Generation",
    "tags": [
      "Backtracking",
      "Recursion",
      "Subset"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "A list of lists containing all possible subsets.",
    "constraints": [
      "0 <= nums.length <= 10",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]",
        "explanation": "The subsets can include the empty set, single elements, pairs, and the whole set."
      },
      {
        "input": "nums = [0]",
        "output": "[[], [0]]",
        "explanation": "The only subsets are the empty set and the set containing 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to explore all combinations.",
      "You can start building subsets by iterating over the elements."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array",
    "description": "Given a sorted array of integers, you need to remove the duplicates in-place such that each element appears only once and returns the new length of the array. Do not allocate extra space for another array. You must do this in-place with O(1) extra memory.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An array of integers nums sorted in non-decreasing order.",
    "output_format": "An integer representing the new length of the array after removing duplicates.",
    "constraints": [
      "0 <= nums.length <= 3 * 10^4",
      "-100 <= nums[i] <= 100",
      "nums is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "2",
        "explanation": "After removing duplicates, the unique elements are [1, 2]. The new length is 2."
      },
      {
        "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
        "output": "5",
        "explanation": "After removing duplicates, the unique elements are [0, 1, 2, 3, 4]. The new length is 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a two-pointer approach to track unique elements.",
      "Consider how you can shift elements to remove duplicates in-place."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Kadane's Algorithm"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the largest sum of the contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The contiguous subarray [4,-1,2,1] has the largest sum = 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The only contiguous subarray is [1], which has the largest sum."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The contiguous subarray [5,4,-1,7,8] has the largest sum = 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to keep track of the maximum sums.",
      "You can iterate through the array while maintaining the current maximum subarray sum."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. For example, if the input is [[1,3],[2,6],[8,10],[15,18]], the merged intervals would be [[1,6],[8,10],[15,18]]. The function should return a new list of merged intervals.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Intervals"
    ],
    "input_format": "A 2D list of integers where each sublist contains two integers representing the start and end of an interval.",
    "output_format": "A 2D list of merged intervals.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^5"
    ],
    "examples": [
      {
        "input": "[[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "The intervals [1,3] and [2,6] overlap, so they are merged into [1,6]."
      },
      {
        "input": "[[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "The intervals [1,4] and [4,5] overlap and can be merged into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals by their starting times.",
      "Use a loop to check for overlaps and merge intervals accordingly."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters. A substring is a contiguous sequence of characters within a string. For example, in the string 'abcabcbb', the longest substring without repeating characters is 'abc', which has a length of 3.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A string s consisting of English letters, digits, symbols, and spaces.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 5 * 10^4",
      "s consists of English letters, digits, symbols and spaces."
    ],
    "examples": [
      {
        "input": "s = 'abcabcbb'",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'abc', which has a length of 3."
      },
      {
        "input": "s = 'bbbbb'",
        "output": "1",
        "explanation": "The longest substring without repeating characters is 'b', which has a length of 1."
      },
      {
        "input": "s = 'pwwkew'",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'wke', which has a length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sliding window approach to solve this problem.",
      "Use a hash map to store the last position of each character."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Find the Index of the First Occurrence in a String",
    "description": "Given two strings `haystack` and `needle`, return the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`.",
    "topic": "String",
    "subtopic": "Searching in Strings",
    "tags": [
      "String",
      "Searching",
      "Index"
    ],
    "input_format": "Two strings, `haystack` and `needle` where 1 <= haystack.length <= 10^4 and 0 <= needle.length <= 100.",
    "output_format": "An integer representing the index of the first occurrence of `needle` in `haystack`, or -1 if not found.",
    "constraints": [
      "1 <= haystack.length <= 10^4",
      "0 <= needle.length <= 100"
    ],
    "examples": [
      {
        "input": "haystack = \"hello\", needle = \"ll\"",
        "output": "2",
        "explanation": "The needle 'll' is found at index 2 of the haystack 'hello'."
      },
      {
        "input": "haystack = \"aaaaa\", needle = \"b\"",
        "output": "-1",
        "explanation": "The needle 'b' is not found in the haystack 'aaaaa'."
      },
      {
        "input": "haystack = \"abc\", needle = \"c\"",
        "output": "2",
        "explanation": "The needle 'c' is found at index 2 of the haystack 'abc'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using the built-in string methods.",
      "Think about the worst-case scenario for performance."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Combination Sum",
    "description": "Given an array of distinct integers 'candidates' and a target integer 'target', return all unique combinations of 'candidates' where the chosen numbers sum to 'target'. You may reuse the same number from 'candidates' an unlimited number of times. The solution set must not contain duplicate combinations.",
    "topic": "Backtracking",
    "subtopic": "Combination Sum",
    "tags": [
      "Backtracking",
      "Recursion",
      "Combination"
    ],
    "input_format": "An array of distinct integers 'candidates' and an integer 'target'.",
    "output_format": "A 2D array containing all unique combinations that sum up to 'target'.",
    "constraints": [
      "1 <= candidates.length <= 30",
      "1 <= candidates[i] <= 200",
      "All elements of candidates are distinct.",
      "1 <= target <= 500"
    ],
    "examples": [
      {
        "input": "candidates = [2, 3, 6, 7], target = 7",
        "output": "[[7], [2, 2, 3]]",
        "explanation": "The unique combinations that sum to 7 are [7] and [2, 2, 3]."
      },
      {
        "input": "candidates = [2, 5, 3, 7], target = 8",
        "output": "[[2, 2, 2, 2], [2, 3, 3], [3, 5]]",
        "explanation": "The unique combinations that sum to 8 are [2, 2, 2, 2], [2, 3, 3], and [3, 5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use backtracking to explore all combinations.",
      "You can reuse numbers, so include them multiple times in a path.",
      "Sort the candidates array to help manage duplicates more effectively."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Swap Nodes in Pairs",
    "description": "Given a linked list, swap every two adjacent nodes and return its head. You must solve this problem using constant space.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "Linked List",
      "Swap",
      "Pair"
    ],
    "input_format": "The head of a singly linked list, where each node contains an integer value.",
    "output_format": "The head of the modified linked list after swapping nodes in pairs.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 100]",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4]",
        "output": "[2, 1, 4, 3]",
        "explanation": "Swapping nodes 1 and 2 gives us: [2, 1, 3, 4]. Swapping nodes 3 and 4 gives us: [2, 1, 4, 3]."
      },
      {
        "input": "head = [1, 2, 3]",
        "output": "[2, 1, 3]",
        "explanation": "Swapping nodes 1 and 2 gives us: [2, 1, 3]. Since 3 has no pair, it remains as is."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "An empty list remains empty."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dummy node to simplify head manipulation.",
      "Keep track of the previous node while swapping."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Find First and Last Position of Element in Sorted Array",
    "description": "Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Binary Search",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Binary Search",
      "Searching"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the starting and ending position of target.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9",
      "nums is a non-decreasing array."
    ],
    "examples": [
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 8",
        "output": "[3, 4]",
        "explanation": "The target 8 first appears at index 3 and last appears at index 4."
      },
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 6",
        "output": "[-1, -1]",
        "explanation": "The target 6 is not found in the array."
      },
      {
        "input": "nums = [], target = 0",
        "output": "[-1, -1]",
        "explanation": "The input array is empty, so the target cannot be found."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use binary search to find the leftmost position.",
      "Use binary search to find the rightmost position."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "topic": "Dynamic Programming",
    "subtopic": "Fibonacci Sequence",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Fibonacci"
    ],
    "input_format": "An integer n, representing the number of steps in the staircase.",
    "output_format": "An integer representing the number of distinct ways to climb to the top.",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: 1 step + 1 step, or 2 steps."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, or 2 steps + 1 step."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Try using recursion to explore all possibilities.",
      "Consider using dynamic programming to store previously calculated results."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Jump Game II",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to find the minimum number of jumps needed to reach the last index. If you cannot reach the last index, return -1.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithms",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of non-negative integers nums where 1 <= nums.length <= 10^4.",
    "output_format": "An integer representing the minimum number of jumps to reach the last index, or -1 if it is not possible.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "2",
        "explanation": "Jump 1: From index 0 to index 1 (nums[0] = 2), Jump 2: From index 1 to index 4 (nums[1] = 3)."
      },
      {
        "input": "nums = [2,3,0,1,4]",
        "output": "2",
        "explanation": "Jump 1: From index 0 to index 1 (nums[0] = 2), Jump 2: From index 1 to index 4 (nums[1] = 3)."
      },
      {
        "input": "nums = [0]",
        "output": "0",
        "explanation": "You are already at the last index."
      },
      {
        "input": "nums = [1,0,0,0]",
        "output": "-1",
        "explanation": "Cannot move beyond the first index."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "You can iterate through the array and keep track of the farthest index you can jump to.",
      "Use a greedy approach to minimize the jumps."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "String to Integer (atoi)",
    "description": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi). The algorithm for converting a string to an integer is as follows: \n1. Ignore all leading whitespace characters. \n2. Check if the next character (after ignoring leading whitespace) is '-' or '+'. Read this character if it exists and is either the sign of the number. \n3. Convert the characters following the sign into digits until the next non-digit character is encountered. \n4. The resulting integer should be clamped to fit in a 32-bit signed integer range [-2^31, 2^31 - 1]. \n5. Return the integer as the final result.",
    "topic": "String",
    "subtopic": "Parsing",
    "tags": [
      "String",
      "Parsing",
      "Integer Conversion"
    ],
    "input_format": "A string s which may contain leading/trailing whitespaces, a sign, and numerical digits.",
    "output_format": "A 32-bit signed integer representing the converted value.",
    "constraints": [
      "0 <= s.length <= 200",
      "s consists of English letters (lower-case and upper-case), digits, '+' or '-', and spaces."
    ],
    "examples": [
      {
        "input": "s = '   -42'",
        "output": "-42",
        "explanation": "Leading spaces are ignored, and the number starts with a negative sign followed by digits."
      },
      {
        "input": "s = '4193 with words'",
        "output": "4193",
        "explanation": "The number 4193 is read before encountering non-digit characters."
      },
      {
        "input": "s = 'words and 987'",
        "output": "0",
        "explanation": "No valid conversion can be made, so the output is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a state machine to parse the string.",
      "Keep track of whether you've encountered a sign.",
      "Check the bounds of the resulting integer as you parse."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Clone Graph",
    "description": "Given a reference to a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors. The deep copy should be a new instance of the graph, preserving the values and the relationships between the nodes.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "Clone"
    ],
    "input_format": "A node of the graph represented as a reference to a Node.",
    "output_format": "A reference to the cloned graph node.",
    "constraints": [
      "The number of nodes in the graph is in the range [0, 100].",
      "Each node's value is unique.",
      "The graph is guaranteed to be connected and undirected."
    ],
    "examples": [
      {
        "input": "graph = [[2,4],[1,3],[2,4],[1,3]]",
        "output": "Cloned graph equivalent to the input graph structure.",
        "explanation": "The original graph has four nodes and the edges represent their connections. The cloned graph will preserve these connections."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to keep track of cloned nodes.",
      "Recursively clone each of the neighbors."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Plus One",
    "description": "You are given a non-empty array of digits representing a non-negative integer. The digits are stored such that the most significant digit is at the head of the array, and each element in the array contains a single digit. You need to add one to the integer represented by the array, and return the resulting array of digits.",
    "topic": "Array",
    "subtopic": "Manipulating Array",
    "tags": [
      "Array",
      "Math",
      "Simulation"
    ],
    "input_format": "An array of integers digits, where 0 <= digits[i] <= 9.",
    "output_format": "An array of integers representing the new integer after adding one.",
    "constraints": [
      "1 <= digits.length <= 100",
      "0 <= digits[i] <= 9",
      "digits does not contain any leading zeros, except for the number 0 itself."
    ],
    "examples": [
      {
        "input": "digits = [1, 2, 3]",
        "output": "[1, 2, 4]",
        "explanation": "The number represented by the array is 123. Adding one gives 124, represented as [1, 2, 4]."
      },
      {
        "input": "digits = [4, 3, 2, 1]",
        "output": "[4, 3, 2, 2]",
        "explanation": "The number represented is 4321. Adding one gives 4322, represented as [4, 3, 2, 2]."
      },
      {
        "input": "digits = [9, 9, 9]",
        "output": "[1, 0, 0, 0]",
        "explanation": "The number is 999. Adding one results in 1000, represented as [1, 0, 0, 0]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider what happens when you add one to a digit that is 9.",
      "Think about how you can handle carry-over when dealing with addition."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Jump Game",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to determine if you can reach the last index starting from the first index. You can assume that you can always reach the last index if you are at an index that has a jump length greater than or equal to the number of steps remaining to the last index.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of non-negative integers nums where nums[i] represents the maximum jump length at the position i.",
    "output_format": "A boolean value, true if you can reach the last index, false otherwise.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "true",
        "explanation": "You can jump to index 1 (value = 3) and then jump to the last index."
      },
      {
        "input": "nums = [3, 2, 1, 0, 4]",
        "output": "false",
        "explanation": "You will always get stuck at index 3 because you cannot jump over to the last index."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to keep track of the farthest point you can reach at each step.",
      "You can stop early if you ever reach or exceed the last index."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "Given an integer array height where height[i] represents the height of a vertical line drawn at index i, return the maximum area of water that can be contained between two of these lines. The formula for calculating the area is given by the shorter line's height multiplied by the distance between the lines.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "input_format": "An array of integers height with length n.",
    "output_format": "An integer representing the maximum area of water that can be contained.",
    "constraints": [
      "2 <= height.length <= 10^5",
      "0 <= height[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The maximum area is between the lines at index 1 and index 8 (heights 8 and 7). The distance between them is 8 - 1 = 7, so the area is min(8, 7) * 7 = 49."
      },
      {
        "input": "height = [1,1]",
        "output": "1",
        "explanation": "The only possible container is the one formed by the two lines at index 0 and index 1. The area is min(1, 1) * (1 - 0) = 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a two-pointer approach.",
      "Calculate the area for the lines pointed by the two pointers and move the pointer pointing to the shorter line."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Longest Valid Parentheses",
    "description": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Stack"
    ],
    "input_format": "A string s consisting of '(' and ')' characters.",
    "output_format": "An integer representing the length of the longest valid parentheses substring.",
    "constraints": [
      "0 <= s.length <= 3 * 10^4",
      "s[i] is either '(' or ')'"
    ],
    "examples": [
      {
        "input": "s = '(()())'",
        "output": "6",
        "explanation": "The entire string is a valid parentheses substring with length 6."
      },
      {
        "input": "s = ')(())('",
        "output": "4",
        "explanation": "The longest valid parentheses substring is '(())' with length 4."
      },
      {
        "input": "s = ')('",
        "output": "0",
        "explanation": "There are no valid parentheses substrings, so the output is 0."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a stack to keep track of indices of the '(' characters.",
      "Consider using a dynamic programming array to keep track of valid lengths."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Palindrome Number",
    "description": "Given an integer x, determine whether it is a palindrome. An integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome, while 123 is not. Do not convert the integer to a string.",
    "topic": "Number",
    "subtopic": "Mathematics",
    "tags": [
      "Palindrome",
      "Number",
      "Mathematics"
    ],
    "input_format": "An integer x.",
    "output_format": "A boolean value indicating whether x is a palindrome.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 121",
        "output": "true",
        "explanation": "121 reads the same backward as forward."
      },
      {
        "input": "x = -121",
        "output": "false",
        "explanation": "-121 reads backward as 121-, which is not the same."
      },
      {
        "input": "x = 10",
        "output": "false",
        "explanation": "10 reads backward as 01, which is not the same."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how you can extract digits from the number."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Insert Interval",
    "description": "Given a set of non-overlapping intervals and a new interval, insert the new interval into the intervals (merge if necessary) and return the result. The intervals should be returned in sorted order.",
    "topic": "Interval",
    "subtopic": "Merging Intervals",
    "tags": [
      "Intervals",
      "Sorting",
      "Merge"
    ],
    "input_format": "A list of non-overlapping intervals and a new interval represented as a list of integers.",
    "output_format": "A list of merged intervals sorted by the start time.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "intervals[i][0] < intervals[i][1]",
      "New interval is also a list of two integers."
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
        "output": "[[1,5],[6,9]]",
        "explanation": "After inserting the new interval [2,5], the intervals [[1,3],[6,9]] merge into [[1,5],[6,9]]."
      },
      {
        "input": "intervals = [[1,5]], newInterval = [2,3]",
        "output": "[[1,5]]",
        "explanation": "The new interval [2,3] does not change the existing interval [1,5]; therefore, the result remains [[1,5]]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to merge overlapping intervals.",
      "Sorting the intervals could help in simplifying the merge process.",
      "Use a loop to iterate through the intervals and find where to insert the new interval."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Search Insert Position",
    "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An integer representing the index of the target or where it would be inserted.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "\u221210^4 <= nums[i] <= 10^4",
      "All integers in nums are unique."
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 5, 6], target = 5",
        "output": "2",
        "explanation": "The target 5 is found at index 2."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 2",
        "output": "1",
        "explanation": "The target 2 would be inserted at index 1."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 7",
        "output": "4",
        "explanation": "The target 7 would be inserted at the end, index 4."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 0",
        "output": "0",
        "explanation": "The target 0 would be inserted at index 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using binary search for efficient searching.",
      "If not found, determine the insertion position based on the remaining elements."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Word Ladder",
    "description": "Given two words, beginWord and endWord, and a dictionary's word list, find the length of the shortest transformation sequence from beginWord to endWord, such that only one letter can be changed at a time and each transformed word must exist in the word list. Note that beginWord is not a part of the word list. If there is no such transformation sequence, return 0.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "String",
      "Word Ladder"
    ],
    "input_format": "A string beginWord, a string endWord, and a list of strings wordList.",
    "output_format": "An integer representing the length of the shortest transformation sequence, or 0 if no such sequence exists.",
    "constraints": [
      "1 <= beginWord.length <= 10",
      "1 <= endWord.length <= 10",
      "1 <= wordList.length <= 5000",
      "beginWord != endWord",
      "All words have the same length.",
      "All words contain only lowercase alphabetic characters."
    ],
    "examples": [
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]",
        "output": "5",
        "explanation": "The shortest transformation sequence is: 'hit' -> 'hot' -> 'dot' -> 'dog' -> 'cog', which is 5 words long."
      },
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\"]",
        "output": "0",
        "explanation": "There is no possible transformation sequence from 'hit' to 'cog' since 'cog' is not in the word list."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a breadth-first search (BFS) approach to explore all possible transformations.",
      "Consider using a queue to keep track of the current word and the transformation steps."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Binary Tree Level Order Traversal",
    "description": "Given a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "topic": "Tree",
    "subtopic": "Traversal",
    "tags": [
      "Tree",
      "BFS",
      "Traversal"
    ],
    "input_format": "The root node of a binary tree.",
    "output_format": "A list of lists, where each inner list contains the values of the nodes at the corresponding level of the tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[9,20],[15,7]]",
        "explanation": "The level order traversal of the tree is: level 0 contains [3], level 1 contains [9, 20], and level 2 contains [15, 7]."
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": "The tree has only one node, thus the level order traversal will only contain that node."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree will result in an empty level order traversal."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to help with the level order traversal.",
      "Make sure to process all nodes at the current level before going to the next level."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Zigzag Conversion",
    "description": "The string is written in a zigzag pattern on an input number of rows like this:  'PAYPALISHIRING' with 3 rows: \n\nP   A   H   N\nA P L S I I G\nY   I   G\n\nYour task is to convert the given string to this zigzag pattern and then read the characters row by row.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Zigzag",
      "Conversion"
    ],
    "input_format": "A string, 's', and an integer, 'numRows', representing the number of rows to be used for zigzag conversion.",
    "output_format": "A single string representing the characters of 's' in zigzag order.",
    "constraints": [
      "1 <= s.length <= 1000",
      "1 <= numRows <= 1000"
    ],
    "examples": [
      {
        "input": "s = 'PAYPALISHIRING', numRows = 3",
        "output": "PAHNAPLSIIGYIR",
        "explanation": "The zigzag pattern construction results in 'P', 'A', 'H', 'N', 'A', 'P', 'L', 'S', 'I', 'I', 'G', 'Y', 'I', 'R'. When read row-by-row, we get 'PAHNAPLSIIGYIR'."
      },
      {
        "input": "s = 'A', numRows = 1",
        "output": "A",
        "explanation": "With only one row, the output is the same as input."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how the characters move in a zigzag pattern.",
      "Use a counter to determine which direction to move as you iterate through the string."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Set Matrix Zeroes",
    "description": "Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do this in place. You must do it without using extra space for another matrix.",
    "topic": "Matrix",
    "subtopic": "In-Place Operations",
    "tags": [
      "Matrix",
      "In-Place",
      "Array"
    ],
    "input_format": "A 2D list of integers representing the matrix.",
    "output_format": "The modified matrix itself with rows and columns set to 0.",
    "constraints": [
      "1 <= m, n <= 200",
      "-10^9 <= matrix[i][j] <= 10^9"
    ],
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": "The second row and second column contain a 0, so the result has those entire row and column set to 0."
      },
      {
        "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
        "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
        "explanation": "The first row and the first column contain a 0, so the entire first row and column are set to 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use the first row and first column to mark which rows and columns need to be zeroed.",
      "Be careful with the first row and first column; handle them separately if they need to be zeroed."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock II",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. However, you can make as many transactions as you like (i.e., you can buy and sell multiple times). Note that you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Return the maximum profit you can achieve.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices where prices[i] represents the price of a stock on day i.",
    "output_format": "An integer representing the maximum profit you can achieve.",
    "constraints": [
      "1 <= prices.length <= 3 * 10^4",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "7",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5. Then buy on day 4 (price = 3) and sell on day 5 (price = 4), profit = 4 - 3 = 1. Total profit = 5 + 1 = 6."
      },
      {
        "input": "prices = [1, 2, 3, 4, 5]",
        "output": "4",
        "explanation": "Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5 - 1 = 4."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "There are no transactions that can yield a profit."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider every peak and valley.",
      "Buy before a price increases and sell immediately after."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Candy",
    "description": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings. You are giving candies to these children subjected to the following requirements:\n\n1. Each child must have at least one candy.\n2. Children with a higher rating get more candies than their neighbors.\n\nReturn the minimum number of candies you must give to the children.",
    "topic": "Greedy",
    "subtopic": "Distribution",
    "tags": [
      "Greedy",
      "Array",
      "Dynamic Programming"
    ],
    "input_format": "An integer array ratings where ratings[i] represents the rating of the ith child.",
    "output_format": "An integer representing the minimum number of candies required.",
    "constraints": [
      "n == ratings.length",
      "1 <= n <= 2 * 10^4",
      "0 <= ratings[i] <= 2 * 10^4"
    ],
    "examples": [
      {
        "input": "ratings = [1, 0, 2]",
        "output": "5",
        "explanation": "You can give 2 candies to the first child, 1 candy to the second child, and 2 candies to the third child. Thus, 2 + 1 + 2 = 5."
      },
      {
        "input": "ratings = [1, 2, 2]",
        "output": "4",
        "explanation": "Two candies for the second child, and one for each of the first and third children. Thus, 1 + 2 + 1 = 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider scanning from left to right first.",
      "Then scan from right to left to adjust the candy distribution."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Length of Last Word",
    "description": "Given a string s consists of some words separated by spaces, return the length of the last word in the string. If there are no words in the string, return 0.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Length"
    ],
    "input_format": "A string s containing words separated by spaces.",
    "output_format": "An integer representing the length of the last word.",
    "constraints": [
      "0 <= s.length <= 10^4",
      "s consists of only printable ASCII characters."
    ],
    "examples": [
      {
        "input": "s = 'Hello World'",
        "output": "5",
        "explanation": "The last word is 'World', which has a length of 5."
      },
      {
        "input": "s = ' '",
        "output": "0",
        "explanation": "There are no words in the string."
      },
      {
        "input": "s = '   fly me   to   the moon  '",
        "output": "4",
        "explanation": "The last word is 'moon', which has a length of 4."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Trim the string to remove any leading or trailing spaces.",
      "Use the last occurrence of a space to find the start of the last word."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Validate Binary Search Tree",
    "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: 1. The left subtree of a node contains only nodes with keys less than the node's key. 2. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "The input is the root of a binary tree.",
    "output_format": "Return true if the binary tree is a valid binary search tree, otherwise return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 104].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root = [2, 1, 3]",
        "output": "true",
        "explanation": "The tree is: 2 is the root, 1 is the left child, and 3 is the right child. It satisfies the BST properties."
      },
      {
        "input": "root = [5, 1, 4, null, null, 3, 6]",
        "output": "false",
        "explanation": "The tree is: 5 is the root, 1 is the left child, and 4 is the right child. 3 is in the right subtree of 5, which is not valid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion to traverse the tree.",
      "Keep track of the min and max value constraints as you traverse."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array nums, find the smallest missing positive integer. You must implement a solution that runs in O(n) time and uses constant extra space.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Sorting"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the first missing positive integer.",
    "constraints": [
      "0 <= nums.length <= 300",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "The positive integers are 1 and 2. The first missing positive integer is 3."
      },
      {
        "input": "nums = [3, 4, -1, 1]",
        "output": "2",
        "explanation": "The positive integers are 1, 3, and 4. The first missing positive integer is 2."
      },
      {
        "input": "nums = [7, 8, 9, 11, 12]",
        "output": "1",
        "explanation": "There are no positive integers from 1 to 6. The first missing positive integer is 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the numbers in the range from 1 to n.",
      "Use the index of the array to store whether a number is present."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Minimum Path Sum",
    "description": "Given a 2D grid filled with non-negative integers, find a path from the top left to the bottom right, which minimizes the sum of the numbers along the path. You can only move either down or right at any point in time.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Pathing",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Path finding"
    ],
    "input_format": "A 2D grid represented as a list of lists where each element is a non-negative integer.",
    "output_format": "An integer representing the minimum sum of the path from the top left to the bottom right.",
    "constraints": [
      "1 <= grid.length <= 100",
      "1 <= grid[0].length <= 100",
      "0 <= grid[i][j] <= 100"
    ],
    "examples": [
      {
        "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7",
        "explanation": "The path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum, resulting in 7."
      },
      {
        "input": "grid = [[1,2,3],[4,5,6]]",
        "output": "12",
        "explanation": "The path 1 \u2192 2 \u2192 3 \u2192 6 results in the minimum path sum of 12."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about using dynamic programming to keep track of the minimum path sums.",
      "Consider how the value at each cell relates to its top and left neighbors."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Pascal's Triangle",
    "description": "Given an integer numRows, return the first numRows of Pascal's Triangle. In Pascal's Triangle, each number is the sum of the two numbers directly above it. The triangle starts with a 1 at the top, and each subsequent row contains one more number than the previous row.",
    "topic": "Dynamic Programming",
    "subtopic": "Combinatorics",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Triangle"
    ],
    "input_format": "An integer numRows representing the number of rows of Pascal's Triangle to generate.",
    "output_format": "A list of lists of integers representing the first numRows of Pascal's Triangle.",
    "constraints": [
      "1 <= numRows <= 30"
    ],
    "examples": [
      {
        "input": "numRows = 5",
        "output": "[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
        "explanation": "The first 5 rows of Pascal's Triangle are as follows: 1, 1 1, 1 2 1, 1 3 3 1, 1 4 6 4 1."
      },
      {
        "input": "numRows = 1",
        "output": "[[1]]",
        "explanation": "The first row of Pascal's Triangle consists of only one element: 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how the values in each row are computed from the values in the previous row."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Palindrome Partitioning",
    "description": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. A palindrome is a string that reads the same backward as forward.",
    "topic": "Backtracking",
    "subtopic": "String Manipulation",
    "tags": [
      "Backtracking",
      "String",
      "Palindrome"
    ],
    "input_format": "A single string s of length n (1 <= n <= 16).",
    "output_format": "A list of lists containing all possible palindrome partitioning of s.",
    "constraints": [
      "1 <= s.length <= 16",
      "s consists of lowercase English letters only."
    ],
    "examples": [
      {
        "input": "s = \"aab\"",
        "output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
        "explanation": "The valid palindrome partitions are ['a', 'a', 'b'] and ['aa', 'b']."
      },
      {
        "input": "s = \"a\"",
        "output": "[[\"a\"]]",
        "explanation": "The only valid palindrome partition is ['a']."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider a recursive approach to try every possible partition.",
      "Use a helper function to check whether a substring is a palindrome."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Permutations",
    "description": "Given a collection of distinct integers, return all possible permutations. You can return the answer in any order. Each permutation must contain each number exactly once.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Recursion",
      "Permutation"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "A list of all possible permutations of the input array.",
    "constraints": [
      "1 <= nums.length <= 10",
      "-10 <= nums[i] <= 10",
      "All elements of nums are distinct."
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]",
        "explanation": "There are 6 possible permutations of the array [1, 2, 3]."
      },
      {
        "input": "nums = [0, 1]",
        "output": "[[0, 1], [1, 0]]",
        "explanation": "There are 2 possible permutations of the array [0, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how you can build the permutations step by step.",
      "Consider using a backtracking approach."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Divide Two Integers",
    "description": "Given two integers 'dividend' and 'divisor', return the quotient after dividing 'dividend' by 'divisor'. The integer division should truncate towards zero, meaning that any fractional part is discarded. You are not allowed to use multiplication, division, or mod operator. Assume the dividend and divisor are both a 32-bit signed integer. For division by zero, return the maximum value of a 32-bit signed integer.",
    "topic": "Math",
    "subtopic": "Integer Division",
    "tags": [
      "Math",
      "Division",
      "Integer"
    ],
    "input_format": "Two integers, dividend and divisor.",
    "output_format": "An integer representing the quotient after dividing dividend by divisor.",
    "constraints": [
      "-2^31 <= dividend, divisor <= 2^31 - 1",
      "divisor != 0"
    ],
    "examples": [
      {
        "input": "dividend = 10, divisor = 3",
        "output": "3",
        "explanation": "10 divided by 3 is 3 with a remainder of 1, thus truncating towards zero gives 3."
      },
      {
        "input": "dividend = 7, divisor = -3",
        "output": "-2",
        "explanation": "7 divided by -3 is -2 with a remainder of 1, thus truncating towards zero gives -2."
      },
      {
        "input": "dividend = 1, divisor = 1",
        "output": "1",
        "explanation": "1 divided by 1 is 1."
      },
      {
        "input": "dividend = -1, divisor = -1",
        "output": "1",
        "explanation": "-1 divided by -1 is 1."
      },
      {
        "input": "dividend = -2147483648, divisor = -1",
        "output": "2147483647",
        "explanation": "The result exceeds maximum 32-bit integer value, so we return 2147483647."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the relationship between subtraction and division.",
      "Think about how to repeatedly subtract the divisor from the dividend."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Minimum Depth of Binary Tree",
    "description": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. A leaf is a node with no children.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth"
    ],
    "input_format": "The root node of a binary tree, where each node contains an integer value and pointers to its left and right children.",
    "output_format": "An integer representing the minimum depth of the binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^5].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "2",
        "explanation": "The minimum depth is 2, which is the path from the root (3) to the leaf node (9)."
      },
      {
        "input": "root = [2,null,3,null,4,null,5,null,6]",
        "output": "5",
        "explanation": "The minimum depth is 5, which is the path from the root (2) to the leaf node (6)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use breadth-first search to find the first leaf node.",
      "Check for the base case when the tree is empty.",
      "A leaf node does not have any children."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "3Sum Closest",
    "description": "Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An integer representing the sum of the three integers that is closest to the target.",
    "constraints": [
      "3 <= nums.length <= 10^3",
      "-10^3 <= nums[i] <= 10^3",
      "-10^4 <= target <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-1, 2, 1, -4], target = 1",
        "output": "2",
        "explanation": "The sum of the three integers closest to the target 1 is -1 + 2 + 1 = 2."
      },
      {
        "input": "nums = [0, 0, 0], target = 1",
        "output": "0",
        "explanation": "The sum of the three integers is 0, which is the closest to the target 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array to apply two pointers technique.",
      "Adjust the pointers based on the current sum compared to the target."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Binary Tree Maximum Path Sum",
    "description": "Given a non-empty binary tree, find the maximum path sum. The path may start and end at any node in the tree and must contain at least one node. The path sum is the sum of the values along the path. The binary tree is represented by a root node, and each node has a value and potentially two children.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "DFS",
      "Recursion"
    ],
    "input_format": "A binary tree represented by the root node.",
    "output_format": "An integer representing the maximum path sum.",
    "constraints": [
      "-10^4 <= node.val <= 10^4",
      "The number of nodes in the tree is in the range [1, 3 * 10^4]."
    ],
    "examples": [
      {
        "input": "[1, 2, 3]",
        "output": "6",
        "explanation": "The path 2 -> 1 -> 3 has the maximum sum: 2 + 1 + 3 = 6."
      },
      {
        "input": "[-10, 9, 20, null, null, 15, 7]",
        "output": "42",
        "explanation": "The path 15 -> 20 -> 7 has the maximum sum: 15 + 20 + 7 = 42."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using recursion to explore all paths.",
      "Keep track of the maximum path sum found during the traversal."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array II",
    "description": "You are given an integer array nums sorted in non-decreasing order, which has been rotated at an unknown pivot index. You are also given an integer target. Write a function to determine if target is in nums. The array may contain duplicates, and you must solve it in O(log n) time complexity if possible. If there are duplicates, your solution must handle them efficiently.",
    "topic": "Binary Search",
    "subtopic": "Search",
    "tags": [
      "Binary Search",
      "Array",
      "Duplication"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "A boolean value, true if target is in nums, false otherwise.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "nums may contain duplicates."
    ],
    "examples": [
      {
        "input": "nums = [2,5,6,0,0,1,2], target = 0",
        "output": "true",
        "explanation": "The target 0 is present in the array."
      },
      {
        "input": "nums = [2,5,6,0,0,1,2], target = 3",
        "output": "false",
        "explanation": "The target 3 is not present in the array."
      },
      {
        "input": "nums = [1,0,1,1,1], target = 0",
        "output": "true",
        "explanation": "The target 0 is present in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider avoiding duplicates effectively.",
      "Think about how the array is rotated."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Unique Paths",
    "description": "A robot is located at the top-left corner of a m x n grid and can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. How many unique paths are there for the robot to reach the bottom-right corner?",
    "topic": "Dynamic Programming",
    "subtopic": "Combinatorics",
    "tags": [
      "Dynamic Programming",
      "Combinatorics",
      "Grid"
    ],
    "input_format": "Two integers m and n, where 1 <= m, n <= 100.",
    "output_format": "An integer representing the number of unique paths from the top-left corner to the bottom-right corner.",
    "constraints": [
      "1 <= m, n <= 100"
    ],
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": "There are 28 unique paths to go from the top-left corner to the bottom-right corner in a 3x7 grid."
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "From the top-left corner to the bottom-right corner, the robot can only move down or right, leading to 3 unique paths."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how many ways you can reach the last row or the last column."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Add Binary",
    "description": "Given two binary strings a and b, return their sum as a binary string. The input strings are both non-empty and consist only of characters 1 or 0.",
    "topic": "String",
    "subtopic": "Binary Arithmetic",
    "tags": [
      "String",
      "Binary",
      "Arithmetic"
    ],
    "input_format": "Two binary strings a and b.",
    "output_format": "A binary string representing the sum of a and b.",
    "constraints": [
      "1 <= a.length, b.length <= 10^4",
      "a and b are both non-empty and consist only of '0' or '1'."
    ],
    "examples": [
      {
        "input": "a = '1101', b = '1011'",
        "output": "'11000'",
        "explanation": "The binary sum of 1101 and 1011 is 11000."
      },
      {
        "input": "a = '1010', b = '1010'",
        "output": "'10100'",
        "explanation": "The binary sum of 1010 and 1010 is 10100."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider iterating over the strings from the end to the beginning.",
      "Keep track of the carry when summing the bits."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Combination Sum II",
    "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note that the solution set must not contain duplicate combinations.",
    "topic": "Backtracking",
    "subtopic": "Combination Sum",
    "tags": [
      "Backtracking",
      "Combination",
      "Sum"
    ],
    "input_format": "An array of integers candidates and an integer target.",
    "output_format": "A list of lists of integers, representing all unique combinations that sum to target.",
    "constraints": [
      "1 <= candidates.length <= 100",
      "1 <= candidates[i] <= 50",
      "The input array is not sorted.",
      "Target is a positive integer."
    ],
    "examples": [
      {
        "input": "candidates = [10, 1, 2, 7, 6, 1, 5], target = 8",
        "output": "[[1, 1, 6], [1, 2, 5], [2, 6], [7]]",
        "explanation": "The combinations that sum up to 8 are [1, 1, 6], [1, 2, 5], [2, 6], and [7]."
      },
      {
        "input": "candidates = [2, 5, 2, 1, 2], target = 5",
        "output": "[[1, 2, 2], [5]]",
        "explanation": "The combinations that sum up to 5 are [1, 2, 2] and [5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to explore combinations.",
      "Use a set to avoid duplicate combinations.",
      "Sort the input array to simplify the combination logic."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Flatten Binary Tree to Linked List",
    "description": "Given a binary tree, flatten it to a linked list in-place. The linked list should be in the same order as a preorder traversal of the binary tree. Each node in the tree should have its right child pointing to the next node in the linked list, and the left child should be null.",
    "topic": "Tree",
    "subtopic": "Tree Traversal",
    "tags": [
      "Tree",
      "Linked List",
      "Preorder",
      "In-Place"
    ],
    "input_format": "The root of a binary tree.",
    "output_format": "The root of the flattened linked list, which is the same as the input tree root.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "The node values are in the range [-1000, 1000]."
    ],
    "examples": [
      {
        "input": "root = [1,2,5,3,4,null,6]",
        "output": "[1,null,2,null,3,null,4,null,5,null,6]",
        "explanation": "The tree is flattened to the linked list: 1 -> 2 -> 3 -> 4 -> 5 -> 6."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree results in an empty linked list."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to help with the preorder traversal.",
      "Keep track of the previous node while flattening."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix II",
    "description": "Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. The spiral order starts from the outermost layer and moves inward, filling each layer sequentially.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Spiral Order",
      "Traversal"
    ],
    "input_format": "An integer n (1 <= n <= 20), representing the size of the n x n matrix.",
    "output_format": "A 2D list (matrix) of integers filled in spiral order.",
    "constraints": [
      "1 <= n <= 20"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[[1, 2, 3], [8, 9, 4], [7, 6, 5]]",
        "explanation": "The numbers from 1 to 9 are filled in spiral order starting from the top left of the matrix."
      },
      {
        "input": "n = 1",
        "output": "[[1]]",
        "explanation": "A single element matrix with the value 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how you can control the boundaries of the spiral.",
      "You can use a direction array to help with the movement."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Unique Paths II",
    "description": "You are given a m x n grid represented as a 2D array. Each cell can either be free (0) or an obstacle (1). Your task is to find the number of unique paths from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1), while only being able to move either down or right at any point in time. Note that you cannot walk through cells that have an obstacle.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Paths",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Pathfinding"
    ],
    "input_format": "A 2D grid of integers, where 0 represents a free cell and 1 represents an obstacle.",
    "output_format": "An integer representing the number of unique paths from the top-left to the bottom-right corner.",
    "constraints": [
      "1 <= m, n <= 100",
      "grid[i][j] is 0 or 1."
    ],
    "examples": [
      {
        "input": "grid = [[0,0,0],[0,1,0],[0,0,0]]",
        "output": "2",
        "explanation": "There are two unique paths to reach the bottom-right corner: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) and (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2)."
      },
      {
        "input": "grid = [[0,1],[0,0]]",
        "output": "1",
        "explanation": "There is only one unique path: (0,0) -> (1,0) -> (1,1)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to build up the number of ways to reach each cell.",
      "You can initialize the starting cell and then iterate over the grid."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Distinct Subsequences",
    "description": "Given two strings s and t, return the number of distinct subsequences of s which equals t. A subsequence of a string is derived by deleting some or no characters from the string, without changing the order of the remaining characters.",
    "topic": "Dynamic Programming",
    "subtopic": "Subsequence",
    "tags": [
      "Dynamic Programming",
      "String",
      "Subsequence"
    ],
    "input_format": "Two strings s and t where 0 <= s.length, t.length <= 1000.",
    "output_format": "An integer representing the number of distinct subsequences of s that equal t.",
    "constraints": [
      "0 <= s.length <= 1000",
      "0 <= t.length <= 1000",
      "The input strings consist of English letters."
    ],
    "examples": [
      {
        "input": "s = \"rabbbit\", t = \"rabbit\"",
        "output": "3",
        "explanation": "There are three ways to form 'rabbit' from 'rabbbit': remove the first 'b', the second 'b', or both."
      },
      {
        "input": "s = \"abc\", t = \"abc\"",
        "output": "1",
        "explanation": "There is only one way to form 'abc' from 'abc' by keeping all characters."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to track subsequence counts.",
      "Try to build a DP table where dp[i][j] represents the number of ways to form t[0...j] from s[0...i]."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Sort Colors",
    "description": "Given an array consisting of red, white, and blue colors represented by integers 0, 1, and 2, respectively, sort the array in-place so that the colors are arranged in the order of red (0), white (1), and blue (2). You must do this without using the library's sort function and in a single pass through the array.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Two Pointers"
    ],
    "input_format": "An integer array nums, where each element is either 0, 1, or 2.",
    "output_format": "The sorted array in-place.",
    "constraints": [
      "1 <= nums.length <= 300",
      "nums[i] is either 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "nums = [2, 0, 2, 1, 1, 0]",
        "output": "[0, 0, 1, 1, 2, 2]",
        "explanation": "In-place sorting results in the array being modified to [0, 0, 1, 1, 2, 2]."
      },
      {
        "input": "nums = [2, 0, 1]",
        "output": "[0, 1, 2]",
        "explanation": "The sorted array in-place becomes [0, 1, 2]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a two-pointer approach.",
      "Keep track of the next position for each color."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Remove Nth Node From End of List",
    "description": "Given a linked list, remove the nth node from the end of the list and return its head. The list can be very long, and you need to solve it in a single pass.",
    "topic": "Linked List",
    "subtopic": "Two Pointers",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Single Pass"
    ],
    "input_format": "The input consists of a head node of a singly linked list, followed by an integer n.",
    "output_format": "Return the head of the linked list after removing the nth node from the end.",
    "constraints": [
      "The number of nodes in the list is in the range [1, 30]",
      "1 <= n <= the number of nodes in the list"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], n = 2",
        "output": "[1, 2, 3, 5]",
        "explanation": "Removing the 2nd node from the end, which is 4, results in [1, 2, 3, 5]."
      },
      {
        "input": "head = [1], n = 1",
        "output": "[]",
        "explanation": "The only node is removed, resulting in an empty list."
      },
      {
        "input": "head = [1, 2], n = 1",
        "output": "[1]",
        "explanation": "Removing the last node (2) results in a list with just [1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use two pointers to find the nth node from the end.",
      "If the first pointer reaches the end, the second pointer will be at the node to remove."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Pow(x, n)",
    "description": "Implement a function that calculates x raised to the power n (i.e., x^n). The function should support both positive and negative integer values for n. You must implement your solution using a recursive approach. Do not use built-in exponentiation operators or library functions.",
    "topic": "Mathematics",
    "subtopic": "Recursion",
    "tags": [
      "Recursion",
      "Mathematics",
      "Power"
    ],
    "input_format": "Two values, x (a floating-point number) and n (an integer).",
    "output_format": "A floating-point number representing the result of x raised to the power n.",
    "constraints": [
      "-10^4 <= x <= 10^4",
      "-10^4 <= n <= 10^4"
    ],
    "examples": [
      {
        "input": "x = 2.0, n = 10",
        "output": "1024.0",
        "explanation": "2 raised to the power 10 is 1024."
      },
      {
        "input": "x = 2.1, n = 3",
        "output": "9.261",
        "explanation": "2.1 raised to the power 3 is approximately 9.261."
      },
      {
        "input": "x = 2.0, n = -2",
        "output": "0.25",
        "explanation": "2 raised to the power -2 is 1/(2^2) = 1/4 = 0.25."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to handle negative exponents.",
      "Use recursion to divide the problem into smaller parts."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "4Sum",
    "description": "Given an array nums of n integers, return all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that: \n\n- 0 <= a, b, c, d < n \n- a, b, c, and d are distinct \n- nums[a] + nums[b] + nums[c] + nums[d] == target \n\nYou may return the answer in any order.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Hash Table"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "A list of lists containing unique quadruplets that add up to target.",
    "constraints": [
      "0 <= n <= 200",
      "-10^9 <= nums[i] <= 10^9",
      "The solution set must not contain duplicate quadruplets."
    ],
    "examples": [
      {
        "input": "nums = [1, 0, -1, 0, -2, 2], target = 0",
        "output": "[[-2, -1, 0, 1], [-2, 0, 0, 2], [-1, 0, 0, 1]]",
        "explanation": "The quadruplets that sum to 0 are: [-2, -1, 0, 1], [-2, 0, 0, 2], and [-1, 0, 0, 1]."
      },
      {
        "input": "nums = [2, 2, 2, 2, 2], target = 8",
        "output": "[[2, 2, 2, 2]]",
        "explanation": "The only quadruplet that sums to 8 is [2, 2, 2, 2]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash table to store pairs of numbers.",
      "Sort the array to make it easier to skip duplicates."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Interleaving String",
    "description": "Given three strings s1, s2, and s3, determine if s3 is formed by the interleaving of s1 and s2. An interleaving of two strings s and t is defined to be a configuration where they are merged into a new string in a way that maintains the left to right ordering of the characters from both strings. For example, if s1 = \"abc\" and s2 = \"def\", then \"adbcef\" is one possible interleaving, while \"abdecf\" is another.",
    "topic": "Dynamic Programming",
    "subtopic": "String Interleaving",
    "tags": [
      "String",
      "Dynamic Programming",
      "Interleaving"
    ],
    "input_format": "Three strings s1, s2, and s3 where 0 <= s1.length, s2.length, s3.length <= 100.",
    "output_format": "A boolean value indicating whether s3 can be formed by interleaving s1 and s2.",
    "constraints": [
      "The lengths of s1 and s2 must sum up to the length of s3.",
      "0 <= s1.length, s2.length <= 100"
    ],
    "examples": [
      {
        "input": "s1 = \"aab\", s2 = \"xyz\", s3 = \"aaxybz\"",
        "output": "true",
        "explanation": "You can interleave s1 and s2 to form s3 like: a (from s1), a (from s1), x (from s2), y (from s2), b (from s1), z (from s2)."
      },
      {
        "input": "s1 = \"abc\", s2 = \"def\", s3 = \"abcdef\"",
        "output": "true",
        "explanation": "You can simply concatenate s1 and s2 to get s3."
      },
      {
        "input": "s1 = \"abc\", s2 = \"def\", s3 = \"abdecf\"",
        "output": "false",
        "explanation": "There is no possible interleaving of s1 and s2 that can produce s3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use dynamic programming to solve the problem.",
      "Create a 2D DP table to track possible interleaving states.",
      "Consider the character positions from both strings to fill the DP table."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Binary Tree Inorder Traversal",
    "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values. In an inorder traversal, the nodes are recursively visited in this order; left, root, right.",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "DFS",
      "Traversal"
    ],
    "input_format": "The input consists of the root node of a binary tree.",
    "output_format": "An array of integers representing the inorder traversal of the binary tree nodes.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[1,3,2]",
        "explanation": "The inorder traversal of the tree is 1, 3, 2."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "Since the tree is empty, the inorder traversal is an empty array."
      },
      {
        "input": "root = [1]",
        "output": "[1]",
        "explanation": "The tree has only one node, so the inorder traversal is just that node value."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a recursive approach to traverse the left subtree, then visit the root, and finally traverse the right subtree."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array II",
    "description": "Given a sorted array of integers, you need to remove the duplicates in-place such that each element appears at most twice and return the new length of the array. Note that it doesn't matter what values are set beyond the returned length. You must do this using O(1) additional space.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-Place",
      "Sorting"
    ],
    "input_format": "A sorted array of integers nums.",
    "output_format": "An integer representing the new length of the array after removing duplicates.",
    "constraints": [
      "0 <= nums.length <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3]",
        "output": "5",
        "explanation": "The modified array is [1,1,2,2,3] with length 5."
      },
      {
        "input": "nums = [0,0,1,1,1,1,2,3,3]",
        "output": "7",
        "explanation": "The modified array is [0,0,1,1,2,3,3] with length 7."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use two pointers to keep track of the current position.",
      "Keep a count of duplicates and replace when necessary."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Multiply Strings",
    "description": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also as a string. You must not use any built-in BigInteger library or directly convert the input strings to integers.",
    "topic": "String",
    "subtopic": "Mathematical Operations",
    "tags": [
      "String",
      "Math",
      "Multiplication"
    ],
    "input_format": "Two strings num1 and num2 representing the non-negative integers.",
    "output_format": "A string representing the product of num1 and num2.",
    "constraints": [
      "1 <= num1.length, num2.length <= 200",
      "num1 and num2 only contain digits.",
      "Both num1 and num2 do not have leading zeros."
    ],
    "examples": [
      {
        "input": "num1 = \"123\", num2 = \"456\"",
        "output": "\"56088\"",
        "explanation": "The product of 123 and 456 is 56088."
      },
      {
        "input": "num1 = \"0\", num2 = \"12345\"",
        "output": "\"0\"",
        "explanation": "Any number multiplied by 0 is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you would multiply two numbers on paper.",
      "Use an array to store the intermediate results."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Gas Station",
    "description": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You also have a car with a fuel tank that starts empty. The car consumes 1 unit of gas per unit of distance traveled. Considering you start at one of the gas stations, find the gas station index from which you can travel around the circuit once without running out of gas. If there is no such starting gas station, return -1.",
    "topic": "Graph",
    "subtopic": "Circular Route",
    "tags": [
      "Greedy",
      "Graph",
      "Simulation"
    ],
    "input_format": "An array of integers gas representing the gas available at each station and an array of integers cost representing the cost of gas to travel to the next station.",
    "output_format": "An integer representing the starting gas station index, or -1 if it's impossible to complete the circuit.",
    "constraints": [
      "1 <= gas.length == cost.length <= 10^4",
      "0 <= gas[i], cost[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "gas = [1, 2, 3, 4, 5], cost = [3, 4, 5, 1, 2]",
        "output": "3",
        "explanation": "Starting at index 3 (gas[3]=4), you can go to the next station while consuming 1 unit of gas and have enough gas to complete the circuit."
      },
      {
        "input": "gas = [2, 3, 4], cost = [3, 4, 3]",
        "output": "-1",
        "explanation": "At each station, you run out of gas before reaching the next station."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Track the total gas and total cost to determine feasibility.",
      "Consider using a greedy approach to find the starting point."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List II",
    "description": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list. It is guaranteed that the input is a valid linked list. Positions are 1-based, meaning the first element in the list is at position 1.",
    "topic": "Linked List",
    "subtopic": "Reversal",
    "tags": [
      "Linked List",
      "Reversal",
      "Two Pointers"
    ],
    "input_format": "The head of a singly linked list, along with two integers left and right.",
    "output_format": "The head of the modified linked list after the specified reversal.",
    "constraints": [
      "1 <= length of the list <= 5000",
      "1 <= left <= right <= length of the list"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], left = 2, right = 4",
        "output": "[1, 4, 3, 2, 5]",
        "explanation": "The nodes from position 2 to 4 are reversed, resulting in the list [1, 4, 3, 2, 5]."
      },
      {
        "input": "head = [1, 2, 3, 4, 5], left = 1, right = 5",
        "output": "[5, 4, 3, 2, 1]",
        "explanation": "The entire list is reversed, resulting in [5, 4, 3, 2, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dummy node to simplify edge cases.",
      "Keep track of the nodes before and after the reversal."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Wildcard Matching",
    "description": "Implement a function that supports wildcard matching with the following rules: The '*' character can represent any sequence of characters (including an empty sequence), while the '?' character can represent any single character. The function should determine if the input string matches the given pattern with wildcards.",
    "topic": "String",
    "subtopic": "Pattern Matching",
    "tags": [
      "String",
      "Dynamic Programming",
      "Pattern Matching"
    ],
    "input_format": "A string s (input string) and a string p (pattern string) where 1 <= s.length, p.length <= 2000.",
    "output_format": "A boolean value indicating whether the input string matches the pattern.",
    "constraints": [
      "The input string and pattern string consists only of lowercase English letters, '?' and '*'",
      "The lengths of both strings will be in the range of 1 to 2000."
    ],
    "examples": [
      {
        "input": "s = \"aa\", p = \"a\"",
        "output": "false",
        "explanation": "The pattern 'a' does not match the input 'aa' since it cannot match additional characters."
      },
      {
        "input": "s = \"aa\", p = \"*\"",
        "output": "true",
        "explanation": "The pattern '*' can match any sequence of characters, hence it matches 'aa'."
      },
      {
        "input": "s = \"cb\", p = \"?a\"",
        "output": "false",
        "explanation": "The second character of the pattern doesn't match anything in the input string."
      },
      {
        "input": "s = \"acdcb\", p = \"a*c?b\"",
        "output": "false",
        "explanation": "The input string 'acdcb' does not match the pattern as it cannot match 'c' with '?'."
      },
      {
        "input": "s = \"mississippi\", p = \"m??*ss*?i*pi\"",
        "output": "true",
        "explanation": "The pattern matches the input by accounting for the wildcards correctly."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider dynamic programming to solve the problem.",
      "Use a table to store matches for substrings based on the wildcard rules."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock III",
    "description": "You are given an array where the ith element represents the price of a stock on the ith day. You want to maximize your profit by making at most two transactions. You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Return the maximum profit you can achieve after making at most two transactions.",
    "topic": "Dynamic Programming",
    "subtopic": "Stock Buy and Sell",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers prices where 0 <= prices.length <= 10^5.",
    "output_format": "An integer representing the maximum profit.",
    "constraints": [
      "0 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "prices = [3,2,6,5,0,3]",
        "output": "7",
        "explanation": "Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6 - 2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3 - 0 = 3. Total profit = 4 + 3 = 7."
      },
      {
        "input": "prices = [1,2,3,4,5]",
        "output": "4",
        "explanation": "Buy on day 1 (price = 1) and sell on day 5 (price = 5). Total profit = 5 - 1 = 4."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "In this case there is no transaction that can contribute to profit, so the maximum profit is 0."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Try to break the problem into several subproblems.",
      "Consider dynamics of two transactions separately.",
      "AI-Driven solutions may use dynamic programming to solve this."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Convert Sorted List to Binary Search Tree",
    "description": "Given a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree (BST). A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "LinkedList",
      "Tree",
      "BinarySearchTree"
    ],
    "input_format": "A singly linked list where the nodes are sorted in ascending order.",
    "output_format": "The root node of a height-balanced binary search tree.",
    "constraints": [
      "The linked list has at most 10^4 nodes.",
      "-10^5 <= Node.val <= 10^5"
    ],
    "examples": [
      {
        "input": "head = [-10,-3,0,5,9]",
        "output": "[0,-3,9,-10,null,5]",
        "explanation": "The height-balanced BST will have root 0, with left child as -3 (which has -10) and right child as 9 (which has 5)."
      },
      {
        "input": "head = []",
        "output": "null",
        "explanation": "An empty list results in a null BST."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a divide-and-conquer approach by finding the middle element of the linked list."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Unique Binary Search Trees II",
    "description": "Given an integer n, return all the structurally unique BST's (binary search trees) that store values 1 to n. Each tree node may contain a unique value from the range, and the order must adhere to the properties of a binary search tree.",
    "topic": "Tree",
    "subtopic": "Binary Search Trees",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Dynamic Programming"
    ],
    "input_format": "An integer n (1 <= n <= 8).",
    "output_format": "A list of all unique BSTs that can be constructed with values 1 to n.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
        "explanation": "These five structures are the unique BSTs possible with nodes 1, 2, and 3."
      },
      {
        "input": "n = 1",
        "output": "[[1]]",
        "explanation": "Only one BST can be constructed with a single node."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion to build the trees.",
      "Think about how to choose the root for each subtree."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Integer to Roman",
    "description": "Convert an integer to its corresponding Roman numeral representation. Roman numerals are based on combinations of the following symbols: 'I' for 1, 'V' for 5, 'X' for 10, 'L' for 50, 'C' for 100, 'D' for 500, and 'M' for 1000. The numeral system can be expressed by combining these symbols together, with the following rules: symbols are typically written from largest to smallest from left to right, and there are specific combinations for cases where a smaller numeral appears before a larger numeral to indicate subtraction.",
    "topic": "Mathematics",
    "subtopic": "String Manipulation",
    "tags": [
      "Math",
      "Strings",
      "Conversion"
    ],
    "input_format": "An integer num (1 <= num <= 3999).",
    "output_format": "A string representing the Roman numeral equivalent of the integer.",
    "constraints": [
      "1 <= num <= 3999"
    ],
    "examples": [
      {
        "input": "num = 3",
        "output": "III",
        "explanation": "The Roman numeral representation of 3 is 'III' as it is made up of three 'I's."
      },
      {
        "input": "num = 58",
        "output": "LVIII",
        "explanation": "'L' is 50, 'V' is 5, and 'III' is 3. Therefore, 58 is represented as 'LVIII'."
      },
      {
        "input": "num = 1994",
        "output": "MCMXCIV",
        "explanation": "'M' is 1000, 'CM' is 900, 'XC' is 90, and 'IV' is 4. Thus, 1994 is represented as 'MCMXCIV'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to break down the integer into its component values.",
      "Use a mapping of integers to Roman numeral symbols for conversion."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Edit Distance",
    "description": "Given two strings 'word1' and 'word2', return the minimum number of operations required to convert 'word1' into 'word2'. You can perform the following operations on a word: insert a character, delete a character, or replace a character.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Edit Distance"
    ],
    "input_format": "Two strings 'word1' and 'word2'.",
    "output_format": "An integer representing the minimum number of operations required to convert 'word1' into 'word2'.",
    "constraints": [
      "0 <= word1.length, word2.length <= 100",
      "word1 and word2 consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "word1 = 'horse', word2 = 'ros'",
        "output": "3",
        "explanation": "The minimum edit distance is 3. horse -> rorse (replace 'h' with 'r'), rorse -> rose (remove 'r'), rose -> ros (remove 'e')."
      },
      {
        "input": "word1 = 'intention', word2 = 'execution'",
        "output": "5",
        "explanation": "The minimum edit distance is 5. intention -> inention (remove 't'), inention -> enention (replace 'i' with 'e'), enention -> exention (replace 'n' with 'x'), exention -> exection (remove 'n'), exection -> execution (insert 'u')."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dynamic programming approach.",
      "Think about the base case where one of the strings is empty."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Maximal Rectangle",
    "description": "Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "Matrix",
    "tags": [
      "Matrix",
      "Dynamic Programming",
      "Binary Search"
    ],
    "input_format": "A 2D binary matrix of size m x n.",
    "output_format": "An integer representing the area of the largest rectangle containing only 1's.",
    "constraints": [
      "1 <= m, n <= 300",
      "matrix[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "matrix = [ ['1', '0', '1', '0', '0'], ['1', '0', '1', '1', '1'], ['1', '1', '1', '1', '1'], ['1', '0', '0', '1', '0'] ]",
        "output": "6",
        "explanation": "The rectangle with the largest area contains 1's and is formed by the bottom three rows and the first three columns."
      },
      {
        "input": "matrix = [ ['0'] ]",
        "output": "0",
        "explanation": "There are no 1's in the matrix."
      },
      {
        "input": "matrix = [ ['1'] ]",
        "output": "1",
        "explanation": "There is a single 1, so the largest rectangle has area 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to store heights of consecutive 1's.",
      "Use a stack to efficiently calculate the area for histograms.",
      "Breaking down the problem into smaller parts can make it easier."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted List",
    "description": "Given a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.",
    "topic": "Linked List",
    "subtopic": "Manipulating Linked List",
    "tags": [
      "Linked List",
      "Duplicates",
      "Sorting"
    ],
    "input_format": "The head of a sorted linked list.",
    "output_format": "The head of the sorted linked list with duplicates removed.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 300].",
      "-100 <= Node.val <= 100",
      "The list is guaranteed to be sorted in ascending order."
    ],
    "examples": [
      {
        "input": "head = [1, 1, 2]",
        "output": "[1, 2]",
        "explanation": "After removing duplicates, the linked list is [1, 2]."
      },
      {
        "input": "head = [1, 1, 2, 3, 3]",
        "output": "[1, 2, 3]",
        "explanation": "After removing duplicates, the linked list is [1, 2, 3]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a pointer to traverse the linked list.",
      "Compare the current node with the next node."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Balanced Binary Tree",
    "description": "Given a binary tree, determine if it is height-balanced. A binary tree is considered height-balanced if for any node in the tree, the height of the left and right subtrees differ by no more than one.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth-first Search"
    ],
    "input_format": "The input is the root node of a binary tree.",
    "output_format": "Return true if the binary tree is height-balanced, otherwise return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "true",
        "explanation": "The tree is balanced as the height of the left subtree (1) and the right subtree (1) differ by no more than 1."
      },
      {
        "input": "root = [1,2,2,3,3,null,null,4,4]",
        "output": "false",
        "explanation": "The left subtree has a height of 3 while the right subtree has a height of 1. The difference is greater than 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider writing a helper function to calculate the height of a subtree.",
      "Check the balance condition for every node, starting from the bottom."
    ],
    "company": "Uber"
  },
  {
    "question_id": "",
    "title": "Reverse Nodes in k-Group",
    "description": "Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k, then the remaining nodes at the end should remain as is. You may not alter the values in the nodes, only nodes themselves may be changed.",
    "topic": "Linked List",
    "subtopic": "Reversal",
    "tags": [
      "Linked List",
      "Reversal",
      "Two Pointers"
    ],
    "input_format": "A linked list head node and an integer k.",
    "output_format": "The head of the modified linked list after reversing nodes in k-groups.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 5000].",
      "0 <= Node.val <= 1000",
      "k is a positive integer and is less than or equal to the length of the linked list."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], k = 2",
        "output": "[2, 1, 4, 3, 5]",
        "explanation": "The first two nodes (1, 2) are reversed to become (2, 1), then the next two nodes (3, 4) are reversed to (4, 3). The last node (5) remains the same."
      },
      {
        "input": "head = [1, 2, 3], k = 3",
        "output": "[3, 2, 1]",
        "explanation": "All three nodes (1, 2, 3) are reversed to become (3, 2, 1)."
      },
      {
        "input": "head = [1, 2, 3, 4, 5], k = 3",
        "output": "[3, 2, 1, 4, 5]",
        "explanation": "The first three nodes (1, 2, 3) are reversed to become (3, 2, 1). The remaining nodes (4, 5) stay in the same order."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a dummy node to simplify the reversal process.",
      "Think about how you can achieve the reversal in batches of k."
    ],
    "company": "Uber"
  }
]