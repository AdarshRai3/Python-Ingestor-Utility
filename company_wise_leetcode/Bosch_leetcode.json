[
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an array of integers nums, return all the unique triplets [nums[i], nums[j], nums[k]] such that i, j, and k are distinct indices, and nums[i] + nums[j] + nums[k] == 0. Note that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Hashing"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A list of lists of integers, where each inner list represents a unique triplet that sums to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The unique triplets that sum to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no numbers, hence no triplets can be formed."
      },
      {
        "input": "nums = [0, 1, 1]",
        "output": "[]",
        "explanation": "No triplets sum to zero in this case."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array first to help streamline identifying triplets.",
      "Use a loop to fix one element and then use two pointers to find pairs that sum to a specific value."
    ],
    "company": "Bosch"
  },
  {
    "question_id": "",
    "title": "Middle of the Linked List",
    "description": "Given a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node.",
    "topic": "Linked List",
    "subtopic": "Traversal",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Fast and Slow Pointers"
    ],
    "input_format": "The input consists of a linked list with at least one node.",
    "output_format": "Return the node that is in the middle of the linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [1, 100]",
      "1 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5]",
        "output": "[3]",
        "explanation": "The linked list is [1 -> 2 -> 3 -> 4 -> 5]. The middle node is 3."
      },
      {
        "input": "head = [1, 2, 3, 4, 5, 6]",
        "output": "[4]",
        "explanation": "The linked list is [1 -> 2 -> 3 -> 4 -> 5 -> 6]. The middle nodes are 3 and 4. We return the second middle node which is 4."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers: a slow pointer and a fast pointer.",
      "The slow pointer moves one step at a time while the fast pointer moves two steps."
    ],
    "company": "Bosch"
  }
]