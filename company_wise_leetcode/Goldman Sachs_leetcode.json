[
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of blocks, compute how much water it can trap after raining. The water trapped above a block is determined by the height of the tallest block to the left and the tallest block to the right of it.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers heights.",
    "output_format": "An integer representing the total amount of trapped rainwater.",
    "constraints": [
      "0 <= heights.length <= 2 * 10^4",
      "0 <= heights[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "heights = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The water can be trapped above heights at indices 2, 4, 5, 6, and between 7 and 9, totaling to 6 units."
      },
      {
        "input": "heights = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The water can be trapped above heights at indices 1, 2, and 3, totaling to 9 units."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the left and right maximum heights for each block.",
      "Use a two-pointer approach to calculate the trapped water efficiently."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays, nums1 and nums2, of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume that nums1 and nums2 are both non-empty.",
    "topic": "Binary Search",
    "subtopic": "Searching",
    "tags": [
      "Binary Search",
      "Array",
      "Median"
    ],
    "input_format": "Two sorted arrays nums1 and nums2.",
    "output_format": "A float representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= nums1.length <= 1000",
      "0 <= nums2.length <= 1000",
      "nums1 and nums2 are sorted in ascending order."
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.0",
        "explanation": "The merged sorted array is [1, 2, 3]. The median is 2.0."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.5",
        "explanation": "The merged sorted array is [1, 2, 3, 4]. The median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using binary search on the smaller array.",
      "The median can be found by partitioning both arrays."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "First Unique Character in a String",
    "description": "Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.",
    "topic": "String",
    "subtopic": "Hash Table",
    "tags": [
      "String",
      "Hash Table",
      "Indexing"
    ],
    "input_format": "A string s consisting of lowercase English letters.",
    "output_format": "An integer representing the index of the first unique character, or -1 if no unique character exists.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = 'leetcode'",
        "output": "0",
        "explanation": "The first non-repeating character is 'l' at index 0."
      },
      {
        "input": "s = 'Loveleetcode'",
        "output": "2",
        "explanation": "The first non-repeating character is 'v' at index 2."
      },
      {
        "input": "s = 'aabb'",
        "output": "-1",
        "explanation": "There are no non-repeating characters in the string."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash table to count the occurrences of each character.",
      "Iterate through the string to find the first character with a count of 1."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Fraction to Recurring Decimal",
    "description": "Given two integers numerator and denominator, represent the decimal value of their division as a string. If the decimal is repeating, enclose the repeating part in parentheses. For example, given numerator = 1 and denominator = 3, your output should be '0.(3)'. The function should accurately return the result of the division, including the integer part, and handle cases with negative and zero values correctly.",
    "topic": "Mathematics",
    "subtopic": "String Manipulation",
    "tags": [
      "Math",
      "String",
      "Division"
    ],
    "input_format": "Two integers numerator and denominator.",
    "output_format": "A string representing the decimal value of the division.",
    "constraints": [
      "-2^31 <= numerator, denominator <= 2^31 - 1",
      "denominator != 0"
    ],
    "examples": [
      {
        "input": "numerator = 1, denominator = 2",
        "output": "0.5",
        "explanation": "The division results in 0.5 which is not repeating."
      },
      {
        "input": "numerator = 1, denominator = 3",
        "output": "0.(3)",
        "explanation": "The division results in 0.3333... which is repeating, hence we put (3) in parentheses."
      },
      {
        "input": "numerator = 2, denominator = 1",
        "output": "2",
        "explanation": "The division results in 2 which is a whole number."
      },
      {
        "input": "numerator = 4, denominator = 333",
        "output": "0.0(012)",
        "explanation": "The division results in 0.001200120012... which is repeating, hence we put (012) in parentheses."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map to track the positions of remainders.",
      "A repeating decimal occurs when a remainder repeats during the division process."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "Matrix"
    ],
    "input_format": "A 2D grid represented as a list of lists of characters, where each character is either '1' or '0'.",
    "output_format": "An integer representing the number of islands.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "grid = [['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]",
        "output": "1",
        "explanation": "All the '1's are connected, hence it counts as one island."
      },
      {
        "input": "grid = [['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]",
        "output": "3",
        "explanation": "There are three islands formed by the groups of '1's."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use DFS or BFS to traverse through the grid.",
      "Mark visited land as water to avoid counting it again.",
      "Count each time you start a DFS from an unvisited '1'."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array where the ith element is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Dynamic Programming",
    "subtopic": "Max Profit",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Max Profit"
    ],
    "input_format": "An array of integers representing stock prices.",
    "output_format": "An integer representing the maximum profit.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate potential profit at each step and keep track of the maximum profit."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Minimum Path Sum",
    "description": "Given a m x n grid filled with non-negative numbers, find a path from the top left to the bottom right, which minimizes the sum of the numbers along the path. You can only move either down or right at any point in time.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Paths",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Pathfinding"
    ],
    "input_format": "A 2D array of integers grid representing the m x n grid.",
    "output_format": "An integer representing the minimum path sum from the top left to the bottom right.",
    "constraints": [
      "1 <= m, n <= 100",
      "0 <= grid[i][j] <= 100"
    ],
    "examples": [
      {
        "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7",
        "explanation": "The path 1 \u2192 3 \u2192 1 \u2192 2 will yield a minimum sum of 7."
      },
      {
        "input": "grid = [[1,2,3],[4,5,6]]",
        "output": "12",
        "explanation": "The path 1 \u2192 2 \u2192 3 \u2192 6 will yield a minimum sum of 12."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store previously computed minimum sums.",
      "You can create a 2D array to keep track of the minimum path sums."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "String Compression",
    "description": "Given a string 's' consisting of characters, you need to compress it using the following method: for each group of consecutive repeating characters, replace that group with the character followed by the number of occurrences. If the compressed string is not shorter than the original string, return the original string. Otherwise, return the compressed string.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Compression",
      "Manipulation"
    ],
    "input_format": "A string s (1 <= s.length <= 1000) consisting of uppercase and lowercase English letters.",
    "output_format": "A string representing the compressed version of s or the original string if compression does not reduce its size.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of English letters (uppercase and lowercase)"
    ],
    "examples": [
      {
        "input": "s = 'aabcccccaaa'",
        "output": "a2b1c5a3",
        "explanation": "The string can be compressed to 'a2b1c5a3'."
      },
      {
        "input": "s = 'abcd'",
        "output": "abcd",
        "explanation": "No compressing needed as it does not lead to a shorter version."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a pointer to traverse the string.",
      "Count characters until a different character is found."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the numbers that add up to target.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "The numbers at indices 0 and 1 are 2 and 7, which add up to 9."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "The numbers at indices 1 and 2 are 2 and 4, which add up to 6."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "The numbers at indices 0 and 1 are both 3, which add up to 6."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash table to store the difference between the target and each number seen so far."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "LRU Cache",
    "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class: LRUCache(int capacity) Initializes the LRU cache with positive size capacity. int get(int key) Returns the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.",
    "topic": "Design",
    "subtopic": "Cache",
    "tags": [
      "Design",
      "Cache",
      "Data Structure"
    ],
    "input_format": "Operations including `get` and `put` on a cache with an integer capacity.",
    "output_format": "Return the values from the `get` method or an acknowledgment for the `put` method.",
    "constraints": [
      "1 <= capacity <= 3000",
      "0 <= key, value <= 10^4",
      "The number of operations in the input will be at most 10^4."
    ],
    "examples": [
      {
        "input": "LRUCache lruCache = new LRUCache(2); lruCache.put(1, 1); lruCache.put(2, 2); lruCache.get(1); lruCache.put(3, 3); lruCache.get(2); lruCache.put(4, 4); lruCache.get(1); lruCache.get(3); lruCache.get(4);",
        "output": "[1,-1,4,3]",
        "explanation": "1. put(1, 1) - Cache is {1=1}  2. put(2, 2) - Cache is {1=1, 2=2}  3. get(1) - Returns 1, Cache is {2=2, 1=1}  4. put(3, 3) - Evicts key 2, Cache is {1=1, 3=3}  5. get(2) - Returns -1 (not found)  6. put(4, 4) - Evicts key 1, Cache is {3=3, 4=4}  7. get(1) - Returns -1 (not found)  8. get(3) - Returns 3  9. get(4) - Returns 4"
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map for efficient key-value storage.",
      "Consider using a doubly linked list to keep track of the usage order."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "topic": "String",
    "subtopic": "Hashing",
    "tags": [
      "String",
      "Hashing",
      "Sorting"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A list of lists containing grouped anagrams.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lower-case English letters."
    ],
    "examples": [
      {
        "input": "strs = ['eat', 'tea', 'tan', 'ate', 'nat', 'bat']",
        "output": "[['bat'], ['nat', 'tan'], ['ate', 'eat', 'tea']]",
        "explanation": "All anagrams are grouped together."
      },
      {
        "input": "strs = ['']",
        "output": "[['']]",
        "explanation": "There is one empty string, which is an anagram of itself."
      },
      {
        "input": "strs = ['a']",
        "output": "[['a']]",
        "explanation": "Single letters are anagrams of themselves."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map to group the strings.",
      "Sorting the characters in the strings can help identify anagrams."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Find Minimum in Rotated Sorted Array",
    "description": "Given a rotated sorted array of distinct integers, return the minimum element in the array. The array was initially sorted in ascending order, but then it was rotated at some pivot unknown to you beforehand. You must write an algorithm with a time complexity of O(log n).",
    "topic": "Binary Search",
    "subtopic": "Array Search",
    "tags": [
      "Array",
      "Binary Search",
      "Searching"
    ],
    "input_format": "An array of distinct integers nums, where 1 <= nums.length <= 5000.",
    "output_format": "An integer representing the minimum element in the rotated sorted array.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "The elements of nums are distinct integers."
    ],
    "examples": [
      {
        "input": "nums = [4, 5, 6, 7, 0, 1, 2]",
        "output": "0",
        "explanation": "The minimum element in the array is 0."
      },
      {
        "input": "nums = [11, 13, 15, 17]",
        "output": "11",
        "explanation": "The array has not been rotated, and the minimum element is the first element: 11."
      },
      {
        "input": "nums = [3, 4, 5, 1, 2]",
        "output": "1",
        "explanation": "The minimum element in the array is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to cut down the search space.",
      "If the middle value is greater than the rightmost value, the minimum is in the right half.",
      "If the middle value is less than the rightmost value, the minimum is in the left half or could be middle."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). 'n' vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with the x-axis forms a container, such that the container contains the most water. Note that you may not slant the container.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "input_format": "An integer array heights representing the height of lines.",
    "output_format": "An integer representing the maximum amount of water the container can store.",
    "constraints": [
      "2 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The maximum water container will be between the lines at indices 1 and 8, with heights 8 and 7 respectively. The area is (8-1) * min(8, 7) = 7 * 7 = 49."
      },
      {
        "input": "heights = [1,1]",
        "output": "1",
        "explanation": "The only container is between the two lines of height 1, leading to an area of (1-0) * min(1, 1) = 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using two pointers to traverse the array.",
      "The area is determined by the distance between two lines and the height of the shorter line."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Decode Ways",
    "description": "A message containing letters from A-Z can be encoded into numbers using the following mapping: 'A' -> 1, 'B' -> 2, ..., 'Z' -> 26. For example, the message 'AB' can be encoded as '12'. Given a string s consisting of digits, return the total number of ways to decode it. The string must not contain any invalid mappings, such as '0' or numbers greater than '26'.",
    "topic": "Dynamic Programming",
    "subtopic": "String Decoding",
    "tags": [
      "Dynamic Programming",
      "String",
      "Decoding"
    ],
    "input_format": "A string s representing the encoded message consisting of digits.",
    "output_format": "An integer representing the total number of ways to decode the string.",
    "constraints": [
      "1 <= s.length <= 100",
      "s contains only digit characters.",
      "s does not contain leading zeros."
    ],
    "examples": [
      {
        "input": "12",
        "output": "2",
        "explanation": "The string '12' can be decoded as 'AB' (1 2) or 'L' (12), so the output is 2."
      },
      {
        "input": "226",
        "output": "3",
        "explanation": "The string '226' can be decoded as 'BBF' (2 2 6), 'BZ' (2 26), or 'VF' (22 6), so the output is 3."
      },
      {
        "input": "06",
        "output": "0",
        "explanation": "The string '06' cannot be decoded because the '0' does not map to any letter, so the output is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider breaking the problem into subproblems by examining one or two digits at a time.",
      "Use a dynamic programming array to store the number of ways to decode substrings."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "You are given a rotated sorted array of unique integers and an integer target. Your task is to determine if the target exists in the array and return its index. If the target does not exist in the array, return -1. The array is rotated at some pivot unknown to you beforehand. You must achieve a time complexity of O(log n) for your solution.",
    "topic": "Binary Search",
    "subtopic": "Searching",
    "tags": [
      "Binary Search",
      "Array",
      "Searching"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An integer representing the index of target if found, or -1 if not found.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "1 <= nums[i] <= 10^6",
      "All elements in nums are unique."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "The target 0 is located at index 4."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "The target 3 does not exist in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how the array is divided into two sorted subarrays.",
      "You can use a modified binary search approach."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters. A substring is a contiguous sequence of characters within a string.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A string s (1 <= s.length <= 5 * 10^4) containing only English letters, digits, symbols, and spaces.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "1 <= s.length <= 5 * 10^4",
      "s consists of English letters, digits, symbols and spaces."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The answer is \"abc\", with the length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The answer is \"b\", with the length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The answer is \"wke\", with the length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to use a sliding window technique to capture the longest substring.",
      "A HashMap can help to track the last index of each character."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Minimize the Maximum of Two Arrays",
    "description": "You are given two arrays of integers, A and B. Your task is to split each array into two non-empty subarrays (A1, A2) and (B1, B2) such that the maximum sum of the elements from each split is minimized. More formally, you need to find two integers S_A and S_B such that S_A = max(sum(A1), sum(A2)) and S_B = max(sum(B1), sum(B2)), and you want to minimize `max(S_A, S_B)`. Return the minimized value.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Minimization"
    ],
    "input_format": "Two arrays of integers A and B.",
    "output_format": "An integer representing the minimized maximum of sums.",
    "constraints": [
      "1 <= A.length, B.length <= 10^4",
      "-10^5 <= A[i], B[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "A = [1, 3, 5, 7], B = [10, 2, 6, 8]",
        "output": "12",
        "explanation": "Split A into [1, 3] and [5, 7], and B into [10] and [2, 6, 8]. The max sums are 4 and 16 respectively, resulting in max(4, 16) = 16. The combination leading to the minimized maximum is 12."
      },
      {
        "input": "A = [1, 1, 1], B = [1, 1, 1]",
        "output": "2",
        "explanation": "Both arrays can be split into two parts with sums of 2 and 1, resulting in max(2, 2) = 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider dynamic programming to explore the possible sums efficiently.",
      "Think about prefix sums for optimal splitting."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock II",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. However, you can make as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note that you must sell the stock before you buy again. Return the maximum profit you can achieve.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices representing the stock prices on different days.",
    "output_format": "An integer representing the maximum profit that can be achieved.",
    "constraints": [
      "0 <= prices.length <= 3 * 10^4",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "7",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6 - 3 = 3. Total profit = 5 + 3 = 8."
      },
      {
        "input": "prices = [1,2,3,4,5]",
        "output": "4",
        "explanation": "Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5 - 1 = 4."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "No transaction is done, profit = 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider what happens on each day.",
      "Think about how the profit accumulates."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Kth Largest Element in an Array",
    "description": "Given an array of integers, find the k-th largest element in the array. Note that it is the k-th largest element in the sorted order, not the k-th distinct element.",
    "topic": "Array",
    "subtopic": "Sorting and Searching",
    "tags": [
      "Array",
      "Sorting",
      "Heap",
      "Binary Search"
    ],
    "input_format": "An integer array nums and an integer k, where 1 <= k <= nums.length.",
    "output_format": "An integer representing the k-th largest element in the array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 1, 5, 6, 4], k = 2",
        "output": "5",
        "explanation": "The sorted array is [1, 2, 3, 4, 5, 6]. The 2nd largest element is 5."
      },
      {
        "input": "nums = [3, 2, 3, 1, 2, 4, 5, 5, 6], k = 4",
        "output": "4",
        "explanation": "The sorted array is [1, 2, 2, 3, 3, 4, 5, 5, 6]. The 4th largest element is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a min-heap to keep track of the top k elements.",
      "You can also consider sorting the array."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Valid Arrangement of Pairs",
    "description": "You are given an array of pairs, where each pair consists of two integers. Your task is to determine if the pairs can be arranged in a valid sequence such that the second integer of one pair matches the first integer of the next pair. If a valid arrangement exists, return true; otherwise, return false.",
    "topic": "Graph",
    "subtopic": "Graph Traversal",
    "tags": [
      "Graph",
      "Traversal",
      "Sequence"
    ],
    "input_format": "An array of pairs, where each pair is represented as a list of two integers.",
    "output_format": "A boolean value indicating whether a valid arrangement of pairs exists.",
    "constraints": [
      "1 <= pairs.length <= 10^5",
      "-10^9 <= pairs[i][0], pairs[i][1] <= 10^9"
    ],
    "examples": [
      {
        "input": "[[1,2],[2,1],[1,3]]",
        "output": "true",
        "explanation": "The pairs can be arranged as [1,2] -> [2,1] -> [1,3]."
      },
      {
        "input": "[[1,2],[2,3],[3,1]]",
        "output": "true",
        "explanation": "The pairs can form a cycle: [1,2] -> [2,3] -> [3,1]."
      },
      {
        "input": "[[1,2],[3,4]]",
        "output": "false",
        "explanation": "There is no way to arrange these pairs such that they connect."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a graph representation to model the connections between pairs.",
      "Check for in-degrees and out-degrees to find valid paths."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. For example, if you have intervals [1,3], [2,6], [8,10], and [15,18], the merged intervals will be [1,6], [8,10], and [15,18]. The input consists of a list of intervals where each interval is represented by a pair of integers, for instance, [start, end].",
    "topic": "Array",
    "subtopic": "Sorting and Merging",
    "tags": [
      "Array",
      "Sorting",
      "Intervals"
    ],
    "input_format": "A list of intervals, where each interval is a list of two integers [start, end].",
    "output_format": "A list of merged intervals.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Intervals [1,3] and [2,6] overlap, so they merge to form [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "Intervals [1,4] and [4,5] also overlap and merge to form [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on the starting time.",
      "Use a stack or a list to keep track of merged intervals."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Construct Smallest Number From DI String",
    "description": "Given a string 's' consisting of characters 'D' (decreasing) and 'I' (increasing), return the lexicographically smallest string that can be formed by arranging the numbers from 1 to n in a way that satisfies the order specified by 's'. For instance, if 's' starts with 'I', the next number must be greater than the previous, while 'D' specifies that the next number must be smaller than the previous one.",
    "topic": "String",
    "subtopic": "Permutation",
    "tags": [
      "String",
      "Permutation",
      "Greedy"
    ],
    "input_format": "A string s consisting of 'I's and 'D's where 1 <= s.length <= 10^4.",
    "output_format": "A string representing the smallest lexicographical permutation of numbers satisfying the conditions set by the DI string.",
    "constraints": [
      "1 <= n <= 10^5",
      "s.length == n - 1"
    ],
    "examples": [
      {
        "input": "s = \"IIDD\"",
        "output": "123468",
        "explanation": "In this case, the smallest lexicographical arrangement is 123468 which satisfies the increasing and decreasing requirements."
      },
      {
        "input": "s = \"DDI\"",
        "output": "3214",
        "explanation": "The sequence '3214' satisfies that 3 > 2 > 1 and then goes to 4, adhering to the orders defined by 'D' and 'I'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to manage the order of numbers.",
      "Think about how to push and pop numbers to form the result."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A palindrome is a string that reads the same forward and backward. You may assume that the input string is non-empty and that the maximum length of s is 1000 characters.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A non-empty string s of length n (1 <= n <= 1000).",
    "output_format": "A string representing the longest palindromic substring.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only printable ASCII characters."
    ],
    "examples": [
      {
        "input": "babad",
        "output": "bab",
        "explanation": "Both 'bab' and 'aba' are valid longest palindromic substrings."
      },
      {
        "input": "cbbd",
        "output": "bb",
        "explanation": "The longest palindromic substring is 'bb'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding around potential centers of palindromes.",
      "A palindrome can be even or odd in length, so check both cases.",
      "Use dynamic programming to store results of subproblems."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Power of Three",
    "description": "Given an integer n, return true if it is a power of three. An integer n is a power of three if there exists an integer x such that n == 3^x. For example, 1 (3^0), 3 (3^1), 9 (3^2) and 27 (3^3) are powers of three, but 2 and 4 are not.",
    "topic": "Math",
    "subtopic": "Number Theory",
    "tags": [
      "Math",
      "Number Theory",
      "Power"
    ],
    "input_format": "An integer n.",
    "output_format": "A boolean value indicating whether n is a power of three.",
    "constraints": [
      "-2^31 <= n <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "n = 9",
        "output": "true",
        "explanation": "9 is 3^2, hence it is a power of three."
      },
      {
        "input": "n = 0",
        "output": "false",
        "explanation": "0 is not a power of three."
      },
      {
        "input": "n = 27",
        "output": "true",
        "explanation": "27 is 3^3, hence it is a power of three."
      },
      {
        "input": "n = 10",
        "output": "false",
        "explanation": "10 is not a power of three."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Think about how you can divide n by 3 repeatedly.",
      "Consider using logarithms."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Longest Increasing Subsequence",
    "description": "Given an array of integers, find the length of the longest subsequence such that all elements of the subsequence are sorted in increasing order. A subsequence is a sequence derived from another sequence where some elements can be deleted without changing the order of the remaining elements.",
    "topic": "Dynamic Programming",
    "subtopic": "Subsequence Problems",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Subsequence"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the length of the longest increasing subsequence.",
    "constraints": [
      "1 <= nums.length <= 2500",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [10, 9, 2, 5, 3, 7, 101, 18]",
        "output": "4",
        "explanation": "The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4."
      },
      {
        "input": "nums = [0, 1, 0, 3, 2, 3]",
        "output": "4",
        "explanation": "The longest increasing subsequence is [0, 1, 2, 3], which has a length of 4."
      },
      {
        "input": "nums = [7, 7, 7, 7, 7, 7, 7]",
        "output": "1",
        "explanation": "The longest increasing subsequence can only be [7], which has a length of 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider dynamic programming to store lengths of increasing subsequences.",
      "You can use binary search to optimize the process."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Count Palindromic Subsequences",
    "description": "Given a string s, return the count of distinct palindromic subsequences in s. A palindromic subsequence is a sequence that can be derived from the string and reads the same forwards and backwards. For example, in the string 'abba', the palindromic subsequences include 'a', 'b', 'bb', 'abba', 'aa', and so on. Consider that the same character combinations formed by different methods are counted as distinct. Return the result modulo 10^9 + 7.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Count",
      "Recursion"
    ],
    "input_format": "A single string s where 1 <= s.length <= 1000.",
    "output_format": "An integer representing the count of distinct palindromic subsequences in s, modulo 10^9 + 7.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = 'bccb'",
        "output": "6",
        "explanation": "The distinct palindromic subsequences are: 'b', 'c', 'bb', 'bccb', 'cb', 'cc'."
      },
      {
        "input": "s = 'abc'",
        "output": "3",
        "explanation": "The distinct palindromic subsequences are: 'a', 'b', 'c'."
      },
      {
        "input": "s = 'aaa'",
        "output": "5",
        "explanation": "The distinct palindromic subsequences are: 'a', 'aa', 'aaa'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to keep track of palindromic counts.",
      "Check how to handle duplicates when counting distinct subsequences.",
      "Break down the problem by expanding around possible palindrome centers."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Range Product Queries of Powers",
    "description": "You are given an array of integers, where each integer represents the power of a specific element. You need to respond to several range product queries. Each query consists of two integers, left and right, which define a subarray from the input array. Your task is to compute the product of all elements in that subarray and return the result modulo 10^9 + 7.",
    "topic": "Array",
    "subtopic": "Range Queries",
    "tags": [
      "Array",
      "Range Queries",
      "Product"
    ],
    "input_format": "An array of integers nums followed by an array of queries, where each query is a pair of integers [left, right].",
    "output_format": "An array of integers, each representing the product of the corresponding query.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i] <= 10^4",
      "1 <= queries.length <= 10^4",
      "0 <= left <= right < nums.length"
    ],
    "examples": [
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4
          ],
          "queries": [
            [
              0,
              1
            ],
            [
              1,
              3
            ]
          ]
        },
        "output": [
          2,
          24
        ],
        "explanation": "For the first query [0, 1], the product is 1 * 2 = 2. For the second query [1, 3], the product is 2 * 3 * 4 = 24."
      },
      {
        "input": {
          "nums": [
            5,
            4,
            3,
            2,
            1
          ],
          "queries": [
            [
              0,
              4
            ],
            [
              1,
              2
            ]
          ]
        },
        "output": [
          120,
          12
        ],
        "explanation": "The first query computes the product of all numbers: 5 * 4 * 3 * 2 * 1 = 120. The second query computes 4 * 3 = 12."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using prefix products to optimize the range queries.",
      "Remember to apply modulo operation to prevent integer overflow."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Minimum Cost Homecoming of a Robot in a Grid",
    "description": "A robot is located at the top-left corner of an m x n grid. It must move to the bottom-right corner of the grid. The robot can only move either down or right at any point in time. The cost of moving to a cell (i, j) is given by the cost grid, where cost[i][j] is the cost of entering the cell. The goal is to minimize the total cost of moving from the top-left corner to the bottom-right corner. Write a function that takes the cost matrix and returns the minimum cost required for the robot to come home.",
    "topic": "Dynamic Programming",
    "subtopic": "Path Finding",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Minimum Cost",
      "Path Finding"
    ],
    "input_format": "A 2D list of integers cost where cost[i][j] represents the cost of cell (i, j).",
    "output_format": "An integer representing the minimum cost to move from the top-left to the bottom-right of the grid.",
    "constraints": [
      "1 <= cost.length <= 200",
      "1 <= cost[0].length <= 200",
      "0 <= cost[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "cost = [[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7",
        "explanation": "The optimal path is 1 \u2192 3 \u2192 1 \u2192 1, which has a cost of 1 + 3 + 1 + 1 = 6."
      },
      {
        "input": "cost = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "21",
        "explanation": "The optimal path is 1 \u2192 2 \u2192 3 \u2192 6 \u2192 9, which has a cost of 1 + 2 + 3 + 6 + 9 = 21."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store the minimum cost at each cell.",
      "You can build the solution from the top-left to the bottom-right."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if the brackets are closed in the correct order. Every opening bracket must have a corresponding closing bracket of the same type.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A string s consisting of parentheses and brackets.",
    "output_format": "A boolean value, true if the string is valid, false otherwise.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses and brackets only."
    ],
    "examples": [
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "All the brackets are closed in the correct order."
      },
      {
        "input": "s = '(]'",
        "output": "false",
        "explanation": "The brackets are not closed in the correct order."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "When you encounter a closing bracket, check if it matches the top of the stack."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Kadane's Algorithm"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum sum of the contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The contiguous subarray [4,-1,2,1] has the largest sum = 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The only element is 1, which is the largest sum."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The contiguous subarray [5,4,-1,7,8] has the largest sum = 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using a greedy algorithm to keep track of the current and maximum sums.",
      "Consider the cases where the maximum sum subarray could start or end in the current element."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Determine if Two Events Have Conflict",
    "description": "You are given two events, each defined by their start and end times. Your task is to determine if these two events conflict with each other. Two events conflict if one starts before the other ends, and one ends after the other starts.",
    "topic": "Interval",
    "subtopic": "Overlap Detection",
    "tags": [
      "Interval",
      "Overlap",
      "Time Management"
    ],
    "input_format": "Two pairs of integers representing the start and end times of the events, formatted as (start1, end1) and (start2, end2).",
    "output_format": "Return true if the two events conflict, otherwise return false.",
    "constraints": [
      "0 <= start1 < end1 <= 10^9",
      "0 <= start2 < end2 <= 10^9"
    ],
    "examples": [
      {
        "input": "(1, 5), (4, 6)",
        "output": "true",
        "explanation": "The first event ends at 5 and the second event starts at 4, hence they overlap."
      },
      {
        "input": "(1, 2), (2, 3)",
        "output": "false",
        "explanation": "The first event ends exactly when the second event starts, so there is no overlap."
      },
      {
        "input": "(10, 15), (5, 10)",
        "output": "false",
        "explanation": "The events do not overlap since the first one ends after the second one starts."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider the start and end times carefully to check if they overlap."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Sliding Window Maximum",
    "description": "Given an integer array nums and an integer k, return the maximum sliding window for each sliding window of size k. You must perform the optimization such that your algorithm runs in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Deque"
    ],
    "input_format": "An integer array nums of size n, and an integer k (1 <= k <= n).",
    "output_format": "An array of integers representing the maximum value in each sliding window.",
    "constraints": [
      "1 <= n <= 10^5",
      " -10^4 <= nums[i] <= 10^4",
      "1 <= k <= n"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3",
        "output": "[3, 3, 5, 5, 6, 7]",
        "explanation": "The maximum for each sliding window of size 3 is [3, 3, 5, 5, 6, 7]."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "Only one element in the window, so the maximum is 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a deque to keep track of indices of useful elements.",
      "Only add indices to the deque that are within the current window."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Find All Good Indices",
    "description": "You are given a 0-indexed integer array nums of size n and two integers k and minLength. An index i is considered a good index if both of the following conditions are satisfied: The subarray nums[i-k+1, i] has a length of exactly k and each element in the subarray is greater than or equal to minLength. Return a list of all good indices in ascending order.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Subarray"
    ],
    "input_format": "An array of integers nums, and two integers k and minLength.",
    "output_format": "A list of integers representing the good indices.",
    "constraints": [
      "1 <= n <= 10^5",
      "0 <= nums[i] <= 10^5",
      "1 <= k <= n",
      "1 <= minLength <= 10^5"
    ],
    "examples": [
      {
        "input": {
          "nums": [
            4,
            3,
            5,
            1,
            6
          ],
          "k": 3,
          "minLength": 3
        },
        "output": [
          0,
          2
        ],
        "explanation": "The good indices are 0 and 2 because the subarrays [4,3,5] and [5,1,6] satisfy the conditions."
      },
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4,
            5
          ],
          "k": 2,
          "minLength": 3
        },
        "output": [
          2,
          3,
          4
        ],
        "explanation": "The good indices are 2, 3, and 4 as the subarrays [3,4], [4,5] all satisfy the conditions."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window to keep track of valid subarrays.",
      "Check each subarray of length k for the minLength condition."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Successful Pairs of Spells and Potions",
    "description": "Alice has a collection of spells, each with a success factor, and a collection of potions, each with a power factor. A pair consisting of a spell and a potion is considered successful if the product of their factors is at least a given success threshold. Given two lists of integers representing the success factors of spells and the power factors of potions, and an integer representing the success threshold, return a list of integers where the ith integer is the count of successful pairs for the ith spell.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Count Pairs"
    ],
    "input_format": "Two lists of integers spells and potions, and an integer successThreshold.",
    "output_format": "A list of integers, where each integer represents the number of successful pairs for the corresponding spell.",
    "constraints": [
      "1 <= spells.length, potions.length <= 10^5",
      "1 <= spells[i], potions[i] <= 10^5",
      "1 <= successThreshold <= 10^10"
    ],
    "examples": [
      {
        "input": "spells = [1, 2, 3], potions = [4, 5, 6], successThreshold = 10",
        "output": "[3, 2, 1]",
        "explanation": "For spell 1: (1,4), (1,5), (1,6) are successful;\\nFor spell 2: (2,4), (2,5) are successful;\\nFor spell 3: (3,4) is successful."
      },
      {
        "input": "spells = [3, 1, 4], potions = [5, 2], successThreshold = 15",
        "output": "[1, 0, 1]",
        "explanation": "Only spell 1 and spell 3 with potion 5 can successfully form pairs."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the potions to optimize pair counting.",
      "Use binary search to find the threshold quickly."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Keep Multiplying Found Values by Two",
    "description": "Given an array of integers, you need to keep multiplying the numbers that are present in the array by two until they are no longer found in the array. The task is to return the resulting array after all the multiplications are performed. The array should contain the unique values after all operations.",
    "topic": "Array",
    "subtopic": "Transformation",
    "tags": [
      "Array",
      "Transformation",
      "Multiplication"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An array of unique integers after applying the multiplication operations.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 4]",
        "output": "[8, 6]",
        "explanation": "Starting with 2: multiply by 2 (4), find 4 again: multiply by 2 (8). 3 remains as it is after one multiplication."
      },
      {
        "input": "nums = [1, 2, 4]",
        "output": "[8, 2]",
        "explanation": "Start with 2: multiply by 2 (4), find 4: multiply by 2 (8). 1 does not multiply further."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a set to track the numbers that need to be processed.",
      "Continue multiplying until a number cannot be found in the array."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Count Number of Texts",
    "description": "You are given a string representing a body of text. Your task is to count the number of sentences in the text. A sentence is defined as any sequence of characters that ends with either a period (.), an exclamation mark (!), or a question mark (?). For the purpose of this problem, any leading or trailing whitespace should be ignored.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Counting",
      "Manipulation"
    ],
    "input_format": "A single string `text` representing the body of text.",
    "output_format": "An integer representing the number of sentences in the text.",
    "constraints": [
      "1 <= text.length <= 10^5"
    ],
    "examples": [
      {
        "input": "Hello, world! How are you? I hope you're doing well.",
        "output": "3",
        "explanation": "There are three sentences in the text: 'Hello, world!', 'How are you?' and 'I hope you're doing well.'"
      },
      {
        "input": "  Is this a question?  Yes, it is!  ",
        "output": "2",
        "explanation": "Two sentences are present: 'Is this a question?' and 'Yes, it is!'. Whitespace is ignored."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use string methods to split the text.",
      "Consider regular expressions to help identify sentence-ending punctuation."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Jump Game",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to determine if you can reach the last index starting from the first index. Return true if you can reach the last index, otherwise return false.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "A boolean value indicating whether you can reach the last index.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "[2, 3, 1, 1, 4]",
        "output": "true",
        "explanation": "From index 0, you can jump to index 1 (3) or index 2 (1). From index 1, you can jump to index 4 (4) and reach the last index."
      },
      {
        "input": "[3, 2, 1, 0, 4]",
        "output": "false",
        "explanation": "It is not possible to reach the last index in this case as index 3 is the furthest point you can reach but cannot reach index 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to maintain the farthest index reachable as you iterate through the array.",
      "If at any point the current index surpasses the farthest reachable index, return false."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Search a 2D Matrix",
    "description": "Write an efficient algorithm to determine if a target value exists in a 2D matrix. This matrix has the following properties: 1) Integers in each row are sorted from left to right. 2) The first integer of each row is greater than the last integer of the previous row. You must write a solution in O(log(m*n)) time complexity where m is the number of rows and n is the number of columns.",
    "topic": "Matrix",
    "subtopic": "Binary Search",
    "tags": [
      "Matrix",
      "Binary Search",
      "Algorithm"
    ],
    "input_format": "A 2D matrix of integers and an integer target.",
    "output_format": "A boolean indicating whether the target exists in the matrix.",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 100",
      "-10^4 <= matrix[i][j], target <= 10^4"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [15, 17, 19]], target = 9",
        "output": "True",
        "explanation": "The target value 9 is present in the matrix."
      },
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [15, 17, 19]], target = 4",
        "output": "False",
        "explanation": "The target value 4 is not present in the matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider treating the 2D matrix as a 1D array to leverage binary search.",
      "Calculate the index in the 2D matrix using row and column indices."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Product of Array Except Self",
    "description": "Given an array nums of n integers where n > 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. You must solve it without using division and in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Product",
    "tags": [
      "Array",
      "Product",
      "Prefix and Suffix"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An array of integers output where output[i] is the product of all elements of nums except nums[i].",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-30 <= nums[i] <= 30",
      "The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer."
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "[24, 12, 8, 6]",
        "explanation": "For the input array [1, 2, 3, 4], the output array is calculated as follows: output[0] = 2 * 3 * 4 = 24, output[1] = 1 * 3 * 4 = 12, output[2] = 1 * 2 * 4 = 8, output[3] = 1 * 2 * 3 = 6."
      },
      {
        "input": "nums = [-1, 1, 0, -3, 3]",
        "output": "[0, 0, 9, 0, 0]",
        "explanation": "For the input array [-1, 1, 0, -3, 3], the output is calculated as: output[0] = 1 * 0 * -3 * 3 = 0, output[1] = -1 * 0 * -3 * 3 = 0, output[2] = -1 * 1 * -3 * 3 = 9, output[3] = -1 * 1 * 0 * 3 = 0, output[4] = -1 * 1 * 0 * -3 = 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider calculating the prefix and suffix products separately.",
      "You can store prefix products in an array and use it to calculate the result in a second pass."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "String to Integer (atoi)",
    "description": "Implement the function myAtoi(string s) that converts a string to a 32-bit signed integer. The function first discards any whitespace characters. Then, starting from the first non-whitespace character, it takes an optional initial plus or minus sign followed by as many numerical digits as possible. The string conversion stops when the next non-digit character is encountered. Finally, the function returns the converted integer. If no valid conversion could be performed, it returns 0. Note that the integer must fit in a 32-bit signed integer range [-231, 231 - 1].",
    "topic": "String",
    "subtopic": "Parsing",
    "tags": [
      "String",
      "Parsing",
      "Conversion"
    ],
    "input_format": "A single string s that represents the input.",
    "output_format": "A 32-bit signed integer after conversion.",
    "constraints": [
      "-2^31 <= result <= 2^31 - 1",
      "The input string is guaranteed not to exceed 5 characters in length for extreme cases."
    ],
    "examples": [
      {
        "input": "s = '42'",
        "output": "42",
        "explanation": "The string '42' can be converted directly to the integer 42."
      },
      {
        "input": "s = '   -42'",
        "output": "-42",
        "explanation": "Leading whitespace is ignored, and the integer part is '-42'."
      },
      {
        "input": "s = 'words and 987'",
        "output": "0",
        "explanation": "No valid conversion could be performed due to the presence of non-digit characters before the number."
      },
      {
        "input": "s = '-91283472332'",
        "output": "-2147483648",
        "explanation": "The number exceeds the 32-bit signed integer range, so we return the minimum value."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the whitespace at the start of the string.",
      "Don't forget to handle overflow cases for 32-bit signed integers."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Subarray Sum Equals K",
    "description": "Given an array of integers and an integer k, return the total number of continuous subarrays whose sum equals to k.",
    "topic": "Array",
    "subtopic": "Prefix Sum",
    "tags": [
      "Array",
      "Hash Table",
      "Prefix Sum"
    ],
    "input_format": "An integer array nums and an integer k.",
    "output_format": "An integer representing the count of continuous subarrays whose sum equals k.",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-1000 <= nums[i] <= 1000",
      "-10^7 <= k <= 10^7"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 1], k = 2",
        "output": "2",
        "explanation": "The subarrays [1,1] (starting at index 0 and 1) are the only two continuous subarrays whose sum equals 2."
      },
      {
        "input": "nums = [1, 2, 3], k = 3",
        "output": "2",
        "explanation": "The subarrays [3] (starting at index 2) and [1, 2] (starting at index 0) both sum to 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map to store the cumulative sum and its frequency.",
      "A prefix sum array is useful to track sums up to the current index."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "House Robber",
    "description": "You are a professional robber planning to steal houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from stealing from two houses adjacent to each other. Given an integer array 'nums' representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "topic": "Dynamic Programming",
    "subtopic": "Memoization",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Recursion"
    ],
    "input_format": "An integer array 'nums' where nums[i] represents the amount of money at the (i+1)-th house.",
    "output_format": "An integer representing the maximum amount of money that can be robbed.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 400"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "4",
        "explanation": "Robbing house 1 (amount = 1) and house 3 (amount = 3) is better than robbing houses 1 and 2."
      },
      {
        "input": "nums = [2, 7, 9, 3, 1]",
        "output": "12",
        "explanation": "Robbing house 2 (amount = 7) and house 4 (amount = 3) and house 5 (amount = 1) gives a total of 12."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how you can use dynamic programming to store results of smaller subproblems.",
      "Consider if you can break down the problem into decisions between robbing a house or skipping it."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Word Search",
    "description": "Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where 'adjacent' cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "topic": "Backtracking",
    "subtopic": "Matrix",
    "tags": [
      "Backtracking",
      "DFS",
      "Matrix"
    ],
    "input_format": "A 2D board consisting of characters and a string word to search.",
    "output_format": "A boolean indicating whether the word exists in the grid.",
    "constraints": [
      "1 <= board.length, board[i].length <= 200",
      "board[i][j] is a lowercase English letter.",
      "1 <= word.length <= 15"
    ],
    "examples": [
      {
        "input": "board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], word = 'ABCCED'",
        "output": "true",
        "explanation": "The word 'ABCCED' can be constructed from the letters of the board."
      },
      {
        "input": "board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], word = 'SEE'",
        "output": "true",
        "explanation": "The word 'SEE' can be found in the grid."
      },
      {
        "input": "board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], word = 'ABCB'",
        "output": "false",
        "explanation": "The word 'ABCB' cannot be constructed as the letter 'B' cannot be reused."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use Depth First Search to explore the potential paths.",
      "Make sure to mark cells as visited to avoid reusing them.",
      "Consider the boundaries of the board when checking adjacent cells."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Pow(x, n)",
    "description": "Implement a function that calculates x raised to the power of n, where x is a floating-point number and n is an integer. The function should handle negative and fractional powers as well.",
    "topic": "Mathematics",
    "subtopic": "Exponential",
    "tags": [
      "Mathematics",
      "Exponential",
      "Recursion"
    ],
    "input_format": "Two values x (float) and n (int), where x represents the base and n represents the exponent.",
    "output_format": "A float representing the result of x raised to the power n.",
    "constraints": [
      "-100.0 < x < 100.0",
      "-2^31 <= n <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 2.0, n = 10",
        "output": "1024.0",
        "explanation": "2.0 raised to the power of 10 is 1024.0."
      },
      {
        "input": "x = 2.1, n = 3",
        "output": "9.261",
        "explanation": "2.1 raised to the power of 3 is approximately 9.261."
      },
      {
        "input": "x = 2.0, n = -2",
        "output": "0.25",
        "explanation": "2.0 raised to the power of -2 is 1/(2.0^2) = 0.25."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion to simplify the calculations.",
      "Handle the case when n is negative separately.",
      "Think about the properties of exponents while calculating."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Linked List Cycle",
    "description": "Given a linked list, determine if it has a cycle in it. A cycle is defined as a node's next pointer pointing to an earlier node in the list, which creates a loop.",
    "topic": "Linked List",
    "subtopic": "Cycle Detection",
    "tags": [
      "Linked List",
      "Cycle Detection"
    ],
    "input_format": "A linked list represented by a head node.",
    "output_format": "Return true if the linked list has a cycle, otherwise return false.",
    "constraints": [
      "The number of nodes in the linked list can be at most 10^4.",
      "The node values can be any integer."
    ],
    "examples": [
      {
        "input": "head = [3, 2, 0, -4], pos = 1",
        "output": "true",
        "explanation": "The linked list has a cycle where the node with value 2 points back to the node with value 3."
      },
      {
        "input": "head = [1, 2], pos = 0",
        "output": "true",
        "explanation": "The linked list has a cycle where the node with value 2 points back to the node with value 1."
      },
      {
        "input": "head = [1], pos = -1",
        "output": "false",
        "explanation": "The linked list has no cycle."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using Floyd's Tortoise and Hare algorithm for cycle detection.",
      "Maintain two pointers to traverse the list; one moves faster than the other."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Next Permutation",
    "description": "Implement the function nextPermutation that takes an array of integers and rearranges the numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it to the lowest possible order (i.e., sorted in ascending order). The algorithm should run in place and use O(1) additional memory.",
    "topic": "Array",
    "subtopic": "Permutations",
    "tags": [
      "Array",
      "Permutation",
      "In-place"
    ],
    "input_format": "An array of integers nums representing the current permutation.",
    "output_format": "An array of integers representing the next permutation of nums.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[1, 3, 2]",
        "explanation": "The next permutation of [1, 2, 3] is [1, 3, 2]."
      },
      {
        "input": "nums = [3, 2, 1]",
        "output": "[1, 2, 3]",
        "explanation": "The next permutation of [3, 2, 1] is the lowest permutation [1, 2, 3]."
      },
      {
        "input": "nums = [1, 1, 5]",
        "output": "[1, 5, 1]",
        "explanation": "The next permutation of [1, 1, 5] is [1, 5, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to find the largest index k such that nums[k] < nums[k + 1].",
      "If no such index exists, the permutation is the last permutation.",
      "Find the largest index l greater than k such that nums[k] < nums[l].",
      "Swap elements at indices k and l, then reverse the sequence from k + 1 to the end."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "topic": "Dynamic Programming",
    "subtopic": "Fibonacci Sequence",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Fibonacci"
    ],
    "input_format": "An integer n, the number of steps in the staircase.",
    "output_format": "An integer representing the number of distinct ways to climb to the top.",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: 1 step + 1 step or 2 steps."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, or 2 steps + 1 step."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Think about breaking down the problem into smaller subproblems.",
      "You can express the number of ways to climb n steps in terms of ways to climb n-1 and n-2 steps."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Missing Number",
    "description": "Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one number that is missing from the array. Your solution should have a linear runtime complexity and use only constant extra space.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Bit Manipulation"
    ],
    "input_format": "An array of integers nums of length n, where 0 <= nums[i] <= n.",
    "output_format": "An integer representing the missing number.",
    "constraints": [
      "1 <= n <= 10^4",
      "All numbers in nums are distinct."
    ],
    "examples": [
      {
        "input": "nums = [3, 0, 1]",
        "output": "2",
        "explanation": "The numbers from 0 to 3 are [0, 1, 2, 3]. The missing number is 2."
      },
      {
        "input": "nums = [0, 1]",
        "output": "2",
        "explanation": "The numbers from 0 to 2 are [0, 1, 2]. The missing number is 2."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using the formula for the sum of the first n natural numbers.",
      "Utilize the properties of XOR operations."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Find Peak Element",
    "description": "A peak element in an array is an element that is strictly greater than its neighbors. Given an integer array nums, you need to find a peak element and return its index. If the array contains multiple peaks, return the index to any one of the peaks.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Peak Element"
    ],
    "input_format": "An integer array nums of length n.",
    "output_format": "An integer representing the index of a peak element.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "\u221210^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "2",
        "explanation": "The peak element is 3 at index 2."
      },
      {
        "input": "nums = [1, 2, 1, 3, 5, 6, 4]",
        "output": "1 or 5",
        "explanation": "The peak elements are 2 at index 1 and 6 at index 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a binary search approach to find the peak efficiently.",
      "A peak can be at the ends of the array."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Minimum Size Subarray Sum",
    "description": "Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An integer representing the minimal length of the subarray, or 0 if no such subarray exists.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i] <= 10^4",
      "1 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2,3,1,2,4,3], target = 7",
        "output": "2",
        "explanation": "The subarray [4,3] has the minimal length 2 and a sum of 7."
      },
      {
        "input": "nums = [1,4,4], target = 4",
        "output": "1",
        "explanation": "The subarray [4] meets the requirement with the minimal length of 1."
      },
      {
        "input": "nums = [1,1,1,1,1,1], target = 11",
        "output": "0",
        "explanation": "There is no subarray whose sum is 11 or greater."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window approach to maintain the range of the subarray.",
      "Keep a running sum and adjust the left pointer to minimize the subarray length."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Sqrt(x)",
    "description": "Implement an algorithm to compute the square root of a non-negative integer x, returning the integer part of the square root. You may not use any built-in exponentiation or square root functions. Your solution should be optimized for both time and space complexity.",
    "topic": "Math",
    "subtopic": "Binary Search",
    "tags": [
      "Math",
      "Binary Search",
      "Square Root"
    ],
    "input_format": "A non-negative integer x.",
    "output_format": "An integer representing the largest integer y such that y*y <= x.",
    "constraints": [
      "0 <= x <= 10^7"
    ],
    "examples": [
      {
        "input": "x = 4",
        "output": "2",
        "explanation": "The square root of 4 is 2."
      },
      {
        "input": "x = 8",
        "output": "2",
        "explanation": "The square root of 8 is approximately 2.828, and the integer part is 2."
      },
      {
        "input": "x = 0",
        "output": "0",
        "explanation": "The square root of 0 is 0."
      },
      {
        "input": "x = 1",
        "output": "1",
        "explanation": "The square root of 1 is 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using binary search to narrow down the range.",
      "The square of the midpoint can help determine which way to adjust the search."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Insert Delete GetRandom O(1)",
    "description": "Design a data structure that supports the following operations in average O(1) time complexity: insert, delete, and getRandom. Implement the data structure as a class. The insert operation should add an element to the set, the delete operation should remove an element from the set, and the getRandom operation should return a random element from the set. All elements are unique when inserted. Note that you should not use any built-in libraries such as random or collections.",
    "topic": "Design",
    "subtopic": "Data Structure",
    "tags": [
      "Design",
      "Hash Table",
      "Random"
    ],
    "input_format": "You need to implement the class RandomizedSet which supports the following methods: insert(val: int) -> bool, remove(val: int) -> bool, getRandom() -> int.",
    "output_format": "The insert and remove methods return a boolean indicating whether the insertion or deletion was successful, and the getRandom method returns an integer from the set.",
    "constraints": [
      "All values will be unique and in the range of -10^6 to 10^6.",
      "The number of calls to insert, remove and getRandom is less than or equal to 2 * 10^4."
    ],
    "examples": [
      {
        "input": "RandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1);\nrandomizedSet.remove(2);\nrandomizedSet.insert(2);\nrandomizedSet.getRandom(); // should return 1 or 2 randomly",
        "output": "true, false, true, 1 or 2",
        "explanation": "First, we insert 1 and attempt to remove 2, which fails. Then, we successfully insert 2. The getRandom method can return either 1 or 2 since both are present in the set."
      },
      {
        "input": "randomizedSet.remove(1); // returns true because 1 was inserted.\nrandomizedSet.insert(2);\nrandomizedSet.getRandom(); // should return 2.",
        "output": "true, true, 2",
        "explanation": "We remove 1 from the set and successfully insert 2. Now, getRandom returns 2, as it is the only element."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to store the values and their indices.",
      "Maintain an array to keep track of the elements for O(1) access."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Minimum Number of Arrows to Burst Balloons",
    "description": "There are several balloons stuck on a 2D plane. Each balloon is represented by a vertical line at point x between `x_start` and `x_end`, where `x_start` is the starting point and `x_end` is the ending point of the balloon. To burst all the balloons, you need to shoot arrows. An arrow can be shot vertically at any point along the x-axis. A single arrow can burst multiple balloons if it can hit them all. Determine the minimum number of arrows needed to burst all the balloons.",
    "topic": "Greedy",
    "subtopic": "Interval Scheduling",
    "tags": [
      "Greedy",
      "Intervals"
    ],
    "input_format": "An array of intervals `balloons`, where each interval is represented as a list of two integers `[x_start, x_end]`.",
    "output_format": "An integer representing the minimum number of arrows needed.",
    "constraints": [
      "1 <= balloons.length <= 10^4",
      "balloons[i].length == 2",
      "-10^9 <= balloons[i][0] < balloons[i][1] <= 10^9"
    ],
    "examples": [
      {
        "input": "balloons = [[10,16],[2,8],[1,6],[7,12]]",
        "output": "2",
        "explanation": "Shoot an arrow at x = 6 and another at x = 10 to burst all balloons."
      },
      {
        "input": "balloons = [[1,2],[3,4],[5,6],[7,8]]",
        "output": "4",
        "explanation": "Each balloon is separate and requires its own arrow."
      },
      {
        "input": "balloons = [[1,2],[2,3],[3,4],[4,5]]",
        "output": "2",
        "explanation": "One arrow can be shot at x = 2 to burst balloons 1 and 2, and another at x = 4 for balloons 3 and 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the balloons by their ending positions.",
      "Use a greedy approach to find the minimum number of arrows."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Top K Frequent Elements",
    "description": "Given a non-empty array of integers, return the k most frequent elements. You may return the answer in any order.",
    "topic": "Heap",
    "subtopic": "Frequency Count",
    "tags": [
      "Hash Map",
      "Heap",
      "Count Frequencies"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "A list of the k most frequent elements.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= nums[i] <= 10^4",
      "k is guaranteed to be in the range [1, the number of unique elements in the array]."
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3], k = 2",
        "output": "[1, 2]",
        "explanation": "The element 1 appears 3 times and element 2 appears 2 times. Thus, the top 2 frequent elements are 1 and 2."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "There is only one element in the array, so the top 1 frequent element is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to count the frequency of each element.",
      "Consider using a heap to store the top k elements."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Maximum Product Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest product, and return that product. You may assume that the input array is non-empty and the result will fit in a 32-bit integer.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Product"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum product of a contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, -2, 4]",
        "output": "6",
        "explanation": "The subarray [2, 3] has the largest product 6."
      },
      {
        "input": "nums = [-2, 0, -1]",
        "output": "0",
        "explanation": "The subarray [0] has the largest product 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider both negative and positive products.",
      "Keep track of the maximum and minimum product at each position."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Candy",
    "description": "There are n children standing in a line. Each child is assigned a rating value, represented by an integer array ratings. You need to distribute candies to these children based on the following two requirements: Each child must have at least one candy, and any child with a higher rating than their neighbor must receive more candies than that neighbor. Your task is to determine the minimum number of candies you need to distribute to satisfy these conditions.",
    "topic": "Greedy",
    "subtopic": "Array",
    "tags": [
      "Greedy",
      "Array",
      "Dynamic Programming"
    ],
    "input_format": "An integer array ratings representing the rating of each child.",
    "output_format": "An integer representing the minimum number of candies required.",
    "constraints": [
      "1 <= ratings.length <= 2 * 10^4",
      "0 <= ratings[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "ratings = [1, 0, 2]",
        "output": "5",
        "explanation": "You can give 2 candies to the first child, 1 to the second, and 2 to the third, giving a total of 5 candies."
      },
      {
        "input": "ratings = [1, 2, 2]",
        "output": "4",
        "explanation": "You can give 1 candy to the first child, 2 to the second, and 1 to the third, which yields a total of 4 candies."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider distributing candies from both ends of the array to manage relationships between neighboring children.",
      "Use two passes: one from left to right and another from right to left to ensure both conditions are met."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Pascal's Triangle",
    "description": "Given a non-negative integer numRows, return the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it. The triangle's first few rows are: \n\n 1\n 1 1\n 1 2 1\n 1 3 3 1\n 1 4 6 4 1\n 1 5 10 10 5 1",
    "topic": "Dynamic Programming",
    "subtopic": "Combinatorics",
    "tags": [
      "Dynamic Programming",
      "Combinatorics",
      "Triangle"
    ],
    "input_format": "An integer numRows representing the number of rows in Pascal's triangle.",
    "output_format": "A list of lists of integers representing the first numRows of Pascal's triangle.",
    "constraints": [
      "0 <= numRows <= 30"
    ],
    "examples": [
      {
        "input": "numRows = 5",
        "output": "[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
        "explanation": "The first 5 rows of Pascal's triangle are 1, [1, 1], [1, 2, 1], [1, 3, 3, 1], and [1, 4, 6, 4, 1]."
      },
      {
        "input": "numRows = 0",
        "output": "[]",
        "explanation": "With 0 rows, the output is an empty list."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how each number in the triangle is formed from the previous row."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Pascal's Triangle II",
    "description": "Given an integer rowIndex, return the rowIndex th (0-indexed) row of the Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it. The triangle starts with the row 0, which is [1].",
    "topic": "Dynamic Programming",
    "subtopic": "Combinatorics",
    "tags": [
      "Dynamic Programming",
      "Combinatorics",
      "Pascal's Triangle"
    ],
    "input_format": "An integer rowIndex representing the index of the row in Pascal's triangle to be returned.",
    "output_format": "A list of integers representing the elements of the rowIndex th row of Pascal's triangle.",
    "constraints": [
      "0 <= rowIndex <= 33"
    ],
    "examples": [
      {
        "input": "rowIndex = 3",
        "output": "[1, 3, 3, 1]",
        "explanation": "The 3rd row of Pascal's triangle is [1, 3, 3, 1]."
      },
      {
        "input": "rowIndex = 0",
        "output": "[1]",
        "explanation": "The 0th row of Pascal's triangle is [1]."
      },
      {
        "input": "rowIndex = 1",
        "output": "[1, 1]",
        "explanation": "The 1st row of Pascal's triangle is [1, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Each element can be computed from the two elements above it.",
      "Consider using a single array to store the current row."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Intersection of Two Linked Lists",
    "description": "Given the heads of two singly linked lists, determine the node at which the two lists intersect. If there is no intersection, return null. The intersection node is defined as the node where the two lists merge.",
    "topic": "Linked List",
    "subtopic": "Intersection",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Intersection"
    ],
    "input_format": "The input consists of two linked list heads, headA and headB.",
    "output_format": "Return the node where the two linked lists intersect, or null if they do not intersect.",
    "constraints": [
      "The number of nodes in both linked lists is in the range [0, 10^4].",
      "The values of the nodes are in the range [-10^4, 10^4].",
      "If the linked lists intersect, the intersecting node is guaranteed to be present in both link lists."
    ],
    "examples": [
      {
        "input": "headA = [4, 1, 8, 4, 5], headB = [5, 0, 1, 8, 4, 5]",
        "output": "8",
        "explanation": "The lists intersect at node with value 8."
      },
      {
        "input": "headA = [1, 9, 1, 2, 4], headB = [3, 2, 4]",
        "output": "2",
        "explanation": "The lists intersect at node with value 2."
      },
      {
        "input": "headA = [2, 6, 4], headB = [1, 5]",
        "output": "null",
        "explanation": "The two lists do not intersect."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to traverse both lists.",
      "If a pointer reaches the end of one list, redirect it to the head of the other list."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. The spiral order is defined as starting from the top-left corner, moving to the right, then downward, then to the left, and finally upward, continuously circling the matrix until all elements are returned.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral"
    ],
    "input_format": "A 2D array of integers representing the matrix.",
    "output_format": "A 1D array of integers representing the elements in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "The total number of elements in the matrix will not exceed 10^4."
    ],
    "examples": [
      {
        "input": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The elements are traversed in the following order: 1 \u2192 2 \u2192 3 \u2192 6 \u2192 9 \u2192 8 \u2192 7 \u2192 4 \u2192 5."
      },
      {
        "input": "[[1]]",
        "output": "[1]",
        "explanation": "The only element in the matrix is 1."
      },
      {
        "input": "[[1, 2], [3, 4]]",
        "output": "[1, 2, 4, 3]",
        "explanation": "The elements are traversed in the order: 1 \u2192 2 \u2192 4 \u2192 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about the direction of your traversal: right \u2192 down \u2192 left \u2192 up.",
      "Use four variables to track the boundaries of the spiral."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Count Number of Pairs With Absolute Difference K",
    "description": "Given an array of integers and an integer k, your task is to count the number of unique pairs (i, j) such that the absolute difference between nums[i] and nums[j] is k. Note that the pair (i, j) is considered the same as (j, i), and you should count each unique pair only once.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An integer representing the number of unique pairs with absolute difference k.",
    "constraints": [
      "1 <= nums.length <= 20000",
      "-10^9 <= nums[i] <= 10^9",
      "0 <= k <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5], k = 2",
        "output": "3",
        "explanation": "The unique pairs with absolute difference 2 are (1, 3), (2, 4), and (3, 5)."
      },
      {
        "input": "nums = [1, 1, 1, 1], k = 0",
        "output": "1",
        "explanation": "The only unique pair with absolute difference 0 is (1, 1)."
      },
      {
        "input": "nums = [3, 1, 4, 1, 5], k = 2",
        "output": "3",
        "explanation": "The unique pairs with absolute difference 2 are (1, 3), (3, 5), and (1, 3)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a set to keep track of elements you've seen.",
      "Think about how you can find a complement that would give you the desired difference."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Letter Combinations of a Phone Number",
    "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below:\n\n2 -> 'abc'\n3 -> 'def'\n4 -> 'ghi'\n5 -> 'jkl'\n6 -> 'mno'\n7 -> 'pqrs'\n8 -> 'tuv'\n9 -> 'wxyz'\n\nNote that 0 and 1 do not map to any letters. Therefore, if the input is empty or contains 0 or 1, you should return an empty list.",
    "topic": "String",
    "subtopic": "Backtracking",
    "tags": [
      "String",
      "Backtracking",
      "Combinations"
    ],
    "input_format": "A string digits (1 <= digits.length <= 4).",
    "output_format": "A list of strings representing all possible letter combinations.",
    "constraints": [
      "The input string contains digits from 2 to 9."
    ],
    "examples": [
      {
        "input": "digits = '23'",
        "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
        "explanation": "The digits '2' and '3' map to 'abc' and 'def'. The combinations are formed by taking one letter from each mapping."
      },
      {
        "input": "digits = ''",
        "output": "[]",
        "explanation": "An empty input results in an empty output."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a backtracking approach to explore all combinations.",
      "Use a mapping to store letters corresponding to each digit."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Find Median from Data Stream",
    "description": "Design a data structure that supports the following two operations: adding a number to the data stream and finding the median of all numbers added so far. The median is the number that separates the higher half from the lower half of the numbers. If there is an even number of numbers, the median is the average of the two middle numbers.",
    "topic": "Data Structure",
    "subtopic": "Heap",
    "tags": [
      "Heap",
      "Data Structure",
      "Median"
    ],
    "input_format": "A sequence of integers, where each integer is added to the data stream one at a time.",
    "output_format": "A floating-point number representing the median of the added numbers after each insertion.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "addNum(1), addNum(2), findMedian()",
        "output": "1.5",
        "explanation": "After adding 1 and 2, the numbers are [1, 2]. The median is (1 + 2) / 2 = 1.5."
      },
      {
        "input": "addNum(3), findMedian()",
        "output": "2.0",
        "explanation": "After adding 3, the numbers are [1, 2, 3]. The median is 2."
      },
      {
        "input": "addNum(4), addNum(5), findMedian()",
        "output": "3.0",
        "explanation": "After adding 4 and 5, the numbers are [1, 2, 3, 4, 5]. The median is 3."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use two heaps to maintain the lower and upper halves of the numbers.",
      "Balance the two heaps to keep the sizes equal or the lower half one larger."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Maximum XOR of Two Numbers in an Array",
    "description": "Given an array of non-negative integers, you are to find the maximum possible XOR of any two numbers in the array. The XOR operation is defined as a bitwise operation that takes two binary representations and performs an exclusive or operation on each corresponding pair of bits. Your task is to compute the maximum XOR value that can be obtained by any two numbers in the input array.",
    "topic": "Bit Manipulation",
    "subtopic": "XOR Operation",
    "tags": [
      "Bit Manipulation",
      "XOR",
      "Maximum"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "An integer representing the maximum XOR of any two numbers from the input array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= nums[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [3, 10, 5, 25, 2, 8]",
        "output": "28",
        "explanation": "The maximum XOR is obtained from 5 and 25: 5 (binary 0101) XOR 25 (binary 11001) = 28 (binary 11100)."
      },
      {
        "input": "nums = [0, 1, 2, 3, 4]",
        "output": "7",
        "explanation": "The maximum XOR is obtained from 3 and 4: 3 (binary 11) XOR 4 (binary 100) = 7 (binary 111)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a trie to optimize the search for maximum XOR.",
      "The properties of the XOR operation can help in finding two numbers that maximize the result."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array nums, find the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses constant extra space.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Mathematics"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the smallest missing positive integer.",
    "constraints": [
      "0 <= nums.length <= 300",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [3, 4, -1, 1]",
        "output": "2",
        "explanation": "The smallest missing positive integer is 2."
      },
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "The smallest missing positive integer is 3."
      },
      {
        "input": "nums = [7, 8, 9, 11, 12]",
        "output": "1",
        "explanation": "The smallest missing positive integer is 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the range of positive integers.",
      "Try to place each number in its correct index."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Maximal Square",
    "description": "Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "Matrix",
    "tags": [
      "Dynamic Programming",
      "Matrix",
      "Array"
    ],
    "input_format": "A 2D binary matrix as a list of lists.",
    "output_format": "An integer representing the area of the largest square containing only 1's.",
    "constraints": [
      "1 <= matrix.length <= 300",
      "1 <= matrix[i].length <= 300",
      "matrix[i][j] is either '0' or '1'."
    ],
    "examples": [
      {
        "input": "matrix = [['1', '0', '1', '0', '0'], ['1', '0', '1', '1', '1'], ['1', '1', '1', '1', '1'], ['1', '0', '0', '1', '0']]",
        "output": "4",
        "explanation": "The largest square has a length of 2, hence the area is 2 * 2 = 4."
      },
      {
        "input": "matrix = [['0', '1'], ['1', '1']]",
        "output": "1",
        "explanation": "The largest square has a length of 1, hence the area is 1 * 1 = 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use dynamic programming to store the size of the largest square ending at each point.",
      "The size of the square at a cell depends on the minimum size of squares to the left, top, and top-left."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Decode String",
    "description": "Given an encoded string, return its decoded version. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. For example, 3[abc]2[ab] returns 'abcabcabcabab'. Note that the input string is always valid and no extra spaces are present.",
    "topic": "String",
    "subtopic": "Decoding",
    "tags": [
      "String",
      "Decoding",
      "Stack"
    ],
    "input_format": "A single string 's' representing the encoded string.",
    "output_format": "A string representing the decoded output.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of lowercase English letters, digits, and square brackets."
    ],
    "examples": [
      {
        "input": "s = \"3[abc]2[ab]\"",
        "output": "abcabcabcabab",
        "explanation": "The first part '3[abc]' decodes to 'abcabcabc', and '2[ab]' decodes to 'abab'. Combining them gives 'abcabcabcabab'."
      },
      {
        "input": "s = \"2[3[a]b]\"",
        "output": "aaabaaab",
        "explanation": "The inner decoding '3[a]' gives 'aaa', which is then multiplied by 2 to give 'aaabaaab'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to manage characters and numbers.",
      "Keep track of the current number while iterating through the string."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Roman to Integer",
    "description": "Convert a given Roman numeral string to its integer equivalent. The Roman numeral system uses the following symbols: I (1), V (5), X (10), L (50), C (100), D (500), M (1000). The numerals are usually written from largest to smallest from left to right. However, there are exceptions where a smaller numeral precedes a larger numeral to indicate subtraction, such as IV (4) and IX (9).",
    "topic": "String Manipulation",
    "subtopic": "Parsing",
    "tags": [
      "String",
      "Conversion",
      "Mathematics"
    ],
    "input_format": "A string representing a Roman numeral.",
    "output_format": "An integer representing the equivalent value of the Roman numeral.",
    "constraints": [
      "1 <= s.length <= 15",
      "s consists of the characters 'I', 'V', 'X', 'L', 'C', 'D', 'M'."
    ],
    "examples": [
      {
        "input": "s = 'III'",
        "output": "3",
        "explanation": "The Roman numeral III is 3 in integer."
      },
      {
        "input": "s = 'IV'",
        "output": "4",
        "explanation": "The Roman numeral IV represents 5 - 1 = 4."
      },
      {
        "input": "s = 'IX'",
        "output": "9",
        "explanation": "The Roman numeral IX represents 10 - 1 = 9."
      },
      {
        "input": "s = 'LVIII'",
        "output": "58",
        "explanation": "The Roman numeral LVIII is 50 + 5 + 3 = 58."
      },
      {
        "input": "s = 'MCMXCIV'",
        "output": "1994",
        "explanation": "The Roman numeral MCMXCIV represents 1000 + (1000 - 100) + (1000 - 10) + 5 = 1994."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a mapping for Roman characters to their integer values.",
      "Keep track of the previous numeral to handle subtraction cases."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "The Skyline Problem",
    "description": "Given a list of buildings represented by their coordinates in a 2D plane, where each building is defined by its left edge, right edge, and height, return the coordinates of the outline formed by these buildings. The outline should represent the silhouette formed when the buildings are viewed from a distance.",
    "topic": "Geometry",
    "subtopic": "Silhouette Problem",
    "tags": [
      "Geometry",
      "Silhouette",
      "Sorting"
    ],
    "input_format": "A list of buildings where each building is defined as a list of three integers: [left, right, height].",
    "output_format": "A list of points (x, y) where each point represents a corner of the outline in the order they appear from left to right.",
    "constraints": [
      "1 <= buildings.length <= 10^4",
      "0 <= left < right <= 10^9",
      "1 <= height <= 10^9"
    ],
    "examples": [
      {
        "input": "[[2,9,10],[3,7,15],[15,20,10],[5,12,12]]",
        "output": "[[2,10],[3,15],[7,12],[12,0],[15,10],[20,0]]",
        "explanation": "The outline formed by the buildings will have points indicating the transitions in height."
      },
      {
        "input": "[[0,2,3],[2,5,3]]",
        "output": "[[0,3],[2,3],[5,0]]",
        "explanation": "Both buildings share the same height, resulting in a continuous outline."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a priority queue to manage the heights of buildings.",
      "Use a sweep line algorithm to identify critical points.",
      "Track the height changes at points where the buildings start and end."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Gas Station",
    "description": "There are n gas stations along a circular route, where the amount of gas at the i-th station is gas[i]. You also have a car with a tank capacity of infinite size, and you can travel an infinite distance if you have enough gas. However, each gas station has a cost of gas needed to reach the next station, given by cost[i]. Your task is to determine the starting gas station index from which you can travel around the circuit once without running out of gas. If there is no such station, return -1.",
    "topic": "Greedy",
    "subtopic": "Circular Array",
    "tags": [
      "Greedy",
      "Array",
      "Simulation"
    ],
    "input_format": "Two arrays of integers, gas and cost, where gas[i] is the gas available at the i-th station and cost[i] is the cost to travel to the next station.",
    "output_format": "An integer representing the starting gas station index, or -1 if it's not possible to complete the circuit.",
    "constraints": [
      "n == gas.length == cost.length",
      "1 <= n <= 10^4",
      "0 <= gas[i], cost[i] <= 10^4"
    ],
    "examples": [
      {
        "input": {
          "gas": [
            1,
            2,
            3,
            4,
            5
          ],
          "cost": [
            3,
            4,
            5,
            1,
            2
          ]
        },
        "output": "3",
        "explanation": "Starting at station 3, we can travel around the circuit once."
      },
      {
        "input": {
          "gas": [
            2,
            3,
            4
          ],
          "cost": [
            3,
            4,
            3
          ]
        },
        "output": "-1",
        "explanation": "There is no station from which we can complete the circuit."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the net gain of gas at each station.",
      "If you can't reach station i, you won't be able to reach any station after it."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Next Greater Element I",
    "description": "You are given two arrays, 'nums1' and 'nums2', where 'nums1' is a subset of 'nums2'. For each element in 'nums1', find the next greater element in 'nums2'. If there is no next greater element, return -1 for that element. The next greater element is the first greater element that is to the right of the current element in 'nums2'.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "input_format": "Two lists of integers, nums1 and nums2, where nums1 is a subset of nums2.",
    "output_format": "A list of integers representing the next greater elements for each element in nums1.",
    "constraints": [
      "1 <= nums1.length <= 1000",
      "1 <= nums2.length <= 1000",
      "0 <= nums1[i], nums2[i] <= 10^4",
      "All elements in nums1 are unique."
    ],
    "examples": [
      {
        "input": "nums1 = [4, 1, 2], nums2 = [1, 3, 4, 2]",
        "output": "[-1, 3, -1]",
        "explanation": "For 4, there is no greater element to its right in nums2. For 1, the next greater element is 3. For 2, there is no greater element."
      },
      {
        "input": "nums1 = [2, 4], nums2 = [1, 2, 3, 4]",
        "output": "[3, -1]",
        "explanation": "For 2, the next greater element is 3. For 4, there is no greater element."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a stack to keep track of the next greater elements.",
      "Iterate through nums2 to build a mapping of next greater elements."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list. The answer is guaranteed to be a list that satisfies the same conditions.",
    "topic": "Linked List",
    "subtopic": "Addition of Numbers",
    "tags": [
      "Linked List",
      "Addition",
      "Number"
    ],
    "input_format": "Two linked lists, l1 and l2.",
    "output_format": "A linked list representing the sum of the two numbers.",
    "constraints": [
      "The number of nodes in each linked list is between 1 and 100.",
      "0 <= node.val <= 9",
      "It is guaranteed that the input numbers do not have leading zeros."
    ],
    "examples": [
      {
        "input": "l1 = [2,4,3], l2 = [5,6,4]",
        "output": "[7,0,8]",
        "explanation": "342 + 465 = 807, which is represented as [7,0,8] in reverse order."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "0 + 0 = 0, which is represented as [0]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dummy head for the result linked list to simplify code.",
      "Keep track of the carry when adding two digits."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock IV",
    "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. However, you are allowed to make at most k transactions, where a transaction is defined as buying and then selling one share of the stock. Return the maximum profit you can achieve. Note that you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
    "topic": "Dynamic Programming",
    "subtopic": "Stock Trading",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Greedy"
    ],
    "input_format": "An integer k representing the maximum number of transactions allowed, followed by an array of integers prices representing the stock prices on different days.",
    "output_format": "An integer representing the maximum profit obtainable.",
    "constraints": [
      "0 <= k <= 100",
      "0 <= prices.length <= 1000",
      "0 <= prices[i] <= 1000"
    ],
    "examples": [
      {
        "input": "k = 2, prices = [2,4,1]",
        "output": "2",
        "explanation": "Buy on day 0 (price = 2) and sell on day 1 (price = 4). Profit = 4 - 2 = 2."
      },
      {
        "input": "k = 2, prices = [3,2,6,5,0,3]",
        "output": "7",
        "explanation": "Buy on day 1 (price = 2) and sell on day 2 (price = 6). Profit = 6 - 2 = 4. Then buy on day 4 (price = 0) and sell on day 5 (price = 3). Profit = 3 - 0 = 3. Total profit = 4 + 3 = 7."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to store results for subproblems.",
      "Try to think about the maximum profit achievable at each transaction step.",
      "If k is greater than half the length of prices, it's equivalent to unlimited transactions."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Merge Two Sorted Lists",
    "description": "You are given the heads of two sorted linked lists. Merge the two lists into one sorted linked list and return the head of the new sorted list. The new list should be made by splicing together the nodes of the first two lists.",
    "topic": "Linked List",
    "subtopic": "Merging Linked Lists",
    "tags": [
      "Linked List",
      "Merging",
      "Sorting"
    ],
    "input_format": "The input consists of two linked list nodes, l1 and l2, where each node has a value and a pointer to the next node.",
    "output_format": "A linked list node which is the head of the merged sorted linked list.",
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50].",
      "-100 <= Node.val <= 100",
      "Both l1 and l2 are sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "l1 = [1, 2, 4], l2 = [1, 3, 4]",
        "output": "[1, 1, 2, 3, 4, 4]",
        "explanation": "Merging the two sorted lists gives us [1, 1, 2, 3, 4, 4]."
      },
      {
        "input": "l1 = [], l2 = [0]",
        "output": "[0]",
        "explanation": "Since l1 is empty, the merged list is simply l2 which is [0]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a dummy node to simplify merging.",
      "Take care to merge only while both lists have nodes."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Set Matrix Zeroes",
    "description": "Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do this in-place, without using extra space for another matrix. You must modify the input matrix directly.",
    "topic": "Array",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Matrix",
      "Array",
      "In-place"
    ],
    "input_format": "A 2D array of integers representing the matrix.",
    "output_format": "The same 2D array, with rows and columns set to 0 where required.",
    "constraints": [
      "1 <= m, n <= 200",
      "-10^7 <= matrix[i][j] <= 10^7"
    ],
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": "The element at (1,1) is 0, so the entire second row and second column are set to 0."
      },
      {
        "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
        "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
        "explanation": "The element at (0,0) is 0, so the entire first row and first column are set to 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use the first row and first column to mark zeroes.",
      "Consider using two passes through the matrix."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Next Greater Element III",
    "description": "Given a positive integer n, find the next greater integer that can be formed by rearranging the digits of n. If no such integer exists, return -1. The solution should use constant space and operate in linear time.",
    "topic": "Greedy",
    "subtopic": "Next Permutation",
    "tags": [
      "Greedy",
      "Next Permutation",
      "Math"
    ],
    "input_format": "A positive integer n.",
    "output_format": "A positive integer representing the next greater number, or -1 if no such number exists.",
    "constraints": [
      "1 <= n <= 2 * 10^31 - 1"
    ],
    "examples": [
      {
        "input": "n = 12",
        "output": "21",
        "explanation": "The next greater number formed by rearranging the digits of 12 is 21."
      },
      {
        "input": "n = 21",
        "output": "-1",
        "explanation": "No greater number can be formed by rearranging the digits of 21."
      },
      {
        "input": "n = 123",
        "output": "132",
        "explanation": "The next greater number formed by rearranging the digits of 123 is 132."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Look for the rightmost ascent in the number's digits.",
      "Swap the found digit with the smallest digit that is larger than it on its right.",
      "Reverse the digits to the right of the swapped position to get the next permutation."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Hashing"
    ],
    "input_format": "An integer array nums of length n.",
    "output_format": "A list of unique triplets, where each triplet contains three integers that form a sum of zero.",
    "constraints": [
      "0 <= n <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that sum to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no elements in the array, so no triplets can be formed."
      },
      {
        "input": "nums = [0, 1, 1]",
        "output": "[]",
        "explanation": "No triplet can sum to zero with the given elements."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the array first to simplify finding triplets.",
      "Use two pointers to find pairs that sum to a target value."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Amount of Time for Binary Tree to Be Infected",
    "description": "A binary tree is given with each node representing a person. Each person can be infected by their adjacent persons (parent and children) in one time unit. The initial infected person is given, and your task is to determine the amount of time it takes for the entire binary tree to be infected. Return the total time taken for the entire tree to be infected.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Binary Tree",
      "Graph",
      "BFS",
      "DFS"
    ],
    "input_format": "The root of the binary tree and the index of the initially infected person.",
    "output_format": "An integer representing the total time taken for the entire tree to become infected.",
    "constraints": [
      "1 <= number of nodes <= 10^5",
      "0 <= index of initially infected person < number of nodes"
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, 4, 5, null, 6], initially_infected = 1",
        "output": "4",
        "explanation": "Starting from node 1, it takes 4 time units to infect all nodes (1 -> 2, 1 -> 3, 2 -> 4, 2 -> 5, 3 -> 6)."
      },
      {
        "input": "root = [1, 2, 3], initially_infected = 0",
        "output": "2",
        "explanation": "Infecting node 1 takes 1 time unit, then both nodes 2 and 3 are infected in the next time unit."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using BFS or DFS to traverse the tree.",
      "Keep track of the time taken for each layer of infection."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Permutation in String",
    "description": "Given two strings s1 and s2, write a function to check if s2 contains a permutation of s1. In other words, return true if one of s1's permutations is the substring of s2.",
    "topic": "String",
    "subtopic": "Substring Search",
    "tags": [
      "String",
      "Permutation",
      "Hashmap"
    ],
    "input_format": "Two strings s1 and s2, where 1 <= s1.length <= 1000 and 1 <= s2.length <= 10^4.",
    "output_format": "A boolean value, true if s2 contains a permutation of s1, otherwise false.",
    "constraints": [
      "1 <= s1.length <= 1000",
      "1 <= s2.length <= 10^4"
    ],
    "examples": [
      {
        "input": "s1 = 'abc', s2 = 'eidbaooo'",
        "output": "true",
        "explanation": "The substring 'bao' is a permutation of 'abc'."
      },
      {
        "input": "s1 = 'ab', s2 = 'eidboaoo'",
        "output": "false",
        "explanation": "'eidboaoo' does not contain any permutation of 'ab'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use character frequency count for comparison.",
      "Utilize a sliding window approach for efficiency."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Unique Paths",
    "description": "You are given a grid with `m` rows and `n` columns. You start at the top-left corner of the grid (0,0) and can only move down or right at any point in time. Your goal is to reach the bottom-right corner of the grid (m-1, n-1). Write a function to count how many unique paths there are from the top-left corner to the bottom-right corner.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Paths",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Counting Paths"
    ],
    "input_format": "Two integers m and n representing the number of rows and columns in the grid, respectively.",
    "output_format": "An integer representing the number of unique paths to reach the bottom-right corner of the grid.",
    "constraints": [
      "1 <= m, n <= 100"
    ],
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": "There are 28 unique paths to get to the bottom-right corner."
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "There are 3 unique paths to get to the bottom-right corner."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how you can break down the problem into smaller subproblems.",
      "Use a 2D array to keep track of paths count at each cell if necessary."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Largest Number",
    "description": "Given a list of non-negative integers, arrange them such that they form the largest possible number. The result must not have leading zeros unless the number is zero itself.",
    "topic": "Sorting",
    "subtopic": "Custom Sorting",
    "tags": [
      "Sorting",
      "Greedy",
      "String"
    ],
    "input_format": "A list of non-negative integers represented as strings.",
    "output_format": "A string representing the largest number that can be formed.",
    "constraints": [
      "0 <= nums.length <= 100",
      "0 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [10, 2]",
        "output": "2210",
        "explanation": "By arranging the numbers as 2 and 10, we get the largest number 2210."
      },
      {
        "input": "nums = [3, 30, 34, 5, 9]",
        "output": "9534330",
        "explanation": "The largest number is formed by arranging the numbers as 9, 5, 34, 3, and 30 to form 9534330."
      },
      {
        "input": "nums = [0, 0]",
        "output": "0",
        "explanation": "The only number formed is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to compare two numbers as strings to decide their order.",
      "You may need to implement a custom comparison function."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Rotate Array",
    "description": "Given an array of integers nums and an integer k, rotate the array to the right by k steps, where k is non-negative. The rotation operation shifts each element of the array to the right, and the elements at the end of the array wrap around to the beginning.",
    "topic": "Array",
    "subtopic": "Rotation",
    "tags": [
      "Array",
      "Rotation",
      "In-place"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "The rotated array after performing k right rotations.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= k <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5, 6, 7], k = 3",
        "output": "[5, 6, 7, 1, 2, 3, 4]",
        "explanation": "Rotating the array [1, 2, 3, 4, 5, 6, 7] by 3 steps results in [5, 6, 7, 1, 2, 3, 4]."
      },
      {
        "input": "nums = [-1, -100, 3, 99], k = 2",
        "output": "[3, 99, -1, -100]",
        "explanation": "Rotating the array [-1, -100, 3, 99] by 2 steps results in [3, 99, -1, -100]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using the reverse technique for rotation.",
      "You can optimize the rotation to handle large values of k efficiently."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Permutations",
    "description": "Given an array of distinct integers, return all possible permutations of the array. You can return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Permutations",
      "Array"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "A list of all possible permutations of the input array.",
    "constraints": [
      "1 <= nums.length <= 6",
      "-10 < nums[i] < 10",
      "All integers in nums are distinct."
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": "The possible permutations of [1, 2, 3] are all the arrangements of the three numbers."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to generate permutations.",
      "Think about how to swap elements to explore different arrangements."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Longest Substring with At Most K Distinct Characters",
    "description": "Given a string s, return the length of the longest substring that contains at most k distinct characters. A substring is any sequence of contiguous characters within the string.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A string s and an integer k, where s is the input string and k is the maximum number of distinct characters.",
    "output_format": "An integer representing the length of the longest substring with at most k distinct characters.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "0 <= k <= 26"
    ],
    "examples": [
      {
        "input": "s = 'eceba', k = 2",
        "output": "3",
        "explanation": "The substring 'ece' is the longest substring that contains at most 2 distinct characters."
      },
      {
        "input": "s = 'aa', k = 1",
        "output": "2",
        "explanation": "The substring 'aa' contains 1 distinct character: 'a'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sliding window approach to maintain the substring.",
      "Use a hash map to count the occurrences of characters in the current window."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Rotate Image",
    "description": "You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). You have to rotate the matrix in-place, which means you have to modify the input 2D matrix directly. Do not return anything from your function.",
    "topic": "Matrix",
    "subtopic": "In-place Operations",
    "tags": [
      "Matrix",
      "In-place",
      "Array Manipulation"
    ],
    "input_format": "A 2D array of integers matrix of size n x n.",
    "output_format": "The input 2D array is modified in-place to represent the rotated image.",
    "constraints": [
      "1 <= n <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[[7, 4, 1], [8, 5, 2], [9, 6, 3]]",
        "explanation": "Rotating the matrix 90 degrees clockwise results in the new arrangement."
      },
      {
        "input": "matrix = [[5]]",
        "output": "[[5]]",
        "explanation": "Rotating a 1x1 matrix results in the same matrix."
      },
      {
        "input": "matrix = [[1, 2], [3, 4]]",
        "output": "[[3, 1], [4, 2]]",
        "explanation": "The 2x2 matrix rotates to a new arrangement after 90 degrees clockwise rotation."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the layers of the matrix.",
      "You may want to use a temporary value for swapping corners."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Find the Duplicate Number",
    "description": "Given an array of integers where each integer is between 1 and n (inclusive) and there is only one duplicate number, return the duplicate number. You must solve the problem without modifying the input array and using constant extra space.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Duplicate"
    ],
    "input_format": "An array of integers nums representing n + 1 integers where each integer is between 1 and n.",
    "output_format": "An integer representing the duplicate number in the array.",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "1 <= nums[i] <= n"
    ],
    "examples": [
      {
        "input": "nums = [3, 1, 3, 4, 2]",
        "output": "3",
        "explanation": "The duplicate number in the array is 3."
      },
      {
        "input": "nums = [1, 3, 4, 2, 2]",
        "output": "2",
        "explanation": "The duplicate number in the array is 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use the properties of the numbers to utilize the array indices.",
      "Consider the idea of cycle detection in linked lists."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Valid Anagram",
    "description": "Given two strings s and t, return true if t is an anagram of s and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "topic": "String",
    "subtopic": "Character Counting",
    "tags": [
      "String",
      "Anagram",
      "Counting"
    ],
    "input_format": "Two strings s and t, where 1 <= s.length, t.length <= 5 * 10^4.",
    "output_format": "A boolean value, true if t is an anagram of s, otherwise false.",
    "constraints": [
      "1 <= s.length, t.length <= 5 * 10^4",
      "s and t consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = 'anagram', t = 'nagaram'",
        "output": "true",
        "explanation": "Both strings have the same letters with the same frequency."
      },
      {
        "input": "s = 'rat', t = 'car'",
        "output": "false",
        "explanation": "The letters are not the same, hence they cannot be anagrams."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Count the frequency of each character in both strings.",
      "Use a hash map or an array for character counting."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Integer to Roman",
    "description": "Given an integer, convert it to a Roman numeral. The conversion must be done according to the rules of Roman numeral representation. Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. For example, the integer 3 is represented as III, and the integer 4 is represented as IV. The goal of this problem is to convert a given integer in the range from 1 to 3999 into its corresponding Roman numeral.",
    "topic": "Mathematics",
    "subtopic": "Conversion",
    "tags": [
      "Math",
      "Strings",
      "Conversion"
    ],
    "input_format": "An integer num (1 <= num <= 3999).",
    "output_format": "A string representing the Roman numeral equivalent of the integer.",
    "constraints": [
      "1 <= num <= 3999"
    ],
    "examples": [
      {
        "input": "num = 3",
        "output": "III",
        "explanation": "The integer 3 is represented as III in Roman numerals."
      },
      {
        "input": "num = 4",
        "output": "IV",
        "explanation": "The integer 4 is represented as IV in Roman numerals."
      },
      {
        "input": "num = 9",
        "output": "IX",
        "explanation": "The integer 9 is represented as IX in Roman numerals."
      },
      {
        "input": "num = 58",
        "output": "LVIII",
        "explanation": "The integer 58 is represented as LVIII in Roman numerals (L = 50, V = 5, III = 3)."
      },
      {
        "input": "num = 1994",
        "output": "MCMXCIV",
        "explanation": "The integer 1994 is represented as MCMXCIV in Roman numerals (M = 1000, CM = 900, XC = 90, IV = 4)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the values of the Roman symbols and their combinations.",
      "Build the Roman numeral string by comparing the integer with predefined values."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Reverse String",
    "description": "Write a function that reverses a string. The input string is given as an array of characters. You must do this by modifying the input array in-place using O(1) extra memory.",
    "topic": "String",
    "subtopic": "In-place Operations",
    "tags": [
      "String",
      "In-place",
      "Manipulation"
    ],
    "input_format": "An array of characters representing the string to be reversed.",
    "output_format": "The input array should be modified in-place to represent the reversed string.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s[i] is a printable ascii character."
    ],
    "examples": [
      {
        "input": "s = ['h', 'e', 'l', 'l', 'o']",
        "output": "['o', 'l', 'l', 'e', 'h']",
        "explanation": "The reversed string of 'hello' is 'olleh'."
      },
      {
        "input": "s = ['H', 'a', 'n', 'n', 'a', 'h']",
        "output": "['h', 'a', 'n', 'n', 'a', 'H']",
        "explanation": "The reversed string of 'Hannah' is 'hannaH'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers to swap characters.",
      "Start from both ends of the string and work towards the center."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Reorder List",
    "description": "Given a singly linked list, reorganize it in such a way that the node values follow the pattern of the first element, the last element, the second element, the second to last element, and so on. You are required to do this rearrangement in-place.",
    "topic": "Linked List",
    "subtopic": "Rearranging Linked List",
    "tags": [
      "LinkedList",
      "Rearranging",
      "In-Place"
    ],
    "input_format": "The head of a singly linked list.",
    "output_format": "The head of the rearranged singly linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [1, 5 * 10^4].",
      "0 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5]",
        "output": "[1, 5, 2, 4, 3]",
        "explanation": "The first node is 1, then the last node is 5, followed by the second node 2, then the second last node 4, and finally the middle node 3."
      },
      {
        "input": "head = [1, 2, 3, 4]",
        "output": "[1, 4, 2, 3]",
        "explanation": "The first node 1, last node 4, second node 2, and second last node 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider splitting the list into two halves.",
      "A two-pointer approach can help you find the middle of the list.",
      "Use a stack to reverse the order of the elements in the second half."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Merge Sorted Array",
    "description": "You are given two integer arrays nums1 and nums2, where nums1 has a size of m + n, which represents the number of elements that nums1 can hold. Initially, nums1 contains m elements sorted in non-decreasing order, and the rest of the space is filled with zeros. nums2 contains n elements sorted in non-decreasing order. You need to merge nums2 into nums1 as one sorted array. The merge should be done in place and does not return anything.",
    "topic": "Arrays",
    "subtopic": "Merging Arrays",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "Two integer arrays nums1 and nums2, and two integers m and n representing the number of initialized elements in nums1 and the number of elements in nums2 respectively.",
    "output_format": "The merged array in nums1.",
    "constraints": [
      "0 <= m, n <= 200",
      "1 <= m + n <= 200",
      "The elements of nums1 and nums2 are in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3",
        "output": "[1, 2, 2, 3, 5, 6]",
        "explanation": "After merging, nums1 contains [1, 2, 2, 3, 5, 6]."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "nums2 is empty, so nums1 remains unchanged."
      },
      {
        "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
        "output": "[1]",
        "explanation": "Since nums1 has no initial elements, nums1 will just contain the elements of nums2."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers, one for each array.",
      "Start merging from the end of the arrays to avoid overwriting elements."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Interleaving String",
    "description": "Given two strings s1 and s2, determine if they can be interleaved to form a third string s3. A string s3 is said to be interleaved with respect to s1 and s2 if it contains all the characters of s1 and s2, preserving the order of the characters from both strings.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Interleaving"
    ],
    "input_format": "Three strings s1, s2, and s3 consisting of lowercase letters.",
    "output_format": "A boolean value indicating whether s3 can be formed by interleaving s1 and s2.",
    "constraints": [
      "1 <= s1.length, s2.length, s3.length <= 100",
      "s1, s2, s3 consist of lowercase letters"
    ],
    "examples": [
      {
        "input": "s1 = 'aab', s2 = 'axy', s3 = 'aaxaby'",
        "output": "true",
        "explanation": "s3 can be formed by interleaving s1 and s2: s1 (aab) and s2 (axy) can form (a, a, x) + (b, y) resulting in 'aaxaby'."
      },
      {
        "input": "s1 = 'ab', s2 = 'bc', s3 = 'acb'",
        "output": "false",
        "explanation": "It\u2019s impossible to form 'acb' by interleaving 'ab' and 'bc' while preserving the character order."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use dynamic programming to solve the problem.",
      "Consider a 2D table to keep track of interleaving possibilities.",
      "Think about the base cases for empty strings."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Query Kth Smallest Trimmed Number",
    "description": "You are given an array of strings 'nums' representing non-negative integers, and an integer 'k'. For each integer, you need to obtain the k-th smallest number after trimming the numbers by their last digits. Numbers are trimmed based on their suffix, meaning that if you have two numbers, '123' and '456', trimming to the last digit gives you '1', '4'. You should return the k-th smallest number after trimming the numbers based on their last 'k' digits and sorting them.",
    "topic": "Sorting",
    "subtopic": "Customize Sorting",
    "tags": [
      "Sorting",
      "String",
      "Array"
    ],
    "input_format": "The first line contains an integer n (1 <= n <= 100) denoting the number of elements in the 'nums' array, followed by n strings representing non-negative integers. The second line contains an integer k (1 <= k <= n).",
    "output_format": "Return the k-th smallest trimmed number as a string.",
    "constraints": [
      "1 <= n <= 100",
      "1 <= k <= n",
      "Each number is a non-negative integer and can contain up to 100 digits."
    ],
    "examples": [
      {
        "input": "nums = [\"102\",\"473\",\"251\",\"814\"], k = 1",
        "output": "\"814\"",
        "explanation": "When trimmed to their last digit: '2', '3', '1', '4'. The sorted order is '1', '2', '3', '4', so the 1st smallest is '814'."
      },
      {
        "input": "nums = [\"345\",\"678\",\"123\"], k = 2",
        "output": "\"678\"",
        "explanation": "Trimming gives '5', '8', '3'. Sorted order: '3', '5', '8', so the 2nd smallest is '678'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you can trim the numbers using string operations.",
      "You may need to sort the trimmed numbers before extracting the k-th smallest."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Two Sum II - Input Array Is Sorted",
    "description": "Given a 1-indexed array of integers 'numbers' that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Return the indices of the two numbers in a 1-indexed format. You may assume that each input would have exactly one solution and you may not use the same element twice. Your solution should be in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Two Pointer",
    "tags": [
      "Array",
      "Two Pointers",
      "Binary Search"
    ],
    "input_format": "An integer array 'numbers' where numbers[i] is the i-th number and an integer 'target'.",
    "output_format": "An array of two integers representing the 1-indexed positions of the two numbers.",
    "constraints": [
      "2 <= numbers.length <= 3 * 10^4",
      "-10^9 <= numbers[i] <= 10^9",
      "numbers is sorted in non-decreasing order",
      "1 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "numbers = [2, 7, 11, 15], target = 9",
        "output": "[1, 2]",
        "explanation": "The numbers 2 and 7 add up to 9. Their indices are 1 and 2."
      },
      {
        "input": "numbers = [1, 2, 3, 4, 4, 9, 10], target = 8",
        "output": "[4, 5]",
        "explanation": "The numbers 4 and 4 add up to 8. Their indices are 4 and 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using two pointers to find the solution efficiently.",
      "Since the array is sorted, you can leverage the sorted property."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Valid Sudoku",
    "description": "Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the rules of Sudoku: each row, column, and each of the nine 3x3 sub-boxes should contain the digits 1-9 without repetition. Empty cells can be filled with '.' which means the cell is empty.",
    "topic": "Matrix",
    "subtopic": "Validation",
    "tags": [
      "Matrix",
      "Validation",
      "Sudoku"
    ],
    "input_format": "A 9x9 2D array of characters representing the Sudoku board, where each cell contains a digit ('1' to '9') or a '.' (empty cell).",
    "output_format": "A boolean indicating whether the given Sudoku board is valid.",
    "constraints": [
      "board.length == 9",
      "board[i].length == 9",
      "board[i][j] is a digit ('1'-'9') or '.'"
    ],
    "examples": [
      {
        "input": [
          [
            "5",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            ".",
            "2",
            "8",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": "true",
        "explanation": "The provided board is a valid Sudoku board."
      },
      {
        "input": [
          [
            "8",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            ".",
            "2",
            "8",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": "false",
        "explanation": "The provided board is not valid because the number '8' appears twice in the first column."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Check each row for duplicates.",
      "Check each column for duplicates.",
      "Check each 3x3 sub-box for duplicates."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Zigzag Conversion",
    "description": "The task is to convert a given string into a zigzag pattern on a given number of rows and then read the characters line by line. For example, if the input string is 'PAYPALISHIRING' and the number of rows is 3, the zigzag pattern would look like this:\n\nP   A   H   N\nA P L S I I G\nY   I   \n\nThe resulting string from reading line by line would be 'PAHNAPLSIIGY'. Write a function that takes a string and a number of rows and returns the converted string in the zigzag pattern.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Zigzag",
      "Pattern"
    ],
    "input_format": "A string s and an integer numRows.",
    "output_format": "A string representing the characters read in zigzag order.",
    "constraints": [
      "1 <= s.length <= 1000",
      "1 <= numRows <= 1000"
    ],
    "examples": [
      {
        "input": "s = 'PAYPALISHIRING', numRows = 3",
        "output": "PAHNAPLSIIGY",
        "explanation": "The zigzag pattern with 3 rows forms 'PAHNAPLSIIGY'."
      },
      {
        "input": "s = 'A', numRows = 1",
        "output": "A",
        "explanation": "With only one row, the output is the same as the input."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to calculate the indices for the characters in the zigzag pattern.",
      "Look for a way to construct rows dynamically based on the input string."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Remove Duplicate Letters",
    "description": "Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Return the final result as a string.",
    "topic": "String",
    "subtopic": "Greedy",
    "tags": [
      "String",
      "Greedy",
      "Stack"
    ],
    "input_format": "A string s consisting of lowercase English letters.",
    "output_format": "A string representing the result after removing duplicate letters.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "cba",
        "output": "abc",
        "explanation": "Removing duplicates gives 'cba', and the smallest lexicographical order is 'abc'."
      },
      {
        "input": "bcabc",
        "output": "abc",
        "explanation": "Removing duplicates gives 'bcabc', and the smallest lexicographical order is 'abc'."
      },
      {
        "input": "cbacdcbc",
        "output": "acdb",
        "explanation": "Removing duplicates gives 'cbacdcbc', and the smallest lexicographical order is 'acdb'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to keep track of the letters in the result.",
      "Consider the last occurrence of each letter when deciding whether to pop from the stack.",
      "Maintain a record of seen letters to avoid duplicates."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Jump Game II",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. You can assume you start at the first index and you must reach the last index. Return the minimum number of jumps required to reach the last index.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "An integer representing the minimum number of jumps to reach the last index.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "2",
        "explanation": "Jump 1 step from index 0 to 1, then 1 jump to the last index."
      },
      {
        "input": "nums = [2, 3, 0, 1, 4]",
        "output": "2",
        "explanation": "Jump 1 step from index 0 to 1, then 1 jump to the last index."
      },
      {
        "input": "nums = [0]",
        "output": "0",
        "explanation": "Already at the last index, no jump needed."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how far you can reach from each index.",
      "Use a greedy approach to find the minimum jumps.",
      "Track the furthest point you can reach at each jump."
    ],
    "company": "Goldman Sachs"
  },
  {
    "question_id": "",
    "title": "Contains Duplicate II",
    "description": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Searching"
    ],
    "input_format": "An integer array nums and an integer k.",
    "output_format": "A boolean indicating if the condition is satisfied.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9",
      "0 <= k <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1,2,3,1], k = 3",
        "output": "true",
        "explanation": "nums[0] == nums[3] and abs(0 - 3) = 3 <= k."
      },
      {
        "input": "nums = [1,0,1,1], k = 1",
        "output": "true",
        "explanation": "nums[2] == nums[3] and abs(2 - 3) = 1 <= k."
      },
      {
        "input": "nums = [1,2,3,1,2,3], k = 2",
        "output": "false",
        "explanation": "There are no duplicates within distance k."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash table to track the indices of elements.",
      "Iterate through the array and update indices as you find duplicates."
    ],
    "company": "Goldman Sachs"
  }
]