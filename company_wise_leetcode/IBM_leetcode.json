[
  {
    "question_id": "",
    "title": "Exclusive Time of Functions",
    "description": "You are given a list of functions executing in a single-threaded CPU. Each function has a unique ID, and the execution logs are provided in the form of a list where each entry signifies a function start or a function end. Your task is to calculate the exclusive time of each function. The exclusive time of a function is defined as the total time spent on the function, excluding the time spent on its children. The function logs are guaranteed to be in the format: 'function_id:start_timestamp' or 'function_id:end_timestamp'. When a function starts, it can be immediately interrupted by a nested function. You need to return a list of integers representing the exclusive time for each function in order of their IDs.",
    "topic": "Stack",
    "subtopic": "Function Call",
    "tags": [
      "Stack",
      "Recursion",
      "Time Complexity"
    ],
    "input_format": "The first line contains an integer n, the number of functions. The next n lines each contain a log entry in the format 'function_id:start_timestamp' or 'function_id:end_timestamp'.",
    "output_format": "A list of integers representing the exclusive time for each function.",
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= function_id < 100"
    ],
    "examples": [
      {
        "input": "n = 8\n0:start:0\n1:start:2\n1:end:5\n0:end:6\n0:start:7\n2:start:8\n2:end:9\n0:end:10",
        "output": "[3, 4, 1]",
        "explanation": "Function 0 runs from 0-1, 6-7, and 10 making it 3 units of time. Function 1 runs from 2-5 (4 units), and Function 2 runs from 8-9 (1 unit). So the result is [3, 4, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to track the function calls.",
      "Remember to calculate the time when a function starts and ends carefully."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Integer to Roman",
    "description": "Given an integer, convert it to a Roman numeral. The input is guaranteed to be within the range from 1 to 3999. Roman numerals are represented by seven symbols: I (1), V (5), X (10), L (50), C (100), D (500), and M (1000). For example, 2 is represented as 'II' and 12 is represented as 'XII'. However, the Roman numeral for 4 is not 'IIII'. Instead, the number 4 is represented as 'IV'. Because the numeral is made up of the two symbols I and V. For another example, the number 9 is represented as 'IX'. There are six instances where subtraction is used: I can be placed before V and X to make 4 and 9. X can be placed before L and C to make 40 and 90. C can be placed before D and M to make 400 and 900. Given the integer num, convert it to a Roman numeral.",
    "topic": "Math",
    "subtopic": "Conversion",
    "tags": [
      "Math",
      "Conversion",
      "String"
    ],
    "input_format": "An integer num (1 <= num <= 3999).",
    "output_format": "A string representing the Roman numeral equivalent of the input integer.",
    "constraints": [
      "1 <= num <= 3999"
    ],
    "examples": [
      {
        "input": "num = 3",
        "output": "III",
        "explanation": "3 is represented as 'III'."
      },
      {
        "input": "num = 4",
        "output": "IV",
        "explanation": "4 is represented as 'IV' (not 'IIII')."
      },
      {
        "input": "num = 9",
        "output": "IX",
        "explanation": "9 is represented as 'IX' (not 'VIIII')."
      },
      {
        "input": "num = 58",
        "output": "LVIII",
        "explanation": "58 is represented as 'LVIII' (L=50, V=5, III=3)."
      },
      {
        "input": "num = 1994",
        "output": "MCMXCIV",
        "explanation": "1994 is represented as 'MCMXCIV' (M=1000, CM=900, XC=90, IV=4)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider each Roman numeral symbol and its value.",
      "Think about how to handle the subtractive combinations.",
      "Use a mapping of integer values to their corresponding Roman numeral representations."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Fizz Buzz",
    "description": "Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output 'Fizz' instead of the number and for the multiples of five output 'Buzz'. For numbers which are multiples of both three and five it should output 'FizzBuzz'.",
    "topic": "Mathematics",
    "subtopic": "Division",
    "tags": [
      "Math",
      "String",
      "Division"
    ],
    "input_format": "An integer n (1 <= n <= 10^4).",
    "output_format": "A list of strings representing the Fizz Buzz sequence.",
    "constraints": [
      "1 <= n <= 10^4"
    ],
    "examples": [
      {
        "input": "n = 15",
        "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]",
        "explanation": "The numbers from 1 to 15 produce Fizz for multiples of 3, Buzz for multiples of 5, and FizzBuzz for multiples of both."
      },
      {
        "input": "n = 5",
        "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]",
        "explanation": "Only numbers 3 and 5 are transformed into Fizz and Buzz respectively."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use modulo operations to determine divisibility."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Roman to Integer",
    "description": "Given a string representation of a Roman numeral, convert it to its integer equivalent. Roman numerals are based on the following symbols: I is 1, V is 5, X is 10, L is 50, C is 100, D is 500, and M is 1000. In the case of Roman numerals, a smaller numeral before a larger numeral indicates subtraction (e.g., IV is 4), while a larger or equal numeral before a smaller one indicates addition (e.g., VI is 6).",
    "topic": "String",
    "subtopic": "Parsing Strings",
    "tags": [
      "String",
      "Conversion",
      "Roman Numerals"
    ],
    "input_format": "A string representing the Roman numeral (1 <= s.length <= 15).",
    "output_format": "An integer representing the equivalent value of the Roman numeral.",
    "constraints": [
      "1 <= s.length <= 15",
      "s contains only the characters {'I', 'V', 'X', 'L', 'C', 'D', 'M'}"
    ],
    "examples": [
      {
        "input": "s = 'III'",
        "output": "3",
        "explanation": "'III' is 1 + 1 + 1 = 3."
      },
      {
        "input": "s = 'IV'",
        "output": "4",
        "explanation": "'IV' is 5 - 1 = 4."
      },
      {
        "input": "s = 'IX'",
        "output": "9",
        "explanation": "'IX' is 10 - 1 = 9."
      },
      {
        "input": "s = 'LVIII'",
        "output": "58",
        "explanation": "'LVIII' is 50 + 5 + 1 + 1 + 1 = 58."
      },
      {
        "input": "s = 'MCMXCIV'",
        "output": "1994",
        "explanation": "'MCMXCIV' is 1000 + (1000 - 100) + (1000 - 10) + 5 = 1994."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a mapping for Roman symbols to their values.",
      "Iterate through the string and check the current and next symbols to determine addition or subtraction."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices where 0 <= prices.length <= 10^5.",
    "output_format": "An integer representing the maximum profit from buying and selling the stock.",
    "constraints": [
      "0 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price observed so far while iterating through the array.",
      "Calculate potential profit by subtracting the minimum price from the current price."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "Assume that the solution exists and each input has exactly one solution."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash map to store the numbers and their indices.",
      "Check if the complement (target - current number) exists in the hash map."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Count Ways to Group Overlapping Ranges",
    "description": "You are given an array of intervals, where each interval is defined by a start and an end point. Your task is to count the number of distinct ways to group these intervals such that no two intervals in the same group overlap. Two intervals [a, b] and [c, d] overlap if either a <= d and c <= b. Return the count of possible groupings of the intervals mod 10^9 + 7.",
    "topic": "Dynamic Programming",
    "subtopic": "Interval Scheduling",
    "tags": [
      "Dynamic Programming",
      "Intervals",
      "Combinatorics"
    ],
    "input_format": "An array of tuples intervals, where each tuple consists of two integers representing the start and end of an interval.",
    "output_format": "An integer representing the count of distinct ways to group the overlapping intervals.",
    "constraints": [
      "1 <= intervals.length <= 1000",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^9"
    ],
    "examples": [
      {
        "input": "intervals = [[1, 3], [2, 4], [3, 5]]",
        "output": "2",
        "explanation": "The two valid groupings are: [[1, 3], [3, 5]] and [[2, 4]] as [1, 3] overlaps with [2, 4]."
      },
      {
        "input": "intervals = [[1, 10], [2, 3], [4, 5]]",
        "output": "3",
        "explanation": "The valid groupings are: [[1, 10]], [[2, 3], [4, 5]], and [[1, 10], [2, 3], [4, 5]] (considered as different)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on their start times.",
      "Use dynamic programming to keep track of combinations.",
      "Consider the last non-overlapping interval for each current interval."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Meeting Rooms II",
    "description": "Given an array of meeting time intervals consisting of start and end times, return the minimum number of conference rooms required to hold all meetings. Each meeting is represented by a pair of integers [start, end], where `start` is the starting time and `end` is the ending time. A conference room can only be allocated to one meeting at a time, but multiple rooms can be used for meetings that do not overlap.",
    "topic": "Interval Scheduling",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Interval",
      "Greedy",
      "Sorting"
    ],
    "input_format": "An array of intervals, where each interval is represented as a list of two integers [start, end].",
    "output_format": "An integer representing the minimum number of meeting rooms required.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "0 <= intervals[i][0] < intervals[i][1] <= 10^6"
    ],
    "examples": [
      {
        "input": "intervals = [[0, 30], [5, 10], [15, 20]]",
        "output": "2",
        "explanation": "We need two rooms; one for [0, 30] and another that can hold [5, 10] and [15, 20]."
      },
      {
        "input": "intervals = [[7, 10], [2, 4]]",
        "output": "1",
        "explanation": "Both meetings can be held in the same room since they do not overlap."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals by start time.",
      "Use a min-heap to track the end times of meetings."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Minimum Operations to Make All Array Elements Equal",
    "description": "Given an integer array nums, you can perform operations where you select an index i and increment all elements in nums by 1. Your goal is to find the minimum number of operations required to make all elements in the array equal.",
    "topic": "Array",
    "subtopic": "Operations on Array",
    "tags": [
      "Array",
      "Operations",
      "Minimum"
    ],
    "input_format": "An integer array nums of length n.",
    "output_format": "An integer representing the minimum number of operations required.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "3",
        "explanation": "To make all elements equal to 3, we can perform operations on elements 1 and 2 a total of 3 times: increment 1 to 3 (2 operations) and 2 to 3 (1 operation). Total operations = 2 + 1 = 3."
      },
      {
        "input": "nums = [5, 5, 5]",
        "output": "0",
        "explanation": "All elements are already equal, so no operations are needed."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how many increments are needed for each number to reach the maximum element.",
      "The answer is simply the sum of differences between each element and the maximum value."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Minimum Absolute Difference",
    "description": "Given an array of integers, find the minimum absolute difference between any two elements in the array. The absolute difference between two integers a and b is defined as |a - b|. You may assume that the input array contains at least two elements.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Minimum Difference"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the minimum absolute difference between any two elements.",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [4, 2, 1, 3]",
        "output": "1",
        "explanation": "The minimum absolute difference is between 2 and 3 or 1 and 2, both yielding an absolute difference of 1."
      },
      {
        "input": "nums = [1, 5, 3, 19, 18, 25]",
        "output": "1",
        "explanation": "The minimum absolute difference is between 18 and 19, yielding an absolute difference of 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider sorting the array first.",
      "Look for differences only between adjacent elements after sorting."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Number of Divisible Triplet Sums",
    "description": "Given an array of integers, your task is to count the number of distinct triplets (i, j, k) such that 0 <= i < j < k < n, and the sum of the elements at these indices nums[i] + nums[j] + nums[k] is divisible by a given integer d. You need to return the count of such triplets.",
    "topic": "Array",
    "subtopic": "Combination",
    "tags": [
      "Array",
      "Combination",
      "Math"
    ],
    "input_format": "An array of integers nums and an integer d.",
    "output_format": "An integer representing the number of distinct triplets that satisfy the condition.",
    "constraints": [
      "3 <= nums.length <= 1000",
      "-10^5 <= nums[i] <= 10^5",
      "1 <= d <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5], d = 3",
        "output": "2",
        "explanation": "The triplets (0, 1, 2) -> 1 + 2 + 3 = 6 and (1, 2, 3) -> 2 + 3 + 4 = 9 are divisible by 3."
      },
      {
        "input": "nums = [1, 5, 3, 2], d = 6",
        "output": "1",
        "explanation": "The triplet (0, 1, 2) -> 1 + 5 + 3 = 9, which is not divisible by 6; only (0, 1, 3) -> 1 + 5 + 2 = 8 is valid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a nested loop approach to check all combinations of triplets.",
      "You can use the modulo operation to verify divisibility by d."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Rotate Image",
    "description": "You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). You have to rotate the matrix in-place, which means you have to modify the input 2D array directly. Do not use an additional array to rotate the image.",
    "topic": "Matrix",
    "subtopic": "In-place Operations",
    "tags": [
      "Matrix",
      "In-place",
      "Rotation"
    ],
    "input_format": "An n x n 2D array of integers representing the image.",
    "output_format": "The input 2D array, rotated by 90 degrees clockwise.",
    "constraints": [
      "1 <= n <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]",
        "explanation": "Rotating the matrix 90 degrees clockwise gives the new arrangement of elements."
      },
      {
        "input": "matrix = [[1]]",
        "output": "[[1]]",
        "explanation": "A single element matrix remains unchanged after rotation."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider layers of the matrix from outside towards inside.",
      "Use swapping to rotate elements in place."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Minimum Operations to Make Median of Array Equal to K",
    "description": "Given an array of integers, you need to find the minimum number of operations required to make the median of the array equal to a given integer K. An operation consists of either increasing or decreasing an element in the array by 1. The median is defined as the middle number in a sorted, odd-length array, or the average of the two middle numbers in a sorted, even-length array. Your task is to calculate the minimum number of operations needed to achieve the desired median.",
    "topic": "Array",
    "subtopic": "Median",
    "tags": [
      "Array",
      "Median",
      "Operations"
    ],
    "input_format": "An array of integers nums and an integer K.",
    "output_format": "An integer representing the minimum number of operations to make the median equal to K.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i], K <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 5], K = 4",
        "output": "2",
        "explanation": "To make the median 4: Increase 3 to 4 and 1 to 4. It takes 1 + 3 = 4 operations."
      },
      {
        "input": "nums = [1, 5, 9, 3], K = 6",
        "output": "3",
        "explanation": "The sorted array is [1, 3, 5, 9]. The median is (3 + 5)/2 = 4. We can change 3 to 6 and 5 to 6. It takes 3 operations."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Remember to sort the array to find the median.",
      "Consider the cases when the length of the array is even or odd.",
      "Think about how many elements need to be adjusted to reach K."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Maximum Profitable Triplets With Increasing Prices I",
    "description": "You are given a list of stock prices where the ith element represents the price of a stock on day i. Your task is to find the maximum profit you can earn by buying and selling the stock, limited to at most three transactions. You can only complete a transaction if the stock price goes up from the day you bought to the day you sold. Return the maximum profit you can achieve.",
    "topic": "Dynamic Programming",
    "subtopic": "Max Profit",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers prices, where prices[i] represents the price of a stock on day i.",
    "output_format": "An integer representing the maximum profit possible from at most three transactions.",
    "constraints": [
      "0 <= prices.length <= 1000",
      "0 <= prices[i] <= 10000"
    ],
    "examples": [
      {
        "input": "prices = [3, 2, 6, 5, 0, 3]",
        "output": "7",
        "explanation": "Buy on day 2 (price = 2) and sell on day 3 (price = 6) for a profit of 4, then buy on day 5 (price = 0) and sell on day 6 (price = 3) for a profit of 3. Total profit = 4 + 3 = 7."
      },
      {
        "input": "prices = [1, 2, 3, 4, 5]",
        "output": "4",
        "explanation": "Buy on day 1 (price = 1) and sell on day 5 (price = 5) for a total profit of 4."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "There is no transaction that can be done, hence the profit is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use dynamic programming to keep track of profits at each state.",
      "Consider using a nested loop to explore all transactions."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "The kth Factor of n",
    "description": "Given two integers n and k, return the k-th factor of n. A factor of an integer n is any integer i such that n % i == 0. If k is greater than the number of factors of n, return -1.",
    "topic": "Mathematics",
    "subtopic": "Divisibility",
    "tags": [
      "Mathematics",
      "Divisibility",
      "Factors"
    ],
    "input_format": "Two integers n and k, where 1 <= n <= 1000 and 1 <= k <= n.",
    "output_format": "An integer representing the k-th factor of n or -1 if there are fewer than k factors.",
    "constraints": [
      "1 <= n <= 1000",
      "1 <= k <= n"
    ],
    "examples": [
      {
        "input": "n = 12, k = 3",
        "output": "3",
        "explanation": "The factors of 12 are [1, 2, 3, 4, 6, 12]. The third factor is 3."
      },
      {
        "input": "n = 7, k = 2",
        "output": "-1",
        "explanation": "The factors of 7 are [1, 7]. There is no second factor."
      },
      {
        "input": "n = 18, k = 4",
        "output": "9",
        "explanation": "The factors of 18 are [1, 2, 3, 6, 9, 18]. The fourth factor is 6."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Iterate through numbers from 1 to n to find factors.",
      "Keep a count of the factors found to determine the k-th one."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Find The First Player to Win K Games in a Row",
    "description": "You are given a list of strings representing the names of players and their respective game results. Each string consists of the player's name followed by either 'W' for a win or 'L' for a loss. Your task is to determine the first player who wins K consecutive games. If no player achieves this, return an empty string.",
    "topic": "Array",
    "subtopic": "Strings",
    "tags": [
      "Array",
      "Strings",
      "Game Theory"
    ],
    "input_format": "A list of strings, where each string is formatted as 'PlayerName Result'.",
    "output_format": "A string representing the name of the first player to win K games in a row, or an empty string if no player achieves this.",
    "constraints": [
      "1 <= games.length <= 10^5",
      "1 <= K <= 10^5",
      "Each PlayerName consists of only alphabetic characters."
    ],
    "examples": [
      {
        "input": "games = ['Alice W', 'Alice W', 'Bob L', 'Alice W', 'Alice W'] K = 3",
        "output": "Alice",
        "explanation": "Alice wins three games consecutively at the start of the list."
      },
      {
        "input": "games = ['Charlie W', 'Charlie W', 'Charlie W', 'Bob W', 'Bob W'] K = 4",
        "output": "",
        "explanation": "No player wins four games in a row."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dictionary to track the win streak for each player.",
      "Loop through the list and update the streak count for each player."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Activity Participants",
    "description": "A group of people has a specific number of activities they can participate in, but not every participant can engage in every activity. Given a list of activities, each associated with the participants who can partake, your task is to determine the total number of unique participants across all activities. A participant may appear in multiple activities, but should only be counted once.",
    "topic": "Set",
    "subtopic": "Unique Elements",
    "tags": [
      "Set",
      "Unique",
      "Counting"
    ],
    "input_format": "A list of activities, where each activity is represented as a list of participant IDs.",
    "output_format": "An integer representing the total number of unique participants.",
    "constraints": [
      "1 <= activities.length <= 1000",
      "1 <= activities[i].length <= 100",
      "1 <= participant ID <= 10^6"
    ],
    "examples": [
      {
        "input": "[[1, 2, 3], [2, 3, 4], [4, 5]]",
        "output": "5",
        "explanation": "The unique participants are 1, 2, 3, 4, and 5, so the count is 5."
      },
      {
        "input": "[[1], [1, 2, 3], [3, 4], [5]]",
        "output": "5",
        "explanation": "The unique participants are 1, 2, 3, 4, and 5, so the count is 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a set to keep track of unique participants.",
      "You can iterate through each activity and add its participants to the set."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Taking Maximum Energy From the Mystic Dungeon",
    "description": "You have entered a mystical dungeon filled with various energy orbs. Each orb provides a certain amount of energy. However, to maximize your energy, you must choose the orbs wisely. You can either take an orb or skip it, but if you take the energy from orb i, you cannot take the energy from orb i-1. Your goal is to find the maximum energy you can collect from the orbs while adhering to this rule.",
    "topic": "Dynamic Programming",
    "subtopic": "1D DP",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Maximize"
    ],
    "input_format": "An array of integers orbs, where each element represents the energy provided by the corresponding orb.",
    "output_format": "An integer representing the maximum energy you can collect.",
    "constraints": [
      "1 <= orbs.length <= 10^4",
      "0 <= orbs[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "orbs = [3, 2, 5, 10, 7]",
        "output": "15",
        "explanation": "Choose orbs at indices 0, 3, and 4. (3 + 10 + 2 = 15)"
      },
      {
        "input": "orbs = [1, 2, 3, 1]",
        "output": "4",
        "explanation": "Choose orbs at indices 1 and 3. (2 + 2 = 4)"
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dynamic programming approach to maintain a record of maximum energy up to each orb.",
      "You can use two variables to keep track of the maximum energy without using extra space."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Minimum Length of String After Operations",
    "description": "You are given a string consisting of lowercase English letters. You can perform the following operations on the string any number of times: remove any 'ab' or 'ba' substring. Your task is to determine the minimum length of the string after performing these operations optimally.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Greedy"
    ],
    "input_format": "A single string s consisting of lowercase English letters.",
    "output_format": "An integer representing the minimum length of the string after performing the operations.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = 'abba'",
        "output": "0",
        "explanation": "The string can be completely reduced to an empty string by removing 'ab' and 'ba' in pairs."
      },
      {
        "input": "s = 'ababbaa'",
        "output": "1",
        "explanation": "After removing pairs, we are left with a single 'a'."
      },
      {
        "input": "s = 'aabba'",
        "output": "1",
        "explanation": "One operation can be done to remove one pair, remaining with one 'a'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to manage characters.",
      "Remember that you can only remove pairs of 'ab' or 'ba'."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Find Occurrences of an Element in an Array",
    "description": "Given an array of integers and a target integer, find the number of occurrences of the target integer in the array. Your solution should have a time complexity of O(n).",
    "topic": "Array",
    "subtopic": "Counting Elements",
    "tags": [
      "Array",
      "Counting",
      "Searching"
    ],
    "input_format": "An array of integers nums followed by an integer target.",
    "output_format": "An integer representing the number of occurrences of target in nums.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^5 <= nums[i] <= 10^5",
      "-10^5 <= target <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 2, 4, 2], target = 2",
        "output": "3",
        "explanation": "The number 2 appears three times in the array."
      },
      {
        "input": "nums = [5, 5, 5, 1, 1], target = 1",
        "output": "2",
        "explanation": "The number 1 appears two times in the array."
      },
      {
        "input": "nums = [7, 8, 9, 10], target = 5",
        "output": "0",
        "explanation": "The number 5 does not appear in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider iterating through the array and counting matches.",
      "You can use a variable to maintain the count of occurrences."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Find Products of Elements of Big Array",
    "description": "Given an array of integers, return an array where each element at index 'i' is the product of all the numbers in the original array except the one at 'i'. You must solve it without using division and in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Product Array",
    "tags": [
      "Array",
      "Product",
      "O(n)"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An array of integers representing the product of elements except self.",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "[24, 12, 8, 6]",
        "explanation": "The products are calculated as follows: 2 * 3 * 4 = 24, 1 * 3 * 4 = 12, 1 * 2 * 4 = 8, 1 * 2 * 3 = 6."
      },
      {
        "input": "nums = [5, 6, 2, 7]",
        "output": "[84, 70, 210, 60]",
        "explanation": "The products are calculated as follows: 6 * 2 * 7 = 84, 5 * 2 * 7 = 70, 5 * 6 * 7 = 210, 5 * 6 * 2 = 60."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider maintaining a prefix and suffix product array.",
      "Use multiplication to avoid division for the product calculation."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Count Vowel Strings in Ranges",
    "description": "You are given an array of strings and a list of range pairs. Your task is to count the number of strings that consist only of vowel letters (a, e, i, o, u) within the specified ranges. Each range is defined by two integers indicating the start and end indices of the substring of the array to consider.",
    "topic": "String",
    "subtopic": "Counting",
    "tags": [
      "String",
      "Counting",
      "Array"
    ],
    "input_format": "An array of strings 'words' and a list of pairs 'ranges', where each pair contains two integers representing the start and end indices.",
    "output_format": "An array of integers, where each integer represents the count of vowel strings within the corresponding range.",
    "constraints": [
      "1 <= words.length <= 1000",
      "1 <= words[i].length <= 100",
      "0 <= ranges.length <= 1000",
      "0 <= ranges[j][0] <= ranges[j][1] < words.length"
    ],
    "examples": [
      {
        "input": {
          "words": [
            "aeiou",
            "hello",
            "world",
            "ae",
            "io"
          ],
          "ranges": [
            [
              0,
              1
            ],
            [
              1,
              2
            ],
            [
              0,
              4
            ]
          ]
        },
        "output": [
          1,
          0,
          3
        ],
        "explanation": "In the first range [0, 1], 'aeiou' is a vowel string. In [1, 2], there are no vowel strings. In [0, 4], 'aeiou', 'ae', and 'io' are vowel strings."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a function to check if a string contains only vowels.",
      "Consider using prefix sums to optimize range queries."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Sort the Students by Their Kth Score",
    "description": "You are given a list of students where each student is represented as an array of scores. Your task is to sort the students based on their Kth score in descending order. If two students have the same Kth score, sort them by their names in alphabetical order.",
    "topic": "Sorting",
    "subtopic": "Custom Sorting",
    "tags": [
      "Sorting",
      "Strings",
      "Arrays"
    ],
    "input_format": "A list of student records where each record is represented as a list of integers, followed by an integer K (0-indexed).",
    "output_format": "A list of student names sorted according to the specified criteria.",
    "constraints": [
      "1 <= students.length <= 10^4",
      "1 <= students[i].length <= 100",
      "0 <= K < students[i].length",
      "Each student's name is unique and consists of lowercase and uppercase letters only."
    ],
    "examples": [
      {
        "input": "[[85, 90, 80, 'Alice'], [90, 85, 95, 'Bob'], [90, 92, 80, 'Charlie']], K = 1",
        "output": "['Bob', 'Alice', 'Charlie']",
        "explanation": "Bob has the highest second score (95), followed by Alice (90) and Charlie (92)."
      },
      {
        "input": "[[70, 80, 'Eve'], [80, 70, 'Dave'], [85, 85, 'Frank']], K = 0",
        "output": "['Frank', 'Dave', 'Eve']",
        "explanation": "Frank has the highest first score (85), followed by Dave (80) and Eve (70)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a custom sorting key for sorting.",
      "You can sort primarily by the Kth score and secondarily by names."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "String Compression",
    "description": "Given a string, implement a method to perform basic string compression using the counts of repeated characters. For example, the string 'aabcccccaaa' would become 'a2b1c5a3'. If the compressed string would not become smaller than the original string, your method should return the original string. You must optimize for both time and space complexity.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Compression",
      "Manipulation"
    ],
    "input_format": "A single string s consisting of alphabetical characters.",
    "output_format": "A compressed version of the string s if it's shorter, otherwise return the original string.",
    "constraints": [
      "0 <= s.length <= 1000",
      "s consists of only uppercase and lowercase letters."
    ],
    "examples": [
      {
        "input": "s = 'aabcccccaaa'",
        "output": "a2b1c5a3",
        "explanation": "The original string has characters 'a' repeated twice, 'b' once, 'c' five times, and 'a' three times, which gives the compressed result 'a2b1c5a3'."
      },
      {
        "input": "s = 'abcd'",
        "output": "abcd",
        "explanation": "The original string is not compressible to a shorter version, so we return it as is."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a loop to iterate through the string.",
      "Think about how to keep track of character counts efficiently."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Minimum Levels to Gain More Points",
    "description": "You are given a 2D grid of integers where each cell represents a level. Players can only move to adjacent (up, down, left, right) cells. The goal is to determine the minimum number of levels that need to be gained to reach a target score from a starting level. Each time a player moves from a cell with value `x` to adjacent cell with value `y`, the player gains `y - x` points if `y > x`. If the player cannot reach the target score, return -1.",
    "topic": "Graph",
    "subtopic": "Shortest Path",
    "tags": [
      "Graph",
      "BFS",
      "Pathfinding"
    ],
    "input_format": "A 2D grid of integers levels and an integer targetScore.",
    "output_format": "An integer representing the minimum levels to gain to reach the target score, or -1 if not possible.",
    "constraints": [
      "1 <= levels.length, levels[i].length <= 100",
      "1 <= levels[i][j] <= 100",
      "0 <= targetScore <= 10^4"
    ],
    "examples": [
      {
        "input": {
          "levels": [
            [
              1,
              2,
              3
            ],
            [
              0,
              5,
              6
            ],
            [
              4,
              8,
              1
            ]
          ],
          "targetScore": 5
        },
        "output": 3,
        "explanation": "Starting from cell (0,0) with value 1, the player can move to (0,1) with gain 1, then to (1,2) for a total of gain 3, reaching the target score 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a BFS approach to explore paths.",
      "Track the scores as you traverse the grid."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Type of Triangle",
    "description": "Given the lengths of three sides of a triangle, determine whether it is an equilateral, isosceles, or scalene triangle. An equilateral triangle has all three sides equal, an isosceles triangle has at least two sides equal, and a scalene triangle has all sides of different lengths. Your task is to return a string indicating the type of triangle.",
    "topic": "Geometry",
    "subtopic": "Triangle Classification",
    "tags": [
      "Geometry",
      "Triangle",
      "Classification"
    ],
    "input_format": "Three integers a, b, and c representing the lengths of the triangle's sides.",
    "output_format": "A string indicating the type of triangle: 'Equilateral', 'Isosceles', or 'Scalene'.",
    "constraints": [
      "1 <= a, b, c <= 10^4"
    ],
    "examples": [
      {
        "input": "a = 3, b = 3, c = 3",
        "output": "Equilateral",
        "explanation": "All sides are equal, hence it is an equilateral triangle."
      },
      {
        "input": "a = 5, b = 5, c = 8",
        "output": "Isosceles",
        "explanation": "Two sides are equal, hence it is an isosceles triangle."
      },
      {
        "input": "a = 4, b = 5, c = 6",
        "output": "Scalene",
        "explanation": "All sides are different, hence it is a scalene triangle."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Check the equality of the sides to determine the triangle type."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters. A substring is defined as a contiguous sequence of characters within the string.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A string s consisting of lowercase and uppercase English letters, digits, symbols, and spaces.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 5 * 10^4",
      "s consists of English letters, digits, symbols, and spaces."
    ],
    "examples": [
      {
        "input": "s = 'abcabcbb'",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'abc', which has a length of 3."
      },
      {
        "input": "s = 'bbbbb'",
        "output": "1",
        "explanation": "The longest substring without repeating characters is 'b', with a length of 1."
      },
      {
        "input": "s = 'pwwkew'",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'wke', which has a length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window to keep track of the current substring.",
      "Utilize a set to store characters and check for duplicates."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Maximum Profitable Triplets With Increasing Prices II",
    "description": "Given an array of integers representing the prices of a stock on consecutive days, your task is to find the maximum profit you can achieve by buying and selling stock on at most three non-overlapping occasions. You must ensure that the prices on each occasion are strictly increasing. Return the maximum profit you can obtain, or return 0 if no profit can be made.",
    "topic": "Dynamic Programming",
    "subtopic": "Stock Trading",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "A list of integers prices where 1 <= prices.length <= 10^5, and 0 <= prices[i] <= 10^9.",
    "output_format": "An integer representing the maximum profit achievable.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "prices = [5, 11, 3, 50, 60, 90]",
        "output": "93",
        "explanation": "Buy at 5, sell at 11, buy at 3, and sell at 90. Total profit = (11 - 5) + (90 - 3) = 6 + 87 = 93."
      },
      {
        "input": "prices = [1, 2, 3, 4, 5]",
        "output": "4",
        "explanation": "Buy at 1, sell at 5. Total profit = (5 - 1) = 4."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "No profitable transactions can be made since prices are decreasing."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a dynamic programming approach to track profits.",
      "Keep track of the increasing sequences while calculating profits."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Average Value of Even Numbers That Are Divisible by Three",
    "description": "Given an array of integers, calculate the average value of all even numbers that are also divisible by three. If there are no even numbers divisible by three, return 0.",
    "topic": "Array",
    "subtopic": "Filtering and Averaging",
    "tags": [
      "Array",
      "Average",
      "Filtering"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A float representing the average value of even numbers that are divisible by three, rounded to two decimal places.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 6, 9, 12]",
        "output": "9.00",
        "explanation": "The even numbers divisible by 3 are 6 and 12. Their average is (6 + 12) / 2 = 9."
      },
      {
        "input": "nums = [2, 4, 8, 10]",
        "output": "0.00",
        "explanation": "There are no even numbers divisible by 3, so the output is 0."
      },
      {
        "input": "nums = [3, 6, 12, 15]",
        "output": "6.00",
        "explanation": "The even numbers divisible by 3 are 6 and 12. Their average is (6 + 12) / 2 = 9."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Check for even numbers using num % 2 == 0.",
      "Check for divisibility by 3 using num % 3 == 0.",
      "Use a sum and count to calculate the average."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Count the Number of Incremovable Subarrays II",
    "description": "Given an array of integers, your task is to count the number of subarrays that can be considered 'incremovable'. An 'incremovable' subarray is defined as a contiguous subarray where you cannot remove any single element and still have a subarray that satisfies the property of being 'great' (increasing in this case). A subarray is 'great' if its elements are strictly increasing. You need to determine how many such 'incremovable' subarrays exist in the given array.",
    "topic": "Array",
    "subtopic": "Subarrays",
    "tags": [
      "Array",
      "Subarrays",
      "Counting"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the number of incremovable subarrays.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "10",
        "explanation": "All subarrays in an entirely increasing sequence are incremovable: [1], [2], [3], [4], [1,2], [2,3], [3,4], [1,2,3], [2,3,4], and [1,2,3,4]."
      },
      {
        "input": "nums = [1, 3, 2, 4]",
        "output": "4",
        "explanation": "The incremovable subarrays here are: [1, 3], [2, 4], and single elements [1], [3]."
      },
      {
        "input": "nums = [5, 1, 2, 6, 3]",
        "output": "6",
        "explanation": "The incremovable subarrays are: [5], [1], [2], [6], [3], and [2, 6]."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how the removal of a single element affects the overall structure of the subarray.",
      "Keep track of lengths of continuously increasing sequences.",
      "Utilize two pointers or a sliding window technique for efficient counting."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Find the Array Concatenation Value",
    "description": "Given an array of integers, the concatenation value of an array is calculated by concatenating the values from the beginning and the end of the array towards the center. Specifically, for an array `nums` of length `n`, the concatenation value is computed as `nums[0] * (10^n) + nums[1] * (10^(n-1)) + ... + nums[n-1] * (10^0)`. Your task is to implement a function that returns the concatenation value of the provided array.",
    "topic": "Array",
    "subtopic": "Concat and Sum",
    "tags": [
      "Array",
      "Concat",
      "Math"
    ],
    "input_format": "An array of integers `nums`.",
    "output_format": "An integer representing the concatenation value of the array.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "123",
        "explanation": "Concatenation of the array yields 1 * 100 + 2 * 10 + 3 * 1 = 100 + 20 + 3 = 123."
      },
      {
        "input": "nums = [5, 0, 3]",
        "output": "503",
        "explanation": "Concatenation of the array yields 5 * 100 + 0 * 10 + 3 * 1 = 500 + 0 + 3 = 503."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Think about how to calculate the positional value of each number in the concatenation."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". A common prefix is defined as a substring that occurs at the beginning of all strings in the array.",
    "topic": "String",
    "subtopic": "Prefix",
    "tags": [
      "String",
      "Prefix",
      "Array"
    ],
    "input_format": "An array of strings strs where 0 <= strs.length <= 200 and 0 <= strs[i].length <= 200.",
    "output_format": "A string representing the longest common prefix. Return an empty string if there is no common prefix.",
    "constraints": [
      "0 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "All strings in strs are lowercase letters."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The longest common prefix is \"fl\"."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among the strings."
      },
      {
        "input": "strs = [\"ab\", \"a\"]",
        "output": "\"a\"",
        "explanation": "The longest common prefix is \"a\"."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider sorting the array.",
      "The common prefix is between the first and the last string in sorted order.",
      "Use a loop to compare characters in the prefix."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. For example, if you have intervals [1,3], [2,6], [8,10], and [15,18], the merged intervals would be [1,6], [8,10], and [15,18]. The intervals are represented as an array of pairs where each pair represents the start and end of an interval. Return the merged intervals in ascending order.",
    "topic": "Array",
    "subtopic": "Sorting & Merging",
    "tags": [
      "Array",
      "Sorting",
      "Interval",
      "Merging"
    ],
    "input_format": "A 2D array of integers where each inner array represents an interval with two integers [start, end].",
    "output_format": "A 2D array of merged intervals in ascending order.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3], [2,6], [8,10], [15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "The intervals [1,3] and [2,6] overlap, so they are merged into [1,6]. The other intervals do not overlap."
      },
      {
        "input": "intervals = [[1,4], [4,5]]",
        "output": "[[1,5]]",
        "explanation": "The intervals [1,4] and [4,5] touch at 4, so they are merged into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on the starting value.",
      "Use a list to store the merged intervals.",
      "Compare the current interval with the last merged interval to check for overlaps."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Maximum Units on a Truck",
    "description": "You are transporting boxes to a warehouse using a truck. Each box has a weight and a number of units. You want to maximize the total number of units on the truck without exceeding its weight capacity. Given an array of boxes, where each box is represented by an array of two integers [weight, units], and an integer capacity, return the maximum total number of units you can transport.",
    "topic": "Greedy",
    "subtopic": "Sorting",
    "tags": [
      "Greedy",
      "Sorting",
      "Array"
    ],
    "input_format": "An array of boxes where each box is a list of two integers [weight, units] and an integer capacity.",
    "output_format": "An integer representing the maximum total number of units.",
    "constraints": [
      "1 <= boxes.length <= 1000",
      "1 <= weight <= 100",
      "1 <= units <= 1000",
      "1 <= capacity <= 10^6"
    ],
    "examples": [
      {
        "input": "boxes = [[1,3],[2,2],[3,4]], capacity = 4",
        "output": "6",
        "explanation": "We can take the first two boxes (weight 1 and 2) which gives us a total of 3 + 2 = 5 units. We cannot take the box with weight 3 because it exceeds the capacity."
      },
      {
        "input": "boxes = [[5,10],[2,5],[3,6]], capacity = 5",
        "output": "5",
        "explanation": "The only box we can take is the one with weight 2 and 5 units."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Sort boxes by units per weight and process them in that order.",
      "Use a greedy approach to maximize the units."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Get Equal Substrings Within Budget",
    "description": "Given a string s and an integer budget, find the length of the longest substring that can be formed by changing at most 'budget' characters in s to make all characters equal. Return the length of that substring.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Two Pointers"
    ],
    "input_format": "A string s consisting of lowercase English letters and an integer budget.",
    "output_format": "An integer representing the length of the longest valid substring.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "1 <= budget <= s.length"
    ],
    "examples": [
      {
        "input": "s = \"AABABBA\", budget = 1",
        "output": "4",
        "explanation": "The longest substring is \"AABA\" or \"ABBA\". We can change one 'B' -> 'A' or one 'A' -> 'B' respectively."
      },
      {
        "input": "s = \"AAABBC\", budget = 2",
        "output": "5",
        "explanation": "The longest substring is \"AAABB\" or \"AABBC\". We can change one 'C' -> 'A' and another 'C' -> 'A' or change two 'C's to 'B's."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sliding window approach.",
      "Keep track of the characters counts within the current window."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if the brackets are closed in the correct order. Every opening bracket must have a corresponding closing bracket of the same type. The string can be considered valid if it is empty.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A string s consisting of characters '(', ')', '{', '}', '[' and ']' only.",
    "output_format": "A boolean value indicating whether the input string is valid.",
    "constraints": [
      "0 <= s.length <= 10^4",
      "s consists of parentheses only."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The string has one pair of valid parentheses."
      },
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "All brackets are closed in the correct order."
      },
      {
        "input": "s = '(]'",
        "output": "false",
        "explanation": "The brackets are not closed in the correct order."
      },
      {
        "input": "s = '([)]'",
        "output": "false",
        "explanation": "The brackets are closed in the wrong order."
      },
      {
        "input": "s = '{[]}'",
        "output": "true",
        "explanation": "The string has valid nested brackets."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "Check if the top of the stack matches the corresponding closing bracket."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Count Binary Substrings",
    "description": "Given a string s consisting of '0's and '1's, return the count of non-empty substrings that have the same number of '0's and '1's. A substring is a contiguous sequence of characters in the string.",
    "topic": "String",
    "subtopic": "Substring",
    "tags": [
      "String",
      "Substring",
      "Counting"
    ],
    "input_format": "A string s of length n (1 <= n <= 100)",
    "output_format": "An integer representing the count of balanced substrings.",
    "constraints": [
      "s consists of '0's and '1's only",
      "1 <= s.length <= 100"
    ],
    "examples": [
      {
        "input": "s = \"00110011\"",
        "output": "6",
        "explanation": "The balanced substrings are: \"0011\", \"01\", \"10\", \"1100\", \"00\", \"11\"."
      },
      {
        "input": "s = \"10101\"",
        "output": "4",
        "explanation": "The balanced substrings are: \"10\", \"01\", \"10\", \"01\"."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a counting method based on runs of consecutive '0's and '1's.",
      "You can keep track of the lengths of these runs."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Maximum Sum of Distinct Subarrays With Length K",
    "description": "Given an array of integers and a positive integer K, find the maximum sum of any distinct subarray of length K. A subarray can be defined as a contiguous part of the array that contains unique elements. If it's not possible to form such a subarray, return -1.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Hash Map"
    ],
    "input_format": "An array of integers nums and an integer K.",
    "output_format": "An integer representing the maximum sum of distinct subarrays of length K, or -1 if no such subarray exists.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= K <= nums.length",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 2, 5], K = 3",
        "output": "10",
        "explanation": "The subarray [2, 3, 5] has a maximum sum of 10."
      },
      {
        "input": "nums = [1, 2, 1], K = 2",
        "output": "3",
        "explanation": "The subarray [1, 2] has a maximum sum of 3, and only unique elements are considered."
      },
      {
        "input": "nums = [1, 2, 2, 1], K = 3",
        "output": "-1",
        "explanation": "It's not possible to form a distinct subarray of length 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window approach to maintain the current subarray.",
      "Utilize a hash map to track the count of elements in the current window.",
      "Keep track of the sum of the current window to find the maximum sum efficiently."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Numbers With Repeated Digits",
    "description": "Given a non-negative integer n, return the total number of unique integers in the range from 0 to n (including n) that do not contain any repeated digits. You should count only integers with digits 0 to 9.",
    "topic": "Mathematics",
    "subtopic": "Combinatorics",
    "tags": [
      "Mathematics",
      "Combinatorics",
      "Counting"
    ],
    "input_format": "A single integer n representing the upper limit of the range.",
    "output_format": "An integer representing the count of unique integers without repeated digits from 0 to n.",
    "constraints": [
      "0 <= n <= 10^9"
    ],
    "examples": [
      {
        "input": "n = 20",
        "output": "19",
        "explanation": "The unique integers without repeated digits from 0 to 20 are: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20. Thus, the count is 19."
      },
      {
        "input": "n = 100",
        "output": "90",
        "explanation": "The unique integers without repeated digits from 0 to 100 are: There are 90 such numbers. Counting carefully, we can verify this."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to generate numbers with distinct digits.",
      "Think about digit positions and possible choices."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Minimum Suffix Flips",
    "description": "You are given a binary string consisting of '0's and '1's. Your goal is to determine the minimum number of operations required to make all characters in the string the same. An operation is defined as flipping all characters in a suffix of the string. A suffix is any contiguous substring that starts from a given index and extends to the end of the string. Return the minimum number of flips needed.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Binary",
      "Greedy"
    ],
    "input_format": "A binary string s consisting of '0's and '1's.",
    "output_format": "An integer representing the minimum number of suffix flips required.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s[i] is either '0' or '1'."
    ],
    "examples": [
      {
        "input": "s = '00110'",
        "output": "1",
        "explanation": "Flipping the suffix starting from index 2 results in '00000'."
      },
      {
        "input": "s = '010101'",
        "output": "3",
        "explanation": "Flipping the entire string results in '101010'. Additionally, flipping the suffix starting from index 4 can lead to '111100'. Two more flips are needed to achieve the final string of all '1's."
      },
      {
        "input": "s = '00000'",
        "output": "0",
        "explanation": "No flips needed as all characters are already the same."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the transitions between '0' and '1' in the string.",
      "Count the number of segments of consecutive '0's and '1's."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Letter Combinations of a Phone Number",
    "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters is as follows: 2 -> 'abc', 3 -> 'def', 4 -> 'ghi', 5 -> 'jkl', 6 -> 'mno', 7 -> 'pqrs', 8 -> 'tuv', 9 -> 'wxyz'. Return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "String Manipulation",
    "tags": [
      "Backtracking",
      "Recursion",
      "String"
    ],
    "input_format": "A string digits representing the digits on a phone keypad.",
    "output_format": "A list of all possible letter combinations that the phone number could represent.",
    "constraints": [
      "0 <= digits.length <= 4",
      "digits[i] is a digit from '2' to '9'."
    ],
    "examples": [
      {
        "input": "digits = '23'",
        "output": "['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']",
        "explanation": "'2' maps to 'abc' and '3' maps to 'def', thus giving combinations of the letters."
      },
      {
        "input": "digits = ''",
        "output": "[]",
        "explanation": "An empty input should yield an empty list."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to build combinations.",
      "Use a mapping of digits to letters to simplify the combination process."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Lexicographically Smallest String After Substring Operation",
    "description": "Given a string, you are allowed to perform the following operation: choose a substring of size `k` and replace it with any other string of size `k`. Your task is to return the lexicographically smallest string that can be formed after performing this operation exactly once on the input string.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Greedy"
    ],
    "input_format": "A string `s` of length `n` (1 <= n <= 1000) and an integer `k` (1 <= k <= n).",
    "output_format": "A string representing the lexicographically smallest string after performing the operation.",
    "constraints": [
      "1 <= s.length <= 1000",
      "1 <= k <= s.length"
    ],
    "examples": [
      {
        "input": "s = 'cba', k = 1",
        "output": "abc",
        "explanation": "By replacing any one character, 'c' with 'a', we can reach 'aba' which is lexicographically smaller than 'cba'. Further, by replacing 'b' with 'a', we get 'aab' which is smaller than 'aba'. Thus, 'abc' is the final result."
      },
      {
        "input": "s = 'zxy', k = 2",
        "output": "axy",
        "explanation": "By replacing the first two characters 'zx' with 'a', we can achieve 'axy' which is lexicographically smaller than 'zxy'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider all possible substrings of length k.",
      "Try replacing the chosen substring with all possible characters."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A substring is defined as a contiguous sequence of characters within the string. A palindrome is a string that reads the same forwards and backwards.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A string s of length n.",
    "output_format": "A string representing the longest palindromic substring of s.",
    "constraints": [
      "1 <= n <= 1000",
      "s consists of lowercase and uppercase English letters."
    ],
    "examples": [
      {
        "input": "s = 'babad'",
        "output": "'bab'",
        "explanation": "Both 'bab' and 'aba' are valid palindromic substrings, but 'bab' is the first longest one."
      },
      {
        "input": "s = 'cbbd'",
        "output": "'bb'",
        "explanation": "'bb' is the longest palindromic substring."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding around possible centers.",
      "Remember that a palindrome can be of even or odd length."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Merge Sorted Array",
    "description": "You are given two sorted arrays of integers, nums1 and nums2. Your task is to merge nums2 into nums1 as one sorted array. The merging should be done in-place, meaning that you should not use any additional array. The final merged array should also be sorted.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "Two sorted integers arrays nums1 and nums2, where nums1 has enough space to hold additional elements from nums2.",
    "output_format": "The combined sorted array in nums1.",
    "constraints": [
      "0 <= nums1.length, nums2.length <= 200",
      "All elements in nums1 and nums2 are in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3",
        "output": "[1, 2, 2, 3, 5, 6]",
        "explanation": "After merging, the array becomes [1, 2, 2, 3, 5, 6]."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "Since nums2 is empty, the result is [1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider merging from the end of nums1 and nums2.",
      "Use two pointers to track the current position in nums1 and nums2."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Kadane's Algorithm"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the largest sum of the contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The contiguous subarray [4,-1,2,1] has the largest sum = 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The only element is 1, which is the largest sum."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The contiguous subarray [5,4,-1,7,8] has the largest sum = 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to maintain the current maximum sum while iterating through the array.",
      "If the current sum becomes negative, reset it to zero."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given a 2D array of integers, return all elements of the matrix in spiral order. The elements should be read from the outermost layer to the innermost layer, moving right, down, left, and up.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral Order"
    ],
    "input_format": "A 2D array of integers matrix where rows * columns >= 1.",
    "output_format": "A list of integers representing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= matrix.length <= 10^4",
      "1 <= matrix[i].length <= 10^4",
      "matrix[i].length == matrix[j].length for all valid i, j"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "Starting from the top-left corner, the order is 1 -> 2 -> 3, then down -> 6, then right -> 9, then up -> 8, then left -> 7, and finally inwards -> 4, 5."
      },
      {
        "input": "matrix = [[1]]",
        "output": "[1]",
        "explanation": "Only one element exists in the matrix."
      },
      {
        "input": "matrix = [[1, 2], [3, 4]]",
        "output": "[1, 2, 4, 3]",
        "explanation": "The order starts at 1, then goes to 2, then down to 4 and finally left to 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use four variables to keep track of the boundaries of the layers.",
      "Keep iterating until all boundaries overlap."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Number of Divisible Substrings",
    "description": "Given a string s and an integer k, return the number of substrings of s that are divisible by k. A substring is considered divisible by k if the integer value of the substring is divisible by k. Substrings can be of any length ranging from 1 to the length of the string with consecutive characters.",
    "topic": "String",
    "subtopic": "Substring",
    "tags": [
      "String",
      "Substring",
      "Math"
    ],
    "input_format": "A string s consisting of digits (0-9) and an integer k (1 <= k <= 100).",
    "output_format": "An integer representing the count of divisible substrings.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists only of digits."
    ],
    "examples": [
      {
        "input": {
          "s": "1234",
          "k": 2
        },
        "output": 5,
        "explanation": "The substrings are '1', '2', '3', '4', '12', '34', '123', '234', '1234'. The substrings '2', '4', '12', '34', and '234' are divisible by 2. Total = 5."
      },
      {
        "input": {
          "s": "000",
          "k": 3
        },
        "output": 6,
        "explanation": "All substrings are '0', '0', '0', '00', '00', '000'. They are all divisible by 3. Total = 6."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider running through possible substrings.",
      "Use integer parsing for each substring to check divisibility."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Longest Consecutive Sequence",
    "description": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence. The consecutive elements sequence should not necessarily be sorted and can include negative numbers as well. Implement an efficient algorithm to solve the problem with a time complexity of O(n).",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Consecutive Sequence"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the length of the longest consecutive sequence.",
    "constraints": [
      "0 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [100, 4, 200, 1, 3, 2]",
        "output": "4",
        "explanation": "The longest consecutive sequence is [1, 2, 3, 4], which has a length of 4."
      },
      {
        "input": "nums = [0, 0, -1, 1, 2, 3]",
        "output": "5",
        "explanation": "The longest consecutive sequence is [-1, 0, 1, 2, 3], which has a length of 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash set to store the elements.",
      "For each number, check how long the consecutive sequence goes."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Count Pairs Of Similar Strings",
    "description": "Given a list of strings, count the number of pairs of strings that are similar. Two strings are considered similar if they can be made identical by rearranging the letters. For example, 'abc' and 'cab' are similar but 'abc' and 'def' are not. Return the total count of such pairs.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Counting",
      "Pairs"
    ],
    "input_format": "A list of strings `words` where 1 <= words.length <= 10^4 and 1 <= words[i].length <= 100.",
    "output_format": "An integer representing the number of pairs of similar strings.",
    "constraints": [
      "1 <= words.length <= 10^4",
      "1 <= words[i].length <= 100"
    ],
    "examples": [
      {
        "input": "words = [\"abc\", \"cba\", \"xyz\", \"zyx\", \"pqr\"]",
        "output": "4",
        "explanation": "The pairs of similar strings are: ('abc', 'cba'), ('cba', 'abc'), ('xyz', 'zyx'), ('zyx', 'xyz')."
      },
      {
        "input": "words = [\"a\", \"b\", \"c\"]",
        "output": "0",
        "explanation": "No pairs of similar strings can be formed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider sorting the strings to identify similar ones.",
      "Use a hash map to count occurrences of sorted strings."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "topic": "String",
    "subtopic": "Grouping",
    "tags": [
      "String",
      "Hash Table",
      "Sorting"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A list of lists containing grouped anagrams.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "explanation": "The input strings can be grouped by their sorted characters. For example, 'eat', 'tea', and 'ate' all share the same sorted character arrangement."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map to group the strings based on their sorted character representation.",
      "Think about how to generate a unique key for each anagram."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Shortest and Lexicographically Smallest Beautiful String",
    "description": "Given a string containing lowercase letters and the requirement to create a new string consisting of exactly 'n' characters, find the shortest lexicographically smallest beautiful string that can be formed. A beautiful string is defined as a string that contains each letter at least once and adheres to the beauty rules, such as no two consecutive letters being the same.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Greedy",
      "Constructive Algorithm"
    ],
    "input_format": "An integer n representing the length of the beautiful string to be formed.",
    "output_format": "A string representing the shortest lexicographically smallest beautiful string.",
    "constraints": [
      "1 <= n <= 26"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "abc",
        "explanation": "The shortest and lexicographically smallest string of length 3 that contains all distinct characters is 'abc'."
      },
      {
        "input": "n = 5",
        "output": "abcde",
        "explanation": "'abcde' is the only option to create a beautiful string of length 5 with distinct characters."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the constraints of unique characters.",
      "Try to build the string starting from 'a' and use the next available letters."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Validate Binary Search Tree",
    "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "The input consists of the root node of a binary tree.",
    "output_format": "Return true if the binary tree is a valid binary search tree, otherwise return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "Each node's value is unique.",
      "-2^31 <= Node.val <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "root = [2, 1, 3]",
        "output": "true",
        "explanation": "The tree is valid because 1 < 2 < 3."
      },
      {
        "input": "root = [5, 1, 4, null, null, 3, 6]",
        "output": "false",
        "explanation": "The tree is invalid because 3 is in the right subtree of 5, but less than 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use recursion to traverse the tree.",
      "Keep track of the valid range of values for each node."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "topic": "Dynamic Programming",
    "subtopic": "Fibonacci Sequence",
    "tags": [
      "Dynamic Programming",
      "Math",
      "Recursion"
    ],
    "input_format": "An integer n representing the number of steps in the staircase.",
    "output_format": "An integer representing the number of distinct ways to climb to the top.",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: 1 step + 1 step or 2 steps."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, or 2 steps + 1 step."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Think of how the problem can be solved using recursion.",
      "Consider the relationship between the current step and the previous steps."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Subarray Product Less Than K",
    "description": "Given an array of positive integers nums and a positive integer k, return the length of the longest subarray where the product of all its elements is less than k.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Two Pointers"
    ],
    "input_format": "An array of positive integers nums followed by a positive integer k.",
    "output_format": "An integer representing the length of the longest subarray with product less than k.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i] < k <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [10, 5, 2, 6], k = 100",
        "output": "4",
        "explanation": "The subarray [10, 5, 2, 6] has a product of 600, but the longest subarray with product less than 100 is [5, 2] or [10, 5], both of length 2. Thus, the answer is 4 (including all elements)."
      },
      {
        "input": "nums = [1, 2, 3, 4], k = 10",
        "output": "4",
        "explanation": "The entire array has a product of 24 which is greater than 10. The longest subarray with product less than 10 is [1, 2, 3] with a product of 6, and has length 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the use of a sliding window technique.",
      "Keep track of the product of elements in the current subarray.",
      "Use two pointers to define the current subarray."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Minimum Swaps to Group All 1's Together II",
    "description": "You are given a binary array with elements 0 and 1. Your task is to determine the minimum number of swaps required to group all 1's together in the array. A swap involves exchanging the position of two elements in the array. Your goal is to return the minimum number of swaps needed to achieve this grouping.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Greedy",
      "Sliding Window"
    ],
    "input_format": "A binary array nums of length n (1 <= n <= 10^5).",
    "output_format": "An integer representing the minimum number of swaps required to group all 1's together.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "nums[i] is either 0 or 1"
    ],
    "examples": [
      {
        "input": "nums = [1, 0, 1, 0, 1]",
        "output": "1",
        "explanation": "By swapping the first 0 with the middle 1, we can group all 1's as [1, 1, 1, 0, 0]."
      },
      {
        "input": "nums = [1, 1, 0, 0, 1, 1]",
        "output": "0",
        "explanation": "All 1's are already grouped together, so no swaps are required."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Count the total number of 1's in the array.",
      "Use a sliding window technique to find the minimum swaps."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Smallest Missing Non-negative Integer After Operations",
    "description": "You are given an array of integers 'nums' that may contain negative numbers. You can perform the following operation on the array any number of times: choose any element 'x' in 'nums' and replace 'x' with 'x - 1' (if it's greater than -1). Your task is to find the smallest non-negative integer that is not present in the modified array after performing any number of such operations.",
    "topic": "Array",
    "subtopic": "Searching and Manipulation",
    "tags": [
      "Array",
      "Searching",
      "Greedy"
    ],
    "input_format": "An array of integers 'nums'.",
    "output_format": "An integer representing the smallest non-negative integer that is not present in the array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [3, 0, 1]",
        "output": "2",
        "explanation": "After performing operations, we can keep 0 and 1 as they exist, thus 2 is the smallest non-negative integer not present."
      },
      {
        "input": "nums = [1, 2, 2, 1]",
        "output": "0",
        "explanation": "We can decrement all 1s and 2s, and 0 is the smallest non-negative integer that is absent."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Focus on the range of non-negative integers.",
      "Consider the frequency of integers in the array."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Divide Players Into Teams of Equal Skill",
    "description": "You are given a list of integers representing the skill levels of players. Your task is to determine whether it is possible to divide the players into two teams such that the sum of skill levels in each team is equal. If it is possible, return true; otherwise, return false.",
    "topic": "Dynamic Programming",
    "subtopic": "Subset Sum Problem",
    "tags": [
      "Dynamic Programming",
      "Subset Sum",
      "Greed"
    ],
    "input_format": "An array of integers representing the skill levels of the players.",
    "output_format": "A boolean value indicating whether the players can be divided into two teams of equal skill.",
    "constraints": [
      "1 <= nums.length <= 200",
      "0 <= nums[i] <= 10000"
    ],
    "examples": [
      {
        "input": "nums = [1, 5, 11, 5]",
        "output": "true",
        "explanation": "The players can be divided into two teams: [1, 5, 5] and [11] with equal skill level of 11."
      },
      {
        "input": "nums = [1, 2, 3, 5]",
        "output": "false",
        "explanation": "It's not possible to split the players into two teams with equal skill level."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Calculate the total skill sum. If it's odd, return false.",
      "Use dynamic programming to determine if a subset can match half of the total."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Find the Index of the First Occurrence in a String",
    "description": "Given a string `haystack` and a string `needle`, return the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`.",
    "topic": "String",
    "subtopic": "Searching",
    "tags": [
      "String",
      "Searching"
    ],
    "input_format": "Two strings, `haystack` and `needle`, where 0 <= haystack.length <= 10^5 and 0 <= needle.length <= 10^5.",
    "output_format": "An integer representing the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` does not occur.",
    "constraints": [
      "0 <= haystack.length <= 10^5",
      "0 <= needle.length <= 10^5"
    ],
    "examples": [
      {
        "input": "haystack = 'hello', needle = 'll'",
        "output": "2",
        "explanation": "The substring 'll' first occurs at index 2 in 'hello'."
      },
      {
        "input": "haystack = 'aaaaa', needle = 'bba'",
        "output": "-1",
        "explanation": "'bba' does not occur in 'aaaaa', hence the output is -1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using string methods or a loop to check for occurrences.",
      "Think about the implications of an empty needle."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Rotate Array",
    "description": "Given an array of integers and a number k, rotate the array to the right by k steps, where k is non-negative. Do this in-place with O(1) extra space.",
    "topic": "Array",
    "subtopic": "In-place Array Manipulation",
    "tags": [
      "Array",
      "Rotation",
      "In-place"
    ],
    "input_format": "An array of integers nums and a non-negative integer k.",
    "output_format": "The rotated array as an integer array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= k <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5], k = 2",
        "output": "[4, 5, 1, 2, 3]",
        "explanation": "Rotating the array [1, 2, 3, 4, 5] to the right by 2 steps results in [4, 5, 1, 2, 3]."
      },
      {
        "input": "nums = [-1, -100, 3, 99], k = 2",
        "output": "[3, 99, -1, -100]",
        "explanation": "Rotating the array [-1, -100, 3, 99] to the right by 2 steps results in [3, 99, -1, -100]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider reversing parts of the array.",
      "Think about the effective number of rotations needed."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Longest Increasing Subsequence",
    "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
    "topic": "Dynamic Programming",
    "subtopic": "Longest Increasing Subsequence",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Binary Search"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the length of the longest increasing subsequence.",
    "constraints": [
      "1 <= nums.length <= 2500",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [10, 9, 2, 5, 3, 7, 101, 18]",
        "output": "4",
        "explanation": "The longest increasing subsequence is [2, 3, 7, 101], so the length is 4."
      },
      {
        "input": "nums = [0, 1, 0, 3, 2, 3]",
        "output": "4",
        "explanation": "The longest increasing subsequence is [0, 1, 2, 3], so the length is 4."
      },
      {
        "input": "nums = [7, 7, 7, 7, 7, 7, 7]",
        "output": "1",
        "explanation": "The longest increasing subsequence can only be one of the 7s, so the length is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store the length of increasing subsequences.",
      "You can also optimize the solution using binary search."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Find Minimum in Rotated Sorted Array",
    "description": "You are given a rotated sorted array of unique integers. Find the minimum element in the array. The rotation is defined as moving some elements from the beginning of the array to the end. It is guaranteed that the input array is non-empty and contains at least one element.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Searching"
    ],
    "input_format": "An integer array `nums` where 1 <= nums.length <= 10^5 and -10^4 <= nums[i] <= 10^4.",
    "output_format": "An integer representing the minimum element in the array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "The array contains unique elements."
    ],
    "examples": [
      {
        "input": "nums = [3, 4, 5, 1, 2]",
        "output": "1",
        "explanation": "The array is rotated at index 3. The minimum element is 1."
      },
      {
        "input": "nums = [4, 5, 6, 7, 0, 1, 2]",
        "output": "0",
        "explanation": "The array is rotated at index 3. The minimum element is 0."
      },
      {
        "input": "nums = [11, 13, 15, 17]",
        "output": "11",
        "explanation": "The array is not rotated. The minimum element is 11."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of a rotated sorted array.",
      "You can apply binary search to reduce the time complexity."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Subsets",
    "description": "Given a set of distinct integers, return all possible subsets (the power set). The solution set must not contain duplicate subsets. You may return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Subsets Generation",
    "tags": [
      "Backtracking",
      "Recursion",
      "Subset"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "A list of lists, where each list represents a unique subset of the input set.",
    "constraints": [
      "0 <= nums.length <= 10",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]",
        "explanation": "The subsets of the set [1, 2, 3] include the empty set, each individual element, pairs of elements, and the full set itself."
      },
      {
        "input": "nums = [0]",
        "output": "[[], [0]]",
        "explanation": "The subsets of the set [0] include the empty set and the set itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider each element and decide whether to include it in a subset or not.",
      "Use a backtracking approach to explore all possible combinations."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Palindrome Number",
    "description": "Given an integer x, return true if x is a palindrome, and false otherwise. A palindrome is a number that remains the same when its digits are reversed.",
    "topic": "Math",
    "subtopic": "Number Manipulation",
    "tags": [
      "Math",
      "Palindrome",
      "Number"
    ],
    "input_format": "An integer x.",
    "output_format": "A boolean value, true if x is a palindrome, false otherwise.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 121",
        "output": "true",
        "explanation": "121 is the same when read forwards and backwards."
      },
      {
        "input": "x = -121",
        "output": "false",
        "explanation": "-121 reads 121- which is not the same as -121."
      },
      {
        "input": "x = 10",
        "output": "false",
        "explanation": "10 reads 01 when reversed, which is not the same as 10."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Convert the number to a string and check if it is the same forwards and backwards.",
      "You can also reverse the number mathematically without converting it to a string."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Subarray Sum Equals K",
    "description": "Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k.",
    "topic": "Array",
    "subtopic": "Subarray",
    "tags": [
      "Array",
      "Hash Table",
      "Prefix Sum"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An integer representing the number of continuous subarrays that sum to k.",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-1000 <= nums[i] <= 1000",
      "-10^7 <= k <= 10^7"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 1], k = 2",
        "output": "2",
        "explanation": "The subarrays [1, 1] (indices 0-1 and 1-2) sum to 2. Hence, there are 2 such subarrays."
      },
      {
        "input": "nums = [1, 2, 3], k = 3",
        "output": "2",
        "explanation": "The subarrays [3] (index 2) and [1, 2] (indices 0-1) sum to 3. Hence, there are 2 such subarrays."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to store the cumulative sum.",
      "For each cumulative sum, check how many times (cumulative_sum - k) has occurred so far."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Number of Operations to Make Network Connected",
    "description": "You are given an integer n representing the number of computers in a network, and an array connections where connections[i] = [a, b] represents a connection between computers a and b. You want to connect all the computers in the network by performing some operations. In one operation, you can connect two unconnected computers. Return the minimum number of operations needed to make all computers connected. If it is impossible to connect all computers, return -1.",
    "topic": "Graph",
    "subtopic": "Union Find",
    "tags": [
      "Graph",
      "Union Find",
      "Connected Components"
    ],
    "input_format": "An integer n followed by an array of connections.",
    "output_format": "An integer representing the minimum number of operations required to connect all computers or -1 if it's impossible.",
    "constraints": [
      "1 <= n <= 10^5",
      "0 <= connections.length <= 10^5",
      "connections[i].length == 2",
      "The connections are bidirectional."
    ],
    "examples": [
      {
        "input": "n = 4, connections = [[0, 1], [0, 2], [1, 2]]",
        "output": "1",
        "explanation": "We can connect computer 3 to any of the already connected computers, resulting in a total of 1 operation."
      },
      {
        "input": "n = 6, connections = [[0, 1], [0, 2], [0, 3], [1, 2]]",
        "output": "-1",
        "explanation": "It's impossible to connect all computers since we can only connect 4 computers with the given connections."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Count the number of connected components in the graph.",
      "If the number of connections is less than n - 1, return -1."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of sizes m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (min(m,n))). You may assume nums1 and nums2 cannot be both empty.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Median"
    ],
    "input_format": "Two sorted arrays nums1 and nums2.",
    "output_format": "A float representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= nums1.length <= 1000",
      "0 <= nums2.length <= 1000",
      "nums1 and nums2 are sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.0",
        "explanation": "The merged array is [1, 2, 3], and the median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.5",
        "explanation": "The merged array is [1, 2, 3, 4], and the median is (2 + 3) / 2 = 2.5."
      },
      {
        "input": "nums1 = [], nums2 = [1]",
        "output": "1.0",
        "explanation": "The merged array is [1], and the median is 1."
      },
      {
        "input": "nums1 = [2], nums2 = []",
        "output": "2.0",
        "explanation": "The merged array is [2], and the median is 2."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using binary search on the smaller array.",
      "Try to partition the arrays to find the median."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Intersection of Two Arrays",
    "description": "Given two integer arrays, find the intersection of these two arrays. Each element in the result must be unique. You may assume the two arrays are not empty and the result can be returned in any order.",
    "topic": "Array",
    "subtopic": "Set Operations",
    "tags": [
      "Array",
      "Intersection",
      "Set"
    ],
    "input_format": "Two arrays of integers, nums1 and nums2.",
    "output_format": "An array of unique integers representing the intersection of nums1 and nums2.",
    "constraints": [
      "1 <= nums1.length, nums2.length <= 10^4",
      "-10^9 <= nums1[i], nums2[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]",
        "output": "[2]",
        "explanation": "The unique intersection of the arrays is [2]."
      },
      {
        "input": "nums1 = [4, 9, 5], nums2 = [9, 4, 9, 8, 4]",
        "output": "[4, 9]",
        "explanation": "The unique intersection of the arrays is [4, 9]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Using a set can help with finding unique elements quickly.",
      "Consider iterating through one array and checking membership in the other."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Next Permutation",
    "description": "Implement an algorithm to rearrange the numbers in an array to produce the next lexicographical permutation. If such an arrangement is not possible, it must be rearranged to the lowest possible order (i.e., sorted in ascending order). The lexicographic order of an array of integers is defined by their ordering as if they were sorted in dictionary order. The implementation should modify the array in place.",
    "topic": "Array",
    "subtopic": "Permutation",
    "tags": [
      "Array",
      "Permutation",
      "Next Permutation"
    ],
    "input_format": "An array of integers nums representing a permutation.",
    "output_format": "The array nums, modified to be the next permutation.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[1, 3, 2]",
        "explanation": "The next permutation of [1, 2, 3] is [1, 3, 2]."
      },
      {
        "input": "nums = [3, 2, 1]",
        "output": "[1, 2, 3]",
        "explanation": "Since [3, 2, 1] is the last permutation in descending order, it should be rearranged to the lowest order [1, 2, 3]."
      },
      {
        "input": "nums = [1, 1, 5]",
        "output": "[1, 5, 1]",
        "explanation": "The next permutation of [1, 1, 5] is [1, 5, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to find the rightmost ascent in the array.",
      "Swap the element just before the ascent with the smallest element larger than it on the right.",
      "Reverse the order of elements after the position of the ascent."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Product of Array Except Self",
    "description": "Given an array of integers 'nums', return an array 'output' such that output[i] is equal to the product of all the elements of 'nums' except 'nums[i]'. You must solve it without using the division operation and in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Prefix and Suffix Products",
    "tags": [
      "Array",
      "Product",
      "Prefix",
      "Suffix"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An array of integers representing the product of 'nums' excluding the element at each index.",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-30 <= nums[i] <= 30"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "[24, 12, 8, 6]",
        "explanation": "The output array is calculated as follows: [2*3*4, 1*3*4, 1*2*4, 1*2*3] = [24, 12, 8, 6]."
      },
      {
        "input": "nums = [-1, 1, 0, -3, 3]",
        "output": "[0, 0, 9, 0, 0]",
        "explanation": "The output array is calculated as follows: [1*0*-3*3, -1*0*-3*3, -1*1*-3*3, -1*1*0*3, -1*1*0*-3] = [0, 0, 9, 0, 0]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using prefix and suffix products.",
      "A two-pass approach may help in achieving the required output."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Flipping an Image",
    "description": "Given a binary matrix representing an image, your task is to flip the image horizontally, and then invert it. Flipping an image horizontally means reversing each row of the image, and inverting it means replacing 0s with 1s and replacing 1s with 0s.",
    "topic": "Array",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Array",
      "Matrix",
      "Inversion"
    ],
    "input_format": "A 2D binary matrix of size m x n, where 1 is black and 0 is white.",
    "output_format": "The modified binary matrix after flipping and inverting.",
    "constraints": [
      "1 <= m, n <= 20",
      "matrix[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "matrix = [[1,1,0],[1,0,1],[0,0,0]]",
        "output": "[[1,0,0],[0,1,0],[0,0,1]]",
        "explanation": "Flipping the image horizontally results in [[0,1,1],[1,0,1],[0,0,0]]. Inverting it gives [[1,0,0],[0,1,0],[1,1,1]]."
      },
      {
        "input": "matrix = [[1,0],[0,1]]",
        "output": "[[1,0],[0,1]]",
        "explanation": "Flipping the image horizontally results in [[0,1],[1,0]]. Inverting it gives [[1,0],[0,1]]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Think about how to reverse the order of elements in each row.",
      "After flipping, consider how to replace each 0 with 1 and each 1 with 0."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "N-Queens",
    "description": "The N-Queens puzzle is the problem of placing N chess queens on an N\u00d7N chessboard so that no two queens threaten each other. Given an integer n, return all distinct solutions to the N-Queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.",
    "topic": "Backtracking",
    "subtopic": "N-Queens Problem",
    "tags": [
      "Backtracking",
      "Recursion",
      "N-Queens"
    ],
    "input_format": "An integer n representing the size of the chessboard.",
    "output_format": "A list of distinct solutions, where each solution is represented as a list of strings.",
    "constraints": [
      "1 <= n <= 9"
    ],
    "examples": [
      {
        "input": "n = 4",
        "output": [
          [
            ".Q..",
            "...Q",
            "Q...",
            "..Q."
          ],
          [
            "..Q.",
            "Q...",
            "...Q",
            ".Q.."
          ]
        ],
        "explanation": "The two distinct solutions for 4-Queens are shown above. Each configuration represents a placement of queens on a 4x4 board."
      },
      {
        "input": "n = 1",
        "output": [
          [
            "Q"
          ]
        ],
        "explanation": "There is only one way to place a single queen on a 1x1 board."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using backtracking to explore possible queen placements.",
      "Use a set to track the columns, and diagonals to avoid conflicts."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Backspace String Compare",
    "description": "Given two strings s and t, return true if they are equal when both are typed into empty text editors. A backspace character '#' means that the text before it should be deleted. Note that the inputs are given as strings and can contain backspace characters. The goal is to compare the final results of the string modifications.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Backspace",
      "Two Pointers"
    ],
    "input_format": "Two strings s and t.",
    "output_format": "A boolean value indicating whether the two strings are equal after processing backspaces.",
    "constraints": [
      "0 <= s.length, t.length <= 200",
      "s and t only contain lowercase letters and '#' characters."
    ],
    "examples": [
      {
        "input": "s = 'ab#c', t = 'ad#c'",
        "output": "true",
        "explanation": "Both strings result in 'ac' after processing backspaces."
      },
      {
        "input": "s = 'ab##', t = 'c#d#'",
        "output": "true",
        "explanation": "Both strings result in '' (empty string) after processing backspaces."
      },
      {
        "input": "s = 'a#c', t = 'b'",
        "output": "false",
        "explanation": "s results in 'c' while t is 'b', so they are not equal."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a stack to build the final strings.",
      "You can also compare the strings in reverse."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Flip String to Monotone Increasing",
    "description": "A binary string is called monotone increasing if it consists of '0's followed by '1's. Given a binary string s, you can flip some of the '0's to '1's or some of the '1's to '0's such that the resulting string is monotone increasing. Return the minimum number of flips required to make the string monotone increasing.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Greedy",
      "Counting"
    ],
    "input_format": "A binary string s (containing only '0's and '1's).",
    "output_format": "An integer representing the minimum number of flips required.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s[i] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "s = '00110'",
        "output": "1",
        "explanation": "Flipping the last '1' to '0' results in '00000', which is monotone increasing. Only 1 flip is needed."
      },
      {
        "input": "s = '010110'",
        "output": "2",
        "explanation": "Flipping the first '1' and the last '0' results in '000111', which is monotone increasing. Therefore, 2 flips are required."
      },
      {
        "input": "s = '00011000'",
        "output": "2",
        "explanation": "Flipping the two '1's to '0's results in '00000000', which is monotone increasing. Thus, 2 flips are needed."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider counting the number of '1's and '0's on both sides of the array.",
      "Think about the transitions between '0's and '1's."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Single-Threaded CPU",
    "description": "You are given a list of tasks where each task consists of a start time, end time, and a unique identifier. Your goal is to execute these tasks on a single-threaded CPU, meaning only one task can be processed at a time. You must maximize the number of tasks that can be completed. The tasks can overlap, but you cannot execute two tasks simultaneously. Return the maximum number of tasks that can be executed.",
    "topic": "Greedy",
    "subtopic": "Task Scheduling",
    "tags": [
      "Greedy",
      "Sorting",
      "Task Scheduling"
    ],
    "input_format": "A list of tasks, where each task is represented by a tuple of integers (startTime, endTime, taskId).",
    "output_format": "An integer representing the maximum number of tasks that can be executed.",
    "constraints": [
      "1 <= tasks.length <= 10^5",
      "0 <= startTime < endTime <= 10^9"
    ],
    "examples": [
      {
        "input": "tasks = [(1, 2, 1), (2, 3, 2), (1, 3, 3)]",
        "output": "2",
        "explanation": "You can schedule the tasks (1, 2, 1) and (2, 3, 2), but not (1, 3, 3) because it overlaps with both."
      },
      {
        "input": "tasks = [(1, 4, 1), (3, 5, 2), (0, 6, 3), (5, 7, 4), (3, 8, 5)]",
        "output": "4",
        "explanation": "You can execute tasks (1, 4), (5, 7), and two other non-overlapping tasks."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the tasks based on end time to consider the earliest finishing tasks.",
      "Use a greedy approach to select the non-overlapping tasks."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Find The Original Array of Prefix Xor",
    "description": "Given a zero-based array of integers 'prefixXor' where 'prefixXor[i]' is the XOR of the elements from the start of the original array up to index 'i', you need to reconstruct the original array. The original array can be determined using properties of the XOR operation. Your task is to find the original array of integers.",
    "topic": "Array",
    "subtopic": "XOR Operation",
    "tags": [
      "Array",
      "XOR",
      "Bit Manipulation"
    ],
    "input_format": "An array of integers prefixXor where 0 <= prefixXor.length <= 10000.",
    "output_format": "An array of integers representing the original array.",
    "constraints": [
      "1 <= prefixXor.length <= 10^4",
      "0 <= prefixXor[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "prefixXor = [5, 2, 7, 8]",
        "output": "[5, 7, 3, 1]",
        "explanation": "The original array can be reconstructed using the XOR properties: 5 (0th index), (5 XOR 2) = 7 (1st index), (7 XOR 2) = 3 (2nd index), (3 XOR 5) = 1 (3rd index)."
      },
      {
        "input": "prefixXor = [1, 3, 0, 2]",
        "output": "[1, 2, 3, 2]",
        "explanation": "The original array can be found as follows: 1 (0th index), (1 XOR 3) = 2 (1st index), (2 XOR 3) = 3 (2nd index), (3 XOR 1) = 2 (3rd index)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use properties of XOR: x XOR x = 0 and x XOR 0 = x.",
      "Iterate through prefixXor and use previous values to determine the original array."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of bars in a histogram, compute how much water can be trapped after raining. The width of each bar is 1 unit.",
    "topic": "Array",
    "subtopic": "Two Pointers, Dynamic Programming",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming",
      "Rain Water"
    ],
    "input_format": "An array of non-negative integers representing the heights of bars.",
    "output_format": "An integer representing the total amount of water trapped.",
    "constraints": [
      "0 <= heights.length <= 10^6",
      "0 <= heights[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "heights = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "Water is trapped between the heights: 1 unit between 1 and 2, 2 units between 2 and 3, and 3 units between heights 1, 1, and 3."
      },
      {
        "input": "heights = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "Water is trapped: 2 units above 2, 3 units above 0, and 4 units above 3."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how water collects at each index based on the tallest bars to the left and right.",
      "Use two pointers to track the left and right boundaries."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Odd String Difference",
    "description": "You are given two strings, `s1` and `s2`, each consisting of lowercase English letters. Your task is to calculate the absolute difference between the count of unique characters in `s1` and the count of unique characters in `s2`. Return the absolute difference as an integer.",
    "topic": "Strings",
    "subtopic": "Character Count",
    "tags": [
      "Strings",
      "Character Set",
      "Count"
    ],
    "input_format": "Two strings `s1` and `s2`, where 1 <= |s1|, |s2| <= 100.",
    "output_format": "An integer representing the absolute difference between the count of unique characters in `s1` and `s2`.",
    "constraints": [
      "1 <= |s1|, |s2| <= 100",
      "s1 and s2 consist of lowercase English letters only."
    ],
    "examples": [
      {
        "input": "s1 = \"abc\", s2 = \"def\"",
        "output": "6",
        "explanation": "The unique characters in 'abc' are 3 (a, b, c) and in 'def' are also 3 (d, e, f). The difference is |3 - 3| = 0."
      },
      {
        "input": "s1 = \"hello\", s2 = \"world\"",
        "output": "2",
        "explanation": "The unique characters in 'hello' are 4 (h, e, l, o) and in 'world' are 5 (w, o, r, l, d). The difference is |4 - 5| = 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a set to count unique characters.",
      "The absolute difference can be calculated using the built-in abs() function."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Rearrange Array to Maximize Prefix Score",
    "description": "You are given an integer array nums. You can rearrange the elements of nums to form a new array. The prefix score of an array is defined as the sum of the maximum elements in all prefixes of the array. Your task is to find the maximum possible prefix score after rearranging the array. Return this maximum prefix score.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Greedy"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum prefix score.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 5, 1, 2]",
        "output": "16",
        "explanation": "By rearranging nums as [1, 1, 2, 3, 5], the prefix scores are: 1, max(1, 1) = 1, max(1, 1, 2) = 2, max(1, 1, 2, 3) = 3, max(1, 1, 2, 3, 5) = 5. The prefix score is 1 + 1 + 2 + 3 + 5 = 12."
      },
      {
        "input": "nums = [4, 3, 2, 1]",
        "output": "16",
        "explanation": "Rearranging nums as [1, 2, 3, 4], the prefix scores are: 1, 2, 3, 4. The prefix score is 1 + 2 + 3 + 4 = 10."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to maximize the contribution of each element.",
      "Think about sorting the array first."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Minimum Number of Flips to Make the Binary String Alternating",
    "description": "Given a binary string s of length n, you need to determine the minimum number of flips required to make the string alternating. An alternating string is defined as a string where no two adjacent characters are the same. For example, '1010' and '0101' are alternating strings, while '1100' and '0011' are not. A flip consists of changing a '0' to a '1' or a '1' to a '0'.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Binary"
    ],
    "input_format": "A single binary string s consisting of only '0's and '1's.",
    "output_format": "An integer representing the minimum number of flips required to make the string alternating.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s[i] is either '0' or '1'."
    ],
    "examples": [
      {
        "input": "s = \"11100\"",
        "output": "2",
        "explanation": "We can flip the first two characters to '01' resulting in the string '0100', which is alternating."
      },
      {
        "input": "s = \"010101\"",
        "output": "0",
        "explanation": "The string is already alternating, so no flips are required."
      },
      {
        "input": "s = \"000\"",
        "output": "1",
        "explanation": "Flipping any one character results in '010' or '001', both of which are alternating."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider both possible alternating patterns: starting with '0' and starting with '1'.",
      "Count the mismatches for both patterns and choose the minimum."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Majority Element",
    "description": "Given an array of size n, find the majority element. The majority element is the element that appears more than n/2 times in the array. You may assume that the majority element always exists in the array.",
    "topic": "Array",
    "subtopic": "Counting Elements",
    "tags": [
      "Array",
      "Counting",
      "Majority Element"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the majority element.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2, 2, 1, 1, 1, 2, 2]",
        "output": "2",
        "explanation": "The number 2 appears 4 times which is more than n/2, thus 2 is the majority element."
      },
      {
        "input": "nums = [3, 3, 4, 2, 4, 4, 2, 4, 4]",
        "output": "4",
        "explanation": "The number 4 appears 5 times which is more than n/2, thus 4 is the majority element."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a hash map to count occurrences of each element.",
      "Think about how you could optimize the space complexity."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "LRU Cache",
    "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. It should support the following operations: get and put. The 'get' operation retrieves the value associated with the given key if the key exists in the cache, otherwise it returns -1. The 'put' operation updates or inserts the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item.",
    "topic": "Design",
    "subtopic": "Data Structure",
    "tags": [
      "Design",
      "Cache",
      "Data Structure"
    ],
    "input_format": "The constructor should take an integer capacity as parameter as the maximum size of the cache. The get and put operations should be done in O(1) time complexity.",
    "output_format": "For the get operation, return the value associated with the key, or -1 if the key is not found. For the put operation, there is no return value.",
    "constraints": [
      "1 <= capacity <= 3000",
      "0 <= key <= 10000",
      "0 <= value <= 10000",
      "The functions get and put must be called a total of at most 2 * 10^5 times."
    ],
    "examples": [
      {
        "input": "LRUCache cache = new LRUCache(2);\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);",
        "output": "1",
        "explanation": "The cache contains (1,1) and (2,2) and upon retrieving 1, it returns 1."
      },
      {
        "input": "cache.put(3, 3);\ncache.get(2);",
        "output": "-1",
        "explanation": "Cache reached capacity, so (2,2) was evicted. Retrieving 2 returns -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map to store keys and values.",
      "You can also use a doubly linked list to maintain the order of usage."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Find All Possible Stable Binary Arrays II",
    "description": "A stable binary array is an array where the value of each element can either be 0 or 1, with the following constraints: For each position in the array, the sum of its neighbors must be equal to the value at that position. Given an integer n representing the length of the binary array, your task is to find all possible stable binary arrays of length n and return them in any order. The binary arrays should be represented as strings of '0's and '1's.",
    "topic": "Dynamic Programming",
    "subtopic": "Backtracking",
    "tags": [
      "Backtracking",
      "Binary Array",
      "Dynamic Programming"
    ],
    "input_format": "An integer n (1 <= n <= 15).",
    "output_format": "A list of strings, where each string represents a stable binary array of length n.",
    "constraints": [
      "1 <= n <= 15"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": [
          "000",
          "111"
        ],
        "explanation": "The binary arrays of length 3 that are stable are '000' and '111'. In both cases, the neighbors' sums meet the criteria."
      },
      {
        "input": "n = 4",
        "output": [
          "0000",
          "1111",
          "0011",
          "1100"
        ],
        "explanation": "The stable configurations for length 4 include '0000', '1111', '0011', and '1100' as they satisfy the neighbor sum conditions."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using backtracking to explore all combinations of binary digits.",
      "Check the neighbors' constraints as you build the array."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Generate Parentheses",
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. A pair of parentheses is considered well-formed if each opening parenthesis has a corresponding closing one and they are properly nested.",
    "topic": "Backtracking",
    "subtopic": "Combination Generation",
    "tags": [
      "Backtracking",
      "Recursion",
      "String"
    ],
    "input_format": "An integer n representing the number of pairs of parentheses.",
    "output_format": "A list of strings containing all combinations of well-formed parentheses.",
    "constraints": [
      "0 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
        "explanation": "The five combinations of well-formed parentheses for n = 3 are generated."
      },
      {
        "input": "n = 1",
        "output": "[\"()\"]",
        "explanation": "There is only one combination of well-formed parentheses for n = 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to explore all combinations.",
      "Keep track of the number of opening and closing parentheses used so far."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Least Number of Unique Integers after K Removals",
    "description": "Given an array of integers and an integer K, you need to remove K elements from the array in such a way that the number of unique integers remaining in the array is minimized. Your task is to return this minimum number of unique integers after making the removals.",
    "topic": "Array",
    "subtopic": "Counting Elements",
    "tags": [
      "Array",
      "Counting",
      "Greedy"
    ],
    "input_format": "An integer array nums and an integer K.",
    "output_format": "An integer representing the minimum number of unique integers left after K removals.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= K <= nums.length",
      "0 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [5, 5, 4, 4, 3], K = 2",
        "output": "2",
        "explanation": "Removing two 5s or two 4s will leave us with {4, 5} or {3, 4} respectively. Both combinations have 2 unique integers."
      },
      {
        "input": "nums = [1, 2, 2, 1, 3, 4], K = 3",
        "output": "2",
        "explanation": "We can remove the three 1s and 2s to be left with {3, 4}. Hence, the minimum number of unique integers is 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Count the frequency of each integer.",
      "Sort the integers by frequency before removing.",
      "Greedy approach may yield the optimal solution."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Find the Duplicate Number",
    "description": "Given an array of integers nums containing n + 1 integers where each integer is between 1 and n (inclusive), you are to find the number that appears more than once. You must solve the problem without modifying the input array and using O(1) extra space.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Binary Search"
    ],
    "input_format": "An array of integers nums where 1 <= nums.length <= 10^5.",
    "output_format": "An integer representing the duplicate number in the array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i] <= n",
      "There is exactly one duplicate number."
    ],
    "examples": [
      {
        "input": "nums = [3, 1, 3, 4, 2]",
        "output": "3",
        "explanation": "The number 3 appears twice in the array."
      },
      {
        "input": "nums = [1, 3, 4, 2, 2]",
        "output": "2",
        "explanation": "The number 2 appears twice in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you could use the values in the array as indices.",
      "Try to think about cycle detection algorithms."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Increasing Triplet Subsequence",
    "description": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exist, return false.",
    "topic": "Array",
    "subtopic": "Subsequences",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Subsequence"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A boolean value indicating whether there exists an increasing triplet subsequence.",
    "constraints": [
      "1 <= nums.length <= 5 * 10^5",
      "-2^31 <= nums[i] <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5]",
        "output": "true",
        "explanation": "The triplet (1, 2, 3) satisfies the condition."
      },
      {
        "input": "nums = [5, 4, 3, 2, 1]",
        "output": "false",
        "explanation": "No increasing triplet subsequence exists."
      },
      {
        "input": "nums = [2, 1, 5, 0, 4, 6]",
        "output": "true",
        "explanation": "The triplet (1, 5, 6) satisfies the condition."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to maintain two variables to represent the smallest and second smallest numbers.",
      "If you find a number larger than the second smallest, a triplet is found."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Find Longest Calls",
    "description": "You are tasked with analyzing a list of phone call entries represented as strings in the format 'call_time_number', where 'call_time' is the duration of the call in seconds and 'number' is a string representation of the phone number. Your goal is to find the longest call duration and return the corresponding phone number. If there are multiple calls with the same maximum duration, return the one that occurs first in the list. If there are no calls, return an empty string.",
    "topic": "String",
    "subtopic": "Parsing",
    "tags": [
      "String",
      "Parsing",
      "Array"
    ],
    "input_format": "A list of strings calls, where each string follows the format 'call_time_number'.",
    "output_format": "A string representing the phone number with the longest call duration, or an empty string if no calls are present.",
    "constraints": [
      "1 <= calls.length <= 10^5",
      "0 <= call_time <= 10^6",
      "call_time is a non-negative integer",
      "number is a valid phone number string"
    ],
    "examples": [
      {
        "input": "calls = ['300_1234567890', '500_9876543210', '300_1122334455']",
        "output": "'500_9876543210'",
        "explanation": "The longest call is to '9876543210' with a duration of 500 seconds."
      },
      {
        "input": "calls = []",
        "output": "''",
        "explanation": "There are no calls, so the output is an empty string."
      },
      {
        "input": "calls = ['200_5551234567', '200_5559876543', '200_5556543210']",
        "output": "'200_5551234567'",
        "explanation": "All calls have the same duration of 200 seconds, but '5551234567' appears first."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dictionary to store call times against their corresponding phone numbers.",
      "Keep track of the maximum duration and update it as you parse the calls."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Happy Number",
    "description": "A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle that does not include 1. Those numbers for which this process ends in 1 are happy numbers, while those that do not end in 1 are unhappy numbers. Given a number n, determine if it is a happy number.",
    "topic": "Math",
    "subtopic": "Number Theory",
    "tags": [
      "Math",
      "Number Theory",
      "Logic"
    ],
    "input_format": "A single positive integer n.",
    "output_format": "A boolean value indicating whether n is a happy number (true) or not (false).",
    "constraints": [
      "1 <= n <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "n = 19",
        "output": "true",
        "explanation": "19 is a happy number, as 1^2 + 9^2 = 82, then 8^2 + 2^2 = 68, then 6^2 + 8^2 = 100, and finally 1^2 + 0^2 + 0^2 = 1."
      },
      {
        "input": "n = 2",
        "output": "false",
        "explanation": "2 is not a happy number, as it enters a cycle of 4 -> 16 -> 37 -> 58 -> 89 -> 145 -> 42 -> 20 -> 4."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a set to track numbers you've seen to detect cycles.",
      "Calculate the sum of the squares of the digits by converting the number to a string."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Partition Equal Subset Sum",
    "description": "Given a non-empty array of positive integers, you are to determine if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. If such a partition exists, return true; otherwise, return false.",
    "topic": "Dynamic Programming",
    "subtopic": "Subset Sum",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Backtracking"
    ],
    "input_format": "An array of integers 'nums' where 1 <= nums.length <= 200 and 1 <= nums[i] <= 1000.",
    "output_format": "A boolean indicating whether the array can be partitioned into two subsets with equal sum.",
    "constraints": [
      "1 <= nums.length <= 200",
      "1 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [1, 5, 11, 5]",
        "output": "true",
        "explanation": "The array can be partitioned into [1, 5, 5] and [11], both subsets summing to 11."
      },
      {
        "input": "nums = [1, 2, 3, 5]",
        "output": "false",
        "explanation": "The array cannot be partitioned into two subsets with equal sum."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the total sum and check if it's even.",
      "Use dynamic programming to find subsets with a specific sum.",
      "Explore possible combinations using recursion or backtracking."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Degree of an Array",
    "description": "Given an integer array nums, you need to find the degree of the array. The degree of an array is defined as the maximum frequency of any element in the array. Moreover, when two elements have the same frequency, the degree is determined by the smallest index of these elements in the array. Your task is to return the length of the smallest subarray that has the same degree as the array.",
    "topic": "Array",
    "subtopic": "Subarray",
    "tags": [
      "Array",
      "Frequency",
      "Subarray",
      "HashMap"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the length of the smallest subarray with the same degree.",
    "constraints": [
      "1 <= nums.length <= 50,000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2, 3, 1]",
        "output": "2",
        "explanation": "The degree of the array is 2, which is the frequency of the number 2. The smallest subarray with the same degree is [2, 2] with length 2."
      },
      {
        "input": "nums = [1, 2, 2, 3, 1, 4, 2]",
        "output": "6",
        "explanation": "The degree of the array is 3, which is the frequency of the number 2. The smallest subarray that has the same degree is [2, 3, 1, 4, 2] with length 6."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a HashMap to count frequencies.",
      "Store the first and last occurrence of each element."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Word Break",
    "description": "Given a string s and a dictionary of strings wordDict, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Word Break"
    ],
    "input_format": "A string s and a list of strings wordDict.",
    "output_format": "A boolean indicating whether s can be segmented into words from wordDict.",
    "constraints": [
      "1 <= s.length <= 300",
      "1 <= wordDict.length <= 1000",
      "1 <= wordDict[i].length <= 20",
      "The input string and words in the dictionary consist of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = 'leetcode', wordDict = ['leet', 'code']",
        "output": "true",
        "explanation": "The string 'leetcode' can be segmented as 'leet' + 'code'."
      },
      {
        "input": "s = 'applepenapple', wordDict = ['apple', 'pen']",
        "output": "true",
        "explanation": "The string 'applepenapple' can be segmented as 'apple' + 'pen' + 'apple'."
      },
      {
        "input": "s = 'catsandog', wordDict = ['cats', 'dog', 'sand', 'and', 'cat']",
        "output": "false",
        "explanation": "The string 'catsandog' cannot be segmented into dictionary words."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to track valid segmentations.",
      "A boolean array can help in recording whether a position in the string can be segmented."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "132 Pattern",
    "description": "Given an array of integers, find out if there exists a 132 pattern in it. A 132 pattern is a subsequence of three integers nums[i], nums[j], nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].",
    "topic": "Array",
    "subtopic": "Subsequence",
    "tags": [
      "Array",
      "Subsequence",
      "Stack"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A boolean value indicating whether there is a 132 pattern in the array.",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 10^2",
      "-10^3 <= nums[i] <= 10^3"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "false",
        "explanation": "There is no valid 132 pattern in the sequence."
      },
      {
        "input": "nums = [3, 1, 4, 2]",
        "output": "true",
        "explanation": "The 132 pattern is found as (1, 4, 2)."
      },
      {
        "input": "nums = [-1, 3, 2, 0]",
        "output": "true",
        "explanation": "The 132 pattern is found as (-1, 2, 0)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to keep track of potential candidates.",
      "Keep the last element as the '2' of the 132 pattern."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "The Employee That Worked on the Longest Task",
    "description": "You are given a list of employee records containing their respective task completion times. Each record consists of an employee ID and their corresponding task time in hours. Your task is to find the employee who spent the longest time working on a task. If multiple employees have the same maximum task time, return the employee ID that appears first in the list.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Employee"
    ],
    "input_format": "A list of tuples, where each tuple consists of an integer employee_id and a float task_time.",
    "output_format": "An integer representing the employee ID of the employee who worked the longest on a task.",
    "constraints": [
      "1 <= records.length <= 10^5",
      "1 <= employee_id <= 10^6",
      "0 <= task_time <= 10^4"
    ],
    "examples": [
      {
        "input": "[ (101, 5.5), (102, 3.0), (103, 5.5), (104, 7.0) ]",
        "output": "104",
        "explanation": "Employee 104 spent the longest time (7.0 hours) working on a task."
      },
      {
        "input": "[ (201, 2.0), (202, 2.0), (203, 4.0), (204, 4.0) ]",
        "output": "203",
        "explanation": "Employees 203 and 204 both spent 4.0 hours, but Employee 203 appears first."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a loop to keep track of the maximum task time encountered.",
      "Utilize a variable to store the corresponding employee ID."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Prime In Diagonal",
    "description": "Given an n x n matrix of integers, return the sum of all prime numbers located in the main diagonal. A prime number is defined as a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers.",
    "topic": "Matrix",
    "subtopic": "Diagonal Traversal",
    "tags": [
      "Matrix",
      "Prime",
      "Diagonal",
      "Sum"
    ],
    "input_format": "An integer n followed by an n x n matrix of integers.",
    "output_format": "An integer representing the sum of all prime numbers on the main diagonal.",
    "constraints": [
      "1 <= n <= 100",
      "-10^5 <= matrix[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "n = 3\nmatrix = [[2, 4, 6], [3, 5, 7], [11, 1, 13]]",
        "output": "15",
        "explanation": "The prime numbers on the diagonal are 2, 5, and 13. Their sum is 2 + 5 + 13 = 20."
      },
      {
        "input": "n = 2\nmatrix = [[4, 6], [8, 10]]",
        "output": "0",
        "explanation": "There are no prime numbers on the diagonal (4, 10) so the sum is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Create a helper function to check for prime numbers.",
      "Only consider the elements at indices (0,0), (1,1), ..., (n-1,n-1)."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Minimum Operations to Reduce an Integer to 0",
    "description": "Given a positive integer num, you can perform two types of operations: if num is even, you can divide it by 2; if num is odd, you can subtract 1 from it. Your task is to determine the minimum number of operations needed to reduce the integer num to 0.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Mathematics"
    ],
    "input_format": "A single integer num (1 <= num <= 10^6).",
    "output_format": "An integer representing the minimum number of operations to reduce num to 0.",
    "constraints": [
      "1 <= num <= 10^6"
    ],
    "examples": [
      {
        "input": "num = 14",
        "output": "6",
        "explanation": "14 is even, divide by 2 to get 7. (1 operation) 7 is odd, subtract 1 to get 6. (2) 6 is even, divide by 2 to get 3. (3) 3 is odd, subtract 1 to get 2. (4) 2 is even, divide by 2 to get 1. (5) 1 is odd, subtract 1 to get 0. (6) Total operations = 6."
      },
      {
        "input": "num = 8",
        "output": "4",
        "explanation": "8 is even, divide by 2 to get 4. (1) 4 is even, divide by 2 to get 2. (2) 2 is even, divide by 2 to get 1. (3) 1 is odd, subtract 1 to get 0. (4) Total operations = 4."
      },
      {
        "input": "num = 3",
        "output": "2",
        "explanation": "3 is odd, subtract 1 to get 2. (1) 2 is even, divide by 2 to get 1. (2) 1 is odd, subtract 1 to get 0. (2) Total operations = 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how the parity of the number affects the operations needed to reduce it."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zeros, except the number 0 itself.",
    "topic": "Linked List",
    "subtopic": "Math",
    "tags": [
      "Linked List",
      "Math",
      "Addition"
    ],
    "input_format": "Two linked lists, l1 and l2, where each linked list node contains a single digit.",
    "output_format": "A linked list representing the sum of the two numbers.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the input linked lists represent valid numbers."
    ],
    "examples": [
      {
        "input": "l1 = [2, 4, 3], l2 = [5, 6, 4]",
        "output": "[7, 0, 8]",
        "explanation": "342 + 465 = 807. The resulting linked list is [7, 0, 8]."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "0 + 0 = 0. The resulting linked list is [0]."
      },
      {
        "input": "l1 = [9, 9, 9], l2 = [1]",
        "output": "[0, 0, 0, 1]",
        "explanation": "999 + 1 = 1000. The resulting linked list is [0, 0, 0, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how you would add the numbers digit by digit.",
      "Consider using a dummy head node to simplify the process."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Range Product Queries of Powers",
    "description": "You are given an array of integers `nums` and a list of queries. Each query consists of two integers `left` and `right`, and your task is to return the product of all numbers in the subarray from `nums[left]` to `nums[right]`, inclusive, raised to the power of the number of elements in that subarray. The product should be computed modulo 10^9 + 7. Implement a function that efficiently handles multiple queries.",
    "topic": "Array",
    "subtopic": "Range Queries",
    "tags": [
      "Array",
      "Range Queries",
      "Modular Arithmetic"
    ],
    "input_format": "An array of integers `nums` followed by a list of queries where each query is an array of two integers `[left, right]`.",
    "output_format": "An array of integers, where each integer represents the result of the corresponding query.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^5 <= nums[i] <= 10^5",
      "1 <= queries.length <= 10^4",
      "0 <= left <= right < nums.length"
    ],
    "examples": [
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4
          ],
          "queries": [
            [
              0,
              1
            ],
            [
              1,
              2
            ],
            [
              0,
              3
            ]
          ]
        },
        "output": [
          2,
          6,
          576
        ],
        "explanation": "For the first query (0, 1): Product = (1 * 2)^2 = 2. For the second query (1, 2): Product = (2 * 3)^2 = 6. For the third query (0, 3): Product = (1 * 2 * 3 * 4)^4 = 576."
      },
      {
        "input": {
          "nums": [
            5,
            3,
            1,
            2
          ],
          "queries": [
            [
              0,
              2
            ],
            [
              1,
              3
            ]
          ]
        },
        "output": [
          225,
          36
        ],
        "explanation": "For the first query (0, 2): Product = (5 * 3 * 1)^3 = 225. For the second query (1, 3): Product = (3 * 1 * 2)^3 = 36."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Store prefix products for efficient range queries.",
      "Use modular arithmetic to avoid overflow.",
      "Think about how to compute powers efficiently."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Count Number of Teams",
    "description": "Given a list of integers representing the strengths of players in different teams, your task is to count the number of valid teams that can be formed. A valid team is defined as having one player stronger than another, and one player weaker than another. More formally, you can form a valid team of three players if the strengths of the players are in increasing order or decreasing order.",
    "topic": "Array",
    "subtopic": "Combinatorics",
    "tags": [
      "Array",
      "Combinatorics",
      "Counting"
    ],
    "input_format": "An integer array strengths, where each element represents the strength of a player.",
    "output_format": "An integer representing the number of valid teams that can be formed.",
    "constraints": [
      "1 <= strengths.length <= 100",
      "1 <= strengths[i] <= 100"
    ],
    "examples": [
      {
        "input": "strengths = [2, 5, 3, 4, 1]",
        "output": "3",
        "explanation": "The valid teams are: (2, 3, 5), (1, 3, 5), and (1, 2, 5)."
      },
      {
        "input": "strengths = [1, 2, 3]",
        "output": "1",
        "explanation": "The only valid team is (1, 2, 3)."
      },
      {
        "input": "strengths = [10, 9, 8, 7]",
        "output": "4",
        "explanation": "The valid teams are: (7, 8, 9), (7, 8, 10), (8, 9, 10), and (9, 10, 7)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the combinations of players when selecting a team.",
      "Using sorting may help simplify the comparison of players.",
      "Think about the properties of increasing and decreasing sequences."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Task Scheduler",
    "description": "You are given a list of tasks that need to be executed. Each task is represented by a capital letter. To avoid overheating, you need to schedule the tasks such that the same task is not executed consecutively. There is also a cooldown period during which the same task cannot be executed again. Your goal is to determine the minimum time required to execute all tasks given the cooldown period.",
    "topic": "Greedy",
    "subtopic": "Task Scheduling",
    "tags": [
      "Greedy",
      "Scheduling",
      "Heap"
    ],
    "input_format": "An array of characters tasks representing the tasks to be executed and an integer n representing the cooldown period.",
    "output_format": "An integer representing the minimum time required to execute all tasks.",
    "constraints": [
      "1 <= tasks.length <= 1000",
      "0 <= n <= 26",
      "tasks[i] is a capital letter."
    ],
    "examples": [
      {
        "input": "tasks = ['A', 'A', 'A', 'B', 'B', 'B'], n = 2",
        "output": "8",
        "explanation": "One of the ways to schedule the tasks is A -> B -> idle -> A -> B -> idle -> A -> B, which takes 8 time units."
      },
      {
        "input": "tasks = ['A', 'A', 'A', 'B', 'B', 'B'], n = 0",
        "output": "6",
        "explanation": "Since there is no cooldown, A can be scheduled consecutively with B: A -> A -> A -> B -> B -> B takes 6 time units."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to effectively utilize idle time.",
      "Use a counter to manage the frequency of each task."
    ],
    "company": "IBM"
  },
  {
    "question_id": "",
    "title": "Removing Stars From a String",
    "description": "You are given a string s, which contains lowercase letters and the '*' character. Each '*' character represents an instruction to remove the preceding character from the string. If there is no preceding character, the '*' character does nothing. Write a function to process the string and return the final result after applying all the removal instructions.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Stack"
    ],
    "input_format": "A string s containing lowercase letters and '*' characters.",
    "output_format": "A string representing the final result after processing all '*' characters.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of lowercase English letters and '*' characters."
    ],
    "examples": [
      {
        "input": "s = \"leet**cod*e\"",
        "output": "lecoe",
        "explanation": "The first '*' removes 't' and the second '*' removes 'e', leaving 'lecoe'."
      },
      {
        "input": "s = \"a*b*c\"",
        "output": "",
        "explanation": "Each '*' removes the preceding character, resulting in an empty string."
      },
      {
        "input": "s = \"xyz***abc\"",
        "output": "abc",
        "explanation": "The first three '*' remove 'z', 'y', and 'x', leaving 'abc'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to help with character removal.",
      "Process the string from left to right."
    ],
    "company": "IBM"
  }
]