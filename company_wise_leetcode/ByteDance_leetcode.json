[
  {
    "question_id": "",
    "title": "LRU Cache",
    "description": "Design and implement a data structure for a Least Recently Used (LRU) cache. It should support the following operations: get and put. The get operation retrieves the value of the key if the key exists in the cache. Otherwise, it returns -1. The put operation updates the value of the key if the key exists. If the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item.",
    "topic": "Data Structure",
    "subtopic": "Cache Optimization",
    "tags": [
      "Cache",
      "Data Structure",
      "Design"
    ],
    "input_format": "The cache has a fixed capacity. Operations are performed via the methods get(key) and put(key, value).",
    "output_format": "The method get returns the value associated with the key, or -1 if the key does not exist.",
    "constraints": [
      "The capacity of the cache is at most 10^4.",
      "The input keys are guaranteed to be in the range [1, 10^5].",
      "The operations put and get are called at most 2 * 10^5 times."
    ],
    "examples": [
      {
        "input": "cache = LRUCache(2); cache.put(1, 1); cache.put(2, 2); cache.get(1); cache.put(3, 3); cache.get(2); cache.put(4, 4); cache.get(1); cache.get(3); cache.get(4);",
        "output": "[1, -1, 3, 4]",
        "explanation": "The operations performed results in the following: put(1,1) -> cache: {1=1}; put(2,2) -> cache: {1=1, 2=2}; get(1) -> returns 1; put(3,3) -> evicts key 2, cache: {1=1, 3=3}; get(2) -> returns -1; put(4,4) -> evicts key 1, cache: {3=3, 4=4}; get(1) -> returns -1; get(3) -> returns 3; get(4) -> returns 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a HashMap to store key-value pairs for quick access.",
      "Maintain a doubly linked list to track the order of usage."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Smallest Subsequence of Distinct Characters",
    "description": "Given a string s, return the lexicographically smallest subsequence of distinct characters in s. The solution must preserve the relative order of characters and only include each character one time. You must choose a subsequence such that it is the smallest in lexicographic order and contains distinct characters.",
    "topic": "String",
    "subtopic": "Subsequence",
    "tags": [
      "String",
      "Subsequence",
      "Greedy"
    ],
    "input_format": "A string s (1 <= s.length <= 100) containing lowercase English letters.",
    "output_format": "A string representing the smallest subsequence of distinct characters.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "bcabc",
        "output": "abc",
        "explanation": "The smallest subsequence of distinct characters is 'abc'."
      },
      {
        "input": "cbacdcbc",
        "output": "acdb",
        "explanation": "The smallest subsequence of distinct characters is 'acdb'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to keep track of characters.",
      "Ensure that you only add a character if it hasn't been already included.",
      "Consider using a frequency count for the characters."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "First Day Where You Have Been in All the Rooms",
    "description": "You are given an array rooms where rooms[i] represents the keys you can obtain after visiting room i. Each room can contain a list of keys to other rooms. Your goal is to determine the first day when you can access all rooms starting from room 0. Return the minimum day you can visit all rooms, or -1 if it is not possible to visit all rooms.",
    "topic": "Graph",
    "subtopic": "Traversal",
    "tags": [
      "Graph",
      "BFS",
      "DFS"
    ],
    "input_format": "An integer array rooms where rooms[i] is a list of keys to other rooms you can access.",
    "output_format": "An integer representing the first day you can access all rooms or -1 if not possible.",
    "constraints": [
      "1 <= rooms.length <= 100",
      "0 <= rooms[i].length <= rooms.length - 1"
    ],
    "examples": [
      {
        "input": "rooms = [[1],[2],[3],[]]",
        "output": "3",
        "explanation": "You need to visit rooms 1, 2, and 3 to access all rooms, which takes 3 days."
      },
      {
        "input": "rooms = [[1,3],[3,0,1],[2],[0]]",
        "output": "-1",
        "explanation": "It's impossible to access all rooms due to room connections."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Breadth-First Search (BFS) to explore the rooms efficiently.",
      "Track visited rooms to determine if you have access to all rooms."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Remove Duplicate Letters",
    "description": "Given a string which contains lowercase letters, remove duplicate letters so that every letter appears once and only once. The result should be the smallest lexicographical order of the string that can be achieved by removing the duplicates. You must do this without using any additional data structures.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Greedy",
      "Stack"
    ],
    "input_format": "A string s consisting of lowercase letters.",
    "output_format": "A string representing the final result with duplicates removed.",
    "constraints": [
      "1 <= s.length <= 100000",
      "s consists of lowercase letters."
    ],
    "examples": [
      {
        "input": "bcabc",
        "output": "abc",
        "explanation": "The letters 'b', 'c', and 'a' are present, and their smallest lexicographical order is 'abc'."
      },
      {
        "input": "cbacdcbc",
        "output": "acdb",
        "explanation": "Removing duplicates and arranging in smallest lexicographical order gives 'acdb'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to maintain the order of characters.",
      "Keep track of the last occurrence of each character."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Graph",
    "subtopic": "DFS/BFS",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Recursion"
    ],
    "input_format": "A 2D grid represented as a list of lists containing '1's and '0's.",
    "output_format": "An integer representing the number of islands.",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[i].length <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "grid = [['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1']]",
        "output": "3",
        "explanation": "There are three islands in the grid."
      },
      {
        "input": "grid = [['1', '1', '1'], ['0', '1', '0'], ['1', '1', '1']]",
        "output": "1",
        "explanation": "There is one island in the grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth First Search (DFS) to traverse the grid.",
      "Mark visited land cells to avoid counting them multiple times.",
      "Be careful with boundary conditions while traversing."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Course Schedule",
    "description": "You are given an integer numCourses representing the total number of courses you have to take, labeled from 0 to numCourses - 1. You are also given an array prerequisites where prerequisites[i] = [a, b] indicates that you must take course b before course a. Return true if you can finish all courses. Otherwise, return false.",
    "topic": "Graph",
    "subtopic": "Topological Sort",
    "tags": [
      "Graph",
      "DFS",
      "Topological Sort"
    ],
    "input_format": "An integer numCourses followed by a list of prerequisite pairs.",
    "output_format": "A boolean value indicating if all courses can be finished.",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= a, b < numCourses"
    ],
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = [[1,0]]",
        "output": "true",
        "explanation": "You can take course 0 first, and then take course 1. Therefore, it's possible to finish all courses."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
        "output": "false",
        "explanation": "It's impossible to finish all courses because they depend on each other."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use Depth First Search to detect cycles in the graph."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Kth Largest Element in an Array",
    "description": "Given an integer array nums and an integer k, return the k-th largest element in the array. Note that it is the k-th largest element in the sorted order, not the k-th distinct element.",
    "topic": "Array",
    "subtopic": "Sorting and Searching",
    "tags": [
      "Array",
      "Sorting",
      "Heap"
    ],
    "input_format": "An array of integers nums followed by an integer k.",
    "output_format": "An integer representing the k-th largest element in the array.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 1, 5, 6, 4], k = 2",
        "output": "5",
        "explanation": "The second largest element in the sorted array [1, 2, 3, 4, 5, 6] is 5."
      },
      {
        "input": "nums = [3, 2, 3, 1, 2, 4, 5, 5, 6], k = 4",
        "output": "4",
        "explanation": "The fourth largest element in the sorted array [1, 2, 2, 3, 3, 4, 5, 5, 6] is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a min-heap to keep track of the top k largest elements.",
      "Sorting the array might be another approach, but can be inefficient for large k.",
      "Remember to handle duplicates correctly."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters. A substring is a contiguous sequence of characters within a string.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A single string s, consisting of English letters, digits, symbols, and spaces.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 5 * 10^4",
      "s consists of characters from the set of Unicode characters."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"abc\", which has a length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The longest substring without repeating characters is \"b\", with a length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"wke\", with a length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window approach to keep track of the current substring.",
      "Utilize a HashMap or HashSet to store characters and their indices."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Combination Sum",
    "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.",
    "topic": "Backtracking",
    "subtopic": "Combination Sum",
    "tags": [
      "Backtracking",
      "Recursion",
      "Combination"
    ],
    "input_format": "Two inputs: an array of integers 'candidates' and an integer 'target'.",
    "output_format": "A list of lists, where each inner list represents a unique combination of numbers that sum to the target.",
    "constraints": [
      "1 <= candidates.length <= 30",
      "1 <= candidates[i] <= 200",
      "All elements of candidates are distinct.",
      "1 <= target <= 500"
    ],
    "examples": [
      {
        "input": "candidates = [2, 3, 6, 7], target = 7",
        "output": "[[7],[2,2,3]]",
        "explanation": "The combinations that sum up to 7 are: [7] and [2, 2, 3]."
      },
      {
        "input": "candidates = [1], target = 2",
        "output": "[[1,1]]",
        "explanation": "The only combination that sums up to 2 is [1, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to explore combinations recursively.",
      "Consider how to handle the current element for multiple combinations."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Regular Expression Matching",
    "description": "Implement a function to perform pattern matching with support for '.' and '*'. The character '.' matches any single character, and the character '*' matches zero or more of the preceding element. Given a string `s` and a pattern `p`, return true if `s` matches `p` and false otherwise.",
    "topic": "Dynamic Programming",
    "subtopic": "String Matching",
    "tags": [
      "Dynamic Programming",
      "String",
      "Regular Expression"
    ],
    "input_format": "A string s and a pattern p.",
    "output_format": "A boolean value indicating whether s matches p.",
    "constraints": [
      "0 <= s.length <= 20",
      "0 <= p.length <= 20",
      "s contains only lowercase alphabetical characters.",
      "p contains lowercase alphabetical characters, '.' and '*'"
    ],
    "examples": [
      {
        "input": "s = 'aa', p = 'a'",
        "output": "false",
        "explanation": "Pattern 'a' does not match string 'aa'."
      },
      {
        "input": "s = 'aa', p = 'a*'",
        "output": "true",
        "explanation": "Pattern 'a*' matches 'aa' since '*' matches zero or more of the preceding element."
      },
      {
        "input": "s = 'ab', p = '.*'",
        "output": "true",
        "explanation": "Pattern '.*' matches 'ab' since '.' can be any character, and '*' allows for 0 or more repetitions."
      },
      {
        "input": "s = 'aab', p = 'c*a*b'",
        "output": "true",
        "explanation": "Pattern 'c*a*b' matches 'aab' since 'c*' accounts for 0 occurrences."
      },
      {
        "input": "s = 'mississippi', p = 'mis*is*p*.'",
        "output": "false",
        "explanation": "Pattern 'mis*is*p*.' does not match 'mississippi'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a dynamic programming approach to store intermediate results.",
      "Think about how to handle characters followed by '*' in the pattern."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Basic Calculator II",
    "description": "Implement a basic calculator to evaluate a simple expression string containing non-negative integers, '+', '-', '*', and '/' operators, and empty spaces. The integer division should truncate toward zero. You may assume that the input expression is always valid. The operators must be evaluated from left to right, without regard to the normal operator precedence.",
    "topic": "Mathematics",
    "subtopic": "Expression Evaluation",
    "tags": [
      "Calculator",
      "String",
      "Math"
    ],
    "input_format": "A string s representing the expression to evaluate.",
    "output_format": "An integer representing the result of the evaluated expression.",
    "constraints": [
      "1 <= s.length <= 3 * 10^5",
      "s consists of digits, '+', '-', '*', '/', and ' ' (space).",
      "The expression is guaranteed to be valid."
    ],
    "examples": [
      {
        "input": "s = '3+2*2'",
        "output": "7",
        "explanation": "In this expression, 2*2 is evaluated first giving 4, and then 3+4 gives 7."
      },
      {
        "input": "s = ' 3/2 '",
        "output": "1",
        "explanation": "The result of 3 divided by 2 is 1 after truncating toward zero."
      },
      {
        "input": "s = ' 3+5 / 2 '",
        "output": "5",
        "explanation": "The evaluation occurs left to right, thus first evaluating 5/2 giving 2, and then 3+2 gives 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to handle the operands and operators.",
      "Don't forget to handle spaces in the input string.",
      "Handle the division carefully to ensure truncation toward zero."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "House Robber",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, and two adjacent houses have security systems connected. If two adjacent houses are robbed, the security system will trigger. Given an integer array 'nums' representing the amount of money of each house, return the maximum amount of money you can rob tonight without triggering the alarm.",
    "topic": "Dynamic Programming",
    "subtopic": "Optimization",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers nums, where nums[i] represents the amount of money stashed in the i-th house.",
    "output_format": "An integer representing the maximum amount of money you can rob without triggering the alarm.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 400"
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 9, 3, 1]",
        "output": "12",
        "explanation": "Robbing house 1 (amount 2), house 3 (amount 9), and house 4 (amount 1) yields the maximum 2 + 9 + 1 = 12."
      },
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "4",
        "explanation": "Robbing house 1 (amount 1) and house 3 (amount 3) yields the maximum 1 + 3 = 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use dynamic programming to keep track of the maximum amount robbed up to each house.",
      "Consider two cases for each house: robbing it or skipping it."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Shortest Distance from All Buildings",
    "description": "You are given a 2D grid of size m x n representing a map where each cell can either be a building (1), an obstacle (2), or empty land (0). You want to determine the shortest distance from any empty land cell to all buildings. The distance is calculated by the number of steps required to travel from one cell to another. You can only move up, down, left, or right, and you cannot move through obstacles. Return the shortest distance from any empty land cell to all buildings. If it is impossible to reach all buildings from a particular empty land cell, return -1.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "Graph",
      "BFS",
      "Searching"
    ],
    "input_format": "A 2D grid represented by a list of lists where each sublist contains integers 0, 1, or 2.",
    "output_format": "An integer representing the shortest distance from any empty land cell to all buildings, or -1 if unreachable.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 20",
      "grid[i][j] is either 0, 1, or 2.",
      "There will be at least one building in the grid."
    ],
    "examples": [
      {
        "input": "grid = [[0, 0, 2], [1, 0, 1], [0, 0, 0]]",
        "output": "4",
        "explanation": "The shortest distance from the empty land at (0, 0) is to reach both buildings at (1, 0) and (1, 2)."
      },
      {
        "input": "grid = [[1, 0]]",
        "output": "-1",
        "explanation": "There is no empty land cell to reach the building."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use BFS to explore all reachable cells from each building.",
      "Keep track of the number of buildings reachable from each empty cell.",
      "Consider the case where some buildings are unreachable."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "House Robber II",
    "description": "In a street of houses, each house has a certain amount of money stashed. However, robbing two adjacent houses will alert the police. Your goal is to determine the maximum amount of money you can rob tonight without alerting the police. This is the twist: the first and last houses are adjacent to each other. You cannot rob both the first and the last house. Therefore, you need to choose between robbing houses from the first to the second last, or from the second to the last house.",
    "topic": "Dynamic Programming",
    "subtopic": "House Robber",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Greedy"
    ],
    "input_format": "An array of integers representing the amount of money in each house.",
    "output_format": "An integer representing the maximum amount of money you can rob.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "[2, 3, 2]",
        "output": "3",
        "explanation": "Robbing the second house yields the maximum amount of 3."
      },
      {
        "input": "[1, 2, 3, 1]",
        "output": "4",
        "explanation": "Robbing the first and third houses yields 1 + 3 = 4."
      },
      {
        "input": "[5, 1, 2, 10, 6]",
        "output": "16",
        "explanation": "Robbing the first, fourth, and fifth houses yields 5 + 10 + 1 = 16."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to reduce the problem into two separate cases.",
      "Use dynamic programming to keep track of maximum sums."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "Given a rotated sorted array nums and a target value, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Binary Search",
    "subtopic": "Searching in Rotated Arrays",
    "tags": [
      "Array",
      "Binary Search",
      "Searching"
    ],
    "input_format": "An integer array nums representing the rotated sorted array, followed by an integer target.",
    "output_format": "An integer representing the index of target in array nums, or -1 if target is not present.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "nums is guaranteed to be rotated at some pivot."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "The target 0 is at index 4 in the rotated array."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "The target 3 is not present in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider binary search and how the rotation affects the indices.",
      "Identify which part of the array is sorted."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Delete Operation for Two Strings",
    "description": "Given two strings word1 and word2, perform a minimum number of delete operations required to make the two strings equal. A delete operation consists of choosing any character of either string and removing it. Return the minimum number of delete operations needed.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Dynamic Programming",
      "Minimum Operations"
    ],
    "input_format": "Two strings word1 and word2, each with lengths up to 1000.",
    "output_format": "An integer representing the minimum number of delete operations needed to make the two strings equal.",
    "constraints": [
      "1 <= word1.length, word2.length <= 1000",
      "word1 and word2 consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "word1 = \"sea\", word2 = \"eat\"",
        "output": "2",
        "explanation": "By deleting 's' and 'a', the strings become 'e' and 'e', which are equal."
      },
      {
        "input": "word1 = \"leetcode\", word2 = \"etco\"",
        "output": "4",
        "explanation": "By deleting 'l', 'e', 'e', and 'd' from 'leetcode', the strings can be made equal to 'eco'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider finding the longest common subsequence of both strings.",
      "The number of deletions will be the total length of both strings minus twice the length of the longest common subsequence."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. For example, given intervals [[1,3],[2,6],[8,10],[15,18]], return [[1,6],[8,10],[15,18]]. You may assume that all intervals are unique and in the input list, no interval overlaps with another.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Interval"
    ],
    "input_format": "A list of intervals represented as pairs of integers, where each pair [start, end] denotes an interval.",
    "output_format": "A list of merged intervals after merging overlapping ones.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^5"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "The intervals [1,3] and [2,6] overlap, so they are merged into [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "The intervals [1,4] and [4,5] touch at 4, so they are merged into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on the starting times.",
      "Use a result list to keep track of merged intervals."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers height, where height[i] is the height of the elevation at index i.",
    "output_format": "An integer representing the total units of trapped rainwater.",
    "constraints": [
      "0 <= height.length <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The trapped water is 1 unit between 1 and 2, 2 units between 2 and 3, and 3 units between 3 and 4."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The trapped water is 2 units over the first 2, 3 over the third, and 4 over the last 2, totaling 9."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using two pointers to track the maximum height from both ends.",
      "Use an array to store the left maximum heights."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers, return the indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hashing",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 2 + 7 = 9, so the output is [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "nums[1] + nums[2] = 2 + 4 = 6, so the output is [1, 2]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash table to store the numbers and their indices.",
      "Check for each number if the complement (target - number) exists in the hash table."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Longest Common Subsequence",
    "description": "Given two strings text1 and text2, return the length of their longest common subsequence. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. For example, 'ace' is a subsequence of 'abcde' while 'aec' is not. A common subsequence of two strings is a subsequence that is common to both strings. If there is no common subsequence, return 0.",
    "topic": "Dynamic Programming",
    "subtopic": "String",
    "tags": [
      "String",
      "Dynamic Programming",
      "Subsequence"
    ],
    "input_format": "Two strings text1 and text2.",
    "output_format": "An integer representing the length of the longest common subsequence.",
    "constraints": [
      "1 <= text1.length, text2.length <= 1000",
      "text1 and text2 consist of only lowercase English characters."
    ],
    "examples": [
      {
        "input": "text1 = 'abcde', text2 = 'ace'",
        "output": "3",
        "explanation": "The longest common subsequence is 'ace' with a length of 3."
      },
      {
        "input": "text1 = 'abc', text2 = 'def'",
        "output": "0",
        "explanation": "There is no common subsequence between 'abc' and 'def'."
      },
      {
        "input": "text1 = 'abc', text2 = 'abc'",
        "output": "3",
        "explanation": "The entire string 'abc' is a common subsequence."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a 2D array to store lengths of common subsequences.",
      "Iterate through each character of both strings to update lengths."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Combination Sum II",
    "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. The solution set must not contain duplicate combinations. Note that the order of combinations matters, and they should be returned in ascending order.",
    "topic": "Backtracking",
    "subtopic": "Combination Sum",
    "tags": [
      "Backtracking",
      "Combination",
      "Sum"
    ],
    "input_format": "An array of integers candidates and an integer target.",
    "output_format": "A list of unique combinations where the sum of the numbers equals target.",
    "constraints": [
      "1 <= candidates.length <= 100",
      "1 <= candidates[i] <= 50",
      "target is a positive integer."
    ],
    "examples": [
      {
        "input": "candidates = [10, 1, 2, 7, 6, 1, 5], target = 8",
        "output": "[[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]",
        "explanation": "The unique combinations that sum up to 8 are: [1, 1, 6], [1, 2, 5], [1, 7], [2, 6]."
      },
      {
        "input": "candidates = [2, 5, 2, 1, 2], target = 5",
        "output": "[[1, 2, 2], [5]]",
        "explanation": "The unique combinations that sum to 5 are: [1, 2, 2] and [5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the candidates to help handle duplicates.",
      "Use backtracking to explore combinations."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Maximal Square",
    "description": "Given a 2D binary grid filled with 0's and 1's, find the largest square containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "2D Matrix",
    "tags": [
      "Dynamic Programming",
      "Matrix",
      "Square"
    ],
    "input_format": "A 2D binary grid matrix of size m x n.",
    "output_format": "An integer representing the area of the largest square containing only 1's.",
    "constraints": [
      "1 <= m, n <= 300",
      "matrix[i][j] is either '0' or '1'."
    ],
    "examples": [
      {
        "input": "matrix = [[1,0,1],[1,1,1],[1,0,0]]",
        "output": "4",
        "explanation": "The largest square has a size of 2 and thus an area of 2 * 2 = 4."
      },
      {
        "input": "matrix = [[0,1],[1,1]]",
        "output": "1",
        "explanation": "The largest square has a size of 1 and thus an area of 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dynamic programming approach to build a DP table.",
      "The size of the square can be derived from the minimum of three adjacent squares."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Sum Game",
    "description": "In the sum game, you start with two bags, each containing a certain number of stones. Each player can either take stones from the first bag or the second bag on their turn. The goal is to maximize the number of stones collected by the player. Given two integer arrays, `first` and `second`, representing the number of stones in two bags, compute the maximum number of stones a player can collect under optimal playing conditions.",
    "topic": "Dynamic Programming",
    "subtopic": "Optimal Strategy",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Game Theory"
    ],
    "input_format": "Two integer arrays `first` and `second` where 1 <= first.length, second.length <= 10^3 and 1 <= first[i], second[i] <= 1000.",
    "output_format": "An integer representing the maximum number of stones that can be collected.",
    "constraints": [
      "1 <= first.length, second.length <= 10^3",
      "1 <= first[i], second[i] <= 1000"
    ],
    "examples": [
      {
        "input": "first = [1, 2, 3], second = [4, 5, 6]",
        "output": "12",
        "explanation": "The optimal strategy is to take 3 from the first bag and 4, 5, and 6 from the second bag, yielding a total of 12 stones."
      },
      {
        "input": "first = [5, 3, 1], second = [2, 4, 6]",
        "output": "15",
        "explanation": "The optimal strategy is to take all stones from the first bag for a total of 9, then 6 from the second bag, for a total of 15."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the choices available at every step.",
      "Dynamic programming can help track the maximum stones collected at each state."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Number of Good Leaf Nodes Pairs",
    "description": "Given a binary tree, a leaf node is considered 'good' if it has a sibling leaf node (another child of the same parent node). The task is to determine the number of pairs of good leaf nodes. A pair is defined as two good leaf nodes that are siblings. You need to return the count of these good leaf node pairs in the tree.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth First Search",
      "Counting"
    ],
    "input_format": "The input is a binary tree represented by its root node.",
    "output_format": "An integer representing the number of good leaf node pairs.",
    "constraints": [
      "1 <= Number of nodes <= 10^4",
      "Each node's value is unique."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, 4, 5]",
        "output": "1",
        "explanation": "In this example, nodes 4 and 5 are leaf nodes and siblings, forming one good leaf node pair."
      },
      {
        "input": "root = [1, 2, null, 3, 4, null, 5]",
        "output": "0",
        "explanation": "There are no sibling leaf nodes in this tree."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth First Search to traverse the tree.",
      "Keep track of leaf nodes and their siblings while traversing."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Top K Frequent Elements",
    "description": "Given a non-empty array of integers, return the k most frequent elements. You may return the answer in any order.",
    "topic": "Array",
    "subtopic": "Counting Frequency",
    "tags": [
      "Array",
      "Hash Table",
      "Counting",
      "Sorting"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "A list of the k most frequent elements.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "k is guaranteed to be in the range [1, the number of unique elements in the array]"
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3], k = 2",
        "output": "[1, 2]",
        "explanation": "1 is the most frequent element and 2 is the second most frequent element."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "There is only one element, so it is the most frequent."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about using a hash map to count frequencies.",
      "Consider using a priority queue to keep track of the top k elements."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "Given an array prices where prices[i] is the price of a given stock on the ith day, return the maximum profit you can achieve from this transaction. You may complete at most one transaction (i.e., buy one and sell one share of the stock). Note that you cannot sell a stock before you buy it.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices where 0 <= prices.length <= 10^5.",
    "output_format": "An integer representing the maximum profit you can achieve.",
    "constraints": [
      "0 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "In this case, no transactions are done, and the max profit is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate the potential profit at each step."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Basic Calculator",
    "description": "Implement a basic calculator that can evaluate a given string expression containing non-negative integers, '+', '-', '*', and '/' operators. The expression should be evaluated according to the rules of operator precedence, where multiplication and division take precedence over addition and subtraction. The calculator should ignore any whitespace in the input string.",
    "topic": "Mathematics",
    "subtopic": "Expression Evaluation",
    "tags": [
      "String",
      "Mathematics",
      "Stack"
    ],
    "input_format": "A string expression s containing non-negative integers and operators ('+', '-', '*', '/').",
    "output_format": "An integer representing the result of the evaluated expression.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "The expression will not contain parentheses.",
      "The input expression is guaranteed to be a valid mathematical expression."
    ],
    "examples": [
      {
        "input": "s = '3 + 2 * 2'",
        "output": "7",
        "explanation": "According to operator precedence, the multiplication is evaluated first: 2 * 2 = 4, then 3 + 4 = 7."
      },
      {
        "input": "s = ' 3/2 '",
        "output": "1",
        "explanation": "The division yields 1.5, which is truncated to 1 as per integer division."
      },
      {
        "input": "s = ' 3 + 5 / 2 '",
        "output": "5",
        "explanation": "5 divided by 2 is 2 (as integer division). Finally, 3 + 2 = 5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to keep track of numbers and operators.",
      "Handle each operator's precedence carefully."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list.",
    "topic": "Linked List",
    "subtopic": "Addition",
    "tags": [
      "Linked List",
      "Addition",
      "Mathematics"
    ],
    "input_format": "Two linked lists, l1 and l2, where each node has a single digit and the digits are stored in reverse order.",
    "output_format": "A linked list representing the sum of the two numbers.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= node.val <= 9",
      "It is guaranteed that the result will not exceed 10^4."
    ],
    "examples": [
      {
        "input": "l1 = [2, 4, 3], l2 = [5, 6, 4]",
        "output": "[7, 0, 8]",
        "explanation": "The numbers are 342 and 465. Their sum is 807, represented as [7, 0, 8] in reverse order."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "Both numbers are 0. The sum is also 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to handle carries during addition.",
      "You can use a dummy node to simplify the process of adding nodes."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Subarray Sum Equals K",
    "description": "Given an integer array nums and an integer k, return the total number of continuous subarrays whose sum equals to k.",
    "topic": "Array",
    "subtopic": "Prefix Sum",
    "tags": [
      "Array",
      "Hashmap",
      "Prefix Sum"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An integer representing the number of continuous subarrays whose sum equals k.",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "-10^7 <= k <= 10^7"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 1], k = 2",
        "output": "2",
        "explanation": "There are two subarrays that sum to 2: [1, 1] (from index 0 to 1) and [1, 1] (from index 1 to 2)."
      },
      {
        "input": "nums = [1, 2, 3], k = 3",
        "output": "2",
        "explanation": "The subarrays that sum to 3 are [3] (from index 2 to 2) and [1, 2] (from index 0 to 1)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hashmap to store the cumulative sum.",
      "Look for how many times a particular sum has been seen."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Longest Consecutive Sequence",
    "description": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Sorting"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the length of the longest consecutive sequence.",
    "constraints": [
      "0 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [100, 4, 200, 1, 3, 2]",
        "output": "4",
        "explanation": "The longest consecutive elements sequence is [1, 2, 3, 4], its length is 4."
      },
      {
        "input": "nums = [0, 0, 1, 1, 2, 2, 3, 3, 4]",
        "output": "5",
        "explanation": "The longest consecutive elements sequence is [0, 1, 2, 3, 4], its length is 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a Set to store the numbers.",
      "Check for the start of a sequence using the Set.",
      "Count consecutive numbers starting from the found number."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Sort List",
    "description": "Given an unsorted list of integers, implement a function to sort the list in non-decreasing order. The sorting algorithm should have O(n log n) time complexity at worst. You can use either in-built sorting methods or implement your own sorting algorithm.",
    "topic": "Sorting",
    "subtopic": "Sorting Algorithms",
    "tags": [
      "Sorting",
      "Algorithms",
      "Array"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An array of integers representing the sorted list.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^6 <= nums[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [3, 1, 4, 1, 5, 9, 2]",
        "output": "[1, 1, 2, 3, 4, 5, 9]",
        "explanation": "The input list is sorted in non-decreasing order."
      },
      {
        "input": "nums = [0, -1, -3, 2, 1]",
        "output": "[-3, -1, 0, 1, 2]",
        "explanation": "The input list contains negative and positive numbers sorted in non-decreasing order."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a popular sorting algorithm like Merge Sort or Quick Sort.",
      "You can also use built-in sort functions if allowed."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Course Schedule II",
    "description": "There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, indicating that you must take one course before another. Given the number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. If there is no possible way to finish all courses, return an empty array. Your solution should use a topological sort algorithm.",
    "topic": "Graph",
    "subtopic": "Topological Sort",
    "tags": [
      "Graph",
      "Topological Sorting",
      "DFS",
      "BFS"
    ],
    "input_format": "An integer n and a 2D array prerequisites where prerequisites[i] = [a, b] indicates that you must take course a before course b.",
    "output_format": "A list of integers representing the order of courses. If it is impossible to finish all courses, return an empty list.",
    "constraints": [
      "1 <= n <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "All pairs [a, b] are distinct."
    ],
    "examples": [
      {
        "input": "n = 4, prerequisites = [[1,0],[2,1],[3,2]]",
        "output": "[0,1,2,3]",
        "explanation": "Taking course 0 first allows you to take course 1, which allows you to take course 2, and finally course 3."
      },
      {
        "input": "n = 2, prerequisites = [[1,0],[0,1]]",
        "output": "[]",
        "explanation": "There is a cycle between courses 0 and 1, making it impossible to finish all courses."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a graph data structure to represent the courses and prerequisites.",
      "If you detect a cycle, you cannot complete all courses."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Rotting Oranges",
    "description": "You are given an m x n grid where each cell can have one of three values: 0 (empty cell), 1 (fresh orange), or 2 (rotten orange). Every minute, any fresh orange that is adjacent (up, down, left, right) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no fresh oranges remain. If this is impossible, return -1.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "Matrix"
    ],
    "input_format": "An m x n grid represented as a list of lists where each element is 0, 1, or 2.",
    "output_format": "An integer representing the minimum number of minutes until no fresh oranges remain, or -1 if it is impossible.",
    "constraints": [
      "1 <= m, n <= 300",
      "grid[i][j] is 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
        "output": "4",
        "explanation": "In 4 minutes, all fresh oranges rot."
      },
      {
        "input": "grid = [[2,1,1],[0,1,1],[1,0,2]]",
        "output": "-1",
        "explanation": "There are fresh oranges that cannot rot."
      },
      {
        "input": "grid = [[0,2]]",
        "output": "0",
        "explanation": "No fresh oranges to rot."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use BFS to spread the rot from rotten oranges.",
      "Keep track of fresh oranges count and rot minutes."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Compare Version Numbers",
    "description": "You are given two version numbers, version1 and version2, which are strings. Version numbers are composed of one or more revision numbers separated by a dot '.'. Each revision number consists of digits and may be preceded by zeroes. The version number is valid if it follows the format described above. To compare two version numbers, consider the revision numbers from left to right. The first revision number is compared to the first revision number, the second to the second, and so on. If one version number has more revision numbers than the other, and all previous revision numbers are equal, the version number with the extra revision is considered greater. Your task is to implement a function that compares these two version numbers and returns 1 if version1 is greater than version2, -1 if version1 is less than version2, and 0 if they are equal.",
    "topic": "String",
    "subtopic": "Comparison",
    "tags": [
      "String",
      "Comparison",
      "Version"
    ],
    "input_format": "Two strings version1 and version2, representing version numbers.",
    "output_format": "An integer, either 1, -1, or 0 indicating the comparison result.",
    "constraints": [
      "0 < version1.length, version2.length <= 15",
      "version1 and version2 are valid version numbers as defined."
    ],
    "examples": [
      {
        "input": "version1 = \"1.0.1\", version2 = \"1.0\"",
        "output": "1",
        "explanation": "The first two segments are equal, but version1 has an additional segment which makes it greater."
      },
      {
        "input": "version1 = \"1.0.1\", version2 = \"1.0.2\"",
        "output": "-1",
        "explanation": "The first two segments are equal, but version2 has the greater last segment."
      },
      {
        "input": "version1 = \"1.0\", version2 = \"1.0.0\"",
        "output": "0",
        "explanation": "Both versions are effectively the same, leading to an equal comparison."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Split the version strings by '.' to compare each segment.",
      "Convert each segment to an integer for accurate comparison."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Sum of Distances in Tree",
    "description": "You are given a tree with n nodes numbered from 0 to n-1, where each node is connected by edges. The tree is rooted at node 0. A distance between two nodes is defined as the number of edges in the shortest path connecting them. You need to calculate the sum of distances from the root node (node 0) to all other nodes in the tree. Your task is to implement a function that computes and returns this sum based on the given structure of the tree.",
    "topic": "Tree",
    "subtopic": "Depth-First Search",
    "tags": [
      "Tree",
      "DFS",
      "Sum",
      "Graph"
    ],
    "input_format": "The first line contains an integer n (1 <= n <= 10^4), the number of nodes in the tree. The next n - 1 lines contain two integers u and v, representing an edge between nodes u and v.",
    "output_format": "An integer representing the sum of distances from the root node to all other nodes.",
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= u, v < n"
    ],
    "examples": [
      {
        "input": "5\n0 1\n0 2\n1 3\n1 4",
        "output": "8",
        "explanation": "The tree structure is: 0 -> 1, 0 -> 2, 1 -> 3, and 1 -> 4. Distances from node 0 are: to node 1 = 1, to node 2 = 1, to node 3 = 2, to node 4 = 2. Sum = 1 + 1 + 2 + 2 = 6."
      },
      {
        "input": "4\n0 1\n0 2\n0 3",
        "output": "6",
        "explanation": "The tree structure is: 0 -> 1, 0 -> 2, and 0 -> 3. Distances are: to node 1 = 1, to node 2 = 1, to node 3 = 1. Sum = 1 + 1 + 1 = 3."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider a depth-first search (DFS) approach to traverse the tree.",
      "Keep track of the depth of each node during the traversal."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water II",
    "description": "Given an m x n grid representing the elevation map where the value at each cell represents the height of the terrain, return the volume of water that can be trapped after raining. Each cell can hold water if all four of its neighboring cells are higher than it.",
    "topic": "Array",
    "subtopic": "2D Array",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Heap"
    ],
    "input_format": "A 2D array of integers representing the elevation map.",
    "output_format": "An integer representing the total trapped rain water volume.",
    "constraints": [
      "1 <= m, n <= 200",
      "0 <= elevationMap[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "elevationMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1],[6,1,4,5,2,3],[5,1,1,2,4,6]]",
        "output": "16",
        "explanation": "Water can be trapped in multiple cells around the lower elevations creating pockets."
      },
      {
        "input": "elevationMap = [[12,13,1,12],[13,4,13,12],[13,13,13,13],[12,13,12,12],[13,12,12,13]]",
        "output": "14",
        "explanation": "The matrix has areas lower than surrounding cells where rainwater can accumulate."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a priority queue to manage the cell heights.",
      "Explore the boundary cells first, as they control the water flow."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Search a 2D Matrix II",
    "description": "Write an efficient algorithm to search for a target value in an m x n integer matrix. This matrix has the following properties: Integers in each row are sorted in ascending order from left to right, and integers in each column are sorted in ascending order from top to bottom. You need to implement a function that returns true if the target is in the matrix and false otherwise.",
    "topic": "Matrix",
    "subtopic": "Search",
    "tags": [
      "Matrix",
      "Binary Search",
      "Search"
    ],
    "input_format": "A 2D matrix of integers matrix and an integer target.",
    "output_format": "A boolean value, true if the target is found in the matrix, false otherwise.",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 100",
      "-10^4 <= matrix[i][j] <= 10^4",
      "All the integers in each row are distinct.",
      "The target value is an integer."
    ],
    "examples": [
      {
        "input": "matrix = [[1, 3, 5], [7, 10, 12], [14, 16, 20]], target = 10",
        "output": "true",
        "explanation": "The target value 10 is found in the matrix at position (1, 1)."
      },
      {
        "input": "matrix = [[1, 3, 5], [7, 10, 12], [14, 16, 20]], target = 6",
        "output": "false",
        "explanation": "The target value 6 is not present in the matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to eliminate rows or columns based on the target's value.",
      "You can treat the matrix like a binary search space."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Merge Sorted Array",
    "description": "You are given two integer arrays, nums1 and nums2, sorted in non-decreasing order. You need to merge nums2 into nums1 as one sorted array. The merging should be done in place and without using additional space. The function should not return anything, but the merged array should be available in nums1.",
    "topic": "Array",
    "subtopic": "Merge",
    "tags": [
      "Array",
      "Sorting",
      "In-place"
    ],
    "input_format": "Two integer arrays, nums1 and nums2, where nums1 has a size of m + n, with the first m elements representing the original elements of nums1 and the last n elements being empty. nums2 has n elements.",
    "output_format": "The merged array is stored in nums1.",
    "constraints": [
      "0 <= m, n <= 200",
      "1 <= m + n <= 200",
      "-10^9 <= nums1[i], nums2[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3",
        "output": "[1, 2, 2, 3, 5, 6]",
        "explanation": "After merging, the numbers from both arrays should be sorted in non-decreasing order."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "Since nums2 is empty, the result is just nums1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider merging from the end of the arrays to avoid overwriting elements."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Peak Index in a Mountain Array",
    "description": "An array arr is called a mountain array if and only if: arr.length >= 3, There exists some i with 0 < i < arr.length - 1 such that arr[0] < arr[1] < ... < arr[i-1] < arr[i] and arr[i] > arr[i+1] > ... > arr[arr.length - 1]. Given a mountain array, return the index of the peak element.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Peak Element"
    ],
    "input_format": "An array of integers arr where arr is a mountain array.",
    "output_format": "An integer representing the index of the peak element.",
    "constraints": [
      "3 <= arr.length <= 10^5",
      "1 <= arr[i] <= 10^6",
      "arr is guaranteed to be a mountain array."
    ],
    "examples": [
      {
        "input": "arr = [0, 2, 1, 0]",
        "output": "1",
        "explanation": "The peak element is 2, which is at index 1."
      },
      {
        "input": "arr = [0, 10, 5, 2]",
        "output": "1",
        "explanation": "The peak element is 10, which is at index 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to find the peak.",
      "If arr[mid] < arr[mid + 1], the peak lies in the right half.",
      "If arr[mid] > arr[mid + 1], the peak lies in the left half."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Minimum Area Rectangle",
    "description": "Given a set of points in a 2D plane, find the minimum area of a rectangle formed by these points. The rectangle must have its sides parallel to the axes. If there is no such rectangle, return 0.",
    "topic": "Geometry",
    "subtopic": "Rectangle",
    "tags": [
      "Geometry",
      "Rectangle",
      "Hashing"
    ],
    "input_format": "A list of points where each point is represented as an array of two integers [x, y].",
    "output_format": "An integer representing the minimum area of the rectangle formed by the points, or 0 if no rectangle can be formed.",
    "constraints": [
      "1 <= points.length <= 1000",
      "-10^4 <= points[i][0], points[i][1] <= 10^4",
      "All points are unique."
    ],
    "examples": [
      {
        "input": "points = [[1,1],[1,3],[3,1],[3,3],[2,2]]",
        "output": "4",
        "explanation": "The rectangle formed by the points (1,1), (1,3), (3,1), and (3,3) has an area of 4."
      },
      {
        "input": "points = [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3]]",
        "output": "0",
        "explanation": "No rectangle can be formed using the given points."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a set to store points for fast lookups.",
      "Loop through pairs of points to find potential opposite corners of a rectangle."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Binary Tree Zigzag Level Order Traversal",
    "description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search"
    ],
    "input_format": "The root node of a binary tree.",
    "output_format": "A 2D list of integers representing the zigzag level order traversal.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3, 9, 20, null, null, 15, 7]",
        "output": "[[3], [20, 9], [15, 7]]",
        "explanation": "The zigzag level order is: first level [3], second level [20, 9] (right to left), third level [15, 7] (left to right)."
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": "There is only one node, so the output is [[1]]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to perform level order traversal.",
      "Toggle the order of traversal at each level."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Subsets",
    "description": "Given a set of distinct integers, return all possible subsets (the power set). The solution set must not contain duplicate subsets. You may return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Combinatorial Generation",
    "tags": [
      "Backtracking",
      "Combinations",
      "Bit Manipulation"
    ],
    "input_format": "An integer array nums, where 1 <= nums.length <= 10 and -10 <= nums[i] <= 10.",
    "output_format": "A list of lists containing all possible subsets.",
    "constraints": [
      "1 <= nums.length <= 10",
      "-10 <= nums[i] <= 10",
      "All elements of nums are distinct."
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]",
        "explanation": "The subsets for the set [1, 2, 3] include all combinations of the elements."
      },
      {
        "input": "nums = [0]",
        "output": "[[], [0]]",
        "explanation": "The subsets for the set [0] include the empty set and the set itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a backtracking approach to explore all subsets.",
      "Consider using bit manipulation to represent subsets."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Longest Repeating Character Replacement",
    "description": "Given a string s that consists of uppercase English letters and an integer k, you can replace any character in the string up to k times to create the longest substring with the same character. Return the length of the longest substring containing the same letter after performing at most k replacements.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Two Pointers"
    ],
    "input_format": "A string s and an integer k.",
    "output_format": "An integer representing the length of the longest substring with repeating characters after at most k replacements.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of only uppercase English letters.",
      "0 <= k <= s.length"
    ],
    "examples": [
      {
        "input": "s = 'AABABBA', k = 1",
        "output": "4",
        "explanation": "Replace one 'B' with 'A' to get 'AABAABBA', which has the longest substring 'AAAA' with length 4."
      },
      {
        "input": "s = 'ABAB', k = 2",
        "output": "4",
        "explanation": "We can replace both characters to get 'AAAA', achieving the longest substring length of 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window approach to keep track of the current substring.",
      "Count the frequency of the characters in the current window.",
      "Keep track of the maximum frequency character in the window."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Design Memory Allocator",
    "description": "You are tasked with designing a memory allocator that efficiently allocates and deallocates memory blocks of varying sizes. The allocator should be able to manage a fixed-size memory pool, providing functions for allocation and deallocation, while ensuring that memory is used efficiently without fragmentation. Your task is to implement the following operations: `allocate(size)` returns a pointer to a block of memory of the requested size, or `NULL` if there is insufficient memory. `deallocate(ptr)` frees the memory block pointed to by ptr. Additionally, you need to provide a function `getAllocatedMemory()` that returns the total memory allocated so far. Write your allocator class in a way that it manages memory effectively while minimizing fragmentation.",
    "topic": "Memory Management",
    "subtopic": "Dynamic Allocation",
    "tags": [
      "Memory",
      "Allocator",
      "Dynamic Programming"
    ],
    "input_format": "The allocator can receive commands to allocate and deallocate memory through the methods described.",
    "output_format": "The output is essentially the state of memory after the operations, as well as the result of the method calls.",
    "constraints": [
      "The total size of the allocated memory should never exceed the fixed size of the memory pool.",
      "1 <= size <= 1024 for allocation."
    ],
    "examples": [
      {
        "input": "allocator = new Allocator(1024);\nptr1 = allocator.allocate(200);\npointer2 = allocator.allocate(300);\nallocator.deallocate(ptr1);\ntotalAllocated = allocator.getAllocatedMemory();",
        "output": "300",
        "explanation": "Initially, 200 and then 300 bytes are allocated. After deallocating the first pointer, only 300 bytes remain allocated."
      },
      {
        "input": "allocator = new Allocator(800);\npointer1 = allocator.allocate(500);\npointer2 = allocator.allocate(300);\nptr3 = allocator.allocate(100);\nallocator.deallocate(pointer1);\nallocator.deallocate(pointer2);\ntotalAllocated = allocator.getAllocatedMemory();",
        "output": "0",
        "explanation": "All allocated blocks have been deallocated, so the total allocated memory is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a linked list or array to manage free and occupied memory blocks.",
      "Think about how to efficiently merge freed memory blocks to reduce fragmentation."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Count Binary Substrings",
    "description": "Given a binary string consisting of '0's and '1's, count the number of non-empty substrings that have the same number of '0's and '1's. A substring is a contiguous sequence of characters in the string.",
    "topic": "String",
    "subtopic": "Substring Counting",
    "tags": [
      "String",
      "Counting",
      "Binary"
    ],
    "input_format": "A binary string s.",
    "output_format": "An integer representing the number of binary substrings with equal numbers of '0's and '1's.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s[i] is either '0' or '1'."
    ],
    "examples": [
      {
        "input": "s = \"00110011\"",
        "output": "6",
        "explanation": "The valid substrings are: \"0011\", \"01\", \"10\", \"1100\", \"10\", \"01\"."
      },
      {
        "input": "s = \"10101\"",
        "output": "4",
        "explanation": "The valid substrings are: \"10\", \"01\", \"10\", \"01\"."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider tracking the count of consecutive '0's and '1's.",
      "Use pairs of counts to determine how many valid substrings can be formed."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Add to Array-Form of Integer",
    "description": "The array-form of an integer is an array representing its digits in left to right order. Given an integer `K` and an array `A` representing the array-form of an integer, return the array-form of the integer `A + K`.",
    "topic": "Array",
    "subtopic": "Mathematics",
    "tags": [
      "Array",
      "Math",
      "Simulation"
    ],
    "input_format": "An integer K and an array A representing the array-form of an integer.",
    "output_format": "An array representing the array-form of the integer A + K.",
    "constraints": [
      "0 <= A.length <= 10000",
      "0 <= K <= 10^4",
      "0 <= A[i] <= 9"
    ],
    "examples": [
      {
        "input": "A = [2, 7, 4], K = 181",
        "output": "[4, 5, 5]",
        "explanation": "A represents the integer 274. When adding 181, we get 455."
      },
      {
        "input": "A = [1, 2, 0, 0], K = 34",
        "output": "[1, 2, 0, 3, 4]",
        "explanation": "A represents the integer 1200. When adding 34, we get 1234."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider iterating through the array from the last index.",
      "Handle carries while adding digits."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "topic": "Dynamic Programming",
    "subtopic": "Fibonacci Sequence",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Fibonacci"
    ],
    "input_format": "An integer n (1 <= n <= 45), representing the number of steps in the staircase.",
    "output_format": "An integer representing the number of distinct ways to climb to the top of the staircase.",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: 1 step + 1 step or 2 steps."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, or 2 steps + 1 step."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Try using a recurrence relation to solve the problem.",
      "Consider how many ways there are to reach the last or second to last step."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Pow(x, n)",
    "description": "Implement a function that calculates x raised to the power n (x^n). The function should handle both positive and negative integer values of n. Do not use built-in exponentiation functions.",
    "topic": "Math",
    "subtopic": "Exponents",
    "tags": [
      "Math",
      "Exponents",
      "Recursion"
    ],
    "input_format": "Two integers x and n, where x is the base and n is the exponent.",
    "output_format": "A float representing the result of x raised to the power n.",
    "constraints": [
      "-10^4 <= x <= 10^4",
      "-2^31 <= n <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 2, n = 10",
        "output": "1024.0",
        "explanation": "2 raised to the power of 10 is 1024."
      },
      {
        "input": "x = 2, n = -2",
        "output": "0.25",
        "explanation": "2 raised to the power of -2 is 1/(2^2) = 1/4 = 0.25."
      },
      {
        "input": "x = 0, n = 5",
        "output": "0.0",
        "explanation": "0 raised to any positive power is 0."
      },
      {
        "input": "x = 1, n = 1000",
        "output": "1.0",
        "explanation": "1 raised to any power is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you can reduce the problem using recursion.",
      "Think about how to handle negative powers."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Intersection of Two Linked Lists",
    "description": "Given the heads of two singly linked lists, determine the node at which the two lists intersect. If the two linked lists do not intersect, return null. An intersection occurs when the two lists share a common node. You may assume that there are no cycles in either of the linked lists.",
    "topic": "Linked List",
    "subtopic": "Intersection of Lists",
    "tags": [
      "Linked List",
      "Intersection",
      "Two Pointers"
    ],
    "input_format": "The head nodes of two singly linked lists.",
    "output_format": "The node where the two linked lists intersect, or null if they do not intersect.",
    "constraints": [
      "The number of nodes in both linked lists will not exceed 10^4.",
      "Do not modify the input linked lists."
    ],
    "examples": [
      {
        "input": "headA = [4, 1, 8, 4, 5], headB = [5, 0, 1, 8, 4, 5]",
        "output": "8",
        "explanation": "The lists intersect at node with value 8."
      },
      {
        "input": "headA = [1, 9, 1, 2, 4], headB = [3, 2, 4]",
        "output": "2",
        "explanation": "The lists intersect at node with value 2."
      },
      {
        "input": "headA = [2, 6, 4], headB = [1, 5]",
        "output": "null",
        "explanation": "The two lists do not intersect."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a two-pointer technique to solve this problem without extra space.",
      "If one pointer reaches the end of one list, start at the head of the other list."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List",
    "description": "Given the head of a singly linked list, reverse the nodes of the list and return the head of the reversed list.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "Linked List",
      "Reversal",
      "Pointers"
    ],
    "input_format": "The head of the linked list, where each node contains an integer value.",
    "output_format": "The head of the reversed linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 5000].",
      "-5000 <= Node.val <= 5000"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5]",
        "output": "[5, 4, 3, 2, 1]",
        "explanation": "Reversing the linked list gives us the nodes in the order: 5 -> 4 -> 3 -> 2 -> 1."
      },
      {
        "input": "head = [1, 2]",
        "output": "[2, 1]",
        "explanation": "Reversing the linked list gives us the nodes in the order: 2 -> 1."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "An empty list remains empty when reversed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use three pointers to keep track of the previous, current, and next nodes.",
      "Iterate through the list and adjust pointers to reverse the links."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Next Permutation",
    "description": "Implement the next permutation algorithm, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it to the lowest possible order (i.e., sorted in ascending order). The replacement must be done in place. You must do this with O(1) extra memory.",
    "topic": "Array",
    "subtopic": "Permutation",
    "tags": [
      "Array",
      "Permutation",
      "In-place"
    ],
    "input_format": "An array of integers nums representing the permutation.",
    "output_format": "Modify the input array to the next permutation in-place.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[1, 3, 2]",
        "explanation": "The next permutation of [1, 2, 3] is [1, 3, 2]."
      },
      {
        "input": "nums = [3, 2, 1]",
        "output": "[1, 2, 3]",
        "explanation": "The current permutation is the highest. The next permutation is the lowest: [1, 2, 3]."
      },
      {
        "input": "nums = [1, 1, 5]",
        "output": "[1, 5, 1]",
        "explanation": "The next permutation of [1, 1, 5] is [1, 5, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Find the rightmost pair where nums[i] < nums[i + 1].",
      "Swap this number with the smallest number larger than it to the right.",
      "Reverse the sequence after the original index."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "H-Index",
    "description": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's H-Index. According to the definition of H-Index, an author with an H-Index of h has published h papers that have each been cited at least h times.",
    "topic": "Sorting",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Sorting",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers citations representing the number of citations for each paper.",
    "output_format": "An integer representing the H-Index of the researcher.",
    "constraints": [
      "1 <= citations.length <= 5000",
      "0 <= citations[i] <= 10000"
    ],
    "examples": [
      {
        "input": "[3, 0, 6, 1, 5]",
        "output": "3",
        "explanation": "The researcher has 3 papers with at least 3 citations each (3, 6, 5)."
      },
      {
        "input": "[1, 3, 1]",
        "output": "1",
        "explanation": "The researcher has 1 paper with at least 1 citation."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the citations in non-decreasing order.",
      "The H-Index can be determined by comparing the number of citations with the index."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "You are given an integer array height where height[i] represents the height of a vertical line at index i. The two lines at indices i and j can form a container, and the amount of water that can be held by this container is determined by the shorter of the two lines multiplied by the distance between them (j - i). Your task is to find the maximum amount of water the container can hold.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "input_format": "An array of integers height representing the heights of the lines.",
    "output_format": "An integer representing the maximum amount of water that can be trapped.",
    "constraints": [
      "2 <= height.length <= 10^5",
      "0 <= height[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The maximum amount of water is formed between the lines at indices 1 and 8, with heights 8 and 7, giving a width of 7 and height 7, thus 7 * 7 = 49."
      },
      {
        "input": "height = [1,1]",
        "output": "1",
        "explanation": "The container formed by the two lines at indices 0 and 1 can hold a maximum of 1 unit of water."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a two-pointer approach to optimize your search.",
      "Start with pointers at both ends and move towards the center."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Decode String",
    "description": "Given an encoded string, return its decoded version. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. You may assume that the input string is always valid. No extra whitespace is present in the input. You need to decode the entire string correctly.",
    "topic": "String",
    "subtopic": "Decoding",
    "tags": [
      "String",
      "Decoding",
      "Stack"
    ],
    "input_format": "A string s representing the encoded message.",
    "output_format": "A string that is the decoded version of the input string.",
    "constraints": [
      "1 <= s.length <= 30",
      "s consists of digits, lowercase English letters, and square brackets '[]'.",
      "The input string is always valid and well-formed."
    ],
    "examples": [
      {
        "input": "3[a2[c]]",
        "output": "accaccacc",
        "explanation": "The decoded string is 'c' repeated twice giving 'cc', which is then repeated three times to get 'accaccacc'."
      },
      {
        "input": "2[abc]3[cd]ef",
        "output": "abcabccdcdcdef",
        "explanation": "The first part decodes to 'abc' repeated twice to get 'abcabc'. The second part decodes to 'cd' repeated thrice to get 'cdcdcd'. Finally combined gives 'abcabccdcdcdef'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to track the decoded strings and repeat counts.",
      "Iterate through the characters, building the result as you encounter digits, letters, and brackets."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Find All Good Indices",
    "description": "You are given an integer array nums of length n and an integer k. A good index is an index i such that the number of elements in the subarray nums[0..i] that are less than or equal to nums[i] is greater than or equal to k. Return a list of all good indices in ascending order.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Index"
    ],
    "input_format": "An integer array nums of length n followed by an integer k.",
    "output_format": "A list of integers representing all good indices.",
    "constraints": [
      "1 <= n <= 10^5",
      "-10^5 <= nums[i] <= 10^5",
      "1 <= k <= n"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 2, 5, 4], k = 3",
        "output": "[3]",
        "explanation": "At index 3, there are 3 numbers (1, 3, 2) less than or equal to 5. Hence, 3 is a good index."
      },
      {
        "input": "nums = [5, 1, 2, 4, 3], k = 2",
        "output": "[0, 3, 4]",
        "explanation": "At index 0, 5 is the only number (itself). At index 3, there are 2 numbers (1, 2) less than or equal to 4. At index 4, there are 3 numbers (1, 2, 3) less than or equal to 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider iterating through each index and counting the relevant elements.",
      "Use a two-pointer technique or a frequency array to optimize counting."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Degree of an Array",
    "description": "Given an array of integers, return the 'degree' of the array, which is defined as the maximum frequency of any of its elements. If the array has multiple elements with the same maximum frequency, the degree of the array is also the length of the smallest subarray that has the same degree. Your task is to find the length of such a subarray.",
    "topic": "Array",
    "subtopic": "Frequency Count",
    "tags": [
      "Array",
      "HashMap",
      "Frequency"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the length of the smallest subarray with the same degree as the array.",
    "constraints": [
      "1 <= nums.length <= 50000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2, 3, 1]",
        "output": "2",
        "explanation": "The degree of the array is 2 (both 1 and 2 appear twice), and the smallest subarray with that degree is [2, 2], which has length 2."
      },
      {
        "input": "nums = [1, 2, 2, 3, 1, 4, 2]",
        "output": "6",
        "explanation": "The degree of the array is 3 (number 2 has the highest frequency). The smallest subarray with this degree is [2, 3, 1, 4, 2], which has length 6."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a HashMap to track the frequency of each element.",
      "Keep track of the first and last occurrence of each element."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Partition to K Equal Sum Subsets",
    "description": "Given an array of integers nums and an integer k, determine if it is possible to partition the array into k non-empty subsets such that the sum of the elements in each subset is equal. The subsets should not overlap, and the order of subsets does not matter.",
    "topic": "Backtracking",
    "subtopic": "Partitioning",
    "tags": [
      "Backtracking",
      "Dynamic Programming",
      "Partition"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "A boolean value indicating whether the partitioning into k equal sum subsets is possible.",
    "constraints": [
      "1 <= nums.length <= 15",
      "0 <= nums[i] <= 1000",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [4, 3, 2, 3, 5, 2, 1], k = 4",
        "output": "true",
        "explanation": "You can partition the array into subsets [4], [3, 3], [2, 2], and [5, 1] each summing to 5."
      },
      {
        "input": "nums = [1, 2, 3, 4], k = 3",
        "output": "false",
        "explanation": "It is not possible to partition the array into 3 subsets with equal sum."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the total sum of the array and check if it's divisible by k.",
      "Use backtracking to try different combinations of subsets."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Open the Lock",
    "description": "You have a lock that consists of 4 wheels, each wheel can be set to a digit between 0 and 9. The lock starts at '0000', and you can turn each wheel independently to unlock it. To unlock it, you must reach a specified target combination. Some specific combinations are forbidden, and you cannot pass through them. Your task is to find the minimum number of turns required to reach the target combination from the starting position. A single turn increments/decrements the wheel by one digit. You may visit the same combination multiple times if necessary.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "Graph",
      "BFS",
      "Search"
    ],
    "input_format": "A string target representing the target combination and an array of strings deadends representing the forbidden combinations.",
    "output_format": "An integer representing the minimum number of turns to unlock the lock, or -1 if it's not possible.",
    "constraints": [
      "The target string consists of exactly 4 digits (0-9).",
      "0 <= deadends.length <= 500.",
      "Each deadend string consists of exactly 4 digits (0-9)."
    ],
    "examples": [
      {
        "input": {
          "target": "0202",
          "deadends": [
            "0000",
            "0201",
            "0101",
            "0102",
            "1212",
            "2002"
          ]
        },
        "output": "6",
        "explanation": "From '0000', we can turn to '0001', '0010', ... up to '0202'. Avoiding banned paths takes 6 moves."
      },
      {
        "input": {
          "target": "8888",
          "deadends": [
            "0000",
            "8888"
          ]
        },
        "output": "-1",
        "explanation": "It's impossible to reach '8888' because it is a deadend."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a BFS approach to explore all possible combinations.",
      "Track the visited combinations to avoid loops.",
      "Each digit can be increased or decreased, think about how to generate next states."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A palindromic substring is a substring that reads the same forward and backward. If there are multiple longest palindromic substrings, return any one of them.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A single string s where 1 <= s.length <= 1000.",
    "output_format": "A string which is the longest palindromic substring of s.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "babad",
        "output": "bab",
        "explanation": "Both 'bab' and 'aba' are valid longest palindromic substrings."
      },
      {
        "input": "cbbd",
        "output": "bb",
        "explanation": "'bb' is the longest palindromic substring."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding around the center of the palindrome.",
      "A palindrome can be expanded in two ways, one character center and two characters center."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Maximum Value at a Given Index in a Bounded Array",
    "description": "You are given an integer array 'nums' and two integers 'maxSum' and 'index'. Your task is to find the maximum possible value at a specified 'index' in the array such that the sum of the elements in the array does not exceed 'maxSum'. The array must have exactly the same length as 'nums'. Additionally, for each element at the specified 'index', you can only initialize values between 0 and the maximum allowable based on the constraints provided. You must ensure the sum remains at most 'maxSum'.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Greedy"
    ],
    "input_format": "An array of integers nums[], an integer maxSum, and an integer index.",
    "output_format": "An integer representing the maximum possible value at the given index.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= maxSum <= 10^9",
      "0 <= index < nums.length",
      "0 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3], maxSum = 6, index = 1",
        "output": "2",
        "explanation": "The maximum value at index 1 can be 2, which is the original value. The total sum is 1 + 2 + 3 = 6, which is equal to maxSum."
      },
      {
        "input": "nums = [1, 2, 3], maxSum = 8, index = 2",
        "output": "6",
        "explanation": "We can increase the element at index 2 to 6, while keeping the sum 1 + 2 + 6 = 9, which is greater than maxSum, hence the maximum allowed value at index 2 is 6 making the total sum equal to 8."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use binary search to efficiently determine the maximum value.",
      "Consider the total sum impact of other elements while adjusting the target index value."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Unique Paths",
    "description": "A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram). How many unique paths are there to reach the finish? \n\nNote: The grid is 1-indexed, and the robot must stay within the grid boundaries.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Navigation",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Mathematics"
    ],
    "input_format": "Two integers m and n representing the dimensions of the grid.",
    "output_format": "An integer representing the number of unique paths from the top-left corner to the bottom-right corner.",
    "constraints": [
      "1 <= m, n <= 100"
    ],
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": "There are 28 unique paths for the robot to reach the bottom-right corner in a 3x7 grid."
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "There are 3 unique paths for the robot to reach the bottom-right corner in a 3x2 grid."
      },
      {
        "input": "m = 7, n = 3",
        "output": "28",
        "explanation": "There are also 28 unique paths for the robot to reach the bottom-right corner in a 7x3 grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to build up the solution.",
      "The number of paths to a cell can be obtained from the number of paths to the cell above it and the cell to the left."
    ],
    "company": "ByteDance"
  },
  {
    "question_id": "",
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of k linked-lists, where each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
    "topic": "Linked List",
    "subtopic": "Merge",
    "tags": [
      "Linked List",
      "Sorting",
      "Heap"
    ],
    "input_format": "An array of k singly-linked lists.",
    "output_format": "A single merged and sorted singly-linked list.",
    "constraints": [
      "0 <= k <= 10^4",
      "0 <= ListNode.val <= 10^4",
      "The total number of nodes in all linked-lists will not exceed 10^4."
    ],
    "examples": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]",
        "explanation": "The merged linked-list is 1->1->2->3->4->4->5->6."
      },
      {
        "input": "lists = []",
        "output": "[]",
        "explanation": "The input is empty, hence the merged linked-list is also empty."
      },
      {
        "input": "lists = [[-1,5],[1,2,3]]",
        "output": "[-1,1,2,3,5]",
        "explanation": "The merged linked-list is -1->1->2->3->5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a min-heap to efficiently merge k lists.",
      "You can use a dummy node to simplify list handling.",
      "Think about edge cases, like empty lists."
    ],
    "company": "ByteDance"
  }
]