[
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A string s consisting of English letters, digits, symbols, and spaces.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 10^5",
      "s consists of printable ASCII characters."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"abc\" with length 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The longest substring without repeating characters is \"b\" with length 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"wke\" with length 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window approach.",
      "Consider using a HashMap to track characters and their indices.",
      "Update the window whenever a repeating character is found."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "LRU Cache",
    "description": "Design and implement a data structure for LRU (Least Recently Used) cache. It should support the following operations: get and put. The get operation should retrieve the value of the key if the key exists in the cache, otherwise return -1. The put operation should update the value of the key if the key exists, or insert the key-value pair if the key does not exist. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item.",
    "topic": "Design",
    "subtopic": "Cache",
    "tags": [
      "Design",
      "Cache",
      "Data Structure"
    ],
    "input_format": "The capacity of the cache will be provided during instantiation. The operations will consist of calls to 'get' and 'put' with specified keys and values.",
    "output_format": "The output for the 'get' operation will be the value associated with the given key or -1 if the key does not exist.",
    "constraints": [
      "The number of keys in the cache will not exceed the given capacity.",
      "1 <= capacity <= 3000",
      "0 <= key <= 10^4",
      "0 <= value <= 10^4"
    ],
    "examples": [
      {
        "input": "LRUCache(2); cache.put(1, 1); cache.put(2, 2); cache.get(1); cache.put(3, 3); cache.get(2); cache.put(4, 4); cache.get(1); cache.get(3); cache.get(4);",
        "output": "[1, -1, -1, 4]",
        "explanation": "After the operations, the values returned by 'get' are in the order: 1 (exists), -1 (does not exist), -1 (does not exist), and 4 (exists)."
      },
      {
        "input": "LRUCache(1); cache.put(2, 1); cache.get(2); cache.put(3, 2); cache.get(2);",
        "output": "[1, -1]",
        "explanation": "After the operations, the 'get' results are: 1 (exists) and -1 (does not exist after eviction)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a combination of a hash map and a doubly linked list.",
      "The hash map can provide O(1) access time, while the linked list can maintain the order of usage."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Max Stack",
    "description": "Design a stack that supports the following operations: push, pop, top, and retrieving the maximum element. Implement the MaxStack class with the following methods: \n\n- void push(int x): Pushes the element x onto the stack. \n- void pop(): Removes the element on the top of the stack. \n- int top(): Gets the top element of the stack. \n- int getMax(): Retrieves the maximum element in the stack. \n\nAll operations must be done in O(1) time complexity.",
    "topic": "Design",
    "subtopic": "Stack",
    "tags": [
      "Stack",
      "Design",
      "Data Structure"
    ],
    "input_format": "A series of operations on the MaxStack class.",
    "output_format": "The output for getMax() and top() methods as integers.",
    "constraints": [
      "The number of operations performed will be at most 10000.",
      "Each push operation will be a valid integer within the range of [-10^9, 10^9]."
    ],
    "examples": [
      {
        "input": "MaxStack stack = new MaxStack(); stack.push(5); stack.push(1); stack.push(5); stack.getMax(); stack.pop(); stack.top(); stack.getMax();",
        "output": "[5, 1, 5]",
        "explanation": "After pushing 5, 1, and 5, the maximum is 5. Popping the top (5) gives us 1, and the max remains 5."
      },
      {
        "input": "MaxStack stack = new MaxStack(); stack.push(1); stack.push(2); stack.push(3); stack.getMax(); stack.pop(); stack.getMax();",
        "output": "[3, 2]",
        "explanation": "The maximum when pushing 1, 2, and 3 is 3. After popping 3, the maximum is now 2."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using an auxiliary stack to track maximum values.",
      "Think about how to efficiently retrieve the max value on push and pop operations."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A string s consisting of bracket characters.",
    "output_format": "A boolean indicating whether the input string is valid.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses only '()[]{}'"
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The parentheses are correctly matched and closed."
      },
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "All types of brackets are correctly matched and closed."
      },
      {
        "input": "s = '(]')",
        "output": "false",
        "explanation": "The brackets are not correctly matched."
      },
      {
        "input": "s = '([)]'",
        "output": "false",
        "explanation": "The brackets are closed in the incorrect order."
      },
      {
        "input": "s = '{()[]}'",
        "output": "true",
        "explanation": "All brackets are correctly matched and closed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "Check if the current character matches the last opening bracket.",
      "At the end, verify that the stack is empty."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices where 0 <= prices.length <= 10^4.",
    "output_format": "An integer representing the maximum profit you can achieve.",
    "constraints": [
      "0 <= prices.length <= 10^4",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). The profit is 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate the maximum profit at each step while iterating through the prices."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers that add up to the target.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "Each input has exactly one solution.",
      "You may not use the same element twice."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 2 + 7 = 9."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "nums[1] + nums[2] = 2 + 4 = 6."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 3 + 3 = 6."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a hash table to store the indices of the numbers."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of bars in a histogram, compute how much water it can trap after raining. The width of each bar is assumed to be 1.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers height where height[i] represents the height of the i-th bar.",
    "output_format": "An integer representing the total amount of water trapped.",
    "constraints": [
      "0 <= height.length <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The water trapped above the bars is 6 units."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The water trapped above the bars is 9 units."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using two pointers to find the boundaries for the water calculation.",
      "Think about how to calculate the water level above each bar."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. For example, if the input is [[1,3],[2,6],[8,10],[15,18]], the merged intervals should be [[1,6],[8,10],[15,18]]. The intervals are represented by pairs of start and end times, and they may overlap with each other.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Intervals"
    ],
    "input_format": "A list of intervals, where each interval is represented by a pair of integers [start, end].",
    "output_format": "A list of merged intervals, where each interval is also represented by a pair of integers [start, end].",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "The intervals [1,3] and [2,6] overlap, so they are merged into [1,6]. The other intervals do not overlap with any other intervals."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "The intervals [1,4] and [4,5] touch at 4, so they are merged into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on the start time.",
      "Use a stack or a list to store the merged intervals."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Divide Intervals Into Minimum Number of Groups",
    "description": "Given a collection of intervals, divide them into the minimum number of groups such that no two intervals in the same group overlap. Each interval is represented as a pair of integers [start, end]. Return the number of groups formed.",
    "topic": "Greedy",
    "subtopic": "Interval Scheduling",
    "tags": [
      "Greedy",
      "Intervals",
      "Sorting"
    ],
    "input_format": "A list of intervals, where each interval is represented by a pair of integers [start, end].",
    "output_format": "An integer representing the minimum number of groups needed to separate the intervals.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= start < end <= 10^6"
    ],
    "examples": [
      {
        "input": "intervals = [[1, 3], [2, 4], [3, 5]]",
        "output": "2",
        "explanation": "Interval [1, 3] overlaps with [2, 4], so they must be in different groups. [3, 5] does not overlap with [1, 3] or [2, 4], so we can place it in the same group as [3, 5]. Thus, we need 2 groups."
      },
      {
        "input": "intervals = [[1, 5], [6, 10], [8, 12], [11, 15]]",
        "output": "3",
        "explanation": "The intervals [1, 5], [8, 12], and [11, 15] overlap, requiring separate groups. Thus, 3 groups are necessary."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals by their start times.",
      "Use a priority queue to manage the end times of the groups."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Word Break",
    "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Backtracking"
    ],
    "input_format": "A string s representing the input string and a list of strings wordDict representing the dictionary of words.",
    "output_format": "A boolean value indicating whether the string can be segmented into a space-separated sequence of dictionary words.",
    "constraints": [
      "1 <= s.length <= 300",
      "1 <= wordDict.length <= 1000",
      "1 <= wordDict[i].length <= 20",
      "The input string s and words in wordDict consist of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = 'leetcode', wordDict = ['leet', 'code']",
        "output": "true",
        "explanation": "'leetcode' can be segmented as 'leet code'."
      },
      {
        "input": "s = 'applepenapple', wordDict = ['apple', 'pen']",
        "output": "true",
        "explanation": "'applepenapple' can be segmented as 'apple pen apple'."
      },
      {
        "input": "s = 'catsandog', wordDict = ['cats', 'dog', 'sand', 'and', 'cat']",
        "output": "false",
        "explanation": "'catsandog' cannot be segmented into words from the dictionary."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store solutions to subproblems.",
      "Think about breaking the string at each position and checking the prefixes."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Middle of the Linked List",
    "description": "Given a non-empty singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node.",
    "topic": "Linked List",
    "subtopic": "Fast and Slow Pointers",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Finding Node"
    ],
    "input_format": "A non-empty singly linked list represented by its head node.",
    "output_format": "A node that represents the middle of the linked list.",
    "constraints": [
      "The number of nodes in the linked list is in the range [1, 100]."
    ],
    "examples": [
      {
        "input": "[1 -> 2 -> 3 -> 4 -> 5]",
        "output": "3",
        "explanation": "The linked list is 1 -> 2 -> 3 -> 4 -> 5. The middle node is 3."
      },
      {
        "input": "[1 -> 2 -> 3 -> 4 -> 5 -> 6]",
        "output": "4",
        "explanation": "The linked list is 1 -> 2 -> 3 -> 4 -> 5 -> 6. The two middle nodes are 3 and 4, and we return the second one, which is 4."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to traverse the list at different speeds.",
      "When the fast pointer reaches the end, the slow pointer will be at the middle."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Maximum Number of Tasks You Can Assign",
    "description": "You are given a list of tasks, each associated with a required skill level and a time to complete. Your goal is to determine the maximum number of tasks that can be assigned to a team member, given their current skill level and a working time limit. A task can only be assigned if the team member's skill level meets or exceeds the required skill level for the task, and the total time taken for the assigned tasks does not exceed the working time limit. Implement a function to calculate the maximum number of tasks that can be completed.",
    "topic": "Greedy",
    "subtopic": "Task Scheduling",
    "tags": [
      "Greedy",
      "Scheduling",
      "Dynamic Programming"
    ],
    "input_format": "An integer array tasks where each element is a tuple (skill, time), followed by two integers, skill_level and time_limit.",
    "output_format": "An integer representing the maximum number of tasks that can be completed.",
    "constraints": [
      "1 <= tasks.length <= 1000",
      "1 <= skill, time <= 10^4",
      "0 <= skill_level <= 10^4",
      "0 <= time_limit <= 10^6"
    ],
    "examples": [
      {
        "input": "tasks = [(3, 1), (2, 2), (5, 3)], skill_level = 5, time_limit = 5",
        "output": "3",
        "explanation": "All tasks can be assigned because the team member has sufficient skill and time."
      },
      {
        "input": "tasks = [(1, 2), (2, 3), (3, 4)], skill_level = 2, time_limit = 4",
        "output": "2",
        "explanation": "The team member can complete tasks with skill levels 1 and 2 within the time limit."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider sorting the tasks based on time required.",
      "Use a greedy approach to find the maximum feasible assignments."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Minimum Operations to Make Array Equal II",
    "description": "You are given an array of integers of length n, which represents a list of integers from 1 to n. Your task is to find the minimum number of operations required to make all the elements equal. In one operation, you can increment or decrement any element by 1. Return the minimum number of such operations needed.",
    "topic": "Array",
    "subtopic": "Manipulation",
    "tags": [
      "Array",
      "Manipulation",
      "Math"
    ],
    "input_format": "An array of integers nums where 1 <= nums.length <= 10^5 and 1 <= nums[i] <= 10^5.",
    "output_format": "An integer representing the minimum number of operations required to make all elements in the array equal.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "2",
        "explanation": "You can increment 1 to 2 and 2 to 3, requiring 2 operations."
      },
      {
        "input": "nums = [2, 3, 2, 3, 4]",
        "output": "3",
        "explanation": "You can decrement 4 to 3, making each number equal to 3, requiring 3 operations."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the number of operations needed to move all numbers to the median.",
      "Think about how to calculate the total cost for moving all elements."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Minimum Number of Operations to Make Arrays Similar",
    "description": "You are given two integer arrays, A and B, of the same length. An operation consists of selecting any element in A and increasing it by 1 or selecting any element in B and decreasing it by 1. Your task is to determine the minimum number of operations required to make the two arrays similar, meaning that for each index i, A[i] and B[i] will be equal after a series of operations. If it is impossible to make the arrays similar, return -1.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Operations"
    ],
    "input_format": "Two arrays of integers A and B, both of length n.",
    "output_format": "An integer representing the minimum number of operations required, or -1 if it is impossible.",
    "constraints": [
      "1 <= n <= 10^5",
      "-10^9 <= A[i], B[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "A = [1, 2, 3], B = [2, 3, 4]",
        "output": "3",
        "explanation": "We can perform operations as follows: increase A[0] to 2, A[1] to 3, and A[2] to 4. This requires 3 operations."
      },
      {
        "input": "A = [1, 1, 1], B = [3, 3, 3]",
        "output": "6",
        "explanation": "We need to increase A[0], A[1], and A[2] to 3, which requires a total of 6 operations."
      },
      {
        "input": "A = [1, 2, 3], B = [3, 2, 1]",
        "output": "-1",
        "explanation": "It is impossible to make the arrays similar since the total sum of A and B is different."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the total increments and decrements required.",
      "Check if the total sum of both arrays is equal."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Count Good Triplets in an Array",
    "description": "You are given an array of integers nums and three integers a, b, and c. A good triplet is defined as a triplet (i, j, k) such that 0 <= i < j < k < nums.length and the following conditions are satisfied: abs(nums[i] - nums[j]) <= a, abs(nums[j] - nums[k]) <= b, and abs(nums[i] - nums[k]) <= c. Your task is to count the number of good triplets in the array.",
    "topic": "Array",
    "subtopic": "Combinatorial Counting",
    "tags": [
      "Array",
      "Triplets",
      "Combinatorics",
      "Counting"
    ],
    "input_format": "An array of integers nums, and three integers a, b, and c.",
    "output_format": "An integer representing the number of good triplets.",
    "constraints": [
      "1 <= nums.length <= 1000",
      "0 <= a, b, c <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4], a = 1, b = 2, c = 1",
        "output": "4",
        "explanation": "The good triplets are (0, 1, 2), (0, 1, 3), (1, 2, 3), and (0, 2, 3)."
      },
      {
        "input": "nums = [5, 1, 3, 4, 2], a = 2, b = 1, c = 1",
        "output": "3",
        "explanation": "The good triplets are (1, 2, 3), (0, 1, 2), and (1, 0, 3)."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Think about how to iterate through triplets efficiently.",
      "Use nested loops but optimize to avoid counting duplicates."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Number of Ways to Separate Numbers",
    "description": "You are given a string of digits. Your task is to determine the number of different ways the string can be separated into substrings such that each substring is a valid integer. A valid integer must not have leading zeros unless it is '0'. An empty substring is not allowed.",
    "topic": "String",
    "subtopic": "Substring Generation",
    "tags": [
      "String",
      "Dynamic Programming",
      "Backtracking"
    ],
    "input_format": "A string s consisting of digits (0-9).",
    "output_format": "An integer representing the number of ways to separate the string into valid integer substrings.",
    "constraints": [
      "1 <= s.length <= 20",
      "s[i] is a digit (0-9)"
    ],
    "examples": [
      {
        "input": "123",
        "output": "3",
        "explanation": "The valid separations are '1', '2', '3'; '1', '23'; and '12', '3'."
      },
      {
        "input": "105",
        "output": "2",
        "explanation": "The valid separations are '1', '05' (not valid due to leading zero) and '10', '5'. So only '10', '5' counts."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using recursion with memoization.",
      "Keep track of valid substrings and their count."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "The Winner University",
    "description": "You are tasked with determining which university has won the most competitions over a series of years. Given a list of universities and a corresponding list of competition results, return the name of the university that has won the most times. If there's a tie, return the university that appears first in the input list.",
    "topic": "String",
    "subtopic": "Counting and Comparison",
    "tags": [
      "String",
      "Counting",
      "Comparison"
    ],
    "input_format": "A list of strings representing the names of universities and a corresponding list of integers representing the results (1 for a win, 0 for a loss).",
    "output_format": "A string representing the name of the university with the most wins.",
    "constraints": [
      "1 <= universities.length <= 100",
      "university name consists of lowercase and uppercase letters and has at most 50 characters.",
      "results.length == universities.length",
      "results[i] is either 0 or 1."
    ],
    "examples": [
      {
        "input": {
          "universities": [
            "A",
            "B",
            "C",
            "A",
            "B"
          ],
          "results": [
            1,
            0,
            1,
            1,
            0
          ]
        },
        "output": "A",
        "explanation": "University A has won 3 times (indices 0, 3) while B has won 2 times. Therefore, A is the winner."
      },
      {
        "input": {
          "universities": [
            "X",
            "Y",
            "Z"
          ],
          "results": [
            1,
            1,
            1
          ]
        },
        "output": "X",
        "explanation": "All universities won, but since X comes first in the list, it is returned."
      },
      {
        "input": {
          "universities": [
            "Alpha",
            "Beta",
            "Gamma",
            "Delta"
          ],
          "results": [
            0,
            1,
            1,
            1
          ]
        },
        "output": "Gamma",
        "explanation": "Gamma and Delta won 1 time each, but Gamma comes first in the list."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a dictionary to count the wins for each university.",
      "Keep track of the first occurrence when a university wins to handle ties."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest substring that is a palindrome. A palindrome is a string that reads the same backward as forward. If there are multiple longest palindromic substrings, return any one of them.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A string s consisting of lowercase and uppercase letters and digits.",
    "output_format": "A string representing the longest palindromic substring.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consist of only digits and English letters."
    ],
    "examples": [
      {
        "input": "babad",
        "output": "bab",
        "explanation": "Both 'bab' and 'aba' are valid longest palindromic substrings."
      },
      {
        "input": "cbbd",
        "output": "bb",
        "explanation": "'bb' is the longest palindromic substring in this case."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding around potential centers.",
      "Use dynamic programming to store results of subproblems."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Generate Parentheses",
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, if n = 3, a solution set is: \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\".",
    "topic": "Backtracking",
    "subtopic": "Recursion",
    "tags": [
      "Backtracking",
      "Recursion",
      "String"
    ],
    "input_format": "An integer n representing the number of pairs of parentheses.",
    "output_format": "A list of strings representing all combinations of well-formed parentheses.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]",
        "explanation": "With 3 pairs of parentheses, the combinations that are well-formed are listed."
      },
      {
        "input": "n = 1",
        "output": "[\"()\"]",
        "explanation": "With 1 pair of parentheses, the only valid combination is \"()\"."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a backtracking approach to explore all combinations.",
      "Keep track of the number of open and close parentheses used."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Kth Largest Element in an Array",
    "description": "Given an array of integers, find the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. You must solve it in linear time complexity.",
    "topic": "Array",
    "subtopic": "Sorting & Searching",
    "tags": [
      "Array",
      "Sorting",
      "Searching",
      "Heap"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An integer representing the kth largest element in the array.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^5 <= nums[i] <= 10^5",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 1, 5, 6, 4], k = 2",
        "output": "5",
        "explanation": "The sorted order of the array is [1, 2, 3, 4, 5, 6]. The 2nd largest element is 5."
      },
      {
        "input": "nums = [3, 2, 3, 1, 2, 4, 5, 5, 6], k = 4",
        "output": "4",
        "explanation": "The sorted order of the array is [1, 2, 2, 3, 3, 4, 5, 5, 6]. The 4th largest element is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a max heap to find the kth largest element.",
      "You can also sort the array and retrieve the kth element."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order. You start from the top-left corner of the matrix, traverse to the right until the end, then down the last column, then to the left on the last row, and finally up the first column. Repeat the process until all elements have been traversed.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral"
    ],
    "input_format": "A 2D array of integers represented as 'matrix'.",
    "output_format": "A 1D array of integers representing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "1 <= m * n <= 10^4",
      "-10^5 <= matrix[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The matrix is traversed as follows: [1, 2, 3] (top row), [6, 9] (right column), [8, 7] (bottom row), [4, 5] (left column)."
      },
      {
        "input": "matrix = [[1,2],[3,4]]",
        "output": "[1, 2, 4, 3]",
        "explanation": "The matrix is traversed as follows: [1, 2] (top row), [4] (right column), [3] (bottom row)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about the boundaries of the matrix that need to be managed.",
      "Use a loop to control the spiral traversal direction."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "You are given an integer array 'nums' sorted in ascending order, but then rotated at an unknown pivot index. You are also given an integer 'target'. Return the index of 'target' in 'nums' if it is in the array, otherwise return -1. You must write a solution with a runtime complexity of O(log n).",
    "topic": "Binary Search",
    "subtopic": "Searching",
    "tags": [
      "Binary Search",
      "Array",
      "Searching"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An integer representing the index of target in nums, or -1 if target is not found.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "nums is guaranteed to be rotated at some pivot.",
      "You may assume all elements in the array are unique."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "The target 0 is located at index 4."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "The target 3 is not in the array, hence the output is -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how the array is rotated.",
      "Use binary search logic with adjustments for the pivot."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the strings into anagrams. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "topic": "String",
    "subtopic": "Hashing",
    "tags": [
      "String",
      "Anagrams",
      "HashMap"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A list of lists containing grouped anagrams.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "explanation": "Here, 'eat', 'tea', and 'ate' are anagrams. 'tan' and 'nat' are also anagrams of each other."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "Only one string in the input, so it forms a group by itself."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "Only one string in the input, so it forms a group by itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hashmap to group words by their sorted character sequence.",
      "You might want to consider the frequency of characters as a way to identify anagrams."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Depth-First Search",
    "subtopic": "Graph Traversal",
    "tags": [
      "DFS",
      "Graph",
      "Matrix"
    ],
    "input_format": "A 2D grid represented by a list of lists of characters, where each character is either '1' or '0'.",
    "output_format": "An integer representing the number of islands in the provided grid.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "grid = [['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1']]",
        "output": "3",
        "explanation": "There are three islands in the given grid."
      },
      {
        "input": "grid = [['1', '1', '1'], ['0', '0', '0'], ['1', '1', '1']]",
        "output": "1",
        "explanation": "There is one single island that occupies the entire row."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using Depth-First Search (DFS) to explore and mark visited lands.",
      "Consider using a union-find structure for more advanced implementations."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Sort Colors",
    "description": "Given an array containing n objects colored red, white, or blue, this problem aims to sort them so that objects of the same color are adjacent, with the colors in the order red, white, and blue. Assume the colors are represented by integers 0, 1, and 2, where 0 represents red, 1 represents white, and 2 represents blue. You must solve this problem in a single pass using constant space.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Sorting",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums where each integer is either 0, 1, or 2.",
    "output_format": "The input array after sorting it in place.",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 300",
      "nums[i] is either 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "nums = [2, 0, 2, 1, 1, 0]",
        "output": "[0, 0, 1, 1, 2, 2]",
        "explanation": "Sorting the colors yields the array [0, 0, 1, 1, 2, 2]."
      },
      {
        "input": "nums = [2, 0, 1]",
        "output": "[0, 1, 2]",
        "explanation": "Sorting the colors yields the array [0, 1, 2]."
      },
      {
        "input": "nums = [0]",
        "output": "[0]",
        "explanation": "The input contains only one color, so it is already sorted."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using the Dutch National Flag problem approach.",
      "You can use two pointers to keep track of the regions for red and blue."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Longest Consecutive Sequence",
    "description": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence. The algorithm should run in O(n) time complexity. It is assumed that the input does not contain duplicates.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Consecutive",
      "Sequence"
    ],
    "input_format": "An unsorted array of integers nums.",
    "output_format": "An integer representing the length of the longest consecutive elements sequence.",
    "constraints": [
      "0 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [100, 4, 200, 1, 3, 2]",
        "output": "4",
        "explanation": "The longest consecutive sequence is [1, 2, 3, 4], which has a length of 4."
      },
      {
        "input": "nums = [0, -1]",
        "output": "2",
        "explanation": "The longest consecutive sequence is [-1, 0], which has a length of 2."
      },
      {
        "input": "nums = []",
        "output": "0",
        "explanation": "There are no elements in the array, so the length of the longest consecutive sequence is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a set to store the numbers for O(1) lookups.",
      "Iterate through the array and count the length of each sequence."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Valid Sudoku",
    "description": "Determine if a 9x9 Sudoku board is valid according to the rules of Sudoku. A Sudoku board is valid if the following conditions are met: 1. Each row must contain the digits 1-9 without repetition. 2. Each column must contain the digits 1-9 without repetition. 3. Each of the nine 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. The board can contain the character '.' which represents an empty cell.",
    "topic": "Array",
    "subtopic": "2D Array",
    "tags": [
      "Array",
      "Backtracking",
      "Matrix"
    ],
    "input_format": "A 2D array of characters representing the Sudoku board.",
    "output_format": "A boolean value indicating whether the Sudoku board is valid.",
    "constraints": [
      "The board is a 9x9 2D array.",
      "Each cell can be a digit from '1' to '9' or '.' for empty cells."
    ],
    "examples": [
      {
        "input": [
          [
            "5",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            ".",
            "2",
            "8",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": "true",
        "explanation": "The given board is valid according to Sudoku rules."
      },
      {
        "input": [
          [
            "8",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            ".",
            "2",
            "8",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": "false",
        "explanation": "The number '8' appears twice in the first column."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use sets to track the numbers seen in rows, columns, and boxes.",
      "You can iterate through the board and validate each row, column, and box."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Move Zeroes",
    "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "In-place",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "The modified array nums with all 0's moved to the end.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [0, 1, 0, 3, 12]",
        "output": "[1, 3, 12, 0, 0]",
        "explanation": "After moving all 0's to the end, the resulting array is [1, 3, 12, 0, 0]."
      },
      {
        "input": "nums = [0, 0, 1]",
        "output": "[1, 0, 0]",
        "explanation": "After moving all 0's to the end, the resulting array is [1, 0, 0]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to maintain the position of non-zero elements."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Coin Change",
    "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. You need to return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.",
    "topic": "Dynamic Programming",
    "subtopic": "Min Coin Change",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Coin Change"
    ],
    "input_format": "Two inputs: an integer array coins, and an integer amount.",
    "output_format": "An integer representing the fewest number of coins needed to make up the amount, or -1 if it's not possible.",
    "constraints": [
      "1 <= coins.length <= 12",
      "1 <= coins[i] <= 2^31 - 1",
      "0 <= amount <= 10^4"
    ],
    "examples": [
      {
        "input": {
          "coins": [
            1,
            2,
            5
          ],
          "amount": 11
        },
        "output": 3,
        "explanation": "The amount 11 can be made with three coins: 5 + 5 + 1."
      },
      {
        "input": {
          "coins": [
            2
          ],
          "amount": 3
        },
        "output": -1,
        "explanation": "The amount 3 cannot be formed with just coin 2."
      },
      {
        "input": {
          "coins": [
            1
          ],
          "amount": 0
        },
        "output": 0,
        "explanation": "No coins are needed to make amount 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dynamic programming array to store the minimum number of coins needed for each amount.",
      "Initialize the array with a value greater than any possible answer."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Binary Tree Zigzag Level Order Traversal",
    "description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Breadth-First Search",
      "Zigzag"
    ],
    "input_format": "The input consists of a tree node defined by the root of a binary tree.",
    "output_format": "A list of lists, where each list represents the values of nodes at that level in zigzag order.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[20,9],[15,7]]",
        "explanation": "The binary tree has levels as follows: Level 0: [3], Level 1: [9, 20] (zigzag: [20, 9]), Level 2: [15, 7]."
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": "The binary tree has only one node; hence the output is [[1]]."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree results in an empty output."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to facilitate level order traversal.",
      "Toggle direction for each level while traversing.",
      "Use a boolean flag to determine the current traversal order."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Combination Sum",
    "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may be used an unlimited number of times. The combinations should be returned in any order. Note that the same number may appear multiple times in different combinations.",
    "topic": "Backtracking",
    "subtopic": "Combination Generation",
    "tags": [
      "Backtracking",
      "Combination",
      "Recursion"
    ],
    "input_format": "A list of distinct integers candidates and an integer target.",
    "output_format": "A list of lists of integers representing all the unique combinations that sum to target.",
    "constraints": [
      "1 <= candidates.length <= 30",
      "1 <= candidates[i] <= 200",
      "All elements of candidates are distinct.",
      "1 <= target <= 500"
    ],
    "examples": [
      {
        "input": "candidates = [2, 3, 6, 7], target = 7",
        "output": "[[2, 2, 3], [7]]",
        "explanation": "The combinations are [2, 2, 3] and [7]. Both sum to 7."
      },
      {
        "input": "candidates = [2, 3, 5], target = 8",
        "output": "[[2, 2, 2, 2], [2, 3, 3], [3, 5]]",
        "explanation": "The combinations are [2, 2, 2, 2], [2, 3, 3], and [3, 5]. All sum to 8."
      },
      {
        "input": "candidates = [1], target = 1",
        "output": "[[1]]",
        "explanation": "The only combination is [1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to build combinations recursively.",
      "Use backtracking to explore all possible combinations.",
      "Track current combination and its current sum."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Degree of an Array",
    "description": "Given an array of integers, find the degree of the array, which is defined as the maximum frequency of any element in the array. Additionally, return the minimum length of a subarray that has the same degree as the entire array.",
    "topic": "Array",
    "subtopic": "Frequency Count",
    "tags": [
      "Array",
      "Frequency",
      "HashMap"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the minimum length of a subarray that has the same degree as the entire array.",
    "constraints": [
      "1 <= nums.length <= 50000",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2, 3, 1]",
        "output": "2",
        "explanation": "The degree is 2 (for number 2), and the minimum length of the subarray is 2 (subarray: [2, 2])."
      },
      {
        "input": "nums = [1, 2, 2, 3, 1, 4, 2]",
        "output": "6",
        "explanation": "The degree is 3 (for number 2), and the minimum length of the subarray is 6 (subarray: [2, 2, 3, 1, 4, 2])."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a HashMap to count the frequency of each element.",
      "Keep track of the first and last position of each element."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Top K Frequent Elements",
    "description": "Given a non-empty integer array, return the k most frequent elements. You may return the answer in any order.",
    "topic": "Hash Table",
    "subtopic": "Frequency Count",
    "tags": [
      "Hash Table",
      "Sorting",
      "Heap"
    ],
    "input_format": "An integer array nums and an integer k, where 1 <= k <= the number of unique elements in the array.",
    "output_format": "A list of the k most frequent elements.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= k <= the number of unique elements in the array"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 1, 2, 2, 3], k = 2",
        "output": "[1, 2]",
        "explanation": "1 appears 3 times and 2 appears 2 times. The top 2 frequent elements are 1 and 2."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "There is only one element, which is 1, so the answer is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map to count the frequency of each element.",
      "You can use a heap to efficiently retrieve the top k elements."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an array of integers, nums, return all the unique triplets [nums[i], nums[j], nums[k]] such that i, j, and k are different indices, and nums[i] + nums[j] + nums[k] == 0. Note that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting",
      "Hash Map"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A list of unique triplets that sum up to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that sum up to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no elements, thus no triplets can be formed."
      },
      {
        "input": "nums = [0, 0, 0]",
        "output": "[[0, 0, 0]]",
        "explanation": "The only triplet that sums up to zero is [0, 0, 0]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the array first.",
      "Use a two-pointer technique to find pairs that sum to a target value."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Rotate Array",
    "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative. You must do this in-place without using extra space for another array.",
    "topic": "Array",
    "subtopic": "In-place Array Manipulation",
    "tags": [
      "Array",
      "In-place",
      "Rotation"
    ],
    "input_format": "An array of integers nums followed by an integer k.",
    "output_format": "The rotated array in the same input array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= k <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5, 6, 7], k = 3",
        "output": "[5, 6, 7, 1, 2, 3, 4]",
        "explanation": "After rotating the array 3 steps to the right, the last three elements [5, 6, 7] are moved to the front."
      },
      {
        "input": "nums = [-1, -100, 3, 99], k = 2",
        "output": "[3, 99, -1, -100]",
        "explanation": "After rotating the array 2 steps to the right, [3, 99] appear at the front."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try reversing parts of the array.",
      "Modulus operation can help with large k."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "All Nodes Distance K in Binary Tree",
    "description": "Given a binary tree, you need to find all the nodes that are at distance K from a given target node. The distance between two nodes is defined as the number of edges in the shortest path connecting them. You are given the root of the binary tree and the value of the target node. Return the values of all nodes that are K distance away from the target node, in any order.",
    "topic": "Trees",
    "subtopic": "Binary Tree",
    "tags": [
      "Binary Tree",
      "DFS",
      "BFS"
    ],
    "input_format": "The input consists of a binary tree and an integer target, where target is the value of the node in the binary tree.",
    "output_format": "A list of integers representing the values of the nodes that are K distance away from the target node.",
    "constraints": [
      "The number of nodes in the tree is between 1 and 100.",
      "Each node's value is unique.",
      "0 <= K <= 100."
    ],
    "examples": [
      {
        "input": "root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2",
        "output": "[7, 4, 1]",
        "explanation": "The nodes at distance 2 from node 5 are 7 (distance 2 from 5) and 4 (distance 2 from 5), as well as node 1 (distance 2 from 5)."
      },
      {
        "input": "root = [1], target = 1, K = 0",
        "output": "[1]",
        "explanation": "The only node is node 1 itself and the distance is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a DFS traversal to find the parent pointers.",
      "After finding the target node, perform a BFS to locate all nodes at distance K."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Pow(x, n)",
    "description": "Implement a function to calculate x raised to the power n (x^n). The function should handle both integer and floating-point numbers for x, and n can be any integer, positive or negative. You must not use the built-in power function or the operator **.",
    "topic": "Math",
    "subtopic": "Exponentiation",
    "tags": [
      "Math",
      "Exponentiation",
      "Recursion"
    ],
    "input_format": "Two values x (float) and n (int), where x is the base and n is the exponent.",
    "output_format": "A float representing the value of x raised to the power n.",
    "constraints": [
      "-10^4 <= x <= 10^4",
      "-10^4 <= n <= 10^4"
    ],
    "examples": [
      {
        "input": "x = 2.0, n = 10",
        "output": "1024.0",
        "explanation": "2^10 = 1024."
      },
      {
        "input": "x = 2.1, n = 3",
        "output": "9.261",
        "explanation": "2.1^3 = 9.261."
      },
      {
        "input": "x = 2, n = -2",
        "output": "0.25",
        "explanation": "2^-2 = 1/(2^2) = 1/4 = 0.25."
      },
      {
        "input": "x = 0, n = 5",
        "output": "0.0",
        "explanation": "0^5 = 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to handle negative exponents.",
      "Use recursion to break the problem into smaller parts."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays, nums1 and nums2, of sizes m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). If the total number of elements is even, the median is the average of the two middle elements. If the total number of elements is odd, the median is the middle element.",
    "topic": "Array",
    "subtopic": "Median",
    "tags": [
      "Array",
      "Binary Search",
      "Median"
    ],
    "input_format": "Two sorted arrays of integers nums1 and nums2.",
    "output_format": "A double representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= m <= 1000",
      "0 <= n <= 1000",
      "1 <= m + n <= 2000",
      "-10^6 <= nums1[i], nums2[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.0",
        "explanation": "The merged array is [1, 2, 3]. The median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.5",
        "explanation": "The merged array is [1, 2, 3, 4]. The median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using binary search to find the median efficiently.",
      "The median will depend on the partitioning of the two arrays."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "House Robber",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected, and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array 'nums' representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "topic": "Dynamic Programming",
    "subtopic": "Memoization",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Greedy"
    ],
    "input_format": "An array of integers nums, where nums[i] represents the amount of money at the ith house.",
    "output_format": "An integer representing the maximum amount of money that can be robbed.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 400"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "4",
        "explanation": "Robbing houses 1 and 3 yields 1 + 3 = 4."
      },
      {
        "input": "nums = [2, 7, 9, 3, 1]",
        "output": "12",
        "explanation": "Robbing houses 2, 4, and 5 yields 2 + 9 + 1 = 12."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about using dynamic programming to store the maximum profit at each house.",
      "You can either rob this house and the one before the previous house, or skip this house."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Add Binary",
    "description": "Given two binary strings a and b, return their sum as a binary string. You must not use any built-in library for converting the binary string into an integer, and you must not use any built-in library for converting the integer back to a binary string.",
    "topic": "Mathematics",
    "subtopic": "Binary",
    "tags": [
      "Binary",
      "Math",
      "String"
    ],
    "input_format": "Two binary strings a and b.",
    "output_format": "A binary string representing the sum of a and b.",
    "constraints": [
      "1 <= a.length, b.length <= 10^4",
      "a and b consist only of '0' and '1' and are both non-empty."
    ],
    "examples": [
      {
        "input": "a = '1101', b = '1011'",
        "output": "'11000'",
        "explanation": "The binary addition of '1101' (13 in decimal) and '1011' (11 in decimal) is '11000' (24 in decimal)."
      },
      {
        "input": "a = '0', b = '0'",
        "output": "'0'",
        "explanation": "The binary addition of '0' and '0' is '0'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Start from the least significant bit and move to the most significant bit.",
      "Keep track of carry while adding the bits."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Search a 2D Matrix",
    "description": "Write an efficient algorithm to search for a target value in a 2D matrix. This matrix has the following properties: It contains integers only, each row is sorted in ascending order from left to right, and the first integer of each row is greater than the last integer of the previous row.",
    "topic": "Binary Search",
    "subtopic": "2D Search",
    "tags": [
      "Matrix",
      "Binary Search",
      "Two Dimensional"
    ],
    "input_format": "A 2D array of integers 'matrix' and an integer 'target'.",
    "output_format": "A boolean value indicating whether 'target' exists in 'matrix'.",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 100",
      "-10^4 <= matrix[i][j] <= 10^4",
      "All integers in 'matrix' are unique.",
      "Target is an integer."
    ],
    "examples": [
      {
        "input": {
          "matrix": [
            [
              1,
              3,
              5
            ],
            [
              7,
              10,
              11
            ],
            [
              12,
              13,
              15
            ]
          ],
          "target": 10
        },
        "output": true,
        "explanation": "10 is present in the matrix."
      },
      {
        "input": {
          "matrix": [
            [
              1,
              3,
              5
            ],
            [
              7,
              10,
              11
            ],
            [
              12,
              13,
              15
            ]
          ],
          "target": 8
        },
        "output": false,
        "explanation": "8 is not present in the matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider treating the 2D matrix like a 1D array.",
      "Use binary search to enhance the search efficiency."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of k linked-lists, each list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
    "topic": "Linked List",
    "subtopic": "Merging Lists",
    "tags": [
      "Linked List",
      "Merge",
      "Sort"
    ],
    "input_format": "An array of k linked-lists, where each linked list node contains an integer value.",
    "output_format": "A merged linked-list that is sorted in ascending order.",
    "constraints": [
      "k == lists.length",
      "0 <= k <= 10^4",
      "0 <= lists[i].length <= 500",
      "-10^4 <= lists[i][j] <= 10^4"
    ],
    "examples": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]",
        "explanation": "The merged linked list is 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6."
      },
      {
        "input": "lists = []",
        "output": "[]",
        "explanation": "There are no lists to merge."
      },
      {
        "input": "lists = [[-1, 5, 11],[2, 6],[3, 4]]",
        "output": "[-1, 2, 3, 4, 5, 6, 11]",
        "explanation": "The merged linked list is -1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 11."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a priority queue to efficiently get the smallest element from the heads of the lists.",
      "You can represent each list node as a tuple of (value, list_index, node)."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".",
    "topic": "String",
    "subtopic": "Prefix",
    "tags": [
      "String",
      "Prefix",
      "Array"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A string representing the longest common prefix.",
    "constraints": [
      "0 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "strs[i] consists of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The longest common prefix is \"fl\"."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among the strings."
      },
      {
        "input": "strs = [\"apple\", \"app\", \"apricot\"]",
        "output": "\"ap\"",
        "explanation": "The longest common prefix is \"ap\"."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Compare characters of each string and find the common ones.",
      "Use vertical scanning to efficiently find the common prefix."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Copy List with Random Pointer",
    "description": "Given a linked list with each node having a random pointer which may point to any node in the list or null, you need to create a deep copy of this list. Each node in the original list has a `next` pointer which points to the next node in the list and a `random` pointer which may point to any node in the list or may be null. Your task is to return the head of the new copied list.",
    "topic": "Linked List",
    "subtopic": "Deep Copy",
    "tags": [
      "Linked List",
      "Copy",
      "Random Pointer"
    ],
    "input_format": "The head of the linked list.",
    "output_format": "The head of the new copied linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 100].",
      "The original linked list may contain cycles.",
      "The random pointer for a node in the linked list is either null or points to a node in the same linked list."
    ],
    "examples": [
      {
        "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "output": "The output should represent the deep copied list structure.",
        "explanation": "The new list should consist of nodes that replicate the original list's structure with next and random pointers."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a mapping approach to connect original and copied nodes.",
      "Consider using a dictionary to keep track of the nodes."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Word Search",
    "description": "Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where 'adjacent' cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "topic": "Backtracking",
    "subtopic": "Matrix Search",
    "tags": [
      "Backtracking",
      "Matrix",
      "DFS"
    ],
    "input_format": "A 2D board of characters and a string word.",
    "output_format": "A boolean value indicating whether the word exists in the grid.",
    "constraints": [
      "1 <= board.length <= 200",
      "1 <= board[i].length <= 200",
      "board[i][j] is a lowercase English letter.",
      "1 <= word.length <= 100"
    ],
    "examples": [
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "ABCCED"
        },
        "output": "true",
        "explanation": "The word 'ABCCED' can be constructed from the grid by traversing through adjacent cells."
      },
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "SEE"
        },
        "output": "true",
        "explanation": "The word 'SEE' can be found in the grid by following adjacent cells."
      },
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "ABCB"
        },
        "output": "false",
        "explanation": "The word 'ABCB' is not present in the grid as it requires using the same letter cell more than once."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using depth-first search (DFS) to explore each potential path.",
      "Use a backtracking approach to mark cells as visited and unvisited."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Flatten Nested List Iterator",
    "description": "Design an iterator to flatten a nested list of integers. Each element in the nested list is either an integer or a list, which may contain more lists. Implement the NestedIterator class that provides a method to return the next integer in the nested list and a method to check if there are more integers to iterate through.",
    "topic": "Design",
    "subtopic": "Iterator",
    "tags": [
      "Design",
      "Iterator",
      "Nested List"
    ],
    "input_format": "A nested list where each element is either an integer or another nested list.",
    "output_format": "An integer if there are more integers to return; otherwise, return None.",
    "constraints": [
      "The total number of integers in the nested list will not exceed 10^4.",
      "The integers will be in the range [-10^5, 10^5]."
    ],
    "examples": [
      {
        "input": "[1, [2, [3, 4], 5], 6]",
        "output": "1",
        "explanation": "The first call to next() will return 1."
      },
      {
        "input": "[[1, 1], 2, [1, 1]]",
        "output": "1",
        "explanation": "The first next() will return 1 from the first nested list."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to help keep track of the current position in the nested list.",
      "Consider how you handle elements that are themselves lists."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Reverse Nodes in k-Group",
    "description": "Given a linked list, you need to reverse the nodes of the list k at a time and return the modified list. If the number of nodes is not a multiple of k then left nodes in the end should remain as they are. You may not alter the values in the nodes, only nodes themselves may be changed.",
    "topic": "Linked List",
    "subtopic": "Reversing Nodes",
    "tags": [
      "Linked List",
      "Reversal",
      "Two Pointers"
    ],
    "input_format": "The head of the linked list and an integer k.",
    "output_format": "The head of the modified linked list after reversing the nodes in k-sized groups.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 10^4].",
      "1 <= k <= 10^4."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], k = 3",
        "output": "[3, 2, 1, 4, 5]",
        "explanation": "The first k=3 nodes are reversed; the remaining nodes stay the same."
      },
      {
        "input": "head = [1, 2, 3, 4, 5], k = 2",
        "output": "[2, 1, 4, 3, 5]",
        "explanation": "The linked list is reversed in pairs."
      },
      {
        "input": "head = [1], k = 1",
        "output": "[1]",
        "explanation": "Only one node, no reversal needed."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Think about how to iterate the linked list in groups of k.",
      "Use a temporary connected node to help with the reversal process.",
      "Consider the cases where the remaining nodes are fewer than k."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Daily Temperatures",
    "description": "Given an array of integers temperatures representing daily temperatures, return an array such that output[i] is the number of days you have to wait until a warmer temperature. If there is no future day for which this is possible, keep output[i] == 0 instead.",
    "topic": "Array",
    "subtopic": "Stack",
    "tags": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "input_format": "An array of integers temperatures where 1 <= temperatures.length <= 30000 and 30 <= temperatures[i] <= 100.",
    "output_format": "An array of integers representing the number of days until a warmer temperature.",
    "constraints": [
      "1 <= temperatures.length <= 30000",
      "30 <= temperatures[i] <= 100"
    ],
    "examples": [
      {
        "input": "temperatures = [73, 74, 75, 71, 69, 72, 76, 73]",
        "output": "[1, 1, 4, 2, 1, 1, 0, 0]",
        "explanation": "For each day, the next warmer day is as follows:\nDay 0: Wait 1 day (to 74)\nDay 1: Wait 1 day (to 75)\nDay 2: Wait 4 days (to 76)\nDay 3: Wait 2 days (to 72)\nDay 4: Wait 1 day (to 72)\nDay 5: Wait 1 day (to 76)\nDay 6: No warmer day\nDay 7: No warmer day"
      },
      {
        "input": "temperatures = [30, 40, 50, 60]",
        "output": "[1, 1, 1, 0]",
        "explanation": "The next warmer temperatures are each one day later."
      },
      {
        "input": "temperatures = [100, 100, 100]",
        "output": "[0, 0, 0]",
        "explanation": "There are no warmer temperatures in the future."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to keep track of indices.",
      "Traverse the list from the end to the beginning.",
      "For each temperature, check if it is warmer than the last processed temperature."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "LFU Cache",
    "description": "Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put. The cache should be initialized with a positive capacity. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. An item is invalidated when it has the lowest frequency of use. If there is a tie in frequency, the least recently used item should be removed. The functions should be efficient with O(1) average time complexity.",
    "topic": "Design",
    "subtopic": "Cache",
    "tags": [
      "Design",
      "Cache",
      "Data Structure"
    ],
    "input_format": "The LFU Cache is initialized with a positive capacity. The get(key) and put(key, value) methods are to be implemented.",
    "output_format": "Return the value of the key if the key exists, otherwise return -1 for the get method. For the put method, it should not return anything.",
    "constraints": [
      "The capacity of the cache is between 1 and 1000.",
      "The keys and values are positive integers.",
      "The maximum number of calls to get and put is 10^4."
    ],
    "examples": [
      {
        "input": "LFUCache lfu = new LFUCache(2); lfu.put(1, 1); lfu.put(2, 2); lfu.get(1); lfu.put(3, 3); lfu.get(2); lfu.get(3); lfu.put(4, 4); lfu.get(1); lfu.get(3); lfu.get(4);",
        "output": "1, -1, 3, 4",
        "explanation": "After put(1,1) and put(2,2), the cache is {1=1, 2=2}. When we get(1), it returns 1, making frequency of key 1 as 2. Then we put(3,3) which evicts key 2. The cache is now {1=1, 3=3}. The next gets return 1, -1 (for key 2 which was evicted), 3 and then the cache will have keys {1=1, 4=4} with the final get returning 1, 3, and 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a combination of a frequency map and a doubly linked list.",
      "Consider how to efficiently maintain the least frequently used order."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array nums, return the smallest missing positive integer. You must implement a solution that runs in O(n) time and uses O(1) extra space.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Sorting"
    ],
    "input_format": "An unsorted integer array nums.",
    "output_format": "An integer representing the first missing positive integer.",
    "constraints": [
      "0 <= nums.length <= 300",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "The smallest missing positive integer is 3."
      },
      {
        "input": "nums = [3, 4, -1, 1]",
        "output": "2",
        "explanation": "The smallest missing positive integer is 2."
      },
      {
        "input": "nums = [7, 8, 9, 11, 12]",
        "output": "1",
        "explanation": "The smallest missing positive integer is 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Try placing each number in its corresponding index.",
      "Consider using the negative marking technique."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Keys and Rooms",
    "description": "You are given a list of rooms, where each room contains a list of keys that can unlock other rooms. Initially, you start in room 0, which contains a list of keys to other rooms. Your goal is to determine if you can visit all the rooms. A room can be visited if you have access to it through a key from any previously visited room.",
    "topic": "Graph",
    "subtopic": "Traversal",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Traversal"
    ],
    "input_format": "A list of lists, rooms, where rooms[i] is a list of keys to other rooms.",
    "output_format": "Return true if all rooms can be visited, otherwise return false.",
    "constraints": [
      "1 <= rooms.length <= 100",
      "0 <= rooms[i].length <= 100",
      "The room keys are unique."
    ],
    "examples": [
      {
        "input": "rooms = [[1],[2],[3],[]]",
        "output": "true",
        "explanation": "You start in room 0 and can unlock room 1. From room 1, you can unlock room 2, and from room 2, you can unlock room 3. Hence, all rooms can be visited."
      },
      {
        "input": "rooms = [[1,3],[3,0,1],[2],[0]]",
        "output": "false",
        "explanation": "You can only visit rooms 0 and 1 initially, but cannot access rooms 2 and 3 from them."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to traverse the rooms using keys.",
      "Consider using Depth First Search (DFS) or Breadth First Search (BFS)."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Squares of a Sorted Array",
    "description": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.",
    "topic": "Array",
    "subtopic": "Sorting and Squaring",
    "tags": [
      "Array",
      "Sorting",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums sorted in non-decreasing order.",
    "output_format": "An array of integers representing the squares of each number, also sorted in non-decreasing order.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-4, -1, 0, 3, 10]",
        "output": "[0, 1, 9, 16, 100]",
        "explanation": "The squares of the elements are [16, 1, 0, 9, 100] which sorted in non-decreasing order is [0, 1, 9, 16, 100]."
      },
      {
        "input": "nums = [-7, -3, 2, 3, 11]",
        "output": "[4, 9, 9, 49, 121]",
        "explanation": "The squares of the elements are [49, 9, 4, 9, 121] which sorted in non-decreasing order is [4, 9, 9, 49, 121]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a two-pointer approach."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Binary Tree Right Side View",
    "description": "Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search"
    ],
    "input_format": "The input will be the root node of a binary tree.",
    "output_format": "A list of integers representing the values of the visible nodes from the right side.",
    "constraints": [
      "The number of nodes in the binary tree is in the range [0, 10^4].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, null, 5, null, 4]",
        "output": "[1, 3, 4]",
        "explanation": "The right side view is [1, 3, 4] since from the root you can see node 1, the right child node 3, and from node 3 you can see node 4."
      },
      {
        "input": "root = [1, null, 3]",
        "output": "[1, 3]",
        "explanation": "The right side view is [1, 3]."
      },
      {
        "input": "root = [1, 2, null, 3]",
        "output": "[1, 2, 3]",
        "explanation": "The right side view is [1, 2, 3]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to perform a level order traversal and keep track of the last node at each level.",
      "Using a queue can help in implementing a breadth-first search."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Course Schedule II",
    "description": "You are given the number of courses you have to take, labeled from 0 to numCourses - 1. You are also given a list of prerequisite pairs, where each pair [a, b] indicates that to take course a, you must first take course b. Your task is to return the ordering of courses you should take to finish all courses. If there are no valid orders, return an empty array. The answer may be returned in any valid order.",
    "topic": "Graph",
    "subtopic": "Topological Sort",
    "tags": [
      "Graph",
      "Topological Sorting",
      "BFS",
      "DFS"
    ],
    "input_format": "An integer numCourses and a list of prerequisite pairs.",
    "output_format": "An array of integers representing the order of courses to take.",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2"
    ],
    "examples": [
      {
        "input": "numCourses = 4, prerequisites = [[1,0],[2,1],[3,2]]",
        "output": "[0,1,2,3]",
        "explanation": "The order of courses to take can be [0, 1, 2, 3] as it respects all prerequisites."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
        "output": "[]",
        "explanation": "It is impossible to finish the courses because the courses depend on each other."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a topological sort approach.",
      "You can use either DFS or BFS to detect cycles."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Subarray"
    ],
    "input_format": "An integer array nums of length n.",
    "output_format": "An integer representing the maximum sum of the contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The contiguous subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The only element is 1, which is the maximum sum."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The contiguous subarray [5,4,-1,7,8] has the largest sum 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a variable to keep track of the current subarray sum.",
      "If the current subarray sum drops below zero, reset it to zero."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Max Consecutive Ones III",
    "description": "Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Binary"
    ],
    "input_format": "An array of integers nums (0s and 1s) and an integer k.",
    "output_format": "An integer representing the maximum number of consecutive 1's that can be achieved.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [1,1,0,0,1,1,1,0,1], k = 2",
        "output": "7",
        "explanation": "By flipping the two 0's at indices 2 and 3, we can achieve a maximum of 7 consecutive 1's."
      },
      {
        "input": "nums = [0,0,0,1,1], k = 1",
        "output": "2",
        "explanation": "By flipping one 0, we can achieve a maximum of 2 consecutive 1's."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try maintaining a sliding window to keep track of the number of 0's flipped.",
      "Expand the right end of the window and shrink the left when the number of flipped 0's exceeds k."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Boundary of Binary Tree",
    "description": "Given a binary tree, return the values of its boundary in anti-clockwise order starting from the root. The boundary consists of the left edge (top to bottom), the leaves (left to right), and the right edge (bottom to top). Note that you should not include the root in the left and right edges, or duplicate leaf nodes from the left or right edges.",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Binary Tree",
      "Traversal",
      "DFS"
    ],
    "input_format": "The root node of a binary tree.",
    "output_format": "A list of integers representing the boundary of the binary tree in anti-clockwise order.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 1000].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [1,2,3,4,null,5,6]",
        "output": "[1, 2, 4, 5, 6, 3]",
        "explanation": "The boundary of the tree is: the root (1), the left edge (2, 4), the leaves (5, 6), and the right edge (3)."
      },
      {
        "input": "root = [1]",
        "output": "[1]",
        "explanation": "There's only one node, which is the boundary itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how you can traverse the left edge and the right edge separately.",
      "You'll need a function to collect leaf nodes while traversing."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Interleaving String",
    "description": "Given three strings s1, s2, and s3, determine if s3 is formed by the interleaving of s1 and s2. A string 'abc' is said to be interleaved with 'def' to form 'adbcef' if 'a' comes from 's1', 'd' comes from 's2', 'b' comes from 's1', and so on. For each character in s3, you can only choose from the current character of s1 or s2, and characters must appear in the same order as they are in their original strings.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Interleaving"
    ],
    "input_format": "Three strings s1, s2, and s3.",
    "output_format": "A boolean indicating whether s3 can be formed by interleaving s1 and s2.",
    "constraints": [
      "0 <= s1.length, s2.length, s3.length <= 100",
      "s3.length == s1.length + s2.length"
    ],
    "examples": [
      {
        "input": "s1 = 'aab', s2 = 'axy', s3 = 'aayab'",
        "output": "true",
        "explanation": "The string s3 can be formed as follows: s1: 'aab' -> 'a', 'a', 'b' and s2: 'axy' -> 'x', 'y' -> resulting in 'a', 'a', 'y', 'b'."
      },
      {
        "input": "s1 = 'ab', s2 = 'cd', s3 = 'abcd'",
        "output": "false",
        "explanation": "The string s3 cannot be formed as 'c' and 'd' do not appear in the correct sequence."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use dynamic programming to keep track of interleaving states.",
      "Consider a 2D boolean table to store results for pairs of indices from s1 and s2."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Flatten Deeply Nested Array",
    "description": "Given an array that may contain nested arrays, return a flattened version of that array. The solution should be able to handle arbitrary levels of nesting. Ensure that the flattened array's elements maintain their original order.",
    "topic": "Array",
    "subtopic": "Recursion",
    "tags": [
      "Array",
      "Recursion",
      "Flattening"
    ],
    "input_format": "An array, which may contain integers and/or nested arrays.",
    "output_format": "A single-dimensional array containing all the integers from the nested input array.",
    "constraints": [
      "The length of the input array does not exceed 10^5.",
      "Each element in the array is an integer or another array."
    ],
    "examples": [
      {
        "input": "[1, 2, [3, [4, 5]], 6]",
        "output": "[1, 2, 3, 4, 5, 6]",
        "explanation": "The original array is deeply nested, but once flattened, we list out all the integers in order."
      },
      {
        "input": "[[[1]], 2, [3, [4, [5]]]]",
        "output": "[1, 2, 3, 4, 5]",
        "explanation": "All integers are extracted from nested sub-arrays and presented in a flat structure."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a recursive approach to handle nested arrays.",
      "Think about how you can concatenate the results of the inner arrays with the outer array."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Partition Equal Subset Sum",
    "description": "Given a non-empty array of positive integers, you are tasked to determine if it can be partitioned into two subsets such that the sum of the elements in both subsets is equal. Your goal is to find a solution that efficiently determines the possible partitioning of the array.",
    "topic": "Dynamic Programming",
    "subtopic": "Subset Sum",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Backtracking"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A boolean value indicating whether the array can be partitioned into two subsets with equal sum.",
    "constraints": [
      "1 <= nums.length <= 200",
      "1 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 5, 11, 5]",
        "output": "true",
        "explanation": "The array can be partitioned into subsets [1, 5, 5] and [11], both of which sum to 11."
      },
      {
        "input": "nums = [1, 2, 3, 5]",
        "output": "false",
        "explanation": "The array cannot be partitioned into two subsets with equal sum."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the total sum of the array. If it's odd, return false immediately.",
      "Try to find a subset that sums up to half of the total sum."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Decode String",
    "description": "Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid. The decoding rule may be nested, so the input will not be a simple k[encoded_string] format.",
    "topic": "String",
    "subtopic": "Decoding",
    "tags": [
      "String",
      "Decoding",
      "Stack"
    ],
    "input_format": "A single string 's' that represents the encoded string.",
    "output_format": "A string that represents the decoded output.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of digits, lowercase English letters, and square brackets '[' and '].",
      "The input string is always valid."
    ],
    "examples": [
      {
        "input": "s = '3[a2[c]]'",
        "output": "accaccacc",
        "explanation": "The string is decoded as: 3 times 'a2[c]', which is 'acc'. So, the final result is 'acc' repeated 3 times."
      },
      {
        "input": "s = '2[abc]3[cd]ef'",
        "output": "abcabccdccdef",
        "explanation": "Decoded as: 'abc' 2 times = 'abcabc', 'cd' 3 times = 'cdcdcd', then combined with 'ef' for the final result."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to keep track of characters and repeat counts.",
      "Handle nested structures carefully to ensure correct decoding."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "First Unique Character in a String",
    "description": "Given a string, find the index of the first non-repeating character in it. If it doesn't exist, return -1.",
    "topic": "String",
    "subtopic": "Character Counting",
    "tags": [
      "String",
      "Hash Table",
      "Counting"
    ],
    "input_format": "A string s consisting of English letters, digits, symbols, and spaces.",
    "output_format": "An integer representing the index of the first unique character, or -1 if it does not exist.",
    "constraints": [
      "0 <= s.length <= 10^5",
      "s consists of printable ASCII characters."
    ],
    "examples": [
      {
        "input": "s = \"leetcode\"",
        "output": "0",
        "explanation": "The first non-repeating character is 'l' at index 0."
      },
      {
        "input": "s = \"loveleetcode\"",
        "output": "2",
        "explanation": "The first non-repeating character is 'v' at index 2."
      },
      {
        "input": "s = \"aabb\"",
        "output": "-1",
        "explanation": "There are no non-repeating characters."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash table to count the occurrences of each character."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Maximum Profit From Trading Stocks",
    "description": "You are given an array where the ith element is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers prices, where prices[i] is the price of a given stock on the ith day.",
    "output_format": "An integer representing the maximum profit you can achieve.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "No transactions are done and the max profit is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to keep track of the minimum price seen so far.",
      "Calculate the potential profit at each step and update the maximum profit."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock II",
    "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. However, you can make as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note that you must sell the stock before you buy again. Return the maximum profit you can achieve.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Strategy",
    "tags": [
      "Array",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers prices.",
    "output_format": "An integer representing the maximum profit.",
    "constraints": [
      "1 <= prices.length <= 3 * 10^4",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "7",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5. Then buy on day 4 (price = 3) and sell on day 5 (price = 4), profit = 4 - 3 = 1. Total profit = 5 + 1 = 6."
      },
      {
        "input": "prices = [1, 2, 3, 4, 5]",
        "output": "4",
        "explanation": "Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5 - 1 = 4."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done as prices are in descending order."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how many times you can buy and sell to maximize profit.",
      "Focus on adding profits from each upward slope in the price.",
      "Use a simple loop to track price changes."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Subarray Sum Equals K",
    "description": "Given an array of integers and an integer k, return the total number of continuous subarrays whose sum equals to k.",
    "topic": "Array",
    "subtopic": "Prefix Sum",
    "tags": [
      "Array",
      "Hash Map",
      "Prefix Sum"
    ],
    "input_format": "An integer array nums and an integer k.",
    "output_format": "An integer representing the number of continuous subarrays whose sum equals k.",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-1000 <= nums[i] <= 1000",
      "-10^7 <= k <= 10^7"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 1], k = 2",
        "output": "2",
        "explanation": "There are two subarrays [1, 1] which sum to 2."
      },
      {
        "input": "nums = [1, 2, 3], k = 3",
        "output": "2",
        "explanation": "The subarrays [3] and [1, 2] sum to 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map to store the cumulative sums.",
      "Think about how to find the past sums that would lead to the current sum equaling k."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "Given n vertical lines drawn on a 2D plane where the ith line has a height represented by an integer array heights, the container can hold the most water between the two vertical lines. Find the maximum amount of water a container can store.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "input_format": "An array of integers heights of length n (1 <= n <= 10^5) representing the heights of the vertical lines.",
    "output_format": "An integer representing the maximum area of water that can be contained.",
    "constraints": [
      "2 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The maximum area is between the lines at index 1 and index 8, with a height of 7 and a distance of 7, giving an area of 7 * 7 = 49."
      },
      {
        "input": "heights = [1,1]",
        "output": "1",
        "explanation": "Only two lines with height 1, the area is 1 * 1 = 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a two-pointer approach to maximize the area."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Koko Eating Bananas",
    "description": "Koko loves to eat bananas, and she wants to eat all of them in a given time. Koko can choose a speed at which to eat bananas: she can either eat a certain number of bananas in one hour or increase her speed for the next hour. Given a pile of bananas and a number of hours, determine the minimum speed at which Koko must eat bananas to finish them all within the given hours. If it is impossible for her to finish them in time, return -1.",
    "topic": "Binary Search",
    "subtopic": "Searching",
    "tags": [
      "Binary Search",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers piles and an integer H, where piles[i] represents the number of bananas in the ith pile and H represents the number of hours.",
    "output_format": "An integer representing the minimum eating speed, or -1 if it's impossible to finish in H hours.",
    "constraints": [
      "1 <= piles.length <= 10^4",
      "1 <= piles[i] <= 10^9",
      "1 <= H <= 10^9"
    ],
    "examples": [
      {
        "input": "piles = [3, 6, 7, 11], H = 8",
        "output": "4",
        "explanation": "Koko can eat at a speed of 4 bananas per hour. She will finish in 4 + 2 + 2 + 3 = 11 hours which is more than 8 hours. However, at speed 4, she can't finish in 8 hours."
      },
      {
        "input": "piles = [30, 11, 23, 4, 20], H = 5",
        "output": "30",
        "explanation": "If Koko eats 30 bananas per hour, she will finish all piles in 30/30 + 11/30 + 23/30 + 4/30 + 20/30 = 1 + 1 + 1 + 1 + 1 = 5 hours."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider binary searching the possible speeds.",
      "Check how many hours are needed for a given speed."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Merge Two Sorted Lists",
    "description": "You are given the heads of two sorted linked lists. Merge the two lists into one sorted linked list and return it. The new list should be made by splicing together the nodes of the first two lists.",
    "topic": "Linked List",
    "subtopic": "Merging Linked Lists",
    "tags": [
      "Linked List",
      "Merge",
      "Sorting"
    ],
    "input_format": "The input consists of two linked lists represented by their head nodes, list1 and list2.",
    "output_format": "Return the head of the merged linked list.",
    "constraints": [
      "The number of nodes in both linked lists is in the range [0, 100]",
      "The values of the nodes are in the range [-100, 100]",
      "Both linked lists are already sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "list1 = [1, 2, 4], list2 = [1, 3, 4]",
        "output": "[1, 1, 2, 3, 4, 4]",
        "explanation": "The merged list is 1 -> 1 -> 2 -> 3 -> 4 -> 4."
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]",
        "explanation": "The merged list is just 0 since list1 is empty."
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]",
        "explanation": "Both lists are empty, so the merged list is also empty."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a dummy node to simplify the merging process.",
      "Iterate through both lists until one of them is exhausted."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Wildcard Matching",
    "description": "Given a string s and a wildcard pattern p, implement wildcard matching with support for '?' and '*'. '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire string (not partial).",
    "topic": "Dynamic Programming",
    "subtopic": "String Matching",
    "tags": [
      "Dynamic Programming",
      "String",
      "Matching"
    ],
    "input_format": "Two strings s and p, where 1 <= s.length, p.length <= 20.",
    "output_format": "Return true if the string s matches the wildcard pattern p, otherwise return false.",
    "constraints": [
      "1 <= s.length, p.length <= 20",
      "s contains only lowercase letters.",
      "p contains only lowercase letters, '?' or '*'."
    ],
    "examples": [
      {
        "input": "s = 'adceb', p = '*a*b'",
        "output": "true",
        "explanation": "The '*' matches the substring 'dce', hence the string matches the pattern."
      },
      {
        "input": "s = 'acdcb', p = 'a*c?b'",
        "output": "false",
        "explanation": "The pattern does not match the string 'acdcb'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to maintain a table for matched states.",
      "Think about how '*' and '?' can change the matching process."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Min Stack",
    "description": "Design a stack that supports the following operations: push, pop, top, and retrieving the minimum element. All operations should be done in constant time. Implement the MinStack class: \n- void push(int val): Pushes the element val onto the stack. \n- void pop(): Removes the element on the top of the stack. \n- int top(): Gets the top element of the stack. \n- int getMin(): Retrieves the minimum element in the stack.",
    "topic": "Stack",
    "subtopic": "Design",
    "tags": [
      "Stack",
      "Design",
      "Data Structure"
    ],
    "input_format": "A series of method calls on the MinStack class instance.",
    "output_format": "Return value from top() and getMin() methods.",
    "constraints": [
      "The number of operations performed will be at most 1000.",
      "-10^6 <= val <= 10^6"
    ],
    "examples": [
      {
        "input": "MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); minStack.pop(); minStack.top(); minStack.getMin();",
        "output": "[-3, 0, -2]",
        "explanation": "Initially, -2 is pushed. Then 0 and -3 are pushed. getMin() returns -3. After pop(), top() returns 0, and getMin() returns -2."
      },
      {
        "input": "MinStack minStack = new MinStack(); minStack.push(1); minStack.push(2); minStack.getMin();",
        "output": "[1]",
        "explanation": "Push 1 first, then 2. getMin() returns 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a second stack to keep track of the minimum values."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Course Schedule",
    "description": "You are given an integer numCourses, the number of courses you have to take, and an array prerequisites, where prerequisites[i] = [a, b] indicates that you must take course b before course a. Return true if you can finish all courses. Otherwise, return false.",
    "topic": "Graph",
    "subtopic": "Topological Sorting",
    "tags": [
      "Graph",
      "Topological Sorting",
      "DFS"
    ],
    "input_format": "An integer numCourses and an array of pairs prerequisites.",
    "output_format": "A boolean indicating whether all courses can be finished.",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2"
    ],
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = [[1, 0]]",
        "output": "true",
        "explanation": "You can take course 0 first, then take course 1."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1, 0], [0, 1]]",
        "output": "false",
        "explanation": "There is a cycle. Course 0 depends on course 1 and vice versa."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using graph traversal techniques.",
      "Check for cycles in the graph."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Jump Game II",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Write a function to determine the minimum number of jumps you need to take to reach the last index. If you cannot reach the last index, return -1.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of non-negative integers nums where nums[i] represents the maximum jump length from index i.",
    "output_format": "An integer representing the minimum number of jumps needed to reach the last index, or -1 if it is not possible.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "2",
        "explanation": "The minimum number of jumps to reach the last index is 2. Jump from index 0 to index 1, then jump to the last index."
      },
      {
        "input": "nums = [2,3,0,1,4]",
        "output": "2",
        "explanation": "Similar to the previous example, you can jump from index 0 to index 1 and then to the last index."
      },
      {
        "input": "nums = [0,1,1,1]",
        "output": "-1",
        "explanation": "It is not possible to reach the last index as the first jump length is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "You may want to keep track of the farthest index you can reach at each step.",
      "Consider a greedy approach to minimize jumps."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Largest Rectangle in Histogram",
    "description": "Given an array of integers representing the heights of bars in a histogram, you need to find the area of the largest rectangle that can be formed in the histogram. The rectangle can be formed by using one or more adjacent bars. The area of a rectangle is given by the width multiplied by the height, where the height is determined by the shortest bar in that rectangle.",
    "topic": "Stack",
    "subtopic": "Monotonic Stack",
    "tags": [
      "Stack",
      "Histogram",
      "Dynamic Programming",
      "Monotonic Stack"
    ],
    "input_format": "An array of integers heights representing the heights of the bars in the histogram.",
    "output_format": "An integer representing the area of the largest rectangle that can be formed.",
    "constraints": [
      "1 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [2,1,5,6,2,3]",
        "output": "10",
        "explanation": "The largest rectangle can be formed using the heights [5, 6] (width 2), giving area 5*2=10."
      },
      {
        "input": "heights = [2,4]",
        "output": "4",
        "explanation": "The largest rectangle can be formed using the height 4 (width 1), giving area 4*1=4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to keep track of the indices of the bars.",
      "When processing a bar, pop from the stack until you find a bar shorter than the current one."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Merge Sorted Array",
    "description": "Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. The merge should be done in place and should not return anything. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The initial elements of nums1 should be considered valid, and the elements of nums2 should be merged in while maintaining the sorted order.",
    "topic": "Array",
    "subtopic": "Merging Arrays",
    "tags": [
      "Array",
      "Merging",
      "In-place"
    ],
    "input_format": "Two integer arrays nums1 and nums2, along with two integers m and n, where m is the number of elements in nums1 and n is the number of elements in nums2.",
    "output_format": "The merged array in nums1, sorted in non-decreasing order.",
    "constraints": [
      "1 <= m + n <= 2 * 10^4",
      "0 <= m, n <= 10^4",
      "-10^9 <= nums1[i], nums2[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3",
        "output": "[1, 2, 2, 3, 5, 6]",
        "explanation": "After merging, the elements of nums1 should be [1, 2, 2, 3, 5, 6]."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "Since nums2 is empty, the result should be nums1 itself, which is [1]."
      },
      {
        "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
        "output": "[1]",
        "explanation": "The merged result should be [1], as there are no initial elements in nums1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers to traverse both arrays.",
      "Fill nums1 from the end to avoid overwriting elements."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Boats to Save People",
    "description": "You are given an array `people` where `people[i]` is the weight of the ith person. There are boats that can carry a maximum weight capacity `limit`. Each boat can carry at most two people at the same time. Return the minimum number of boats required to save all the people from rising waters, assuming that a person can get into a boat only with another person if the sum of their weights is less than or equal to `limit`.",
    "topic": "Greedy",
    "subtopic": "Two Pointers",
    "tags": [
      "Greedy",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "An array of integers `people` (1 <= people.length <= 10^5) representing the weights of the people, and an integer `limit` (1 <= limit <= 300000) representing the boat's weight limit.",
    "output_format": "An integer representing the minimum number of boats required to save all the people.",
    "constraints": [
      "1 <= people.length <= 10^5",
      "1 <= people[i] <= limit"
    ],
    "examples": [
      {
        "input": "people = [1, 2, 3, 4], limit = 4",
        "output": "3",
        "explanation": "One boat can carry (1, 3), another boat can carry (2), and the last boat can carry (4)."
      },
      {
        "input": "people = [3, 2, 2, 1], limit = 3",
        "output": "3",
        "explanation": "The boats can carry (1, 2), (2), (3), which results in 3 boats."
      },
      {
        "input": "people = [5, 1, 4, 2], limit = 6",
        "output": "2",
        "explanation": "One boat can carry (2, 4) and another boat can carry (5, 1)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the people array.",
      "Use two pointers to maximize boat usage.",
      "Always try to pair the heaviest person with the lightest if possible."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Fruit Into Baskets",
    "description": "You have a row of fruit trees in your garden. Each tree produces one type of fruit, represented by an integer. You want to collect the fruits in two baskets, but you can only collect fruits from two different types of trees. Your task is to determine the maximum number of fruits you can collect in total by following the above rule. Return the maximum number of fruits you can collect continuously from the trees.",
    "topic": "Sliding Window",
    "subtopic": "Two Pointers",
    "tags": [
      "Sliding Window",
      "Two Pointers",
      "Greedy"
    ],
    "input_format": "An array of integers representing the types of fruits in a row: [1, 2, 1, 2, 3, 2, 2].",
    "output_format": "An integer representing the maximum number of fruits that can be collected.",
    "constraints": [
      "1 <= fruits.length <= 10^5",
      "0 <= fruits[i] < 10^5"
    ],
    "examples": [
      {
        "input": "[1, 2, 1]",
        "output": "3",
        "explanation": "All fruits can be collected as there are only two types, so the maximum is 3."
      },
      {
        "input": "[0, 1, 2, 2]",
        "output": "3",
        "explanation": "Collecting fruits of types 1 and 2 gives you a maximum length of 3 (1, 2, 2)."
      },
      {
        "input": "[1, 2, 3, 2, 2]",
        "output": "4",
        "explanation": "Collecting fruits of types 2 and 3 gives you [2, 3, 2, 2] which is 4 in length."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window to track the fruit types.",
      "Maintain a frequency map to keep count of collected fruit types."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Decode Ways",
    "description": "A message containing letters from 'A' to 'Z' can be encoded into numbers using the following mapping: 'A' -> '1', 'B' -> '2', ..., 'Z' -> '26'. Given a string s consisting of digits, return the total number of ways to decode it. The decoding rules are as follows: a digit cannot be '0' and any valid two-digit number must be between '10' and '26'.",
    "topic": "Dynamic Programming",
    "subtopic": "Memoization",
    "tags": [
      "Dynamic Programming",
      "String",
      "Recursion"
    ],
    "input_format": "A string s, representing the encoded message.",
    "output_format": "An integer representing the number of ways to decode the string.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of digits only and does not contain leading zeros."
    ],
    "examples": [
      {
        "input": "s = '12'",
        "output": "2",
        "explanation": "The string can be decoded as 'AB' (1, 2) or 'L' (12)."
      },
      {
        "input": "s = '226'",
        "output": "3",
        "explanation": "The string can be decoded as 'BZF' (2, 26), 'BZ' (2, 2, 6), or 'VF' (22, 6)."
      },
      {
        "input": "s = '06'",
        "output": "0",
        "explanation": "The string cannot be decoded since it starts with a zero."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to solve the problem.",
      "Store the results of subproblems to avoid redundant calculations.",
      "Think about how to build the solution based on previous results."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Minimum Add to Make Parentheses Valid",
    "description": "Given a string s containing just the characters '(' and ')', return the minimum number of parentheses we must add to make the input string valid. A parentheses string is valid if every opening parenthesis '(' has a corresponding closing parenthesis ')' and the parentheses are closed in the correct order.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Greedy"
    ],
    "input_format": "A string s of length n, where 0 <= n <= 1000.",
    "output_format": "An integer representing the minimum number of parentheses that need to be added.",
    "constraints": [
      "0 <= s.length <= 1000",
      "s consists of '(' and ')'."
    ],
    "examples": [
      {
        "input": "s = \"())\"",
        "output": "1",
        "explanation": "We need to add one closing parenthesis to make it valid: \"())\" -> \"()()\"."
      },
      {
        "input": "s = \"((\"",
        "output": "2",
        "explanation": "We need to add two closing parentheses to make it valid: \"((\" -> \"(())\"."
      },
      {
        "input": "s = \"()\"",
        "output": "0",
        "explanation": "The string is already valid, so no parentheses need to be added."
      },
      {
        "input": "s = \"())(\"",
        "output": "2",
        "explanation": "We need to add one opening and one closing parenthesis to make it valid: \"())(\" -> \"(())()\"."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to track the unmatched parentheses.",
      "Count how many unmatched opening and closing parentheses exist.",
      "The result is the sum of unmatched opening and closing parentheses."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Palindrome Number",
    "description": "Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome while 123 is not.",
    "topic": "Math",
    "subtopic": "Number Theory",
    "tags": [
      "Palindrome",
      "Math",
      "Number Theory"
    ],
    "input_format": "An integer x, where x is the number to be checked.",
    "output_format": "A boolean value: true if x is a palindrome, false otherwise.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 121",
        "output": "true",
        "explanation": "The number 121 reads the same backward."
      },
      {
        "input": "x = -121",
        "output": "false",
        "explanation": "The negative number -121 reads as 121-."
      },
      {
        "input": "x = 10",
        "output": "false",
        "explanation": "The number 10 reads as 01 backward."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how to handle negative numbers.",
      "You can reverse the number and compare it to the original."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Valid Palindrome II",
    "description": "Given a string s, return true if the s can be a palindrome after deleting at most one character from it. A palindrome is a string that reads the same forward and backward.",
    "topic": "String",
    "subtopic": "Two Pointers",
    "tags": [
      "String",
      "Palindrome",
      "Two Pointers"
    ],
    "input_format": "A single string s, where 1 <= s.length <= 1000.",
    "output_format": "A boolean value true or false.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of lowercase and uppercase English letters and symbols."
    ],
    "examples": [
      {
        "input": "s = \"abca\"",
        "output": "true",
        "explanation": "Removing the character 'b' results in the palindrome 'aca'."
      },
      {
        "input": "s = \"racecar\"",
        "output": "true",
        "explanation": "The string is already a palindrome without any deletion."
      },
      {
        "input": "s = \"abc\"",
        "output": "false",
        "explanation": "Removing any one character does not form a palindrome."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers to compare characters from both ends.",
      "If characters at both pointers do not match, check the substrings by skipping either character."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Reorganize String",
    "description": "Given a string s, rearrange the characters of s so that no two adjacent characters are the same. If it is not possible to rearrange the string, return an empty string. You may return the answer in any order.",
    "topic": "String",
    "subtopic": "Rearranging Characters",
    "tags": [
      "String",
      "Greedy",
      "Heap"
    ],
    "input_format": "A string s consisting of lowercase letters.",
    "output_format": "A rearranged string with no two adjacent characters being the same, or an empty string if unable to rearrange.",
    "constraints": [
      "1 <= s.length <= 500",
      "s consists of only lowercase letters."
    ],
    "examples": [
      {
        "input": "aabb",
        "output": "abab",
        "explanation": "One possible rearrangement is 'abab' where no two adjacent characters are the same."
      },
      {
        "input": "aaab",
        "output": "",
        "explanation": "It's impossible to rearrange the string so that no two 'a's are adjacent."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a frequency counter for characters.",
      "A max heap may help to always place the most frequent character next."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Second Highest Salary",
    "description": "Write a SQL query to retrieve the second highest salary from the Employee table. If there is no second highest salary, the query should return null.",
    "topic": "Database",
    "subtopic": "SQL",
    "tags": [
      "SQL",
      "Database",
      "Query"
    ],
    "input_format": "A table called Employee with a column Salary.",
    "output_format": "An integer representing the second highest salary or null if it does not exist.",
    "constraints": [
      "The Employee table has at most 10^4 rows.",
      "Salary values can be any integer."
    ],
    "examples": [
      {
        "input": "Employee = [[1, 3000], [2, 4000], [3, 5000]]",
        "output": "4000",
        "explanation": "The highest salary is 5000, and the second highest salary is 4000."
      },
      {
        "input": "Employee = [[1, 1000], [2, 1000], [3, 1000]]",
        "output": "null",
        "explanation": "All salaries are the same, so there is no second highest salary."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using DISTINCT to handle duplicate salaries.",
      "Use LIMIT and ORDER BY to find the appropriate salary."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Reverse Words in a String III",
    "description": "Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. A word is defined as a sequence of non-space characters. Your task is to implement a function that performs this transformation.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Reverse"
    ],
    "input_format": "A single string s, where 1 <= s.length <= 10^5.",
    "output_format": "A single string representing the sentence with each word reversed.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of printable ASCII characters and whitespace.",
      "There are no leading or trailing spaces."
    ],
    "examples": [
      {
        "input": "Let's take LeetCode contest",
        "output": "s'teL ekat edoCteeL tsetnoc",
        "explanation": "Each word in the string is reversed, preserving the order of words."
      },
      {
        "input": "God Ding",
        "output": "doG gniD",
        "explanation": "The two words are reversed while retaining their order."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how to split the string into words.",
      "Think about reversing each word separately."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Linked List Cycle",
    "description": "Given a linked list, determine if it has a cycle in it. A cycle is defined as a situation where a node's next pointer points to an earlier node in the sequence, causing an infinite loop. Your task is to implement a function that returns true if there is a cycle, otherwise, it returns false.",
    "topic": "Linked List",
    "subtopic": "Cycle Detection",
    "tags": [
      "LinkedList",
      "Cycle",
      "Detection"
    ],
    "input_format": "The input consists of the head node of a linked list.",
    "output_format": "Return a boolean value indicating whether the linked list has a cycle.",
    "constraints": [
      "The number of nodes in the linked list can be in the range [0, 10^4].",
      "The value of each node can be a valid integer."
    ],
    "examples": [
      {
        "input": "head = [3, 2, 0, -4], pos = 1",
        "output": "true",
        "explanation": "The linked list has a cycle where the last node points back to the second node."
      },
      {
        "input": "head = [1, 2], pos = 0",
        "output": "true",
        "explanation": "The linked list has a cycle where the last node points back to the first node."
      },
      {
        "input": "head = [1], pos = -1",
        "output": "false",
        "explanation": "The linked list does not have a cycle as there is only one node and it does not form a loop."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to detect the cycle.",
      "If the fast pointer meets the slow pointer, there is a cycle."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Count Primes",
    "description": "Given a non-negative integer n, count all the prime numbers that are less than n. A prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers.",
    "topic": "Math",
    "subtopic": "Prime Numbers",
    "tags": [
      "Math",
      "Primes",
      "Counting"
    ],
    "input_format": "A single integer n representing the upper limit to count prime numbers.",
    "output_format": "An integer representing the total count of prime numbers less than n.",
    "constraints": [
      "0 <= n <= 10^6"
    ],
    "examples": [
      {
        "input": "n = 10",
        "output": "4",
        "explanation": "The prime numbers less than 10 are 2, 3, 5, and 7. Hence, the count is 4."
      },
      {
        "input": "n = 0",
        "output": "0",
        "explanation": "There are no prime numbers less than 0."
      },
      {
        "input": "n = 1",
        "output": "0",
        "explanation": "There are no prime numbers less than 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using the Sieve of Eratosthenes for efficient counting.",
      "Remember that 0 and 1 are not prime numbers."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Reverse Words in a String",
    "description": "Given an input string, reverse the order of words. A word is defined as a sequence of non-space characters. The resulting string should not have leading or trailing spaces and should only contain a single space between words.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Reverse"
    ],
    "input_format": "A single string s, consisting of words and spaces.",
    "output_format": "A string with the words in reverse order.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of English letters, digits, and spaces."
    ],
    "examples": [
      {
        "input": "s = '  hello world  '",
        "output": "'world hello'",
        "explanation": "The input contains a leading and trailing space. After reversing, the order of words becomes 'world hello'."
      },
      {
        "input": "s = 'the sky is blue'",
        "output": "'blue is sky the'",
        "explanation": "Words are reversed to 'blue is sky the'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider splitting the string into words.",
      "Use built-in functions for reversing the list of words."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Maximal Square",
    "description": "Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "Matrix",
    "tags": [
      "Dynamic Programming",
      "Matrix",
      "Square",
      "Area"
    ],
    "input_format": "A 2D binary matrix represented as a list of lists, where each inner list contains '0's and '1's.",
    "output_format": "An integer representing the area of the largest square containing only '1's.",
    "constraints": [
      "1 <= matrix.length <= 300",
      "1 <= matrix[i].length <= 300",
      "matrix[i][j] is '0' or '1'"
    ],
    "examples": [
      {
        "input": [
          [
            "1",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "0",
            "1",
            "1",
            "1"
          ],
          [
            "1",
            "1",
            "1",
            "1",
            "1"
          ],
          [
            "1",
            "0",
            "0",
            "1",
            "0"
          ]
        ],
        "output": "4",
        "explanation": "The largest square has a side length of 2, with area 2 * 2 = 4."
      },
      {
        "input": [
          [
            "0",
            "1"
          ],
          [
            "1",
            "1"
          ]
        ],
        "output": "1",
        "explanation": "The largest square has a side length of 1, with area 1 * 1 = 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use dynamic programming to build a solution.",
      "Keep track of the maximum size of square found so far.",
      "For each '1', determine the possible square size based on adjacent squares."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Product of Array Except Self",
    "description": "Given an integer array nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. You must solve it without using the division operation and in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Product Calculation",
    "tags": [
      "Array",
      "Product",
      "O(n) time"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An array of integers output where output[i] is the product of all elements except nums[i].",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-30 <= nums[i] <= 30"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "[24, 12, 8, 6]",
        "explanation": "The product of all elements except nums[0] (1) is 2 * 3 * 4 = 24, nums[1] (2) is 1 * 3 * 4 = 12, nums[2] (3) is 1 * 2 * 4 = 8, and nums[3] (4) is 1 * 2 * 3 = 6."
      },
      {
        "input": "nums = [-1, 1, 0, -3, 3]",
        "output": "[0, 0, 9, 0, 0]",
        "explanation": "The output for each index is the product of all other elements, resulting in zeros due to presence of zero in the input array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using two passes over the array for left and right products.",
      "Use an additional array to store results during computation."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Valid Anagram",
    "description": "Given two strings s and t, return true if t is an anagram of s and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "topic": "String",
    "subtopic": "Sorting & Searching",
    "tags": [
      "String",
      "Anagram",
      "Sorting"
    ],
    "input_format": "Two strings s and t, where 1 <= s.length, t.length <= 5 * 10^4.",
    "output_format": "A boolean value, true if t is an anagram of s, false otherwise.",
    "constraints": [
      "s and t consist of lowercase English letters.",
      "The lengths of s and t will be the same."
    ],
    "examples": [
      {
        "input": "s = 'anagram', t = 'nagaram'",
        "output": "true",
        "explanation": "Both strings contain the same characters with the same frequency."
      },
      {
        "input": "s = 'rat', t = 'car'",
        "output": "false",
        "explanation": "The character frequencies are different."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how you would compare character frequencies.",
      "What data structure could help you count characters effectively?"
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Perfect Squares",
    "description": "Given a positive integer n, you need to determine the least number of perfect square numbers that sum to n. A perfect square is an integer that is the square of an integer. For example, 1, 4, 9, 16, and so on are perfect squares.",
    "topic": "Dynamic Programming",
    "subtopic": "State Transition",
    "tags": [
      "Dynamic Programming",
      "Mathematics",
      "Minimization"
    ],
    "input_format": "A single positive integer n.",
    "output_format": "An integer representing the least number of perfect square numbers that sum to n.",
    "constraints": [
      "1 <= n <= 10^4"
    ],
    "examples": [
      {
        "input": "n = 12",
        "output": "3",
        "explanation": "12 can be expressed as 4 + 4 + 4, which includes three perfect squares."
      },
      {
        "input": "n = 13",
        "output": "2",
        "explanation": "13 can be expressed as 4 + 9, which includes two perfect squares."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider dynamic programming to build on previous results.",
      "Try to build the solution using smaller subproblems."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Binary Tree Longest Consecutive Sequence",
    "description": "Given the root of a binary tree, return the length of the longest consecutive sequence path. The path must be downward, meaning that you cannot go back up to the parent node. A consecutive sequence path is defined as a path where the values of the nodes along the path are consecutive integers, that is, each value should be exactly one more than the previous value on the path.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth-First Search",
      "Recursion"
    ],
    "input_format": "The input consists of a binary tree represented by its root. Each node contains an integer value.",
    "output_format": "An integer representing the length of the longest consecutive sequence path.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3]",
        "output": "2",
        "explanation": "The longest consecutive sequence is 1 -> 2, which has a length of 2."
      },
      {
        "input": "root = [2, 3, 2, 1, 2]",
        "output": "2",
        "explanation": "The longest consecutive sequence is 2 -> 3, which has a length of 2."
      },
      {
        "input": "root = [1, 2, 3, 4, 5, 6, 7]",
        "output": "3",
        "explanation": "The longest consecutive sequence is either 5 -> 6 -> 7 or 1 -> 2 -> 3, both have lengths of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use depth-first search to explore all paths.",
      "Keep track of lengths of consecutive sequences as you traverse."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Maximum Number of Non-overlapping Palindrome Substrings",
    "description": "You are given a string s consisting of lowercase letters. Your task is to find the maximum number of non-overlapping substring palindromes in the string. A substring is considered a palindrome if it reads the same backward as forward. Two palindromes are non-overlapping if they do not share any characters. You need to return the maximum count of such non-overlapping substrings.",
    "topic": "String",
    "subtopic": "Palindrome",
    "tags": [
      "String",
      "Palindrome",
      "Dynamic Programming"
    ],
    "input_format": "A single string s (1 <= s.length <= 1000).",
    "output_format": "An integer representing the maximum number of non-overlapping palindrome substrings.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of lowercase English letters only."
    ],
    "examples": [
      {
        "input": "ababa",
        "output": "2",
        "explanation": "The substrings 'a' and 'aba' can be chosen as non-overlapping palindromes."
      },
      {
        "input": "racecarannakayak",
        "output": "4",
        "explanation": "The substrings 'racecar', 'anna', and 'kayak' are all palindromes and non-overlapping."
      },
      {
        "input": "abcba",
        "output": "3",
        "explanation": "Choose 'a', 'b', and 'c' as non-overlapping palindromes."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to find all palindromic substrings.",
      "Keep track of the end index of the last added palindrome to ensure non-overlapping.",
      "Use a set to store unique palindromes."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Palindrome Partitioning",
    "description": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. A palindrome is a string that reads the same backward as forward.",
    "topic": "String",
    "subtopic": "Backtracking",
    "tags": [
      "String",
      "Backtracking",
      "Palindrome"
    ],
    "input_format": "A string s, where 1 <= s.length <= 16.",
    "output_format": "A list of lists containing all possible palindrome partitioning of s.",
    "constraints": [
      "1 <= s.length <= 16",
      "s consists of English letters and digits."
    ],
    "examples": [
      {
        "input": "s = \"aab\"",
        "output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
        "explanation": "The palindrome substrings are 'a', 'a', and 'b', as well as 'aa' and 'b'."
      },
      {
        "input": "s = \"a\"",
        "output": "[[\"a\"]]",
        "explanation": "The only substring is 'a', which is a palindrome."
      },
      {
        "input": "s = \"racecar\"",
        "output": "[[\"r\",\"a\",\"c\",\"e\",\"c\",\"a\",\"r\"],[\"r\",\"aceca\",\"r\"],[\"racecar\"]]",
        "explanation": "The substrings can be split into each character or group palindromes like 'aceca' and 'racecar'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use backtracking to explore possible partitions.",
      "Check if a string is a palindrome."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Binary Tree Maximum Path Sum",
    "description": "Given a non-empty binary tree, find the maximum path sum. The path must start and end at any node in the tree, and it can go in any direction. A path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The maximum path sum is the highest sum of values along this path.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth First Search",
      "Recursion"
    ],
    "input_format": "The input is the root node of a binary tree where each node has an integer value.",
    "output_format": "An integer representing the maximum path sum.",
    "constraints": [
      "-10^4 <= node.val <= 10^4",
      "The number of nodes in the tree is in the range [1, 3 * 10^4]."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3]",
        "output": "6",
        "explanation": "The maximum path sum is 1 + 2 + 3 = 6."
      },
      {
        "input": "root = [-10, 9, 20, null, null, 15, 7]",
        "output": "42",
        "explanation": "The maximum path sum is 15 + 20 + 7 = 42."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "A path can start and end at any node.",
      "Consider the contribution of each node to the path sum.",
      "Utilize recursion to explore all possible paths."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Longest Palindrome",
    "description": "Given a string s, return the length of the longest substring that is a palindrome. A palindrome is a string that reads the same backward as forward. You should consider both odd and even length palindromes.",
    "topic": "String",
    "subtopic": "Substring",
    "tags": [
      "String",
      "Palindrome",
      "Dynamic Programming"
    ],
    "input_format": "A single string s of length n where 1 <= n <= 1000.",
    "output_format": "An integer representing the length of the longest palindromic substring.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only printable ASCII characters."
    ],
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "3",
        "explanation": "The longest palindromic substring is \"bab\" or \"aba\", both of length 3."
      },
      {
        "input": "s = \"cbbd\"",
        "output": "2",
        "explanation": "The longest palindromic substring is \"bb\", which has length 2."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider expanding from the center to check for palindromes.",
      "Keep track of the maximum length found."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Populating Next Right Pointers in Each Node II",
    "description": "Given a binary tree, each node in the tree has a 'next' pointer that should point to its immediate right neighbor. If there is no right neighbor, the next pointer should be set to null. You need to populate these next right pointers for all nodes in the tree. Unlike the previous version of this problem, this time, you can use any method (iterative or recursive) to solve it, and the tree can also have nodes without both left and right children.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Pointers"
    ],
    "input_format": "The root of a binary tree node.",
    "output_format": "The root of the modified binary tree with the next pointers populated.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 6000].",
      "Each node's value is unique."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, 4, 5, null, 6]",
        "output": "root = [1,#, 2,3,#, 4,5,6,#]",
        "explanation": "The tree has the structure: 1 -> 2 -> 3 and 2 -> 4 -> 5 and 3 -> 6."
      },
      {
        "input": "root = []",
        "output": "root = []",
        "explanation": "An empty tree remains empty."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a queue to perform level-order traversal.",
      "You can utilize the 'next' pointer to simplify the process."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list. The input lists are represented as Linked List nodes.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "Linked List",
      "Addition",
      "Two Pointers"
    ],
    "input_format": "Two linked lists l1 and l2 where each node contains a single digit.",
    "output_format": "A linked list representing the sum of the two numbers.",
    "constraints": [
      "The number of nodes in each linked list is between 1 and 100.",
      "0 <= Node.val <= 9",
      "It is guaranteed that the input lists represent valid integers."
    ],
    "examples": [
      {
        "input": "l1 = [2, 4, 3], l2 = [5, 6, 4]",
        "output": "[7, 0, 8]",
        "explanation": "342 + 465 = 807, so the output linked list is 7 -> 0 -> 8."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "0 + 0 = 0, so the output linked list is 0."
      },
      {
        "input": "l1 = [9, 9, 9, 9, 9, 9, 9], l2 = [9, 9, 9]",
        "output": "[8, 9, 9, 9, 0, 0, 1]",
        "explanation": "9999999 + 999 = 10009998, so the output linked list is 8 -> 9 -> 9 -> 9 -> 0 -> 0 -> 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a carry variable to handle sums greater than 9.",
      "Iterate through both lists until both are empty."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Path Sum II",
    "description": "Given a binary tree and a target sum, return all root-to-leaf paths where the sum of the node values equals the target sum. Each path should be represented as a list of integers, and the list of paths should be returned in the form of a list of lists.",
    "topic": "Tree",
    "subtopic": "Depth-First Search",
    "tags": [
      "Tree",
      "DFS",
      "Backtracking"
    ],
    "input_format": "The input consists of the root of a binary tree and an integer representing the target sum.",
    "output_format": "A list of lists of integers representing all root-to-leaf paths where the sum equals the target sum.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 1000].",
      "-1000 <= Node.val <= 1000",
      "-1000 <= target <= 1000"
    ],
    "examples": [
      {
        "input": "root = [5, 4, 8, 11, null, 13, 4, 7, 2], target = 22",
        "output": "[[5, 4, 11, 2], [5, 8, 4]]",
        "explanation": "There are two paths where the sum equals 22: 5 -> 4 -> 11 -> 2 and 5 -> 8 -> 4."
      },
      {
        "input": "root = [1, 2, 3], target = 5",
        "output": "[]",
        "explanation": "There are no root-to-leaf paths where the sum equals 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use Depth-First Search (DFS) to explore each path.",
      "Keep track of the current path and its sum as you traverse.",
      "Only add complete paths when you reach a leaf node."
    ],
    "company": "Walmart Labs"
  },
  {
    "question_id": "",
    "title": "Populating Next Right Pointers in Each Node",
    "description": "Given a binary tree where each node has a 'next' pointer which is initialized to null, populate each node's 'next' pointer to point to its next right node. If there is no next right node, the 'next' pointer should be set to null. Initially, all 'next' pointers are set to null. You may assume that it is a perfect binary tree (i.e., all leaves are at the same level, and every parent has two children).",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Linked List"
    ],
    "input_format": "The root node of a perfect binary tree.",
    "output_format": "The modified root node of the binary tree with next pointers populated.",
    "constraints": [
      "The number of nodes in the tree is between 1 and 1000.",
      "Each node's value is between 1 and 1000."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, 4, 5, 6, 7]",
        "output": "[1,#,2,3,#,4,5,6,7,#]",
        "explanation": "After populating, the tree would look like this: 1 -> #, 2 -> 3 -> #, 4 -> 5 -> 6 -> 7 -> #."
      },
      {
        "input": "root = [1]",
        "output": "[1,#]",
        "explanation": "There is only one node, and its next pointer remains null."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use level order traversal to connect nodes at the same depth.",
      "Utilize the next pointers from the previous level to connect nodes in the current level."
    ],
    "company": "Walmart Labs"
  }
]