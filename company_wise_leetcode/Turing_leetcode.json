[
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if the brackets are closed in the correct order. Every opening bracket must have a corresponding closing bracket of the same type.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A string s consisting of parentheses.",
    "output_format": "Return true if the string is valid; otherwise, return false.",
    "constraints": [
      "0 <= s.length <= 10^4",
      "s consists of parentheses only '()', '{}', '[]'."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The parentheses are closed in the correct order."
      },
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "All brackets are closed correctly."
      },
      {
        "input": "s = '(]'",
        "output": "false",
        "explanation": "The closing bracket ']' does not match the opening bracket '('."
      },
      {
        "input": "s = '([)]'",
        "output": "false",
        "explanation": "The order of brackets is incorrect."
      },
      {
        "input": "s = '{[]}.'",
        "output": "true",
        "explanation": "The brackets are correctly nested and closed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of the opening brackets.",
      "Check for corresponding closing brackets when encountering a closing bracket."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters. A substring is a contiguous sequence of characters within the string.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A single string s consisting of characters from the English alphabet.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of English letters, digits, symbols and spaces."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The answer is \"abc\", with the length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The answer is \"b\", with the length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The answer is \"wke\", with the length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a set to track characters in the current substring.",
      "Use two pointers to manage the sliding window."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Baseball Game",
    "description": "You are keeping score for a baseball game. The game uses a simple scoring system. You are given a list of strings representing the operations of the game. Each operation can be one of the following: \n1. An integer x (0 <= x <= 100): Score for the current round. \n2. \"C\": This operation means to remove the last score. \n3. \"D\": This means to double the last score. \n4. \"+\": This means to add the last two scores together. \nReturn the sum of all the scores after processing the operations.",
    "topic": "Array",
    "subtopic": "Stack",
    "tags": [
      "Array",
      "Stack",
      "Score Calculation"
    ],
    "input_format": "A list of strings operations representing the score operations.",
    "output_format": "An integer representing the total score after processing all operations.",
    "constraints": [
      "1 <= operations.length <= 1000",
      "operations[i] is either an integer or one of 'C', 'D', '+'"
    ],
    "examples": [
      {
        "input": "operations = [\"5\", \"2\", \"C\", \"D\", \"+\"]",
        "output": "30",
        "explanation": "Scores are [5, 2, C (remove 2), 10 (double last score 5), 15 (5 + 10)] => sum is 5 + 10 + 15 = 30."
      },
      {
        "input": "operations = [\"5\", \"-2\", \"4\", \"C\", \"D\", \"+\"]",
        "output": "27",
        "explanation": "Scores are [5, -2, C (remove -2), 10 (double last score 5), 15 (5 + 10)] => sum is 5 + 10 + 15 = 30."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of the scores.",
      "Make sure to handle the operations in the correct order."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Minimum Cost For Tickets",
    "description": "You are given an integer array days where days[i] represents the days you will travel. You are also given an integer array costs where costs[0] is the cost of a 1-day pass, costs[1] is the cost of a 7-day pass, and costs[2] is the cost of a 30-day pass. You need to return the minimum cost of buying passes for all the travel days. You may only buy one pass at a time and you cannot overlap passes.",
    "topic": "Dynamic Programming",
    "subtopic": "Optimization",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "Two integer arrays days and costs.",
    "output_format": "An integer representing the minimum cost of tickets.",
    "constraints": [
      "1 <= days.length <= 365",
      "1 <= days[i] <= 365",
      "1 <= costs[i] <= 1000"
    ],
    "examples": [
      {
        "input": "days = [1, 4, 6, 7, 8], costs = [2, 7, 15]",
        "output": "11",
        "explanation": "You can buy a 7-day pass for the days 1, 4, 6, 7, and 8."
      },
      {
        "input": "days = [1, 2, 3, 4, 5], costs = [2, 7, 15]",
        "output": "6",
        "explanation": "You can buy two 1-day passes for the first two days and one 1-day pass for the last three days."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider dynamic programming to keep track of the minimum cost up to each day.",
      "You can compare the costs of buying different types of passes."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Koko Eating Bananas",
    "description": "Koko loves bananas. There are n piles of bananas, where the i-th pile has bananas[i] bananas. Koko can decide to eat a certain number of bananas per hour, k. Koko wants to eat all the bananas in the piles. If Koko eats k bananas an hour, then the remaining bananas in a pile will be reduced by k after an hour. Koko can choose to eat at any rate, but she wants to minimize the number of hours required to eat all the bananas. Write a function to determine the minimum integer k such that Koko can eat all the bananas in h hours or less.",
    "topic": "Binary Search",
    "subtopic": "Searching",
    "tags": [
      "Binary Search",
      "Greedy",
      "Array"
    ],
    "input_format": "Two inputs: an integer array bananas, and an integer h.",
    "output_format": "An integer representing the minimum k Koko needs to eat all bananas in h hours.",
    "constraints": [
      "1 <= bananas.length <= 10^4",
      "1 <= bananas[i] <= 10^9",
      "1 <= h <= 10^9"
    ],
    "examples": [
      {
        "input": "bananas = [3, 6, 7, 11], h = 8",
        "output": "4",
        "explanation": "If Koko eats 4 bananas an hour, in 8 hours she can eat all the bananas as follows: the piles will be reduced to [0, 2, 3, 7] after the first hour, then [0, 0, 1, 5], and so on until all are eaten."
      },
      {
        "input": "bananas = [30, 11, 23, 4, 20], h = 5",
        "output": "30",
        "explanation": "Here, Koko would need to eat 30 bananas an hour to finish all piles within 5 hours."
      },
      {
        "input": "bananas = [30, 11, 23, 4, 20], h = 6",
        "output": "23",
        "explanation": "In this case, if Koko eats 23 bananas an hour, she can clear all piles in exactly 6 hours."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider binary search over the range of possible values for k.",
      "Keep track of the total hours consumed based on the current k."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "DFS",
      "Graph",
      "Matrix"
    ],
    "input_format": "A 2D grid of characters where '1' represents land and '0' represents water.",
    "output_format": "An integer representing the number of islands.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "[['1','1','1','1','0'], ['1','1','0','1','0'], ['1','1','0','0','0'], ['0','0','0','0','0']]",
        "output": "1",
        "explanation": "There is one island in the given grid."
      },
      {
        "input": "[['1','1','0','0','0'], ['1','1','0','0','0'], ['0','0','1','0','0'], ['0','0','0','1','1']]",
        "output": "3",
        "explanation": "There are three islands in the given grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use DFS or BFS to explore the islands.",
      "Mark visited land cells to avoid counting them multiple times."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Validate IP Address",
    "description": "Given a string ip, which represents an IP address, determine if it is a valid IPv4 or IPv6 address. An IPv4 address consists of four decimal numbers separated by dots, where each number is between 0 and 255 inclusive and cannot have leading zeros. An IPv6 address consists of eight groups of four hexadecimal digits, separated by colons. Leading zeros in a group are allowed, but empty groups are not allowed. Return 'IPv4' if the IP address is a valid IPv4 address, 'IPv6' if it is a valid IPv6 address, or 'Neither' if it is neither.",
    "topic": "String",
    "subtopic": "Validation",
    "tags": [
      "String",
      "Validation",
      "IPv4",
      "IPv6"
    ],
    "input_format": "A string ip representing the IP address.",
    "output_format": "Return 'IPv4', 'IPv6', or 'Neither' depending on the validity of the IP address.",
    "constraints": [
      "1 <= ip.length <= 40"
    ],
    "examples": [
      {
        "input": "ip = '192.168.1.1'",
        "output": "IPv4",
        "explanation": "The input is a valid IPv4 address since all parts are in the range [0, 255] and have no leading zeros."
      },
      {
        "input": "ip = '256.100.50.25'",
        "output": "Neither",
        "explanation": "The first part '256' is not valid as it exceeds 255."
      },
      {
        "input": "ip = '2001:0db8:85a3:0000:0000:8a2e:0370:7334'",
        "output": "IPv6",
        "explanation": "This is a valid IPv6 address, consisting of 8 groups of 4 hexadecimal digits."
      },
      {
        "input": "ip = '2001:db8:85a3::8a2e:370:7334'",
        "output": "Neither",
        "explanation": "The address contains empty groups, which is not allowed in the representation used."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "For IPv4, split the string by '.' and validate each part.",
      "For IPv6, split the string by ':' and validate each group."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function that takes an array of strings and returns the longest common prefix among them. If there is no common prefix, return an empty string \"\".",
    "topic": "String",
    "subtopic": "Prefix",
    "tags": [
      "String",
      "Prefix",
      "Array"
    ],
    "input_format": "An array of strings strArray, where 1 <= strArray.length <= 200 and 0 <= strArray[i].length <= 200.",
    "output_format": "A string representing the longest common prefix.",
    "constraints": [
      "1 <= strArray.length <= 200",
      "0 <= strArray[i].length <= 200"
    ],
    "examples": [
      {
        "input": "strArray = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The common prefix is 'fl'."
      },
      {
        "input": "strArray = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix."
      },
      {
        "input": "strArray = [\"a\"]",
        "output": "\"a\"",
        "explanation": "The only string is 'a', so the common prefix is 'a'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Check the prefix character by character until the characters mismatch."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "topic": "Dynamic Programming",
    "subtopic": "Fibonacci Sequence",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Mathematics"
    ],
    "input_format": "An integer n, representing the number of steps in the staircase.",
    "output_format": "An integer, the number of distinct ways to climb to the top of the staircase.",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "input": "2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: 1 step + 1 step or 2 steps."
      },
      {
        "input": "3",
        "output": "3",
        "explanation": "There are three ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, or 2 steps + 1 step."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how many ways you can reach the previous step.",
      "You can use dynamic programming to build up solutions from smaller subproblems."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Find the Town Judge",
    "description": "In a town, there are n people labeled from 1 to n. Some people may accuse others of being dishonest. The town judge is defined as a person who is honest and is not accused by anyone. If the judge exists, return the label of the judge. If no judge exists, return -1. You need to implement a function to determine who the town judge is based on the given accusations.",
    "topic": "Graph",
    "subtopic": "Graph Traversal",
    "tags": [
      "Graph",
      "Traversal",
      "Count"
    ],
    "input_format": "An integer n, followed by an array of pairs of integers trust.",
    "output_format": "An integer representing the label of the town judge or -1 if no judge exists.",
    "constraints": [
      "1 <= n <= 1000",
      "0 <= trust.length <= 10^4",
      "trust[i].length == 2",
      "trust[i][0] != trust[i][1]",
      "All trust[i] are distinct."
    ],
    "examples": [
      {
        "input": "n = 2, trust = [[1, 2]]",
        "output": "2",
        "explanation": "Person 1 trusts person 2. Person 2 is trusted by 1 person and trusts no one, making them the town judge."
      },
      {
        "input": "n = 3, trust = [[1, 2], [2, 3]]",
        "output": "-1",
        "explanation": "There is no one who is trusted by everyone and does not trust anyone."
      },
      {
        "input": "n = 3, trust = [[1, 3], [2, 3]]",
        "output": "3",
        "explanation": "Person 3 is trusted by both person 1 and person 2 and does not trust anyone."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider the number of people who accuse each person.",
      "A judge is the only one with an in-degree equal to n - 1."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Divide and Conquer"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum sum of the contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The only subarray is [1] and its sum is 1."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The subarray [5,4,-1,7,8] has the largest sum 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Kadane's algorithm for an efficient solution.",
      "Maintain two variables - one for the current subarray sum, and one for the maximum sum found so far."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Apply Operations to Make Sum of Array Greater Than or Equal to k",
    "description": "Given an array of integers 'nums' and an integer 'k', apply a series of operations to elements in the array to make the sum of the modified array greater than or equal to 'k'. Each operation consists of incrementing an integer by 1. Return the minimum number of operations required to achieve this condition. If it is not possible to reach or exceed 'k', return -1.",
    "topic": "Array",
    "subtopic": "Prefix Sum",
    "tags": [
      "Array",
      "Greedy",
      "Simulation"
    ],
    "input_format": "An array of integers 'nums' and an integer 'k'.",
    "output_format": "An integer representing the minimum number of operations needed to make the sum of the array greater than or equal to 'k'. Return -1 if not possible.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= k <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4], k = 15",
        "output": "5",
        "explanation": "The initial sum is 10. We need at least 5 more to reach 15. Incrementing the largest value 4 five times will make the sum = 15."
      },
      {
        "input": "nums = [0, 0, 0], k = 1",
        "output": "3",
        "explanation": "The initial sum is 0. We need 1 more to reach k = 1. Incrementing any of the zeros three times will suffice."
      },
      {
        "input": "nums = [1, 2, 3], k = 10",
        "output": "-1",
        "explanation": "The sum of the array is 6. Even if we apply all operations, we cannot reach 10."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the sum of the array and compare it with k.",
      "Focus on the largest numbers for incrementing to minimize operations."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Minimum Length of Anagram Concatenation",
    "description": "Given an array of strings, your task is to find the minimum length of a concatenation of all possible distinct anagram pairs. An anagram pair consists of two strings that can be rearranged to form each other. The concatenation length should represent the total number of characters in those pairs. If no such pairs exist, return 0.",
    "topic": "String",
    "subtopic": "Anagram Detection",
    "tags": [
      "String",
      "Anagram",
      "Concatenation"
    ],
    "input_format": "An array of strings 'words'.",
    "output_format": "An integer representing the minimum length of the concatenation of all distinct anagram pairs.",
    "constraints": [
      "1 <= words.length <= 10^5",
      "1 <= words[i].length <= 10",
      "All input strings are lowercase English letters."
    ],
    "examples": [
      {
        "input": "words = [\"bat\", \"tab\", \"cat\", \"act\"]",
        "output": "6",
        "explanation": "The distinct anagram pairs are (\"bat\", \"tab\") and (\"cat\", \"act\"). The lengths are 3 and 3, respectively, giving a total of 6."
      },
      {
        "input": "words = [\"abc\", \"bca\", \"cde\"]",
        "output": "6",
        "explanation": "The distinct anagram pair is (\"abc\", \"bca\"). The length is 3, so the total is 3."
      },
      {
        "input": "words = [\"abc\", \"def\"]",
        "output": "0",
        "explanation": "There are no anagram pairs, so the output is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dictionary to group words by their sorted characters.",
      "Count the pairs that can be formed from each group.",
      "Remember to count distinct pairs only."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals and return an array of the merged intervals. An interval is defined as a pair of integers [start, end], where start <= end. The merged intervals should be non-overlapping and sorted in ascending order based on the start value.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Intervals"
    ],
    "input_format": "A list of intervals, where each interval is represented as a list of two integers [start, end].",
    "output_format": "A list of merged intervals in ascending order.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^5"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Intervals [1,3] and [2,6] overlap, so they are merged to [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "Intervals [1,4] and [4,5] overlap, so they are merged to [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals by their starting values.",
      "Merge intervals by comparing the current interval with the last added interval."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "House Robber",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected. If two adjacent houses were robbed on the same night, the security system will automatically contact the police. Given an integer array 'nums' representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "topic": "Dynamic Programming",
    "subtopic": "1D DP",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers nums where 0 <= nums[i] <= 400.",
    "output_format": "An integer representing the maximum amount of money you can rob without alerting the police.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 400"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "4",
        "explanation": "Robbing the first and third houses yields the maximum amount: 1 + 3 = 4."
      },
      {
        "input": "nums = [2, 7, 9, 3, 1]",
        "output": "12",
        "explanation": "Robbing the second (7) and the fourth (3) houses gives you 7 + 3 + 2 = 12."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to keep track of the maximum money."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Regular Expression Matching",
    "description": "Implement a function that performs pattern matching using regular expressions. You need to support the characters '.' and '*', where '.' matches any single character and '*' matches zero or more occurrences of the preceding element. Your function should determine if the input string matches the given pattern completely.",
    "topic": "String",
    "subtopic": "Regular Expressions",
    "tags": [
      "String",
      "Recursion",
      "Dynamic Programming"
    ],
    "input_format": "Two strings, s and p, representing the input string and the pattern respectively.",
    "output_format": "A boolean indicating whether the input string matches the pattern.",
    "constraints": [
      "1 <= s.length, p.length <= 20",
      "s and p consist of lowercase English letters, '.' and '*'.",
      "Pattern p can include '*' which cannot appear at the start."
    ],
    "examples": [
      {
        "input": "s = 'aa', p = 'a'",
        "output": "false",
        "explanation": "The pattern 'a' does not match the string 'aa'."
      },
      {
        "input": "s = 'aa', p = 'a*'",
        "output": "true",
        "explanation": "The pattern 'a*' matches the string 'aa' because '*' indicates zero or more occurrences of 'a'."
      },
      {
        "input": "s = 'ab', p = '.*'",
        "output": "true",
        "explanation": "The pattern '.*' matches any string, including 'ab'."
      },
      {
        "input": "s = 'aab', p = 'c*a*b'",
        "output": "true",
        "explanation": "'c*' can match an empty string, 'a*b' matches 'aa'."
      },
      {
        "input": "s = 'mississippi', p = 'mis*is*p*.'",
        "output": "false",
        "explanation": "The pattern does not match the string 'mississippi'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to solve this problem.",
      "Think about how to handle the '*' character effectively."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Product of Array Except Self",
    "description": "Given an integer array nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. You must solve it without using division and in O(n) time complexity. Furthermore, you should not use any extra space for the answer besides the output array.",
    "topic": "Array",
    "subtopic": "Product Calculation",
    "tags": [
      "Array",
      "Product",
      "Prefix-Suffix"
    ],
    "input_format": "An array of integers nums of length n.",
    "output_format": "An array of integers where output[i] is the product of all elements in nums except nums[i].",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-30 <= nums[i] <= 30"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "[24, 12, 8, 6]",
        "explanation": "The product of all elements except the first is 2 * 3 * 4 = 24, for the second element is 1 * 3 * 4 = 12, and so on."
      },
      {
        "input": "nums = [-1, 1, 0, -3, 3]",
        "output": "[0, 0, 9, 0, 0]",
        "explanation": "The product excluding -1 is 1 * 0 * -3 * 3 = 0, and similar calculations for others."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think of ways to calculate prefix and suffix products.",
      "Try to use two traversals of the array."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Partition Array Into Three Parts With Equal Sum",
    "description": "Given an array of integers, you need to determine whether it is possible to partition the array into three non-empty parts such that the sum of the elements in each part is equal. If it is possible, return true; otherwise, return false.",
    "topic": "Array",
    "subtopic": "Partitioning",
    "tags": [
      "Array",
      "Partitioning",
      "Sum"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A boolean indicating whether the array can be partitioned into three equal sum parts.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [0, 2, 1, 0, 0, 1, 2, 0]",
        "output": "true",
        "explanation": "The array can be partitioned into [0, 2, 1], [0, 0, 1], and [2, 0] which all sum to 3."
      },
      {
        "input": "nums = [1, 1, 1, 2, 2, 2]",
        "output": "false",
        "explanation": "It is not possible to partition this array into three parts with equal sum."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Calculate the total sum and check if it is divisible by 3.",
      "Use a prefix sum approach to find possible partitions."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Degree of an Array",
    "description": "Given a non-empty array of non-negative integers, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest length of a subarray that has the same degree as the original array. A subarray is defined as a contiguous part of the array. If there are multiple solutions, return the length of the smallest one.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Frequency",
      "Subarray"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "An integer representing the length of the smallest subarray which has the same degree as nums.",
    "constraints": [
      "1 <= nums.length <= 50,000",
      "0 <= nums[i] < 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2, 3, 1]",
        "output": "2",
        "explanation": "The degree of the array is 2 (both 1 and 2 appear twice). The smallest subarray with the same degree is [2, 2]."
      },
      {
        "input": "nums = [1, 2, 2, 3, 1, 4, 2]",
        "output": "6",
        "explanation": "The degree of the array is 3 (the number 2 appears three times). The smallest subarray with the same degree is [2, 2, 3, 1, 4, 2]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a dictionary to count the frequency of each number.",
      "Track the first and last occurrence of each number for calculating subarray length.",
      "You need to consider the degree when determining the smallest subarray."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Longest Repeating Character Replacement",
    "description": "Given a string s that consists of uppercase English letters, you can change at most k characters to any other uppercase letter. Find the length of the longest substring containing all repeating characters after performing at most k changes.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Two Pointers"
    ],
    "input_format": "A string s and an integer k.",
    "output_format": "An integer representing the length of the longest substring with all repeating characters after k changes.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of only uppercase English letters.",
      "0 <= k <= s.length"
    ],
    "examples": [
      {
        "input": "s = 'AABABBA', k = 1",
        "output": "4",
        "explanation": "Replace one 'B' with 'A', the longest substring is 'AAAA' with length 4."
      },
      {
        "input": "s = 'AAABBC', k = 2",
        "output": "5",
        "explanation": "Replace 'B' and 'C' with 'A', the longest substring is 'AAAAA' with length 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window to count characters.",
      "Keep track of the most frequently occurring character in the window."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Find Duplicate File in System",
    "description": "Given a list of paths, each represented as a string, where each path points to a file in the system, identify all the files that have duplicate content. A file's content is represented by the text after the last space in the path string. Return a list of lists, where each inner list contains the full paths of duplicate files.",
    "topic": "Hash Table",
    "subtopic": "String Manipulation",
    "tags": [
      "Hash Table",
      "String",
      "File System"
    ],
    "input_format": "A list of strings, where each string is a path in the format 'path/to/directory filename.txt content'.",
    "output_format": "A list of lists of strings, with each inner list containing the paths of files that have the same content.",
    "constraints": [
      "1 <= paths.length <= 2000",
      "1 <= paths[i].length <= 3000",
      "Content of each file will not exceed 1000 characters"
    ],
    "examples": [
      {
        "input": [
          "root/a 1.txt(abcd)",
          "root/c 2.txt(abcd)",
          "root/c/d 3.txt(efgh)"
        ],
        "output": [
          [
            "root/a 1.txt(abcd)",
            "root/c 2.txt(abcd)"
          ]
        ],
        "explanation": "The first two files have the same content 'abcd', so they are duplicates."
      },
      {
        "input": [
          "root/a 1.txt(abcd)",
          "root/b 2.txt(efgh)",
          "root/c 3.txt(abcd)"
        ],
        "output": [
          [
            "root/a 1.txt(abcd)",
            "root/c 3.txt(abcd)"
          ]
        ],
        "explanation": "The first and third files have the same content 'abcd', making them duplicates."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash table to map content to file paths.",
      "Split each path string to separate the filename and content."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Maximum Number of Vowels in a Substring of Given Length",
    "description": "Given a string s and an integer k, return the maximum number of vowels in any substring of length k. A vowel is defined as one of the following characters: 'a', 'e', 'i', 'o', 'u' (case insensitive).",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Vowels"
    ],
    "input_format": "A string s and an integer k.",
    "output_format": "An integer representing the maximum number of vowels in any substring of length k.",
    "constraints": [
      "1 <= s.length <= 100",
      "1 <= k <= s.length"
    ],
    "examples": [
      {
        "input": "s = 'abciiidef', k = 3",
        "output": "3",
        "explanation": "The substring 'iii' has 3 vowels."
      },
      {
        "input": "s = 'aeiou', k = 2",
        "output": "2",
        "explanation": "The maximum number of vowels in any substring of length 2 is 2."
      },
      {
        "input": "s = 'abcde', k = 1",
        "output": "1",
        "explanation": "The substring 'a' has 1 vowel."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sliding window approach to maintain the length of k."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Longest Consecutive Sequence",
    "description": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Consecutive Sequence"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the length of the longest consecutive sequence.",
    "constraints": [
      "0 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [100, 4, 200, 1, 3, 2]",
        "output": "4",
        "explanation": "The longest consecutive sequence is [1, 2, 3, 4], which has a length of 4."
      },
      {
        "input": "nums = [0, 0, 1, 1, 2, 2]",
        "output": "3",
        "explanation": "The longest consecutive sequence is [0, 1, 2], which has a length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash set to store elements for quick access.",
      "For each number, check if it's the start of a sequence."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Reverse Only Letters",
    "description": "Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. The words consist of uppercase and lowercase English letters, and the string can contain additional non-letter characters which should remain unchanged. The function should return the modified string.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Reverse"
    ],
    "input_format": "A single string s containing letters and non-letter characters.",
    "output_format": "A single string with only letters reversed in each word, maintaining the original structure.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of printable ASCII characters."
    ],
    "examples": [
      {
        "input": "ab-cd",
        "output": "dc-ba",
        "explanation": "The letters are reversed within the words 'ab' and 'cd' while the '-' remains unchanged."
      },
      {
        "input": "a-bC-dEf-ghIj",
        "output": "j-Ih-gfE-dCba",
        "explanation": "Each word's letters are reversed, preserving the non-letter characters in their original positions."
      },
      {
        "input": "Test1ng-Leet=code-Q!",
        "output": "Qedo1ct-eeLg=tnse-T!",
        "explanation": "The letters in 'Test1ng', 'Leet', 'code', 'Q' are reversed while non-letters remain unchanged."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider ignoring non-letter characters during reversal.",
      "You can use two pointers technique for swapping characters."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an array of integers, nums, return all the triplets [nums[a], nums[b], nums[c]] such that a, b, and c are distinct indices, and nums[a] + nums[b] + nums[c] == 0. You may return the answer in any order. The solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two-Pointers",
    "tags": [
      "Array",
      "Two-Pointers",
      "Sorting"
    ],
    "input_format": "An integer array nums of length n.",
    "output_format": "A list of unique triplets that sum up to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets [-1, -1, 2] and [-1, 0, 1] are the unique combinations that sum to zero."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no elements in the array, hence no triplets can be formed."
      },
      {
        "input": "nums = [0, 1, 1]",
        "output": "[]",
        "explanation": "There are no triplets that sum to zero in this array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sorting the array may help in avoiding duplicates.",
      "Use a two-pointer technique to find pairs that sum to a specific value."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Sum of Digit Differences of All Pairs",
    "description": "Given an integer array nums, calculate the sum of the absolute differences of all pairs of digits formed from the integers in the array. For each number, consider the digits as individual values, and then find the absolute difference between each pair of digits from all numbers. Return the sum of these differences.",
    "topic": "Array",
    "subtopic": "Mathematical Operations",
    "tags": [
      "Array",
      "Mathematics",
      "Difference"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the sum of digit differences of all pairs.",
    "constraints": [
      "1 <= nums.length <= 1000",
      "1 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [12, 34]",
        "output": "8",
        "explanation": "Digits extracted are 1, 2 from 12 and 3, 4 from 34. The pairs are (1,3), (1,4), (2,3), (2,4). The absolute differences are |1-3|=2, |1-4|=3, |2-3|=1, |2-4|=2. Total = 2 + 3 + 1 + 2 = 8."
      },
      {
        "input": "nums = [111, 222]",
        "output": "0",
        "explanation": "All digits are the same (1 and 2), thus all pair differences are 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Extract the digits from each number.",
      "Use nested loops to compare each pair of digits."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase. All inputs will be in lowercase.",
    "topic": "String",
    "subtopic": "Hashing",
    "tags": [
      "String",
      "Hashing",
      "Anagrams"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A list of lists of strings, where each sublist contains words that are anagrams of each other.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100"
    ],
    "examples": [
      {
        "input": "strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
        "output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
        "explanation": "The output can be in any order. The groups of anagrams are: ['eat', 'tea', 'ate'] and ['tan', 'nat'] and ['bat']."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "The only string is an empty string, thus it forms its own group."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "The only string is 'a', thus it forms its own group."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash table to store groups of anagrams.",
      "You can sort the characters of each string to check for anagrams."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Minimum Number of Operations to Make Word K-Periodic",
    "description": "You are given a string 's' consisting of lowercase letters and an integer 'k'. Your task is to determine the minimum number of operations required to make the string k-periodic. A string is considered k-periodic if it can be divided into segments of length k, where all segments are identical. Each operation consists of changing one character in the string to any other lowercase letter. Return the minimum number of operations needed.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Greedy",
      "Frequency Count"
    ],
    "input_format": "A string 's' (1 <= s.length <= 1000) followed by an integer 'k' (1 <= k <= s.length).",
    "output_format": "An integer representing the minimum number of operations required to make 's' k-periodic.",
    "constraints": [
      "1 <= s.length <= 1000",
      "1 <= k <= s.length"
    ],
    "examples": [
      {
        "input": "s = 'aabbcc', k = 2",
        "output": "2",
        "explanation": "To make it k-periodic, we can change the first 'a' to 'b' and one 'c' to 'a', resulting in 'bbacca' or 'bccbbc'."
      },
      {
        "input": "s = 'aaa', k = 1",
        "output": "0",
        "explanation": "The string is already 1-periodic since all characters are the same."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Group characters based on their positions in segments of length k.",
      "Consider using a frequency count to identify the most common characters in each group."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Jump Game",
    "description": "You are given an integer array nums. You are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to determine if you can reach the last index. You can assume that you can always reach the end of the array if you can jump that far.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An integer array nums where 1 <= nums.length <= 10^4 and 0 <= nums[i] <= 10^5.",
    "output_format": "A boolean value, true if you can reach the last index, false otherwise.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "true",
        "explanation": "You can jump to index 1, and then jump to the last index."
      },
      {
        "input": "nums = [3, 2, 1, 0, 4]",
        "output": "false",
        "explanation": "You will always land at index 3, which cannot jump to the last index."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how far you can jump from each position.",
      "Keep track of the furthest position you can reach."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Race Car",
    "description": "In a race car simulation, you have a car that can accelerate and decelerate. The car moves forward and backward within a bounded track. You are given an integer 'target' which represents the position you want to reach on the track. The car starts at position 0. The acceleration and deceleration are affected by the car's current speed. Your task is to return the minimum number of steps required to reach the target position from the starting position. A step consists of either accelerating (increasing speed by 1), moving forward (updating position based on speed), or decelerating (decreasing speed by 1). Consider the car moves forward when it accelerates or if its speed is positive.",
    "topic": "Dynamic Programming",
    "subtopic": "State Compression",
    "tags": [
      "Dynamic Programming",
      "BFS",
      "State Management"
    ],
    "input_format": "An integer target (-10^7 <= target <= 10^7).",
    "output_format": "An integer representing the minimum number of steps to reach the target.",
    "constraints": [
      "-10^7 <= target <= 10^7"
    ],
    "examples": [
      {
        "input": "target = 3",
        "output": "2",
        "explanation": "The optimal solution is to accelerate twice to reach position 1, then accelerate again to reach position 3."
      },
      {
        "input": "target = 2",
        "output": "3",
        "explanation": "Accelerate to reach position 1 (1 step), then decelerate to 0 (2 steps), then accelerate to reach position 2 (3 steps)."
      },
      {
        "input": "target = 5",
        "output": "5",
        "explanation": "The optimal sequence of actions will take 5 steps to reach position 5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using breadth-first search (BFS) to explore all possible positions.",
      "Take note of the speed and how it affects your position on each step.",
      "Track your visited states to avoid cycles."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Find First and Last Position of Element in Sorted Array",
    "description": "Given an array of integers sorted in non-decreasing order, find the starting and ending position of a given target value. If the target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An array of integers nums sorted in non-decreasing order followed by an integer target.",
    "output_format": "An array of two integers representing the starting and ending position of the target.",
    "constraints": [
      "0 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9",
      "nums is sorted in non-decreasing order.",
      "The target value is also an integer."
    ],
    "examples": [
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 8",
        "output": "[3, 4]",
        "explanation": "The target 8 appears at indices 3 and 4."
      },
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 6",
        "output": "[-1, -1]",
        "explanation": "The target 6 is not present in the array."
      },
      {
        "input": "nums = [], target = 0",
        "output": "[-1, -1]",
        "explanation": "An empty array returns [-1, -1] since no elements are present."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider utilizing binary search for efficient searching.",
      "After finding the target, you may need to search left and right to find boundaries."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Find All Anagrams in a String",
    "description": "Given a string s and a non-empty string p, return all the start indices of p's anagrams in s. You may return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Hash Map"
    ],
    "input_format": "Two strings s and p where 1 <= s.length <= 10^4 and 1 <= p.length <= s.length.",
    "output_format": "A list of integers representing the starting indices of the anagrams of p in s.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "1 <= p.length <= s.length",
      "Both strings consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = \"cbaebabacd\", p = \"abc\"",
        "output": "[0, 6]",
        "explanation": "The substring with start index = 0 is \"cba\", which is an anagram of \"abc\". The substring starting at index 6 is \"bac\", which is also an anagram of \"abc\"."
      },
      {
        "input": "s = \"abab\", p = \"ab\"",
        "output": "[0, 1, 2]",
        "explanation": "The substring starting at index 0 is \"ab\", which is an anagram of \"ab\". The substring starting at index 1 is \"ba\", which is also an anagram of \"ab\". The substring starting at index 2 is \"ab\"."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to count characters in p.",
      "Use a sliding window to compare character counts in s."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Valid Palindrome",
    "description": "Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring case. A palindrome is a word, phrase, number, or other sequences of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).",
    "topic": "String",
    "subtopic": "Two Pointers",
    "tags": [
      "String",
      "Palindrome",
      "Two Pointers"
    ],
    "input_format": "A single input string s.",
    "output_format": "A boolean value indicating whether the string is a palindrome.",
    "constraints": [
      "0 <= s.length <= 2 * 10^5",
      "s consists only of printable ASCII characters."
    ],
    "examples": [
      {
        "input": "A man, a plan, a canal: Panama",
        "output": "true",
        "explanation": "Ignoring non-alphanumeric characters and case, the string reads 'amanaplanacanalpanama', which is a palindrome."
      },
      {
        "input": "race a car",
        "output": "false",
        "explanation": "Ignoring non-alphanumeric characters and case, the string reads 'raceacar', which is not a palindrome."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers to compare characters from both ends of the string.",
      "You may want to use a helper function to check if a character is alphanumeric."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Consecutive Numbers",
    "description": "Given an integer array 'nums', determine if there are three consecutive integers in the array. If there are, return true; otherwise, return false. The integers can be in any order.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Consecutive"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A boolean value, true if there are three consecutive integers in the array, false otherwise.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [3, 1, 4, 2, 5]",
        "output": "true",
        "explanation": "The integers 1, 2, and 3 are consecutive."
      },
      {
        "input": "nums = [1, 2, 6, 3, 4]",
        "output": "true",
        "explanation": "The integers 1, 2, and 3 are also consecutive."
      },
      {
        "input": "nums = [7, 5, 4, 1]",
        "output": "false",
        "explanation": "There are no three consecutive integers in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a set to store the numbers for O(1) lookups.",
      "Iterate through the array and check if the current number + 1 and + 2 exist."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You have a series of stock prices for a particular stock on different days represented by an array. Your task is to determine the maximum profit you can achieve by buying on one day and selling on a different, later day. Return 0 if no profit can be made.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices where prices[i] is the price of a given stock on the ith day.",
    "output_format": "An integer representing the maximum profit achievable.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate the potential profit at each step."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. The elements should be traversed starting from the top-left corner and moving right, continuing to move in a spiral pattern until all elements have been visited.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral"
    ],
    "input_format": "A 2D array of integers representing the matrix.",
    "output_format": "A 1D array of integers representing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "1 <= m * n <= 10^4",
      "-10^5 <= matrix[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The matrix in spiral order is 1, 2, 3, 6, 9, 8, 7, 4, 5."
      },
      {
        "input": "matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]",
        "output": "[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]",
        "explanation": "The matrix in spiral order is 1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Keep track of the boundaries of the matrix.",
      "Use a loop to traverse right, down, left, and up in that order."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Kth Largest Element in an Array",
    "description": "Given an integer array nums and an integer k, return the k-th largest element in the array. Note that it is the k-th largest element in the sorted order, not the k-th distinct element.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Heap"
    ],
    "input_format": "An integer array nums followed by an integer k.",
    "output_format": "An integer representing the k-th largest element in the array.",
    "constraints": [
      "1 <= k <= nums.length",
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 1, 5, 6, 4], k = 2",
        "output": "5",
        "explanation": "The second largest element in the sorted array [1, 2, 3, 4, 5, 6] is 5."
      },
      {
        "input": "nums = [3, 2, 3, 1, 2, 4, 5, 5, 6], k = 4",
        "output": "4",
        "explanation": "The fourth largest element in the sorted array [1, 2, 2, 3, 3, 4, 5, 5, 6] is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a max heap to find the k-th largest element.",
      "You can also sort the array and access the k-th largest directly."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Maximum Repeating Substring",
    "description": "Given a string, find the maximum length of a substring that contains only repeating characters. A substring is defined as a contiguous sequence of characters within a string. If there are multiple substrings with the maximum repeating length, return the length of any one of them.",
    "topic": "String",
    "subtopic": "Substring Search",
    "tags": [
      "String",
      "Substring",
      "Counting"
    ],
    "input_format": "A string s of lowercase English letters.",
    "output_format": "An integer representing the length of the maximum repeating substring.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists only of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = \"aaabbcaaa\"",
        "output": "3",
        "explanation": "The substring 'aaa' has a length of 3, which is the maximum length of a repeating substring."
      },
      {
        "input": "s = \"abcde\"",
        "output": "1",
        "explanation": "All characters are unique, hence the maximum length of any repeating substring is 1."
      },
      {
        "input": "s = \"xxxyyyzzzzz\"",
        "output": "5",
        "explanation": "The substring 'zzzzz' has a length of 5, making it the maximum repeating substring."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a simple loop to find repeating characters.",
      "Keep track of current repeating character length and compare with the maximum found."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Number of Subsequences That Satisfy the Given Sum Condition",
    "description": "Given an array of integers and a target integer target, return the number of non-empty subsequences such that the sum of the minimum and maximum elements in the subsequence is less than or equal to target.",
    "topic": "Array",
    "subtopic": "Subsequences",
    "tags": [
      "Array",
      "Subsequence",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An integer representing the number of valid subsequences.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i] <= 10^6",
      "1 <= target <= 2 * 10^6"
    ],
    "examples": [
      {
        "input": "nums = [3, 5, 6, 7], target = 8",
        "output": "4",
        "explanation": "The valid subsequences are: [3], [5], [6], and [3, 5]."
      },
      {
        "input": "nums = [1, 2, 3, 4], target = 5",
        "output": "6",
        "explanation": "The valid subsequences are: [1], [2], [3], [4], [1, 2], and [1, 3]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the array to easily find minimum and maximum elements.",
      "Use two pointers to efficiently count valid subsequences."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A palindrome is a string that reads the same forward and backward.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Palindrome",
      "Dynamic Programming"
    ],
    "input_format": "A single string s with a length of n.",
    "output_format": "A string representing the longest palindromic substring.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consist of only digits and English letters."
    ],
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\" or \"aba\"",
        "explanation": "Both 'bab' and 'aba' are valid longest palindromic substrings."
      },
      {
        "input": "s = \"cbbd\"",
        "output": "\"bb\"",
        "explanation": "'bb' is the longest palindromic substring."
      },
      {
        "input": "s = \"a\"",
        "output": "\"a\"",
        "explanation": "The longest palindromic substring is 'a'."
      },
      {
        "input": "s = \"ac\"",
        "output": "\"a\" or \"c\"",
        "explanation": "Both 'a' and 'c' are one-character palindromic substrings."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding around the center of potential palindromes.",
      "You can also use dynamic programming to solve this problem."
    ],
    "company": "Turing"
  },
  {
    "question_id": "",
    "title": "Minimum Number of Operations to Satisfy Conditions",
    "description": "You are given an array of integers where each integer represents an operation cost. Your goal is to determine the minimum number of operations required to satisfy a given set of conditions: you must ensure that the sum of all integers in the array is equal to a target value. You can only increase or decrease the costs of operations, but each operation must correspond to one of the elements in the array. Return the minimum number of operations needed to achieve the target sum.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Min Operations"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An integer representing the minimum number of operations to satisfy the conditions.",
    "constraints": [
      "1 <= nums.length <= 100",
      "-10^4 <= nums[i] <= 10^4",
      "-10^4 <= target <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3], target = 6",
        "output": "0",
        "explanation": "The sum of the array is already 6, so no operations are needed."
      },
      {
        "input": "nums = [1, 2, 3], target = 10",
        "output": "4",
        "explanation": "We need to increase the sum by 4 to reach 10. This can be done in one operation (increase any element by 4)."
      },
      {
        "input": "nums = [1, 2, 3], target = 0",
        "output": "6",
        "explanation": "To reach a sum of 0, we need to decrease the total sum by 6. This can be done in 6 operations (decrease each element by 1)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a greedy approach to minimize operations.",
      "Think about the total sum of the array vs the target."
    ],
    "company": "Turing"
  }
]