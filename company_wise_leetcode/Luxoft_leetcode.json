[
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash table to store the difference between the target and each number."
    ],
    "company": "Luxoft"
  },
  {
    "question_id": "",
    "title": "Regular Expression Matching",
    "description": "Implement a function that takes a string 's' and a pattern 'p' and returns true if the string matches the pattern. The pattern may include the following special characters: '.' which matches any single character and '*' which matches zero or more of the preceding element. The matching should cover the entire string (not partial).",
    "topic": "String",
    "subtopic": "Pattern Matching",
    "tags": [
      "String",
      "Dynamic Programming",
      "Recursion"
    ],
    "input_format": "Two strings: s (the input string) and p (the pattern).",
    "output_format": "A boolean value indicating whether the string matches the pattern.",
    "constraints": [
      "1 <= s.length <= 20",
      "1 <= p.length <= 20"
    ],
    "examples": [
      {
        "input": "s = 'aa', p = 'a'",
        "output": "false",
        "explanation": "The pattern 'a' does not match the string 'aa' as it expects only one character."
      },
      {
        "input": "s = 'aa', p = 'a*'",
        "output": "true",
        "explanation": "The pattern 'a*' can match 'aa' because '*' allows the preceding 'a' to appear zero or more times."
      },
      {
        "input": "s = 'ab', p = '.*'",
        "output": "true",
        "explanation": "The pattern '.*' matches the string 'ab' because '.' can match any character, and '*' allows it to match as many as needed."
      },
      {
        "input": "s = 'aab', p = 'c*a*b'",
        "output": "true",
        "explanation": "'c*' can match zero occurrences of 'c', and 'a*b' matches 'aa' followed by 'b'."
      },
      {
        "input": "s = 'mississippi', p = 'mis*is*p*.'",
        "output": "false",
        "explanation": "The pattern 'mis*is*p*.' does not match 'mississippi'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using recursion with memoization.",
      "Think about how to handle the '*' character.",
      "A 2D DP table could help you track matches."
    ],
    "company": "Luxoft"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List",
    "description": "Given the head of a singly linked list, reverse the list, and return the reversed list's head.",
    "topic": "Linked List",
    "subtopic": "Reversing a Linked List",
    "tags": [
      "Linked List",
      "Reversal",
      "Pointers"
    ],
    "input_format": "The head of a singly linked list, where each node contains an integer value.",
    "output_format": "The head of the new reversed singly linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 5000].",
      "-5000 <= Node.val <= 5000"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5]",
        "output": "[5, 4, 3, 2, 1]",
        "explanation": "Reversing the linked list results in the order: 5, 4, 3, 2, 1."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "An empty list remains empty when reversed."
      },
      {
        "input": "head = [1]",
        "output": "[1]",
        "explanation": "A single node list remains unchanged when reversed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use three pointers to reverse the nodes: previous, current, and next.",
      "Iterate through the list and adjust the pointers accordingly."
    ],
    "company": "Luxoft"
  }
]