[
  {
    "question_id": "",
    "title": "Maximize Sum Of Array After K Negations",
    "description": "Given an integer array nums and an integer k, you can negate any number of elements of the array up to k times. Your goal is to maximize the sum of the array after performing at most k negations. Return the maximum possible sum you can achieve.",
    "topic": "Array",
    "subtopic": "Manipulation",
    "tags": [
      "Array",
      "Greedy",
      "Sorting"
    ],
    "input_format": "An integer array nums and an integer k.",
    "output_format": "An integer representing the maximum possible sum of the array after performing at most k negations.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-100 <= nums[i] <= 100",
      "0 <= k <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [4, 2, 3], k = 1",
        "output": "5",
        "explanation": "Negate the 2 to get the array [4, -2, 3]. The sum is 4 + (-2) + 3 = 5."
      },
      {
        "input": "nums = [3, -1, 0, 2], k = 3",
        "output": "6",
        "explanation": "Negate -1 and 0, resulting in the array [3, 1, 0, 2]. The sum is 3 + 1 + 0 + 2 = 6."
      },
      {
        "input": "nums = [2, -3, -1, 5, -4], k = 2",
        "output": "13",
        "explanation": "Negate -3 and -4 to get the array [2, 3, -1, 5, 4]. The sum is 2 + 3 + (-1) + 5 + 4 = 13."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider the benefit of negating the smallest absolute values first.",
      "Sorting the array can help you quickly identify which elements to negate.",
      "After negating k elements, calculate the sum using the modified array."
    ],
    "company": "Druva"
  },
  {
    "question_id": "",
    "title": "Reorganize String",
    "description": "Given a string s, rearrange the characters in the string so that no two adjacent characters are the same. If it is not possible, return an empty string. The rearranged string should have the characters in the same proportion as they appear in the original string.",
    "topic": "String",
    "subtopic": "Sorting and Rearranging",
    "tags": [
      "String",
      "Rearrangement",
      "Greedy"
    ],
    "input_format": "A string s consisting of uppercase and lowercase letters.",
    "output_format": "A rearranged string if possible, otherwise an empty string.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of only letters."
    ],
    "examples": [
      {
        "input": "s = \"aab\"",
        "output": "aba",
        "explanation": "One possible rearrangement is \"aba\", where no adjacent characters are the same."
      },
      {
        "input": "s = \"aaab\"",
        "output": "",
        "explanation": "It is not possible to rearrange the characters so that no two adjacent characters are the same."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a max heap to keep track of character frequencies.",
      "You may need to check if the most frequent character is more than half of the total characters."
    ],
    "company": "Druva"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "You are given a rotated sorted array and a target value. Your task is to find the index of the target in the array. If the target is not found, return -1. The array does not contain duplicates. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An integer representing the index of target in nums or -1 if the target is not found.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "All elements in nums are distinct."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "The target 0 is present at index 4."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "The target 3 is not present in the array."
      },
      {
        "input": "nums = [1], target = 0",
        "output": "-1",
        "explanation": "The target 0 is not present in the array which contains only 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of the rotated array.",
      "Use binary search strategy carefully."
    ],
    "company": "Druva"
  },
  {
    "question_id": "",
    "title": "Longest Increasing Subsequence",
    "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
    "topic": "Dynamic Programming",
    "subtopic": "Longest Increasing Subsequence",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Binary Search"
    ],
    "input_format": "An array of integers nums representing the sequence.",
    "output_format": "An integer representing the length of the longest increasing subsequence.",
    "constraints": [
      "1 <= nums.length <= 2500",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [10,9,2,5,3,7,101,18]",
        "output": "4",
        "explanation": "The longest increasing subsequence is [2,3,7,101], hence the length is 4."
      },
      {
        "input": "nums = [0,1,0,3,2,3]",
        "output": "4",
        "explanation": "The longest increasing subsequence is [0,1,2,3], hence the length is 4."
      },
      {
        "input": "nums = [7,7,7,7,7,7,7]",
        "output": "1",
        "explanation": "The longest increasing subsequence has only one element since all elements are the same."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to build the solution progressively.",
      "Binary search may help in improving efficiency."
    ],
    "company": "Druva"
  }
]