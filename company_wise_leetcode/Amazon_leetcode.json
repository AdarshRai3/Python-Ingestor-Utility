[
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Map",
    "tags": [
      "Array",
      "Hash Map",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Assume that there is exactly one solution."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash map to store the indices of the numbers you have seen.",
      "Check if the complement (target - current number) exists in the hash map."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of walls, calculate how much rain water can be trapped after it rains. The width of each wall is 1 unit. You need to return the total amount of water trapped.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Water Trapping"
    ],
    "input_format": "An array of non-negative integers height, where height[i] represents the height of the wall at index i.",
    "output_format": "An integer representing the total amount of trapped rainwater.",
    "constraints": [
      "2 <= height.length <= 10^5",
      "0 <= height[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The walls trap 6 units of water, between heights 1, 2, and 3."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The walls trap 9 units of water throughout the structure."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use two pointers to evaluate the left and right boundaries.",
      "Calculate trapped water based on the height of the walls."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters. For example, for the input 'abcabcbb', the answer is 3, because the longest substring is 'abc'.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Hash Map"
    ],
    "input_format": "A string s consisting of English letters, digits, symbols and spaces.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 10^5",
      "s consists of printable ASCII characters"
    ],
    "examples": [
      {
        "input": "s = 'abcabcbb'",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'abc', which has a length of 3."
      },
      {
        "input": "s = 'bbbbb'",
        "output": "1",
        "explanation": "The longest substring without repeating characters is 'b', which has a length of 1."
      },
      {
        "input": "s = 'pwwkew'",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'wke', which has a length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sliding window approach.",
      "Use a set to track characters in the current substring."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Merge Sorted Array",
    "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order. You need to merge nums2 into nums1 as one sorted array. The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has a size equal to m + n and is initialized with all elements as 0, which indicates that you can overwrite it. After merging, the elements in nums1 should also be in non-decreasing order.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Sorting",
      "Merge"
    ],
    "input_format": "Two integer arrays nums1 and nums2, where nums1 has a length of m + n and is partially filled with m elements followed by n zeros.",
    "output_format": "The merged array in nums1, which should be sorted in non-decreasing order.",
    "constraints": [
      "0 <= m, n <= 200",
      "1 <= m + n <= 200",
      "-10^9 <= nums1[i], nums2[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3",
        "output": "[1, 2, 2, 3, 5, 6]",
        "explanation": "After merging, the sorted array will be [1, 2, 2, 3, 5, 6]."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "Since nums2 is empty, the result is simply [1]."
      },
      {
        "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
        "output": "[1]",
        "explanation": "nums1 is empty (with valid size), so we should fill it with nums2, resulting in [1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to track the current position of elements in nums1 and nums2."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once.",
    "topic": "Hash Table",
    "subtopic": "String Grouping",
    "tags": [
      "String",
      "Hash Table",
      "Anagrams"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A list of lists of strings, where each sublist contains grouped anagrams.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "explanation": "The input strings can be arranged into three groups: 'bat', 'nat' and 'tan', 'ate', 'eat' and 'tea'."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "The only input string is an empty string, which forms a group on its own."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "The single input string 'a' forms a group by itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort each string to identify anagrams.",
      "Use a hashmap to group sorted strings."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contains a single digit. Add the two numbers and return it as a linked list.",
    "topic": "Linked List",
    "subtopic": "Addition of Linked Lists",
    "tags": [
      "Linked List",
      "Math",
      "Two Pointers"
    ],
    "input_format": "The input consists of two linked lists where each linked list represents a non-negative integer in reverse order.",
    "output_format": "Return a linked list representing the sum of the two numbers in reverse order.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the input lists do not have leading zeros."
    ],
    "examples": [
      {
        "input": "l1 = [2, 4, 3], l2 = [5, 6, 4]",
        "output": "[7, 0, 8]",
        "explanation": "342 + 465 = 807. The sum is returned as a linked list in reverse order."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "0 + 0 = 0. The sum is returned as a linked list containing zero."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to handle carries as you iterate through the lists."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if the brackets are closed in the correct order. Every opening bracket must have a corresponding closing bracket of the same type.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A string s containing parentheses characters.",
    "output_format": "A boolean value indicating whether the string is valid or not.",
    "constraints": [
      "0 <= s.length <= 10^4",
      "s consists of parentheses only '()[]{}'."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The string consists of a pair of matching parentheses."
      },
      {
        "input": "s = '([{}])'",
        "output": "true",
        "explanation": "All brackets are properly closed and nested."
      },
      {
        "input": "s = '({[})]'",
        "output": "false",
        "explanation": "The brackets are not closed in the correct order."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "Check if the closing bracket matches the top of the stack."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A palindromic substring is a substring that reads the same forward and backward.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A single string s, where 1 <= s.length <= 1000.",
    "output_format": "A string representing the longest palindromic substring in s.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only digits and English letters."
    ],
    "examples": [
      {
        "input": "s = 'babad'",
        "output": "'bab'",
        "explanation": "The longest palindromic substring is 'bab'. 'aba' is also a valid answer."
      },
      {
        "input": "s = 'cbbd'",
        "output": "'bb'",
        "explanation": "The longest palindromic substring is 'bb'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding from the center for potential palindromes.",
      "Use dynamic programming to store and check substrings."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an array of integers, nums, return all the unique triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A list of unique triplets that sum up to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that sum to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no numbers to form a triplet."
      },
      {
        "input": "nums = [0, 0, 0]",
        "output": "[[0, 0, 0]]",
        "explanation": "The only triplet formed is [0, 0, 0]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the array first to make it easier to find triplets.",
      "Use two pointers to find if a triplet exists for a fixed number."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. For example, if you have intervals [1, 3], [2, 6], [8, 10], and [15, 18], you should return [1, 6], [8, 10], and [15, 18].",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Intervals"
    ],
    "input_format": "A list of intervals, where each interval is represented by a list of two integers [start, end].",
    "output_format": "A list of merged intervals.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "[[1, 3], [2, 6], [8, 10], [15, 18]]",
        "output": "[[1, 6], [8, 10], [15, 18]]",
        "explanation": "The intervals [1, 3] and [2, 6] overlap, so they are merged into [1, 6]. The other intervals do not overlap."
      },
      {
        "input": "[[1, 4], [4, 5]]",
        "output": "[[1, 5]]",
        "explanation": "The intervals [1, 4] and [4, 5] touch at the point 4, so they are merged into [1, 5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on their starting values.",
      "Use a list to keep track of the merged intervals."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (min(m,n))).",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Median"
    ],
    "input_format": "Two sorted arrays nums1 and nums2.",
    "output_format": "A float representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= nums1.length <= 1000",
      "0 <= nums2.length <= 1000",
      "Both nums1 and nums2 are sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.0",
        "explanation": "The combined sorted array is [1, 2, 3], thus the median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.5",
        "explanation": "The combined sorted array is [1, 2, 3, 4], thus the median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider partitioning the arrays.",
      "The median will depend on the total length of the combined array.",
      "Binary search can be utilized to find the correct partition."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "Given n non-negative integers a1, a2, ..., an where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of a line i is at (i, ai) and (i, 0). Find two lines, which together with the x-axis forms a container, such that the container contains the most water.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "input_format": "An array of integers heights representing the height of each line.",
    "output_format": "An integer representing the maximum area of water that can be contained.",
    "constraints": [
      "2 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The lines at indices 1 and 8 (heights 8 and 7) form a container with width 7 and height 7, so the area is 7 * 7 = 49."
      },
      {
        "input": "heights = [1,1]",
        "output": "1",
        "explanation": "The only lines are at indices 0 and 1 with height 1, so the area is 1 * 1 = 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Start with two pointers at each end of the array.",
      "Calculate the area and move the pointer pointing to the shorter line inward."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function that finds the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Prefix",
      "Manipulation"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A string representing the longest common prefix.",
    "constraints": [
      "0 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "All input strings are lowercase letters a-z."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The longest common prefix is \"fl\"."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among the strings."
      },
      {
        "input": "strs = []",
        "output": "\"\"",
        "explanation": "There are no strings in the array, so the prefix is empty."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "If the array is empty, return an empty string.",
      "Start by assuming the first string is the common prefix.",
      "Iteratively compare the assumed prefix with each string."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of k linked lists, each linked list is sorted in ascending order. Merge all the linked lists into one sorted linked list and return it. The linked list should be formed by splicing together the nodes of the given k lists.",
    "topic": "Linked List",
    "subtopic": "Merging",
    "tags": [
      "Linked List",
      "Merge",
      "Sorting"
    ],
    "input_format": "An array of k linked list nodes, where each node has a value and a next pointer to the next node in the list.",
    "output_format": "A linked list node representing the head of the merged sorted linked list.",
    "constraints": [
      "0 <= k <= 10^4",
      "0 <= N <= 10^4, where N is the total number of nodes in all k lists combined",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]",
        "explanation": "The merged linked list is 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6."
      },
      {
        "input": "lists = []",
        "output": "[]",
        "explanation": "Since the input is an empty list, the output should also be an empty list."
      },
      {
        "input": "lists = [[-1,5],[1,3]]",
        "output": "[-1,1,3,5]",
        "explanation": "The merged linked list is -1 -> 1 -> 3 -> 5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a heap (priority queue) to efficiently merge multiple lists.",
      "Remember to handle the case when one of the lists is empty."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Kadane's Algorithm"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum sum of the contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The contiguous subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The only element is 1, which has the largest sum."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The contiguous subarray [5,4,-1,7,8] has the largest sum 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Kadane's algorithm.",
      "Maintain the current maximum sum and check if adding the current element increases it."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "topic": "Dynamic Programming",
    "subtopic": "Fibonacci Sequence",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Fibonacci"
    ],
    "input_format": "An integer n representing the number of steps in the staircase.",
    "output_format": "An integer representing the number of distinct ways to climb to the top.",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: 1 step + 1 step or 2 steps."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, or 2 steps + 1 step."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Think about how you can build the solution using the previous steps.",
      "Consider using a dynamic programming approach to solve this problem."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Jump Game",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to determine if you are able to reach the last index starting from the first index. You can assume that you can always jump to the last index if you are at the last index itself.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "A boolean value: true if you can reach the last index, false otherwise.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "true",
        "explanation": "Starting at index 0, you can jump to index 1 (step 1) and then jump to index 4 (step 2)."
      },
      {
        "input": "nums = [3, 2, 1, 0, 4]",
        "output": "false",
        "explanation": "You cannot reach the last index because from index 2 you cannot move forward to reach index 3 (which is 0)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how far you can jump from each index.",
      "Use a greedy algorithm to check if you can reach the end."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Letter Combinations of a Phone Number",
    "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n1 -> None\n2 -> a, b, c\n3 -> d, e, f\n4 -> g, h, i\n5 -> j, k, l\n6 -> m, n, o\n7 -> p, q, r, s\n8 -> t, u, v\n9 -> w, x, y, z\n\nThe combinations can be returned in any order.",
    "topic": "Backtracking",
    "subtopic": "Combinatorial Generation",
    "tags": [
      "Backtracking",
      "String",
      "Combination"
    ],
    "input_format": "A string digits representing the digit buttons on a phone.",
    "output_format": "A list of all possible letter combinations.",
    "constraints": [
      "0 <= digits.length <= 4",
      "digits[i] is a digit from '2' to '9'"
    ],
    "examples": [
      {
        "input": "digits = '23'",
        "output": "['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']",
        "explanation": "The digit '2' maps to 'abc', and '3' maps to 'def'. Combinations of these letters are generated."
      },
      {
        "input": "digits = ''",
        "output": "[]",
        "explanation": "An empty input should return an empty list since there are no combinations to form."
      },
      {
        "input": "digits = '2'",
        "output": "['a', 'b', 'c']",
        "explanation": "The digit '2' maps to 'abc', so the output is the list of those letters."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a backtracking approach to build combinations.",
      "Consider the mapping of digits to letters.",
      "Keep the recursion small and manage the letters as you go."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Generate Parentheses",
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. A well-formed parentheses sequence is one in which every opening parenthesis has a matching closing parenthesis, and the parentheses are closed in the correct order.",
    "topic": "Backtracking",
    "subtopic": "Combinatorial Generation",
    "tags": [
      "Backtracking",
      "Recursion",
      "String"
    ],
    "input_format": "An integer n representing the number of pairs of parentheses.",
    "output_format": "A list of strings representing all combinations of well-formed parentheses.",
    "constraints": [
      "0 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]",
        "explanation": "The combinations of well-formed parentheses for 3 pairs are generated."
      },
      {
        "input": "n = 1",
        "output": "[\"()\"]",
        "explanation": "Only one combination is available for 1 pair of parentheses."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use recursion to explore all possible combinations.",
      "Track the number of opened and closed parentheses."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order. The spiral order starts from the top left corner of the matrix and proceeds right, then down, then left, and finally up, repeating this process until all elements have been visited.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral"
    ],
    "input_format": "A 2D array of integers matrix with dimensions m x n.",
    "output_format": "A list of integers representing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "1 <= m * n <= 10^4",
      "-10^5 <= matrix[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[1,2,3,6,9,8,7,4,5]",
        "explanation": "The elements are collected in the following spiral order: 1 \u2192 2 \u2192 3 \u2192 6 \u2192 9 \u2192 8 \u2192 7 \u2192 4 \u2192 5."
      },
      {
        "input": "matrix = [[1,2],[3,4]]",
        "output": "[1,2,4,3]",
        "explanation": "The elements are collected in the following spiral order: 1 \u2192 2 \u2192 4 \u2192 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Keep track of the boundaries of the matrix as you traverse.",
      "Use a direction variable to control the movement: right, down, left, up."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Roman to Integer",
    "description": "Given a string representing a Roman numeral, convert it to an integer. The input string is guaranteed to be a valid Roman numeral in the range from 1 to 3999.",
    "topic": "String",
    "subtopic": "Conversion",
    "tags": [
      "String",
      "Conversion",
      "Greedy"
    ],
    "input_format": "A string s representing a Roman numeral.",
    "output_format": "An integer representing the equivalent value of the Roman numeral.",
    "constraints": [
      "1 <= s.length <= 15",
      "s is guaranteed to be a valid Roman numeral within the range [1, 3999]."
    ],
    "examples": [
      {
        "input": "s = \"III\"",
        "output": "3",
        "explanation": "The Roman numeral 'III' represents the integer 3."
      },
      {
        "input": "s = \"IV\"",
        "output": "4",
        "explanation": "The Roman numeral 'IV' represents the integer 4."
      },
      {
        "input": "s = \"IX\"",
        "output": "9",
        "explanation": "The Roman numeral 'IX' represents the integer 9."
      },
      {
        "input": "s = \"LVIII\"",
        "output": "58",
        "explanation": "The Roman numeral 'LVIII' represents the integer 58."
      },
      {
        "input": "s = \"MCMXCIV\"",
        "output": "1994",
        "explanation": "The Roman numeral 'MCMXCIV' represents the integer 1994."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Roman numerals are based on the combination of letters from the Latin alphabet.",
      "If a smaller numeral appears before a larger one, it should be subtracted."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "You are given an integer array 'nums' that is sorted in ascending order, but is rotated at an unknown pivot index. Write a function to search for a target value in this array. If the target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Binary Search",
    "subtopic": "Searching in Rotated Arrays",
    "tags": [
      "Binary Search",
      "Array",
      "Searching"
    ],
    "input_format": "An array of integers nums, followed by an integer target.",
    "output_format": "An integer representing the index of target in nums, or -1 if target is not found.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "1 <= nums[i] <= 10^4",
      "All integers in nums are unique.",
      "nums is guaranteed to be rotated at some pivot."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "The target 0 is located at index 4."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "The target 3 is not present in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search in a modified way.",
      "Determine which part of the array is sorted."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Palindrome Number",
    "description": "Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome, while 123 is not.",
    "topic": "Mathematics",
    "subtopic": "Number Theory",
    "tags": [
      "Palindrome",
      "Mathematics",
      "Number Theory"
    ],
    "input_format": "A single integer x.",
    "output_format": "Return true if the integer is a palindrome, otherwise return false.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 121",
        "output": "true",
        "explanation": "121 reads the same backward as forward."
      },
      {
        "input": "x = -121",
        "output": "false",
        "explanation": "Reading -121 backward gives 121- which is not the same as -121."
      },
      {
        "input": "x = 10",
        "output": "false",
        "explanation": "10 reads backward as 01 which is not the same as 10."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how to reverse the integer and compare it with the original."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Merge Two Sorted Lists",
    "description": "You are given the heads of two sorted linked lists. Merge the two lists into one sorted list. The merged list should be made by splicing together the nodes of the first two lists. Return the head of the new sorted list.",
    "topic": "Linked List",
    "subtopic": "Merging",
    "tags": [
      "Linked List",
      "Merge",
      "Sorting"
    ],
    "input_format": "The input consists of two ListNode objects, representing the heads of the two sorted linked lists.",
    "output_format": "Return a ListNode object representing the head of the merged sorted linked list.",
    "constraints": [
      "The number of nodes in each list is in the range [0, 50].",
      "1 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "l1 = [1, 2, 4], l2 = [1, 3, 4]",
        "output": "[1, 1, 2, 3, 4, 4]",
        "explanation": "The merged list is 1 -> 1 -> 2 -> 3 -> 4 -> 4."
      },
      {
        "input": "l1 = [], l2 = [0]",
        "output": "[0]",
        "explanation": "The merged list is just 0."
      },
      {
        "input": "l1 = [], l2 = []",
        "output": "[]",
        "explanation": "Both lists are empty, so the merged list is also empty."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a dummy node to simplify the merging process.",
      "Iterate through both lists and compare elements to maintain the sorted order."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Reverse Integer",
    "description": "Given a 32-bit signed integer, reverse the digits of the integer. For example, if the input is 123, the output should be 321. However, if the reversed integer overflows, return 0. Note that the negative sign should be preserved.",
    "topic": "Math",
    "subtopic": "Integer Manipulation",
    "tags": [
      "Integer",
      "Math",
      "String"
    ],
    "input_format": "A single integer x, where -2^31 <= x <= 2^31 - 1.",
    "output_format": "An integer representing the reversed digits of the input integer, or 0 if the result overflows.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 123",
        "output": "321",
        "explanation": "Reversing 123 gives us 321."
      },
      {
        "input": "x = -123",
        "output": "-321",
        "explanation": "Reversing -123 gives us -321."
      },
      {
        "input": "x = 120",
        "output": "21",
        "explanation": "Reversing 120 gives us 21, as leading zeros are not counted."
      },
      {
        "input": "x = 1534236469",
        "output": "0",
        "explanation": "Reversing 1534236469 causes overflow for a 32-bit signed integer, so the output is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to handle overflow conditions.",
      "Use integer division and modulus to extract digits.",
      "Remember to handle negative numbers carefully."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Rotate Image",
    "description": "You are given an n x n 2D matrix representing an image. You need to rotate the image by 90 degrees (clockwise) in-place. This means you should not use any additional matrix to perform the rotation.",
    "topic": "Matrix",
    "subtopic": "In-place Matrix Manipulation",
    "tags": [
      "Matrix",
      "In-place",
      "Rotation"
    ],
    "input_format": "An n x n 2D array of integers representing the image.",
    "output_format": "The input 2D array, modified in-place to represent the rotated image.",
    "constraints": [
      "1 <= n <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "matrix = [[7, 4, 1], [8, 5, 2], [9, 6, 3]]",
        "explanation": "Rotating the given matrix 90 degrees clockwise gives the new arrangement."
      },
      {
        "input": "matrix = [[5]]",
        "output": "matrix = [[5]]",
        "explanation": "A single element matrix remains the same after rotation."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the layers of the matrix and how they can be rotated.",
      "You can rotate elements layer by layer."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array",
    "description": "Given a sorted array of integers, you need to remove the duplicates in-place such that each element appears only once and returns the new length of the array. Do not allocate extra space for another array; you must do this in-place with O(1) extra memory.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An integer array nums sorted in non-decreasing order.",
    "output_format": "An integer representing the new length of the array after removing duplicates.",
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-100 <= nums[i] <= 100",
      "nums is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums = [1,1,2]",
        "output": "2",
        "explanation": "After removing duplicates, the array will be [1, 2]. The new length is 2."
      },
      {
        "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
        "output": "5",
        "explanation": "After removing duplicates, the array will be [0, 1, 2, 3, 4]. The new length is 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to keep track of the unique elements."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Word Search",
    "description": "Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where 'adjacent' cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "topic": "Backtracking",
    "subtopic": "Matrix Search",
    "tags": [
      "Backtracking",
      "Depth-First Search",
      "Matrix"
    ],
    "input_format": "A board represented as a 2D array of characters and a string word.",
    "output_format": "A boolean value indicating whether the word exists in the grid.",
    "constraints": [
      "1 <= board.length, board[i].length <= 200",
      "board[i][j] is a lowercase English letter.",
      "1 <= word.length <= 600"
    ],
    "examples": [
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "ABCCED"
        },
        "output": "true",
        "explanation": "The word 'ABCCED' can be found in the grid."
      },
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "SEE"
        },
        "output": "true",
        "explanation": "The word 'SEE' can be found by traversing downwards."
      },
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "ABCB"
        },
        "output": "false",
        "explanation": "The word 'ABCB' cannot be formed in the grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to explore all possible paths from each cell.",
      "Use Depth-First Search (DFS) for backtracking."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Next Permutation",
    "description": "Implement the next permutation algorithm, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order). The replacement must be done in place and use only constant extra memory.",
    "topic": "Array",
    "subtopic": "Permutation",
    "tags": [
      "Array",
      "Permutation",
      "In-place"
    ],
    "input_format": "A list of integers nums, representing the current permutation.",
    "output_format": "Modify nums in place to represent the next permutation.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[1, 3, 2]",
        "explanation": "The next permutation of [1, 2, 3] is [1, 3, 2]."
      },
      {
        "input": "nums = [3, 2, 1]",
        "output": "[1, 2, 3]",
        "explanation": "The next permutation of [3, 2, 1] is [1, 2, 3] as it is the last permutation."
      },
      {
        "input": "nums = [1, 1, 5]",
        "output": "[1, 5, 1]",
        "explanation": "The next permutation of [1, 1, 5] is [1, 5, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Find the largest index k such that nums[k] < nums[k + 1].",
      "Find the largest index l such that nums[k] < nums[l].",
      "Swap nums[k] and nums[l].",
      "Reverse the sequence from nums[k + 1] to the end."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Largest Rectangle in Histogram",
    "description": "Given an array of integers representing the heights of bars in a histogram, return the area of the largest rectangle that can be formed within that histogram. The rectangle can be formed by using one or more contiguous bars and must have a height of at least the height of the shortest bar in that range.",
    "topic": "Array",
    "subtopic": "Stack",
    "tags": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "input_format": "An array of integers heights where heights[i] represents the height of the i-th bar.",
    "output_format": "An integer representing the area of the largest rectangle that can be formed in the histogram.",
    "constraints": [
      "1 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [2, 1, 5, 6, 2, 3]",
        "output": "10",
        "explanation": "The largest rectangle can be formed using the heights of 5 and 6. The area is 5 * 2 = 10."
      },
      {
        "input": "heights = [2, 4]",
        "output": "4",
        "explanation": "The largest rectangle can be formed using the heights of 2 and 4. The area is 2 * 2 = 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a stack to keep track of the indices of the bars.",
      "When processing each bar, calculate area with the bar at the top of the stack as the smallest height.",
      "The largest rectangle can span consecutive bars."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Valid Sudoku",
    "description": "Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition, each column must contain the digits 1-9 without repetition, and each of the 9 3x3 sub-boxes of the grid must also contain the digits 1-9 without repetition. An empty cell is represented by the character '.'",
    "topic": "Array",
    "subtopic": "Grid Validation",
    "tags": [
      "Array",
      "Grid",
      "Validation"
    ],
    "input_format": "A 2D array of characters representing the Sudoku board.",
    "output_format": "A boolean value indicating whether the Sudoku board is valid.",
    "constraints": [
      "board.length == 9",
      "board[i].length == 9",
      "board[i][j] is either a digit '1' to '9' or '.'"
    ],
    "examples": [
      {
        "input": "[['5', '3', '.', '.', '7', '.', '.', '.', '.'], ['6', '.', '.', '1', '9', '5', '.', '.', '.'], ['.', '9', '8', '.', '.', '.', '.', '6', '.'], ['8', '.', '.', '.', '6', '.', '.', '.', '3'], ['4', '.', '.', '8', '.', '3', '.', '.', '1'], ['7', '.', '.', '.', '2', '.', '.', '.', '6'], ['.', '6', '.', '.', '.', '.', '2', '8', '.'], ['.', '.', '.', '4', '1', '9', '.', '.', '5'], ['.', '.', '.', '.', '8', '.', '.', '7', '9']]",
        "output": "true",
        "explanation": "The Sudoku board satisfies all the conditions for a valid Sudoku."
      },
      {
        "input": "[['8', '3', '.', '.', '7', '.', '.', '.', '.'], ['6', '.', '.', '1', '9', '5', '.', '.', '.'], ['.', '9', '8', '.', '.', '.', '.', '6', '.'], ['8', '.', '.', '.', '6', '.', '.', '.', '3'], ['4', '.', '.', '8', '.', '3', '.', '.', '1'], ['7', '.', '.', '.', '2', '.', '.', '.', '6'], ['.', '6', '.', '.', '.', '.', '2', '8', '.'], ['.', '.', '.', '4', '1', '9', '.', '.', '5'], ['.', '.', '.', '.', '8', '.', '.', '7', '9']]",
        "output": "false",
        "explanation": "The number '8' appears twice in the first column, making the Sudoku invalid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use sets to track seen numbers for rows, columns, and sub-boxes.",
      "An empty cell can be ignored during validation.",
      "Check each number against its respective row, column, and box."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Set Matrix Zeroes",
    "description": "Given a m x n matrix, if an element is 0, set its entire row and column to 0. You must do this in place. Do not use any extra space for another matrix.",
    "topic": "Matrix",
    "subtopic": "In-place Modification",
    "tags": [
      "Matrix",
      "Array Manipulation",
      "In-place"
    ],
    "input_format": "A 2D matrix represented as a list of lists containing integers.",
    "output_format": "The modified matrix after setting rows and columns to zero.",
    "constraints": [
      "m == matrix.length",
      "n == matrix[0].length",
      "1 <= m, n <= 200",
      "-10^5 <= matrix[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": "The element at (1,1) is 0, setting its entire row and column to 0 results in the modified matrix."
      },
      {
        "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
        "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
        "explanation": "The elements at (0,0) and (0,3) are 0, setting their respective rows and columns to 0 yields the modified matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using the first row and column to track the rows and columns that should be zeroed.",
      "Iterate through the matrix to mark the zero rows and columns."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array nums, return the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses O(1) extra space.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Mathematical"
    ],
    "input_format": "An array of integers nums, where 1 <= nums.length <= 10^5 and -10^9 <= nums[i] <= 10^9.",
    "output_format": "An integer representing the smallest missing positive integer.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3, 4, -1, 1]",
        "output": "2",
        "explanation": "The smallest missing positive integer is 2."
      },
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "The smallest missing positive integer is 3."
      },
      {
        "input": "nums = [7, 8, 9, 11, 12]",
        "output": "1",
        "explanation": "The smallest missing positive integer is 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the properties of positive integers and their indices.",
      "In-place swapping can help in rearranging elements."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Find First and Last Position of Element in Sorted Array",
    "description": "Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Binary Search",
    "subtopic": "Searching in Sorted Array",
    "tags": [
      "Array",
      "Binary Search",
      "Searching"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the starting and ending position of the target.",
    "constraints": [
      "0 <= nums.length <= 10^5",
      "nums is a non-decreasing array.",
      "-10^9 <= nums[i], target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [5,7,7,8,8,10], target = 8",
        "output": "[3, 4]",
        "explanation": "The target value 8 appears first at index 3 and last at index 4."
      },
      {
        "input": "nums = [5,7,7,8,8,10], target = 6",
        "output": "[-1, -1]",
        "explanation": "The target value 6 is not present in the array."
      },
      {
        "input": "nums = [], target = 0",
        "output": "[-1, -1]",
        "explanation": "The array is empty, hence target cannot be found."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to find the first and last positions.",
      "You may want to create two separate functions for finding the bounds."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Subsets",
    "description": "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. You may return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Subsets Generation",
    "tags": [
      "Backtracking",
      "Subset",
      "Recursion"
    ],
    "input_format": "An integer array nums containing unique elements.",
    "output_format": "A list of lists, where each list represents a subset of nums.",
    "constraints": [
      "1 <= nums.length <= 10",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]",
        "explanation": "All possible subsets are formed from the set {1, 2, 3}."
      },
      {
        "input": "nums = [0]",
        "output": "[[], [0]]",
        "explanation": "Only two subsets can be formed from a single element set."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to generate all subsets.",
      "An empty subset is always included in the power set."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Jump Game II",
    "description": "You are given an integer array nums. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Write a function that returns the minimum number of jumps needed to reach the last index. If it is not possible to reach the last index, return -1.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithms",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An integer array nums where nums[i] is the maximum jump length from that position.",
    "output_format": "An integer representing the minimum number of jumps to reach the last index, or -1 if it is not possible.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "2",
        "explanation": "The minimum number of jumps to reach the last index is 2: jump from index 0 to index 1, and then from index 1 to index 4."
      },
      {
        "input": "nums = [2, 3, 0, 1, 4]",
        "output": "2",
        "explanation": "You can jump from index 0 to index 1 (2 -> 3) and then from index 1 to index 4 (3 -> 4), which reaches the end in 2 jumps."
      },
      {
        "input": "nums = [0, 1]",
        "output": "-1",
        "explanation": "It is not possible to jump anywhere because the first position is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how many jumps you can make at each index.",
      "Use a greedy approach to always jump to the furthest reachable index."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "4Sum",
    "description": "Given an array nums of n integers and an integer target, return all unique quadruplets (a, b, c, d) such that a + b + c + d = target. You may return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "A list of unique quadruplets, where each quadruplet is a list of four integers.",
    "constraints": [
      "0 <= n <= 200",
      "-10^9 <= nums[i] <= 10^9",
      "The solution set must not contain duplicate quadruplets."
    ],
    "examples": [
      {
        "input": "nums = [1, 0, -1, 0, -2, 2], target = 0",
        "output": "[[-2, -1, 0, 1], [-2, 0, 0, 2], [-1, 0, 0, 1]]",
        "explanation": "The unique quadruplets that sum to 0 are [-2, -1, 0, 1] and [-2, 0, 0, 2]."
      },
      {
        "input": "nums = [2, 2, 2, 2, 2], target = 8",
        "output": "[[2, 2, 2, 2]]",
        "explanation": "The only quadruplet that sums to 8 is [2, 2, 2, 2]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a set to avoid duplicates.",
      "Try sorting the array first.",
      "Use a two-pointer approach to improve the efficiency."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Pow(x, n)",
    "description": "Implement the function 'myPow' that calculates x raised to the power of n (x^n), where x is a floating-point number and n is an integer. You must solve this problem in O(log n) time complexity.",
    "topic": "Mathematics",
    "subtopic": "Exponentiation",
    "tags": [
      "Math",
      "Recursion",
      "Binary Search"
    ],
    "input_format": "Two values: a floating-point number x and an integer n.",
    "output_format": "A floating-point number representing x raised to the power of n.",
    "constraints": [
      "The base x is a floating-point number where -10^4 <= x <= 10^4.",
      "The exponent n is an integer where -10^4 <= n <= 10^4."
    ],
    "examples": [
      {
        "input": "x = 2.0, n = 10",
        "output": "1024.0",
        "explanation": "2 raised to the power of 10 is 1024."
      },
      {
        "input": "x = 2.1, n = 3",
        "output": "9.261",
        "explanation": "2.1 raised to the power of 3 is approximately 9.261."
      },
      {
        "input": "x = 2.0, n = -2",
        "output": "0.25",
        "explanation": "2.0 raised to the power of -2 equals 1/(2^2) = 1/4 = 0.25."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion for a more efficient solution.",
      "You can reduce the problem size by dividing the exponent."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Unique Paths",
    "description": "A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Paths",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Counting Paths"
    ],
    "input_format": "Two integers m and n, representing the number of rows and columns in the grid.",
    "output_format": "An integer representing the number of unique paths from the top-left corner to the bottom-right corner.",
    "constraints": [
      "1 <= m, n <= 100"
    ],
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": "There are 28 unique paths from the top-left corner to the bottom-right corner."
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "There are 3 unique paths: right -> down -> down, down -> right -> down, and down -> down -> right."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dynamic programming approach to store the number of paths to each cell.",
      "Observe the state transition based on the previous cells."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Regular Expression Matching",
    "description": "Implement a function that matches a given string against a regular expression pattern. The pattern may include the characters '.' which matches any single character, and '*' which matches zero or more of the preceding element. The function should return true if the string matches the pattern, and false otherwise.",
    "topic": "String",
    "subtopic": "Regular Expression",
    "tags": [
      "String",
      "Dynamic Programming",
      "Regular Expression"
    ],
    "input_format": "Two strings: s and p, where s is the text string and p is the pattern string.",
    "output_format": "A boolean value indicating whether the string matches the pattern.",
    "constraints": [
      "1 <= s.length <= 20",
      "1 <= p.length <= 20",
      "s and p consist of lowercase English letters and the characters '.' and '*'."
    ],
    "examples": [
      {
        "input": "s = 'aa', p = 'a'",
        "output": "false",
        "explanation": "'a' does not match 'aa'."
      },
      {
        "input": "s = 'aa', p = 'a*'",
        "output": "true",
        "explanation": "'a*' matches 'aa' because '*' means zero or more of the preceding element."
      },
      {
        "input": "s = 'ab', p = '.*'",
        "output": "true",
        "explanation": "'.*' matches any string, including 'ab'."
      },
      {
        "input": "s = 'aab', p = 'c*a*b'",
        "output": "true",
        "explanation": "'c*' matches empty and 'a*b' matches 'aab'."
      },
      {
        "input": "s = 'mississippi', p = 'mis*is*p*.'",
        "output": "false",
        "explanation": "'mis*is*p*.' does not match 'mississippi'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to handle overlapping subproblems.",
      "Break down the matching process into smaller subproblems.",
      "Use a 2D table to store the results of subproblems."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Reverse Nodes in k-Group",
    "description": "Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then leave the last nodes as they are. You may not alter the values in the nodes, only nodes themselves may be changed.",
    "topic": "Linked List",
    "subtopic": "Reverse Linked List",
    "tags": [
      "Linked List",
      "Recursion",
      "Two Pointers"
    ],
    "input_format": "The head of the linked list and an integer k.",
    "output_format": "The head of the modified linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 5000].",
      "0 <= Node.val <= 1000",
      "1 <= k <= length of the list"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], k = 2",
        "output": "[2, 1, 4, 3, 5]",
        "explanation": "The first two nodes (1 and 2) are reversed to form [2, 1]. The next two nodes (3 and 4) are also reversed to form [4, 3]. The last node (5) remains as it is."
      },
      {
        "input": "head = [1, 2, 3, 4, 5], k = 3",
        "output": "[3, 2, 1, 4, 5]",
        "explanation": "The first three nodes (1, 2, 3) are reversed to form [3, 2, 1]. The last two nodes (4 and 5) remain unchanged."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using recursion for a cleaner solution.",
      "You may need to keep track of the next nodes while reversing.",
      "Think about edge cases when the list length is not a multiple of k."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Remove Nth Node From End of List",
    "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head. It is guaranteed that the number of nodes is at least n. Your solution should be in one pass.",
    "topic": "Linked List",
    "subtopic": "Two Pointers",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Deletion"
    ],
    "input_format": "The input consists of the head of the linked list followed by an integer n.",
    "output_format": "Return the head of the linked list after removing the nth node from the end.",
    "constraints": [
      "The number of nodes in the list is in the range [1, 30]",
      "1 <= n <= length of the list"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], n = 2",
        "output": "[1, 2, 3, 5]",
        "explanation": "Removing the 2nd node from the end (node with value 4) results in the list [1, 2, 3, 5]."
      },
      {
        "input": "head = [1], n = 1",
        "output": "[]",
        "explanation": "Removing the only node from the list leaves an empty list."
      },
      {
        "input": "head = [1, 2], n = 1",
        "output": "[1]",
        "explanation": "Removing the 1st node from the end (node with value 2) results in the list [1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using two pointers to find the nth node from the end.",
      "You can use a dummy node to simplify edge cases."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Sort Colors",
    "description": "Given an array nums consisting of n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's built-in sort function.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Sorting",
      "Two Pointers"
    ],
    "input_format": "An integer array nums where nums[i] is 0, 1, or 2.",
    "output_format": "The sorted array nums, ordered as 0s, 1s, and then 2s.",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 300",
      "nums[i] is 0, 1, or 2"
    ],
    "examples": [
      {
        "input": "nums = [2, 0, 2, 1, 1, 0]",
        "output": "[0, 0, 1, 1, 2, 2]",
        "explanation": "Sorting the array will result in all 0s followed by 1s and then 2s."
      },
      {
        "input": "nums = [2, 0, 1]",
        "output": "[0, 1, 2]",
        "explanation": "The smallest number 0 comes first followed by 1 and then 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a three-pointer approach to divide the colors."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Search a 2D Matrix",
    "description": "You are given an m x n matrix (0-indexed) that is sorted in non-decreasing order both row-wise and column-wise. Write a function that searches for a target value in the matrix. If the target exists, return true; otherwise, return false.",
    "topic": "Matrix",
    "subtopic": "Search Algorithms",
    "tags": [
      "Binary Search",
      "Matrix",
      "Searching"
    ],
    "input_format": "A 2D matrix of integers and an integer target.",
    "output_format": "A boolean indicating whether the target exists in the matrix.",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 100",
      "-10^4 <= matrix[i][j], target <= 10^4"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [15, 17, 19]], target = 9",
        "output": "true",
        "explanation": "The target value 9 is present in the matrix."
      },
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [15, 17, 19]], target = 10",
        "output": "false",
        "explanation": "The target value 10 is not present in the matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how the properties of the sorted matrix can be leveraged for efficient searching.",
      "You can start from the top-right corner and eliminate rows or columns based on the comparisons."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Validate Binary Search Tree",
    "description": "Given a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key, the right subtree of a node contains only nodes with keys greater than the node's key, and both the left and right subtrees must also be binary search trees.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "The root of a binary tree.",
    "output_format": "Return true if the binary tree is a valid binary search tree; otherwise, return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root = [2, 1, 3]",
        "output": "true",
        "explanation": "This is a valid binary search tree."
      },
      {
        "input": "root = [5, 1, 4, null, null, 3, 6]",
        "output": "false",
        "explanation": "The node with value 3 is in the right subtree of the node with value 5, but it is less than 5, hence it's invalid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use in-order traversal to check the order of the nodes.",
      "Keep track of the minimum and maximum values for each node."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Minimum Window Substring",
    "description": "Given two strings s and t, return the minimum window in s which will contain all the characters in t (including duplicates). If there is no such window in s that covers all characters in t, return the empty string. The answer is guaranteed to be unique.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Hash Table"
    ],
    "input_format": "Two strings s and t where 1 <= s.length, t.length <= 10^5.",
    "output_format": "A string representing the minimum window substring covering all characters from t.",
    "constraints": [
      "1 <= s.length, t.length <= 10^5",
      "s and t consist of English letters, digits, and symbols."
    ],
    "examples": [
      {
        "input": "s = 'ADOBECODEBANC', t = 'ABC'",
        "output": "'BANC'",
        "explanation": "The minimum window substring 'BANC' contains all the characters of 'ABC'."
      },
      {
        "input": "s = 'AA', t = 'AA'",
        "output": "'AA'",
        "explanation": "The minimum window substring is 'AA' itself."
      },
      {
        "input": "s = 'A', t = 'AA'",
        "output": "''",
        "explanation": "There is no window that contains all characters of 'AA' in 'A'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use two pointers to create a sliding window.",
      "Keep a count of characters required and match it while expanding/shrinking the window.",
      "Consider edge cases where s is smaller than t."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Remove Element",
    "description": "Given an array nums and a value val, remove all instances of that value in-place and return the new length of the array. Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn\u2019t matter what you leave beyond the new length.",
    "topic": "Array",
    "subtopic": "In-place Operations",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An array of integers nums and an integer val.",
    "output_format": "An integer representing the new length of the array after removal.",
    "constraints": [
      "0 <= nums.length <= 100",
      "-100 <= nums[i] <= 100",
      "val is guaranteed to be a value in nums."
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 2, 3], val = 3",
        "output": "2",
        "explanation": "After removing 3, the array becomes [2, 2] and the new length is 2."
      },
      {
        "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
        "output": "5",
        "explanation": "After removing 2, the array could be [0, 1, 3, 0, 4] and the new length is 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Try to use two pointers to manage the current position in the array."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Find the Index of the First Occurrence in a String",
    "description": "Given a string 'haystack' and a string 'needle', return the index of the first occurrence of 'needle' in 'haystack', or -1 if 'needle' is not part of 'haystack'. If 'needle' is an empty string, return 0. It is guaranteed that 'haystack' consists of only lowercase English letters.",
    "topic": "String",
    "subtopic": "Searching",
    "tags": [
      "String",
      "Searching",
      "Index"
    ],
    "input_format": "Two strings haystack and needle, where 1 <= haystack.length <= 10^4 and 0 <= needle.length <= 100.",
    "output_format": "An integer representing the index of the first occurrence of 'needle' in 'haystack' or -1 if not found.",
    "constraints": [
      "1 <= haystack.length <= 10^4",
      "0 <= needle.length <= 100"
    ],
    "examples": [
      {
        "input": "haystack = 'hello', needle = 'll'",
        "output": "2",
        "explanation": "The substring 'll' occurs at index 2."
      },
      {
        "input": "haystack = 'aaaaa', needle = 'bba'",
        "output": "-1",
        "explanation": "'bba' is not found in 'aaaaa'."
      },
      {
        "input": "haystack = 'abc', needle = ''",
        "output": "0",
        "explanation": "An empty string is considered to be found at the start (index 0)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using built-in string search methods.",
      "Iterate through haystack and check for the needle."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Combination Sum",
    "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. It is guaranteed that the solution set will not exceed 10^4 unique combinations.",
    "topic": "Backtracking",
    "subtopic": "Combination Sum",
    "tags": [
      "Backtracking",
      "Recursion",
      "Combination"
    ],
    "input_format": "An array of distinct integers candidates and a target integer target.",
    "output_format": "A list of lists of integers, where each list represents a unique combination that sums to the target.",
    "constraints": [
      "1 <= candidates.length <= 30",
      "1 <= candidates[i] <= 200",
      "All elements of candidates are distinct.",
      "1 <= target <= 500"
    ],
    "examples": [
      {
        "input": "candidates = [2, 3, 6, 7], target = 7",
        "output": "[[7], [2, 2, 3]]",
        "explanation": "The two combinations that sum to 7 are [7] and [2, 2, 3]."
      },
      {
        "input": "candidates = [1], target = 2",
        "output": "[[1, 1]]",
        "explanation": "The only combination that sums to 2 is [1, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to explore possible combinations.",
      "Start from an empty combination and try to build it up."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Sqrt(x)",
    "description": "Implement a function to compute the square root of a non-negative integer x, rounded down to the nearest integer. The function must not use built-in square root functions and should have a time complexity of O(log x).",
    "topic": "Binary Search",
    "subtopic": "Searching",
    "tags": [
      "Binary Search",
      "Math",
      "Integer"
    ],
    "input_format": "A single non-negative integer x.",
    "output_format": "An integer representing the square root of x, rounded down.",
    "constraints": [
      "0 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 4",
        "output": "2",
        "explanation": "The square root of 4 is 2."
      },
      {
        "input": "x = 8",
        "output": "2",
        "explanation": "The square root of 8 is approximately 2.828, rounded down to 2."
      },
      {
        "input": "x = 0",
        "output": "0",
        "explanation": "The square root of 0 is 0."
      },
      {
        "input": "x = 1",
        "output": "1",
        "explanation": "The square root of 1 is 1."
      },
      {
        "input": "x = 15",
        "output": "3",
        "explanation": "The square root of 15 is approximately 3.872, rounded down to 3."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using binary search for an efficient solution.",
      "The range for the square root should be [0, x]."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "N-Queens",
    "description": "The N-Queens puzzle is the problem of placing N chess queens on an N \u00d7 N chessboard so that no two queens threaten each other. This means that no two queens can be placed in the same row, the same column, or the same diagonal. Given an integer N, return all distinct solutions to the N-Queens puzzle. Each solution contains a distinct board configuration of the Q queens' placement, where 'Q' and '.' indicate a queen and an empty space, respectively.",
    "topic": "Backtracking",
    "subtopic": "Combinatorial Problems",
    "tags": [
      "Backtracking",
      "Recursion",
      "Chess"
    ],
    "input_format": "An integer N representing the size of the chessboard.",
    "output_format": "A list of lists, where each inner list represents a distinct solution and contains strings of '.' and 'Q'.",
    "constraints": [
      "1 <= N <= 9"
    ],
    "examples": [
      {
        "input": "N = 4",
        "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]",
        "explanation": "There are two distinct solutions to the 4-Queens problem. The first solution has the queens placed in the first, fourth, second, and third rows, and the second solution has them placed in the third, first, fourth, and second rows."
      },
      {
        "input": "N = 1",
        "output": "[[\"Q\"]]",
        "explanation": "There is only one solution for the 1-Queens problem."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use backtracking to explore all possible placements of queens.",
      "Keep track of used columns and diagonals."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Integer to Roman",
    "description": "Convert an integer to its corresponding Roman numeral representation. Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. For example, the integer 3 is represented as 'III' in Roman numeral, and the integer 58 is represented as 'LVIII', which is composed of 'L' for 50, 'V' for 5, and 'III' for 3. The integer 1994 is represented as 'MCMXCIV', which is composed of 'M' for 1000, 'CM' for 900, 'XC' for 90, and 'IV' for 4. Your task is to implement a function that converts a given integer to its Roman numeral equivalent.",
    "topic": "Mathematics",
    "subtopic": "Conversion",
    "tags": [
      "Mathematics",
      "Conversion",
      "Strings"
    ],
    "input_format": "An integer num (1 <= num <= 3999).",
    "output_format": "A string representing the Roman numeral equivalent of the input integer.",
    "constraints": [
      "1 <= num <= 3999"
    ],
    "examples": [
      {
        "input": "num = 3",
        "output": "III",
        "explanation": "The integer 3 is represented as 'III' in Roman numerals."
      },
      {
        "input": "num = 58",
        "output": "LVIII",
        "explanation": "The integer 58 is represented as 'LVIII', which is 50 + 5 + 3."
      },
      {
        "input": "num = 1994",
        "output": "MCMXCIV",
        "explanation": "The integer 1994 is represented as 'MCMXCIV', which is 1000 + (1000 - 100) + (100 - 10) + (5 - 1)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a mapping of integers to their corresponding Roman symbols.",
      "Be aware of the subtractive notation used in Roman numerals.",
      "Build the Roman numeral string iteratively by checking the largest possible values."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Zigzag Conversion",
    "description": "The string 'Zigzag conversion' is defined as writing a string in a zigzag pattern on a given number of rows and then reading it row by row. Given a string `s` and an integer `numRows`, return the zigzag conversion of the string. If the number of rows is 1 or greater than the length of the string, the output will be the string itself.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Zigzag",
      "Conversion"
    ],
    "input_format": "A string `s` representing the text to be converted and an integer `numRows` indicating the number of rows for the zigzag pattern.",
    "output_format": "A string representing the zigzag conversion of the input string.",
    "constraints": [
      "1 <= s.length <= 1000",
      "1 <= numRows <= 1000"
    ],
    "examples": [
      {
        "input": "s = 'PAYPALISHIRING', numRows = 3",
        "output": "PAHNAPLSIIGYIR",
        "explanation": "The zigzag pattern with 3 rows would look like:\nP   A   H   N\nA P L S I I G\n Y   I\nReading line by line gives PAHNAPLSIIGYIR."
      },
      {
        "input": "s = 'A', numRows = 1",
        "output": "A",
        "explanation": "When numRows is 1, the output is the same as input."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to map the characters to rows in a zigzag pattern.",
      "The index pattern for the zigzag can be calculated using a specific algorithm."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Permutations",
    "description": "Given an array of distinct integers, return all possible permutations of the array. You can return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Array",
      "Permutations"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "A list of lists, where each sublist represents a permutation of the input array.",
    "constraints": [
      "1 <= nums.length <= 6",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": "The permutations of [1, 2, 3] are all possible arrangements of the numbers."
      },
      {
        "input": "nums = [0, 1]",
        "output": "[[0,1],[1,0]]",
        "explanation": "The permutations of [0, 1] are [0, 1] and [1, 0]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion to generate permutations.",
      "Swap elements to create different arrangements in the recursion."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Plus One",
    "description": "Given a non-empty array of digits representing a non-negative integer, increment the integer by one and return the resulting array of digits. The digits are stored such that the most significant digit is at the head of the array, and each element in the array contains a single digit. You may assume the integer does not contain any leading zeros, except for the number 0 itself.",
    "topic": "Array",
    "subtopic": "Manipulation",
    "tags": [
      "Array",
      "Math",
      "Simulation"
    ],
    "input_format": "An array of integers representing the digits of a non-negative integer.",
    "output_format": "An array of integers representing the digits of the resulting integer after incrementing by one.",
    "constraints": [
      "1 <= digits.length <= 100",
      "0 <= digits[i] <= 9",
      "digits does not contain any leading zeros"
    ],
    "examples": [
      {
        "input": "digits = [1, 2, 3]",
        "output": "[1, 2, 4]",
        "explanation": "The number is 123, incrementing it by one gives 124."
      },
      {
        "input": "digits = [4, 3, 2, 1]",
        "output": "[4, 3, 2, 2]",
        "explanation": "The number is 4321, incrementing it by one gives 4322."
      },
      {
        "input": "digits = [9]",
        "output": "[1, 0]",
        "explanation": "The number is 9, incrementing it by one gives 10."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how to handle carry when adding one.",
      "You may need to expand the size of your array."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Longest Valid Parentheses",
    "description": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Stack"
    ],
    "input_format": "A string s consisting of '(' and ')'.",
    "output_format": "An integer representing the length of the longest valid parentheses substring.",
    "constraints": [
      "0 <= s.length <= 10^4",
      "s[i] is either '(' or ')'."
    ],
    "examples": [
      {
        "input": "s = '(()')",
        "output": "2",
        "explanation": "The longest valid parentheses substring is '()', which has length 2."
      },
      {
        "input": "s = ')()())'",
        "output": "4",
        "explanation": "The longest valid parentheses substring is '()()', which has length 4."
      },
      {
        "input": "s = ''",
        "output": "0",
        "explanation": "An empty string has no valid parentheses, so the length is 0."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to keep track of indices.",
      "You may also utilize dynamic programming to build on smaller solutions."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Search Insert Position",
    "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Searching"
    ],
    "input_format": "An array of integers nums representing the sorted array, and an integer target.",
    "output_format": "An integer representing the index where the target value is found or can be inserted.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^4",
      "All elements in nums are distinct."
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 5, 6], target = 5",
        "output": "2",
        "explanation": "The target 5 is found at index 2."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 2",
        "output": "1",
        "explanation": "The target 2 is not found, but it can be inserted at index 1."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 7",
        "output": "4",
        "explanation": "The target 7 is not found, but it can be inserted at index 4."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 0",
        "output": "0",
        "explanation": "The target 0 is not found, but it can be inserted at index 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using binary search for optimal performance.",
      "Think about the cases when the target is less than or greater than the elements in the array."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Swap Nodes in Pairs",
    "description": "Given a linked list, swap every two adjacent nodes and return its head. You must solve it in one pass. If the number of nodes is odd, the last node should remain in the original position. The nodes should be swapped in pairs, meaning that the link between the first and second nodes is reversed, and the same goes for the next pair of nodes.",
    "topic": "Linked List",
    "subtopic": "Node Manipulation",
    "tags": [
      "LinkedList",
      "Node",
      "Swap"
    ],
    "input_format": "A linked list represented by its head node.",
    "output_format": "The head of the modified linked list after swapping pairs of nodes.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 100].",
      "Each node's value is in the range [-100, 100]."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4]",
        "output": "[2, 1, 4, 3]",
        "explanation": "The pairs (1, 2), (3, 4) are swapped to yield [2, 1, 4, 3]."
      },
      {
        "input": "head = [1]",
        "output": "[1]",
        "explanation": "With only one node, no swapping occurs."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "An empty list remains unchanged."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dummy node to simplify swapping at the head.",
      "Iterate through the list in steps of two.",
      "Don't forget to handle cases with an odd number of nodes."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List II",
    "description": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list. It is guaranteed that the input list has at least left nodes and at least right nodes. Positioning is 1-based indexing.",
    "topic": "Linked List",
    "subtopic": "Reversal",
    "tags": [
      "Linked List",
      "Reversal",
      "Two Pointers"
    ],
    "input_format": "The head of the singly linked list along with two integers left and right.",
    "output_format": "The head of the modified linked list after reversing the specified segment.",
    "constraints": [
      "1 <= left <= right <= n",
      "The number of nodes in the list is n.",
      "1 <= n <= 500"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5], left = 2, right = 4",
        "output": "[1, 4, 3, 2, 5]",
        "explanation": "The nodes from position 2 to 4 are reversed: 2 -> 3 -> 4 becomes 4 -> 3 -> 2."
      },
      {
        "input": "head = [1], left = 1, right = 1",
        "output": "[1]",
        "explanation": "The list contains only one node, so it remains unchanged."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to reverse a part of a linked list.",
      "Use a dummy node to simplify edge cases.",
      "You may need to connect the reversed part back to the original list."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "String to Integer (atoi)",
    "description": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi). The function discards all leading whitespace characters until the first non-whitespace character is found. Then, it takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numeric value. The function should stop reading characters as soon as the next character is not a digit. Additionally, if the numeric value is out of the range of a 32-bit signed integer, it should return the respective bound, either Integer.MAX_VALUE or Integer.MIN_VALUE.",
    "topic": "String",
    "subtopic": "Parsing",
    "tags": [
      "String",
      "Parsing",
      "Conversion"
    ],
    "input_format": "A string s representing the input to be converted.",
    "output_format": "An integer representing the converted value.",
    "constraints": [
      "0 <= s.length <= 200",
      "s consists of English letters (lowercase and uppercase), digits, symbols and whitespace characters."
    ],
    "examples": [
      {
        "input": "s = '   -42'",
        "output": "-42",
        "explanation": "Leading whitespaces are removed, the negative sign is recognized, and '42' is converted to -42."
      },
      {
        "input": "s = '4193 with words'",
        "output": "4193",
        "explanation": "Leading whitespaces are removed, and it reads '4193' until it encounters a non-digit character."
      },
      {
        "input": "s = 'words and 987'",
        "output": "0",
        "explanation": "Since there's no valid conversion, it returns 0."
      },
      {
        "input": "s = '-91283472332'",
        "output": "-2147483648",
        "explanation": "Value underflows the 32-bit integer, returns Integer.MIN_VALUE."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Ignore leading whitespace.",
      "Check for optional sign at the beginning.",
      "Convert characters to integer until a non-digit is encountered.",
      "Handle overflow by checking against 32-bit signed integer bounds."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Add Binary",
    "description": "Given two binary strings a and b, return their sum as a binary string. The input strings are both non-empty and contain only characters '0' or '1'.",
    "topic": "String",
    "subtopic": "Binary Manipulation",
    "tags": [
      "String",
      "Binary",
      "Math"
    ],
    "input_format": "Two binary strings 'a' and 'b'.",
    "output_format": "A binary string representing the sum of 'a' and 'b'.",
    "constraints": [
      "1 <= a.length, b.length <= 10^4",
      "Both 'a' and 'b' consist of characters '0' or '1'."
    ],
    "examples": [
      {
        "input": "a = '1010', b = '1011'",
        "output": "'10101'",
        "explanation": "'1010' + '1011' = '10101' in binary."
      },
      {
        "input": "a = '0', b = '0'",
        "output": "'0'",
        "explanation": "Adding '0' and '0' gives '0'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a loop to add the bits from right to left.",
      "Remember to handle the carry for numbers that sum to more than 1."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Divide Two Integers",
    "description": "Implement a function that divides two integers without using multiplication, division, and modulus operators. The function should return the quotient after dividing the first integer by the second integer, rounding towards zero. If the result exceeds the limits of a 32-bit signed integer, return the maximum or minimum 32-bit integer value accordingly.",
    "topic": "Math",
    "subtopic": "Bit Manipulation",
    "tags": [
      "Math",
      "Bit Manipulation",
      "Division"
    ],
    "input_format": "Two integers, dividend and divisor.",
    "output_format": "An integer representing the quotient after the division.",
    "constraints": [
      "-2^31 <= dividend, divisor <= 2^31 - 1",
      "divisor != 0"
    ],
    "examples": [
      {
        "input": "dividend = 10, divisor = 3",
        "output": "3",
        "explanation": "10 divided by 3 is 3 with a remainder of 1, so when rounded towards zero, the result is 3."
      },
      {
        "input": "dividend = 7, divisor = -3",
        "output": "-2",
        "explanation": "7 divided by -3 is -2 with a remainder of 1, so the result is -2."
      },
      {
        "input": "dividend = -1, divisor = 1",
        "output": "-1",
        "explanation": "-1 divided by 1 is -1."
      },
      {
        "input": "dividend = -2147483648, divisor = -1",
        "output": "2147483647",
        "explanation": "Dividing the minimum 32-bit integer by -1 exceeds the 32-bit signed integer limit, so we return 2147483647."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using bit manipulation for efficient division.",
      "Handle edge cases for integer overflow."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Simplify Path",
    "description": "Given a string representing an absolute path for a file (Unix-style), you need to simplify it. In the path, '.' refers to the current directory, '..' refers to the parent directory, and any multiple consecutive slashes (/) should be treated as a single slash. The resulting path must always be absolute and should not end with a slash unless it is the root directory.",
    "topic": "String",
    "subtopic": "Path Manipulation",
    "tags": [
      "String",
      "Path",
      "Manipulation"
    ],
    "input_format": "A string representing the absolute path.",
    "output_format": "A simplified absolute path string.",
    "constraints": [
      "1 <= path.length <= 3000",
      "path consists of English letters, digits, '.', '..', and '/'"
    ],
    "examples": [
      {
        "input": "/home/../usr//bin/",
        "output": "/usr/bin",
        "explanation": "The directory '../' goes back to 'home' and then to 'usr/bin'. Multiple slashes are simplified to a single slash."
      },
      {
        "input": "/a/./b/../../c/",
        "output": "/c",
        "explanation": "The '.' refers to the current directory 'a', then to 'b', and '../' goes back to 'a' and then back to root, and finally to 'c'."
      },
      {
        "input": "/../",
        "output": "/",
        "explanation": "The path goes to the parent directory of root, which is still root."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to keep track of the directories.",
      "Consider special cases for '.', '..', and multiple consecutive slashes."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array II",
    "description": "Given a sorted array of integers, modify the array in-place such that duplicates appear at most twice and return the new length of the modified array. Do not allocate extra space for another array. The relative order of the elements should be kept the same.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "A sorted array of integers nums.",
    "output_format": "An integer representing the new length of the modified array.",
    "constraints": [
      "0 <= nums.length <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3]",
        "output": "5",
        "explanation": "The modified array is [1,1,2,2,3] with a new length of 5."
      },
      {
        "input": "nums = [0,0,1,1,1,1,2,3,3]",
        "output": "7",
        "explanation": "The modified array is [0,0,1,1,2,3,3] with a new length of 7."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using two pointers to keep track of the position of unique elements.",
      "Count occurrences while iterating through the array."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Rotate List",
    "description": "Given the head of a linked list, rotate the list to the right by k places, where k is non-negative. This means that the last k elements of the list will be moved to the front of the list.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "Linked List",
      "Rotation",
      "Two Pointers"
    ],
    "input_format": "A linked list represented by the head node and an integer k.",
    "output_format": "The head of the rotated linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 500].",
      "-100 <= Node.val <= 100",
      "0 <= k <= 2 * 10^9"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], k = 2",
        "output": "[4, 5, 1, 2, 3]",
        "explanation": "Rotating the list by 2 places results in [4, 5, 1, 2, 3]."
      },
      {
        "input": "head = [0, 1, 2], k = 4",
        "output": "[2, 0, 1]",
        "explanation": "Rotating the list by 4 is equivalent to rotating by 1, giving [2, 0, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the length of the linked list to optimize k.",
      "Use a fast and slow pointer approach to find the new head.",
      "Don't forget to handle the case when the list is empty."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Decode Ways",
    "description": "A message containing letters from A-Z can be encoded into numbers using the following mapping: 'A' -> 1, 'B' -> 2, ..., 'Z' -> 26. Given a string s consisting of digits, return the total number of distinct ways to decode it. For example, '12' can be decoded as 'AB' (1 2) or 'L' (12). The string may contain leading zeros, and the decoded message must not contain any invalid values.",
    "topic": "Dynamic Programming",
    "subtopic": "String Decoding",
    "tags": [
      "Dynamic Programming",
      "String",
      "Recursion"
    ],
    "input_format": "A string s consisting of digits (0-9).",
    "output_format": "An integer representing the total number of ways to decode the string.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of digits and may contain leading zeros."
    ],
    "examples": [
      {
        "input": "s = '12'",
        "output": "2",
        "explanation": "'12' can be decoded as 'AB' (1 2) or 'L' (12)."
      },
      {
        "input": "s = '226'",
        "output": "3",
        "explanation": "'226' can be decoded as 'BBF' (2 2 6), 'BZ' (2 26), or 'VF' (22 6)."
      },
      {
        "input": "s = '0'",
        "output": "0",
        "explanation": "'0' cannot be decoded since there is no mapping for 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you can break the string down into smaller parts.",
      "Dynamic programming can help track the count of decodings.",
      "Think about the implications of leading zeros."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Combination Sum II",
    "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note that the solution set must not contain duplicate combinations.",
    "topic": "Backtracking",
    "subtopic": "Combination Sum",
    "tags": [
      "Backtracking",
      "Combination",
      "Sum"
    ],
    "input_format": "A list of distinct integers candidates and an integer target.",
    "output_format": "A list of unique combinations where the sum equals target.",
    "constraints": [
      "1 <= candidates.length <= 100",
      "1 <= candidates[i] <= 50",
      "0 <= target <= 30"
    ],
    "examples": [
      {
        "input": "candidates = [10, 1, 2, 7, 6, 1, 5], target = 8",
        "output": "[[1, 1, 6], [1, 2, 5], [2, 6], [7]]",
        "explanation": "The combinations that sum to 8 are [1, 1, 6], [1, 2, 5], [2, 6], and [7]."
      },
      {
        "input": "candidates = [2, 5, 2, 1, 2], target = 5",
        "output": "[[1, 2, 2], [5]]",
        "explanation": "The combinations that sum to 5 are [1, 2, 2] and [5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to explore combinations.",
      "Sort the candidates to facilitate the elimination of duplicates."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Minimum Path Sum",
    "description": "Given a grid of size m x n filled with non-negative integers, find a path from the top left corner to the bottom right corner which minimizes the sum of the numbers along its path. You can only move down or right at any point in time.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Pathfinding",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Pathfinding"
    ],
    "input_format": "A 2D array grid where grid[i][j] represents the cost of moving to that cell.",
    "output_format": "An integer representing the minimum path sum from the top left to the bottom right corner.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 100",
      "0 <= grid[i][j] <= 100"
    ],
    "examples": [
      {
        "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7",
        "explanation": "The path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimises the sum: 1 + 3 + 1 + 1 + 1 = 7."
      },
      {
        "input": "grid = [[1,2,3],[4,5,6]]",
        "output": "12",
        "explanation": "The path 1 \u2192 2 \u2192 3 \u2192 6 minimizes the sum: 1 + 2 + 3 + 6 = 12."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about using dynamic programming to build the solution bottom-up.",
      "You can use a 2D array to keep track of the minimum path sums to each cell."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Edit Distance",
    "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You can perform the following three operations: insert a character, delete a character, or replace a character.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Edit Distance"
    ],
    "input_format": "Two strings word1 and word2.",
    "output_format": "An integer representing the minimum number of operations needed to convert word1 to word2.",
    "constraints": [
      "1 <= word1.length, word2.length <= 100",
      "word1 and word2 consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "word1 = 'horse', word2 = 'ros'",
        "output": "3",
        "explanation": "Horse -> Ros (horse -> rorse (replace 'h' with 'r'), rorse -> rose (remove 'r'), rose -> ros (remove 'e')) requires 3 operations."
      },
      {
        "input": "word1 = 'intention', word2 = 'execution'",
        "output": "5",
        "explanation": "Intention -> Execution (intention -> exten (replace 'i' with 'e', 'n' with 'x', 't' with 'c', and 'i' with 'u') and insert 'o' and 'n') requires 5 operations."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a 2D array to store the distances.",
      "Consider using dynamic programming to build the solution iteratively."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Subsets II",
    "description": "Given a collection of integers that might contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.",
    "topic": "Backtracking",
    "subtopic": "Subset Generation",
    "tags": [
      "Backtracking",
      "Subset",
      "Recursion"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A list of lists representing all the unique subsets.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2]",
        "output": "[[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]",
        "explanation": "Unique subsets include the empty set, single elements, pairs, and the triplet."
      },
      {
        "input": "nums = [0]",
        "output": "[[], [0]]",
        "explanation": "The only subsets are the empty set and the set containing the element 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array to easily skip duplicates.",
      "Use backtracking to explore the inclusion and exclusion of each element."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Insert Interval",
    "description": "Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). The intervals should be sorted by their start time. For example, if you have intervals [1,3],[6,9] and you want to insert [2,5], you would modify the intervals to be [1,5],[6,9].",
    "topic": "Array",
    "subtopic": "Intervals",
    "tags": [
      "Array",
      "Intervals",
      "Merge"
    ],
    "input_format": "An array of intervals (each interval is represented as a list of two integers) and a new interval to insert.",
    "output_format": "An array of intervals after the insertion and possible merging.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "intervals is sorted by intervals[i][0]",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^5",
      "newInterval.length == 2",
      "0 <= newInterval[0] <= newInterval[1] <= 10^5"
    ],
    "examples": [
      {
        "input": "[[1,3],[6,9]], [2,5]",
        "output": "[[1,5],[6,9]]",
        "explanation": "The new interval [2,5] overlaps with [1,3], so they merge into [1,5]."
      },
      {
        "input": "[[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]",
        "output": "[[1,2],[3,10],[12,16]]",
        "explanation": "The new interval [4,8] merges with [3,5] and [6,7] to form [3,10]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to iterate through the intervals to find the right place for the new interval.",
      "Think about edge cases for intervals that overlap."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Same Tree",
    "description": "Given two binary trees, you need to determine if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Recursion"
    ],
    "input_format": "Two binary tree nodes, root1 and root2.",
    "output_format": "A boolean value, true if the trees are the same, otherwise false.",
    "constraints": [
      "The number of nodes in both trees is in the range [0, 100].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root1 = [1,2,3], root2 = [1,2,3]",
        "output": "true",
        "explanation": "Both trees have the same structure and values."
      },
      {
        "input": "root1 = [1,2], root2 = [1,null,2]",
        "output": "false",
        "explanation": "The structure of the trees is different."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a recursive approach to compare nodes.",
      "Check if both nodes are null for the base case."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Length of Last Word",
    "description": "Given a string s consisting of words separated by spaces, return the length of the last word in the string. A word is defined as a maximal substring consisting of non-space characters only. If there are no words in the string, return 0.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Length"
    ],
    "input_format": "A single string s, where 1 <= s.length <= 10^4.",
    "output_format": "An integer representing the length of the last word.",
    "constraints": [
      "1 <= s.length <= 10^4"
    ],
    "examples": [
      {
        "input": "Hello World",
        "output": "5",
        "explanation": "The last word is 'World', which has a length of 5."
      },
      {
        "input": "   fly me   to   the moon  ",
        "output": "4",
        "explanation": "The last word is 'moon', which has a length of 4."
      },
      {
        "input": "luffy is still joyboy",
        "output": "6",
        "explanation": "The last word is 'joyboy', which has a length of 6."
      },
      {
        "input": "   ",
        "output": "0",
        "explanation": "There are no words in the string, so the length is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Trim the string first to remove leading and trailing spaces.",
      "Split the string by spaces and access the last word.",
      "You can use built-in functions to handle string manipulation."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "3Sum Closest",
    "description": "Given an array of integers nums and an integer target, find the sum of three integers in nums such that the sum is closest to the target. Return the sum of the three integers. You may assume that each input would have exactly one solution.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "An array of integers nums, followed by an integer target.",
    "output_format": "An integer representing the sum of three integers that is closest to the target.",
    "constraints": [
      "3 <= nums.length <= 1000",
      "-10^4 <= nums[i] <= 10^4",
      "-10^4 <= target <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-1, 2, 1, -4], target = 1",
        "output": "2",
        "explanation": "The sum that is closest to the target 1 is -1 + 2 + 1 = 2."
      },
      {
        "input": "nums = [0, 0, 0], target = 1",
        "output": "0",
        "explanation": "The only possible sum is 0 + 0 + 0 = 0, which is closest to the target 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array to enable two-pointer technique.",
      "Consider the case when the sum exceeds the target.",
      "Keep track of the closest sum found so far."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Sudoku Solver",
    "description": "Write a program to solve a given Sudoku puzzle by filling empty cells. A Sudoku puzzle is an n \u00d7 n grid filled with digits from 1 to n, where n is typically 9. The objective is to fill the grid such that each column, each row, and each of the nine 3 \u00d7 3 subgrids that compose the grid contain all of the digits from 1 to 9 without repetition. You will be given a partially filled grid represented as a 2D array. Empty cells are represented by the character '.' and are the only cells that can be filled. Your task is to modify the given grid in-place to complete the Sudoku puzzle.",
    "topic": "Backtracking",
    "subtopic": "Grid Search",
    "tags": [
      "Backtracking",
      "Grid",
      "Sudoku"
    ],
    "input_format": "A 9x9 2D array of characters representing the Sudoku board.",
    "output_format": "The 9x9 2D array of characters representing the completed Sudoku board.",
    "constraints": [
      "The board is guaranteed to be solvable.",
      "All rows, columns, and 3x3 subgrids contain no duplicates except for the empty cells."
    ],
    "examples": [
      {
        "input": [
          [
            "5",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            ".",
            "2",
            "8",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": [
          [
            "5",
            "3",
            "4",
            "6",
            "7",
            "8",
            "9",
            "1",
            "2"
          ],
          [
            "6",
            "7",
            "2",
            "1",
            "9",
            "5",
            "3",
            "4",
            "8"
          ],
          [
            "1",
            "9",
            "8",
            "3",
            "4",
            "2",
            "5",
            "6",
            "7"
          ],
          [
            "8",
            "5",
            "9",
            "7",
            "6",
            "1",
            "4",
            "2",
            "3"
          ],
          [
            "4",
            "2",
            "6",
            "8",
            "5",
            "3",
            "7",
            "9",
            "1"
          ],
          [
            "7",
            "1",
            "3",
            "9",
            "2",
            "4",
            "8",
            "5",
            "6"
          ],
          [
            "9",
            "6",
            "1",
            "5",
            "3",
            "7",
            "2",
            "8",
            "4"
          ],
          [
            "2",
            "8",
            "7",
            "4",
            "1",
            "9",
            "6",
            "3",
            "5"
          ],
          [
            "3",
            "4",
            "5",
            "2",
            "8",
            "6",
            "1",
            "7",
            "9"
          ]
        ],
        "explanation": "After following the Sudoku rules and filling in the empty cells, we obtain a valid completed Sudoku board."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider backtracking to explore potential solutions.",
      "Make use of the constraints of Sudoku to prune your search."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Count and Say",
    "description": "The 'Count and Say' sequence is a sequence of digit strings defined by the recursive formula: \n- countAndSay(1) = '1' \n- To generate the next sequence from the previous one, you read the previous sequence, counting the number of digits in groups of the same digit. For example, the sequence from '1' is '11' (one '1'). The sequence from '11' is '21' (two '1's). The sequence from '21' is '1211' (one '2', then one '1').\nYour task is to implement the function countAndSay(n) that returns the nth term of the 'Count and Say' sequence.",
    "topic": "Strings",
    "subtopic": "Sequence Generation",
    "tags": [
      "Strings",
      "Recursion",
      "Sequence"
    ],
    "input_format": "An integer n (1 <= n <= 30), representing the term in the 'Count and Say' sequence to generate.",
    "output_format": "A string representing the nth term in the 'Count and Say' sequence.",
    "constraints": [
      "1 <= n <= 30"
    ],
    "examples": [
      {
        "input": "1",
        "output": "'1'",
        "explanation": "The first term of the sequence is '1'."
      },
      {
        "input": "4",
        "output": "'1211'",
        "explanation": "The fourth term is generated from '21' which is read as one '2', one '1', giving '1211'."
      },
      {
        "input": "5",
        "output": "'111221'",
        "explanation": "The fifth term comes from '1211', which is read as one '1', one '2', two '1's, resulting in '111221'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a loop to read through the previous term.",
      "Keep track of the count of each digit as you generate the next term.",
      "Consider using a temporary string to build the new term iteratively."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Wildcard Matching",
    "description": "Given an input string s and a pattern p, implement wildcard pattern matching with support for '?' and '*'. A '?' matches any single character, while '*' matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial).",
    "topic": "Dynamic Programming",
    "subtopic": "String Matching",
    "tags": [
      "String",
      "Dynamic Programming",
      "Matching"
    ],
    "input_format": "Two strings s (the input string) and p (the pattern string) where 1 <= s.length, p.length <= 2000.",
    "output_format": "A boolean value indicating whether the input string matches the pattern.",
    "constraints": [
      "1 <= s.length, p.length <= 2000",
      "s and p consist of only lowercase English letters, '?' and '*'."
    ],
    "examples": [
      {
        "input": "s = \"aa\", p = \"a\"",
        "output": "false",
        "explanation": "Pattern 'a' does not match 'aa'."
      },
      {
        "input": "s = \"mississippi\", p = \"m??*ss*?i*pi\"",
        "output": "true",
        "explanation": "The pattern can match the input string by substituting '?' with 'i' and using '*' to match the characters in between."
      },
      {
        "input": "s = \"abcd\", p = \"*b\"",
        "output": "false",
        "explanation": "The pattern does not match as it requires only 'b' at the end."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a 2D DP array.",
      "Initialize your base cases for '*' and '?'.",
      "Iterate through both strings and update your DP table based on current matches."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array II",
    "description": "Given a possibly duplicated sorted array 'nums' that has been rotated at some pivot unknown to you beforehand. Write a function to search for a target value in the array. If the target exists, return true; otherwise, return false.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An array of integers nums that may contain duplicates and an integer target.",
    "output_format": "A boolean value indicating whether the target exists in the array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "nums is guaranteed to be rotated at some pivot",
      "The array may contain duplicates."
    ],
    "examples": [
      {
        "input": "nums = [2,5,6,0,0,1,2], target = 0",
        "output": "true",
        "explanation": "The target 0 exists in the array."
      },
      {
        "input": "nums = [2,5,6,0,0,1,2], target = 3",
        "output": "false",
        "explanation": "The target 3 does not exist in the array."
      },
      {
        "input": "nums = [1], target = 0",
        "output": "false",
        "explanation": "The target 0 does not exist in the array."
      },
      {
        "input": "nums = [1, 0, 1, 1, 1], target = 0",
        "output": "true",
        "explanation": "The target 0 exists in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to eliminate duplicates while performing binary search.",
      "The key is to identify which part of the array is sorted."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Binary Tree Inorder Traversal",
    "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values. In inorder traversal, the nodes are recursively visited in this order; left subtree, root node, and then right subtree.",
    "topic": "Tree",
    "subtopic": "Traversal",
    "tags": [
      "Tree",
      "Traversal",
      "In-order"
    ],
    "input_format": "A binary tree node with a structure defined as: `class TreeNode { int val; TreeNode left; TreeNode right; }`.",
    "output_format": "A list of integers representing the inorder traversal of the tree's nodes.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[1,3,2]",
        "explanation": "In the given binary tree, the inorder traversal is left, root, right. This results in nodes being visited in the order 1 (left) -> 3 (right) -> 2 (root)."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "The tree is empty, hence the inorder traversal results in an empty list."
      },
      {
        "input": "root = [1]",
        "output": "[1]",
        "explanation": "The tree contains only one node, which is the root, resulting in a traversal of just that node."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to help with the traversal.",
      "Recursively visit the left subtree, then the root, and finally the right subtree."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted List",
    "description": "Given a sorted linked list, delete all duplicates such that each element appear only once. Return the linked list sorted as well.",
    "topic": "Linked List",
    "subtopic": "Traversal",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "A sorted linked list represented by the head node.",
    "output_format": "The head node of the linked list after removing duplicates.",
    "constraints": [
      "The linked list contains at most 100 nodes.",
      "Each node's value is an integer in the range [-100, 100]."
    ],
    "examples": [
      {
        "input": "1 -> 1 -> 2",
        "output": "1 -> 2",
        "explanation": "The input list has duplicates '1'. The output list contains only unique values."
      },
      {
        "input": "1 -> 1 -> 2 -> 3 -> 3",
        "output": "1 -> 2 -> 3",
        "explanation": "The input list contains duplicates '1' and '3'. The output list contains only unique values."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a pointer to traverse the list and a reference to the current unique node."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Multiply Strings",
    "description": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2 represented as a string. Since the result can be very large, you should not use any built-in BigInteger library or convert the inputs to integers directly.",
    "topic": "String Manipulation",
    "subtopic": "Arithmetic Operations",
    "tags": [
      "String",
      "Arithmetic",
      "Multiplication"
    ],
    "input_format": "Two non-negative integers represented as strings, num1 and num2.",
    "output_format": "A string representing the product of num1 and num2.",
    "constraints": [
      "1 <= num1.length, num2.length <= 200",
      "num1 and num2 consist of digits only.",
      "Both num1 and num2 do not have leading zeros, except for the number '0'."
    ],
    "examples": [
      {
        "input": "num1 = '123', num2 = '456'",
        "output": "'56088'",
        "explanation": "123 multiplied by 456 equals 56088."
      },
      {
        "input": "num1 = '2', num2 = '3'",
        "output": "'6'",
        "explanation": "2 multiplied by 3 equals 6."
      },
      {
        "input": "num1 = '0', num2 = '12345'",
        "output": "'0'",
        "explanation": "Any number multiplied by 0 gives 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you would multiply numbers by hand.",
      "You can simulate the multiplication process using the character digits."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Text Justification",
    "description": "Given an array of strings words and a length maxWidth, format the text such that each line has exactly maxWidth characters and is fully justified. You should pack your words such that they follow specific justification rules. If a line contains a single word, it will be left-justified. If not, the words should be evenly distributed, with extra spaces distributed from left to right, meaning that the leftmost spaces are given to the leftmost gaps between words. The last line should be left-justified, and any extra spaces should be added to the end of the line. Return a list of strings representing the justified text.",
    "topic": "String",
    "subtopic": "Text Formatting",
    "tags": [
      "String",
      "Justification",
      "Formatting"
    ],
    "input_format": "An array of strings words, and an integer maxWidth.",
    "output_format": "A list of strings where each string represents a justified line of text.",
    "constraints": [
      "1 <= words.length <= 3000",
      "1 <= words[i].length <= 100",
      "1 <= maxWidth <= 100"
    ],
    "examples": [
      {
        "input": {
          "words": [
            "This",
            "is",
            "an",
            "example",
            "of",
            "text",
            "justification."
          ],
          "maxWidth": 16
        },
        "output": [
          "This    is    an",
          "example  of text",
          "justification.  "
        ],
        "explanation": "The first line is justified with spaces between 'This' and 'is'. The second line has 'example' and 'of' with spaces, and the last line is left-justified."
      },
      {
        "input": {
          "words": [
            "What",
            "must",
            "be",
            "acknowledgment",
            "shall",
            "be"
          ],
          "maxWidth": 16
        },
        "output": [
          "What   must   be",
          "acknowledgment  ",
          "shall be        "
        ],
        "explanation": "The first line is justified with spaces as per the rules. The second line is the last one and should be left-justified, and extra spaces are added at the end."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Think about how to calculate the total spaces needed for each line.",
      "Consider how to distribute the spaces between words to achieve full justification.",
      "Handle the last line differently since it should be left-justified."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Partition List",
    "description": "Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions.",
    "topic": "Linked List",
    "subtopic": "Partitioning",
    "tags": [
      "Linked List",
      "Partition",
      "Two Pointers"
    ],
    "input_format": "A singly linked list and an integer x.",
    "output_format": "The head of the modified linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 200].",
      "-100 <= Node.val <= 100",
      "-200 <= x <= 200"
    ],
    "examples": [
      {
        "input": "head = [1, 4, 3, 2, 5, 2], x = 3",
        "output": "[1, 2, 2, 4, 3, 5]",
        "explanation": "The nodes less than 3 (1, 2, 2) come before the nodes greater than or equal to 3 (4, 3, 5)."
      },
      {
        "input": "head = [2, 1], x = 2",
        "output": "[1, 2]",
        "explanation": "The node less than 2 (1) comes before the node equal to 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using two pointers to keep track of the partitions.",
      "Use a dummy head for the two partitions to simplify the merging."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Maximal Rectangle",
    "description": "Given a 2D binary matrix filled with 0's and 1's, find the area of the largest rectangle containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Dynamic Programming",
      "Matrix",
      "Rectangle"
    ],
    "input_format": "A 2D binary matrix represented as a list of lists, where each inner list consists of '0's and '1's.",
    "output_format": "An integer representing the area of the largest rectangle containing only 1's.",
    "constraints": [
      "1 <= matrix.length <= 300",
      "1 <= matrix[0].length <= 300",
      "matrix[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "[['1', '0', '1', '0', '0'], ['1', '0', '1', '1', '1'], ['1', '1', '1', '1', '1'], ['1', '0', '0', '1', '0']]",
        "output": "6",
        "explanation": "The largest rectangle containing only 1's has an area of 6."
      },
      {
        "input": "[['0', '0'], ['0', '0']]",
        "output": "0",
        "explanation": "There are no 1's in the matrix, hence the area is 0."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how you can convert the problem to a histogram problem.",
      "Use a stack to keep track of the heights of consecutive 1's."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Unique Binary Search Trees II",
    "description": "Given an integer n, generate all structurally unique Binary Search Trees (BSTs) that can be formed with the values 1 to n. A Binary Search Tree is defined as a tree where every node follows the left child < parent < right child property. The result should be a list of all unique BSTs that can be created using values from 1 to n.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Dynamic Programming"
    ],
    "input_format": "An integer n (1 <= n <= 8).",
    "output_format": "A list of unique BSTs represented as the root nodes.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
        "explanation": "The unique BSTs that can be formed with values 1, 2, 3 are shown. The array represents the tree structure in a serialized manner."
      },
      {
        "input": "n = 1",
        "output": "[[1]]",
        "explanation": "Only one BST can be formed with a single node."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider different values as root nodes and build subtrees recursively.",
      "Use dynamic programming to store results of subproblems."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Unique Paths II",
    "description": "A robot is located at the top-left corner of an m x n grid and can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. However, some cells in the grid are blocked by obstacles. The robot cannot move through these obstacles. Given an m x n grid where each cell can either be 0 (empty) or 1 (obstacle), return the number of unique paths from the top-left corner to the bottom-right corner.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Paths",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Backtracking"
    ],
    "input_format": "A 2D array of integers obstacleGrid of size m x n.",
    "output_format": "An integer representing the number of unique paths to reach the bottom-right corner.",
    "constraints": [
      "1 <= m, n <= 100",
      "obstacleGrid[i][j] is 0 or 1."
    ],
    "examples": [
      {
        "input": "[[0,0,0],[0,1,0],[0,0,0]]",
        "output": "2",
        "explanation": "There are two unique paths to the bottom-right corner: one going down then right, and the other going right then down."
      },
      {
        "input": "[[0,1],[0,0]]",
        "output": "1",
        "explanation": "There is only one unique path to reach the bottom-right corner."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you can use dynamic programming to count paths in a grid.",
      "Think about how obstacles affect the possible paths."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Permutation Sequence",
    "description": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, you will get a unique sequence of integers. Given n and k, return the k-th permutation sequence of these permutations. Note that k is 1-based index, which means that if you want the first permutation, you should return the one corresponding to k = 1.",
    "topic": "Backtracking",
    "subtopic": "Permutation Generation",
    "tags": [
      "Backtracking",
      "Recursion",
      "Array",
      "Math"
    ],
    "input_format": "The input consists of two integers n and k, where 1 <= n <= 9 and 1 <= k <= n!.",
    "output_format": "Return a string representing the k-th permutation sequence of numbers 1 to n.",
    "constraints": [
      "1 <= n <= 9",
      "1 <= k <= n!"
    ],
    "examples": [
      {
        "input": "n = 3, k = 3",
        "output": "213",
        "explanation": "The permutations of [1, 2, 3] are ['123', '132', '213', '231', '312', '321']. The third permutation is '213'."
      },
      {
        "input": "n = 4, k = 9",
        "output": "2314",
        "explanation": "The permutations of [1, 2, 3, 4] are ['1234', '1243', '1324', '1342', '1423', '1432', '2134', '2143', '2314', '2341', '2413', '2431', '3124', '3142', '3214', '3241', '3412', '3421', '4123', '4132', '4213', '4231', '4312', '4321']. The ninth permutation is '2314'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Factorial helps to determine the number of possible permutations.",
      "Use a list to keep track of available numbers.",
      "Iteratively build the result string using quotient and remainder to find the positions."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Combinations",
    "description": "Given an integer n and an integer k, return all possible combinations of k numbers chosen from the range 1 to n. You may return the combinations in any order.",
    "topic": "Backtracking",
    "subtopic": "Combinations",
    "tags": [
      "Backtracking",
      "Combinations",
      "Recursion"
    ],
    "input_format": "Two integers n and k (1 <= k <= n <= 10^n).",
    "output_format": "A list of lists, where each list contains a combination of k numbers.",
    "constraints": [
      "1 <= n <= 20",
      "1 <= k <= n"
    ],
    "examples": [
      {
        "input": "n = 4, k = 2",
        "output": "[[2, 4], [3, 4], [1, 2], [1, 3], [1, 4], [2, 3]]",
        "explanation": "The combinations of 2 numbers from the set {1, 2, 3, 4} are listed in any order."
      },
      {
        "input": "n = 1, k = 1",
        "output": "[[1]]",
        "explanation": "The only combination of 1 number from the set {1} is [1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to explore all combinations.",
      "Use a list to store the current combination being formed."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Substring with Concatenation of All Words",
    "description": "You are given a string s and an array of strings words of the same length. Each string in words is of the same length. Your goal is to find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. The order of words in the concatenation matters.",
    "topic": "String",
    "subtopic": "Substring Search",
    "tags": [
      "String",
      "Substring",
      "Hash Table"
    ],
    "input_format": "A string s and an array of strings words.",
    "output_format": "A list of starting indices of substring(s) that are concatenations of each word in words.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 100",
      "The input strings consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = 'barfoothefoobarman', words = ['foo', 'bar']",
        "output": "[0, 9]",
        "explanation": "The substring starting at index 0 is 'barfoo' and the substring starting at index 9 is 'foobar'. Both are a concatenation of 'foo' and 'bar'."
      },
      {
        "input": "s = 'wordgoodgoodgoodbestword', words = ['word', 'good', 'best', 'word']",
        "output": "[]",
        "explanation": "Since the word 'word' appears twice in words but only once in the string s, there can be no valid concatenation."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a hash table to keep count of words.",
      "The substring length must equal the total length of words multiplied by the length of each word."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Recover Binary Search Tree",
    "description": "Given a binary search tree (BST) with exactly two nodes swapped, recover the tree so that the property of BST is restored. You need to perform an in-place recovery without modifying the structure of the tree.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "The root of the binary search tree.",
    "output_format": "Nothing is returned, but the input tree should be modified in-place to recover the BST properties.",
    "constraints": [
      "The number of nodes in the tree is in the range [2, 1000].",
      "Node values are distinct integers."
    ],
    "examples": [
      {
        "input": "root = [1, 3, null, null, 2]",
        "output": "The tree should be recovered to [3, 1, null, null, 2], maintaining the BST properties.",
        "explanation": "Nodes 1 and 3 are swapped. The correct BST should have 1 as the left child of 2."
      },
      {
        "input": "root = [3, 1, 4, null, null, 2]",
        "output": "The tree should be recovered to [2, 1, 4, null, null, 3].",
        "explanation": "Nodes 2 and 3 are swapped. The correct BST should have 1 as the left child of 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using an in-order traversal to identify the two nodes that are swapped.",
      "Keep track of the previous node while performing the traversal."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Permutations II",
    "description": "Given a collection of numbers that might contain duplicates, return all possible unique permutations. The solution set must not contain duplicate permutations.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Permutations",
      "Array"
    ],
    "input_format": "An integer array nums representing the collection of numbers.",
    "output_format": "A list of lists containing all unique permutations of the input array.",
    "constraints": [
      "1 <= nums.length <= 8",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "[[1, 1, 2], [1, 2, 1], [2, 1, 1]]",
        "explanation": "The unique permutations of the array [1, 1, 2] are [[1, 1, 2], [1, 2, 1], [2, 1, 1]]."
      },
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]",
        "explanation": "All permutations of the array [1, 2, 3] are unique."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the input array to facilitate duplicate handling.",
      "Use a backtracking approach to generate permutations."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Interleaving String",
    "description": "Given three strings s1, s2, and s3, determine if s3 is formed by the interleaving of s1 and s2. An interleaving of two strings s1 and s2 is a configuration where characters from s1 and s2 are mixed in a way that maintains the order of characters from both strings.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Interleaving"
    ],
    "input_format": "Three strings s1, s2, and s3.",
    "output_format": "A boolean value indicating whether s3 is an interleaving of s1 and s2.",
    "constraints": [
      "0 <= s1.length, s2.length, s3.length <= 100",
      "The total length of s1 and s2 must be equal to s3."
    ],
    "examples": [
      {
        "input": "s1 = \"aab\", s2 = \"axy\", s3 = \"aabyx\"",
        "output": "true",
        "explanation": "s3 can be formed by interleaving s1 and s2: \"aab\" + \"axy\" = \"aabyx\"."
      },
      {
        "input": "s1 = \"abc\", s2 = \"def\", s3 = \"abdecf\"",
        "output": "false",
        "explanation": "The characters in s3 do not maintain the order of s1 and s2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store the state of interleaving.",
      "A 2D array can help track which characters have been used from s1 and s2."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Gray Code",
    "description": "The Gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the number of bits, return the sequence of Gray code. A Gray code sequence must begin with 0, and it must contain 2^n values, which means that the sequence will have integer values ranging from 0 to 2^n - 1.",
    "topic": "Bit Manipulation",
    "subtopic": "Gray Code Generation",
    "tags": [
      "Bit Manipulation",
      "Gray Code",
      "Binary"
    ],
    "input_format": "An integer n (0 <= n <= 20) representing the number of bits in the Gray code.",
    "output_format": "A list of integers representing the sequence of Gray code.",
    "constraints": [
      "0 <= n <= 20"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "[0, 1, 3, 2]",
        "explanation": "The Gray code for n = 2 is [00, 01, 11, 10] which corresponds to the decimal values [0, 1, 3, 2]."
      },
      {
        "input": "n = 1",
        "output": "[0, 1]",
        "explanation": "The Gray code for n = 1 is [0, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the formula to generate the ith Gray code as i ^ (i >> 1)."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix II",
    "description": "Given an integer n, generate an n x n matrix filled with elements from 1 to n^2 in spiral order. The matrix should start from the top left corner and proceed to the right, then down, then left, then up, and repeat this pattern until it fills the matrix completely.",
    "topic": "Matrix",
    "subtopic": "Spiral Traversal",
    "tags": [
      "Matrix",
      "Spiral",
      "Array"
    ],
    "input_format": "An integer n representing the size of the matrix.",
    "output_format": "A 2D list of integers representing the generated spiral matrix.",
    "constraints": [
      "1 <= n <= 20"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[[1, 2, 3], [8, 9, 4], [7, 6, 5]]",
        "explanation": "The numbers from 1 to 9 are arranged in a 3x3 matrix in a spiral order."
      },
      {
        "input": "n = 1",
        "output": "[[1]]",
        "explanation": "A 1x1 matrix only contains the number 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use four pointers to manage the boundaries of the spiral.",
      "Keep a loop counter to know when to change direction."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Unique Binary Search Trees",
    "description": "Given an integer n, return the number of unique BSTs (binary search trees) that can be formed with n distinct nodes labeled from 1 to n.",
    "topic": "Dynamic Programming",
    "subtopic": "Combinatorial Structures",
    "tags": [
      "Dynamic Programming",
      "Binary Tree",
      "Combinatorics"
    ],
    "input_format": "An integer n (1 <= n <= 19).",
    "output_format": "An integer representing the number of unique BSTs that can be formed.",
    "constraints": [
      "1 <= n <= 19"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "5",
        "explanation": "The 5 unique BSTs that can be formed are: (1/ N/ 2/ N/ 3), (1/ N/ 3/ N/ 2), (2/ 1/ N/ N/ 3), (3/ 1/ N/ 2/ N), and (3/ 2/ N/ 1/ N)."
      },
      {
        "input": "n = 1",
        "output": "1",
        "explanation": "There is only one unique BST that can be formed with 1 node."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to build up the number of unique BSTs.",
      "The number of unique BSTs for a given n can be derived from the unique BST counts of smaller values."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Restore IP Addresses",
    "description": "Given a string containing only digits, restore it by returning all possible valid IP address combinations. A valid IP address consists of four integers separated by periods, where each integer is between 0 and 255 (inclusive) and cannot be preceded by a zero unless it is the number '0' itself.",
    "topic": "Backtracking",
    "subtopic": "String Manipulation",
    "tags": [
      "Backtracking",
      "String",
      "IP Addresses"
    ],
    "input_format": "A string s containing only numeric characters (0-9).",
    "output_format": "A list of strings representing all possible valid IP address combinations.",
    "constraints": [
      "0 < s.length <= 20",
      "s contains only digits."
    ],
    "examples": [
      {
        "input": "s = \"25525511135\"",
        "output": "[\"255.255.11.135\", \"255.255.111.35\"]",
        "explanation": "The valid IP addresses that can be formed are 255.255.11.135 and 255.255.111.35."
      },
      {
        "input": "s = \"0000\"",
        "output": "[\"0.0.0.0\"]",
        "explanation": "The only valid IP address that can be formed is 0.0.0.0."
      },
      {
        "input": "s = \"1111\"",
        "output": "[\"1.1.1.1\"]",
        "explanation": "The only valid IP address that can be formed is 1.1.1.1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider splitting the string into segments of 1 to 3 characters.",
      "Use backtracking to find all combinations while ensuring the segments are valid."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted List II",
    "description": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.",
    "topic": "Linked List",
    "subtopic": "Modification",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "A singular linked list head, represented by the ListNode class.",
    "output_format": "The modified linked list, with duplicates removed.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 300].",
      "-100 <= Node.val <= 100",
      "The list is guaranteed to be sorted in ascending order."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 3, 4, 4, 5]",
        "output": "[1, 2, 5]",
        "explanation": "Nodes with values 3 and 4 are duplicates and removed. The remaining list is 1 -> 2 -> 5."
      },
      {
        "input": "head = [1, 1, 1, 2, 3]",
        "output": "[2, 3]",
        "explanation": "All nodes with value 1 are duplicates. The remaining nodes are 2 and 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dummy node to simplify the list manipulation.",
      "Maintain a pointer that keeps track of the last unique node."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Valid Number",
    "description": "Implement a function that determines if a given string can be interpreted as a decimal number. A valid number can be an integer, a decimal or a number in scientific notation. The function should return true if the number is valid and false otherwise.",
    "topic": "String",
    "subtopic": "Parsing",
    "tags": [
      "String",
      "Parsing",
      "Validation"
    ],
    "input_format": "A string s representing the number to validate.",
    "output_format": "A boolean value indicating whether the number is valid.",
    "constraints": [
      "1 <= s.length <= 20",
      "s can contain digits, '.', 'e', '+', and '-'"
    ],
    "examples": [
      {
        "input": "s = '0.1'",
        "output": "true",
        "explanation": "'0.1' is a valid decimal number."
      },
      {
        "input": "s = 'abc'",
        "output": "false",
        "explanation": "'abc' is not a valid number."
      },
      {
        "input": "s = '1e10'",
        "output": "true",
        "explanation": "'1e10' is a valid number in scientific notation."
      },
      {
        "input": "s = '-1.5e+2'",
        "output": "true",
        "explanation": "'-1.5e+2' is valid as it represents -150."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using regular expressions for number validation.",
      "Handle edge cases for signs and decimal points."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "N-Queens II",
    "description": "The N-Queens II problem is to determine the number of distinct solutions to the N-Queens puzzle. The goal is to place N queens on an N x N chessboard such that no two queens threaten each other. Specifically, this means that no two queens can be in the same row, the same column, or on the same diagonal.",
    "topic": "Backtracking",
    "subtopic": "N-Queens",
    "tags": [
      "Backtracking",
      "Recursion",
      "Search"
    ],
    "input_format": "An integer N (1 <= N <= 15) representing the size of the chessboard.",
    "output_format": "An integer representing the total number of distinct solutions to the N-Queens puzzle.",
    "constraints": [
      "1 <= N <= 15"
    ],
    "examples": [
      {
        "input": "N = 4",
        "output": "2",
        "explanation": "There are two distinct approaches to placing four queens on a 4x4 chessboard such that no two queens threaten each other."
      },
      {
        "input": "N = 1",
        "output": "1",
        "explanation": "There is only one way to place one queen on a 1x1 chessboard."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using backtracking to explore possible placements of queens.",
      "Track the positions of threatened rows, columns, and diagonals."
    ],
    "company": "Amazon"
  },
  {
    "question_id": "",
    "title": "Scramble String",
    "description": "Given a string s1 and a string s2, determine if s2 is a scrambled string of s1. A string is considered scrambled if it can be formed by recursively swapping substrings. For example, 'great' can become 'rgeat' by swapping 'gr' and 'eat'.",
    "topic": "String",
    "subtopic": "Recursion",
    "tags": [
      "String",
      "Recursion",
      "Dynamic Programming"
    ],
    "input_format": "Two strings s1 and s2 of length n (1 <= n <= 30).",
    "output_format": "Return true if s2 is a scrambled string of s1, otherwise return false.",
    "constraints": [
      "1 <= s1.length, s2.length <= 30",
      "s1 and s2 consist of lowercase English letters.",
      "Both strings have the same length."
    ],
    "examples": [
      {
        "input": "s1 = \"great\", s2 = \"rgeat\"",
        "output": "true",
        "explanation": "One possible way to scramble 'great' into 'rgeat' is to swap 'gr' and 'eat'."
      },
      {
        "input": "s1 = \"abcde\", s2 = \"caebd\"",
        "output": "false",
        "explanation": "'caebd' cannot be obtained by scrambling 'abcde'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how you can recursively swap different segments of the strings.",
      "Check if the characters in both strings are the same."
    ],
    "company": "Amazon"
  }
]