[
  {
    "question_id": "",
    "title": "Zigzag Conversion",
    "description": "The input string is to be written in a zigzag pattern on a given number of rows. The characters are arranged in a zigzagging fashion downwards and then upwards again, forming a V-shape. Then, the characters are read line by line (from top to bottom) to create a new string. Your task is to implement this conversion algorithm.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Zigzag",
      "Manipulation"
    ],
    "input_format": "A string s and an integer numRows representing the number of rows in the zigzag pattern.",
    "output_format": "A string representing the characters in the zigzag pattern read line by line.",
    "constraints": [
      "1 <= s.length <= 1000",
      "1 <= numRows <= 1000"
    ],
    "examples": [
      {
        "input": "s = 'PAYPALISHIRING', numRows = 3",
        "output": "'PAHNAPLSIIGY'",
        "explanation": "'PAYPALISHIRING' arranged in a zigzag pattern with 3 rows becomes:\nP   A   H   N\nA P L S I I G\nY\nReading line by line gives 'PAHNAPLSIIGY'."
      },
      {
        "input": "s = 'A', numRows = 1",
        "output": "'A'",
        "explanation": "With 1 row, the output is simply the input string."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how characters are placed in each row and the direction of placement.",
      "You may need to track the current position in the zigzag pattern."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "LRU Cache",
    "description": "Design and implement a data structure for a Least Recently Used (LRU) cache. It should support the following operations: `get(key)` and `put(key, value)`. The `get(key)` operation should return the value of the key if the key exists in the cache, otherwise return -1. The `put(key, value)` operation should update the value of the key if the key exists. If the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item.",
    "topic": "Design",
    "subtopic": "Data Structures",
    "tags": [
      "Cache",
      "Design",
      "Data Structures",
      "Linked List",
      "Hash Map"
    ],
    "input_format": "An integer representing the capacity of the cache. Followed by various operations `get` and `put`.",
    "output_format": "Return the output of `get(key)` operations.",
    "constraints": [
      "The capacity of the cache is between 1 and 3000.",
      "The keys and values consist of the range of 1 to 10^4.",
      "All operations are guaranteed to be valid."
    ],
    "examples": [
      {
        "input": "LRUCache cache = new LRUCache(2); cache.put(1, 1); cache.put(2, 2); int output1 = cache.get(1); cache.put(3, 3); int output2 = cache.get(2); cache.put(4, 4); int output3 = cache.get(1); int output4 = cache.get(3); int output5 = cache.get(4);",
        "output": "[1, -1, -1, 4]",
        "explanation": "After the operations, the cache contains {1=1, 3=3}, 'get(2)' returns -1 since it's evicted. 'get(1)' returns 1, 'get(3)' returns 3, 'get(4)' returns 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a combination of a double-linked list and a hashmap.",
      "Keep track of the order of usage of keys."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Count Vowel Strings in Ranges",
    "description": "You are given an array of strings and a list of ranges. A vowel string is a string that starts and ends with a vowel ('a', 'e', 'i', 'o', 'u'). Your task is to count the number of vowel strings for each range given. The range is defined by two indices, and you should include the strings at those indices in the count.",
    "topic": "Arrays",
    "subtopic": "String Manipulation",
    "tags": [
      "Array",
      "String",
      "Counting"
    ],
    "input_format": "An array of strings 'words' and a list of ranges 'ranges'. Each range is represented as a list of two integers [start, end].",
    "output_format": "An array of integers where the i-th integer is the count of vowel strings in the i-th range.",
    "constraints": [
      "1 <= words.length <= 1000",
      "1 <= words[i].length <= 100",
      "1 <= ranges.length <= 100",
      "0 <= start <= end < words.length"
    ],
    "examples": [
      {
        "input": {
          "words": [
            "apple",
            "banana",
            "orange",
            "umbrella",
            "grape"
          ],
          "ranges": [
            [
              0,
              1
            ],
            [
              1,
              3
            ],
            [
              0,
              4
            ]
          ]
        },
        "output": [
          1,
          2,
          3
        ],
        "explanation": "For the range [0, 1]: 'apple' is a vowel string. For [1, 3]: 'orange' and 'umbrella' are vowel strings. For [0, 4]: 'apple', 'orange', and 'umbrella' are vowel strings."
      },
      {
        "input": {
          "words": [
            "ee",
            "b",
            "io",
            "u",
            "a"
          ],
          "ranges": [
            [
              0,
              2
            ],
            [
              1,
              4
            ]
          ]
        },
        "output": [
          2,
          3
        ],
        "explanation": "In range [0, 2]: 'ee' and 'io' are vowel strings. In range [1, 4]: 'io', 'u', and 'a' are vowel strings."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a helper function to check if a string starts and ends with a vowel.",
      "Iterate through each range and count the valid strings."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Minimum Replacements to Sort the Array",
    "description": "Given an array of integers, your task is to determine the minimum number of replacements needed to make the array sorted in non-decreasing order. A replacement involves changing an element of the array to any integer. You may make as many replacements as needed.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Greedy"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the minimum number of replacements required.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [4, 2, 3]",
        "output": "1",
        "explanation": "We can replace the 4 with 2, making the array [2, 2, 3], which is sorted."
      },
      {
        "input": "nums = [5, 4, 3, 2, 1]",
        "output": "4",
        "explanation": "We need to replace the first four elements to make the array sorted. After replacements, it can be [1, 2, 3, 4, 5]."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the longest non-decreasing subsequence.",
      "Use a greedy approach to minimize replacements."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Count the Number of Vowel Strings in Range",
    "description": "Given an array of strings, your task is to count the number of strings that consist only of vowels and fall within a specified range of indices. A string is considered a vowel string if it contains only the characters 'a', 'e', 'i', 'o', and 'u' (case insensitive). You need to implement a function that determines the count of such vowel strings within the given range.",
    "topic": "String",
    "subtopic": "Counting",
    "tags": [
      "String",
      "Counting",
      "Vowels"
    ],
    "input_format": "An array of strings strings and two integers left and right.",
    "output_format": "An integer representing the count of vowel strings in the specified range.",
    "constraints": [
      "1 <= strings.length <= 100",
      "1 <= left <= right <= strings.length",
      "Each string consists of lowercase and uppercase English letters only."
    ],
    "examples": [
      {
        "input": "strings = [\"aeiou\", \"hello\", \"UOIEA\", \"world\", \"AEIOU\"], left = 1, right = 3",
        "output": "2",
        "explanation": "The vowel strings in the range are \"UOIEA\" and \"hello\", hence the count is 2."
      },
      {
        "input": "strings = [\"sky\", \"eye\", \"ocean\", \"echo\"], left = 0, right = 3",
        "output": "2",
        "explanation": "The vowel strings are \"eye\" and \"ocean\", hence the count is 2."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Check each string for allowed characters.",
      "Use a simple loop to traverse the given range."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Word Search",
    "description": "Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where 'adjacent' cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "topic": "Backtracking",
    "subtopic": "Grid Search",
    "tags": [
      "Backtracking",
      "Depth-First Search",
      "Matrix"
    ],
    "input_format": "A 2D board represented as a list of lists of characters, followed by a string that represents the word to search for.",
    "output_format": "Return true if the word exists in the grid, otherwise return false.",
    "constraints": [
      "1 <= board.length, board[i].length <= 6",
      "1 <= word.length <= 15",
      "board[i][j] is a lowercase English letter."
    ],
    "examples": [
      {
        "input": "board = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], word = 'ABCCED'",
        "output": "true",
        "explanation": "The word 'ABCCED' can be constructed from the letters in the grid."
      },
      {
        "input": "board = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], word = 'SEE'",
        "output": "true",
        "explanation": "The word 'SEE' can be constructed from the letters in the grid."
      },
      {
        "input": "board = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], word = 'ABCB'",
        "output": "false",
        "explanation": "The word 'ABCB' cannot be constructed from the letters in the grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth-First Search (DFS) to explore paths on the grid.",
      "Keep track of visited cells to avoid reusing the same letter."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array where the ith element is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Write a function that returns the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Dynamic Programming",
    "subtopic": "Maximum Profit",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices where each element represents the price of a stock on day i.",
    "output_format": "An integer representing the maximum profit that can be achieved.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Use a single pass to calculate the maximum profit."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Number of Valid Move Combinations On Chessboard",
    "description": "Given a chessboard of size n x n and the initial position of a knight, return the number of valid ways the knight can move to reach a specified target position in exactly k moves. The knight can move in an L-shape: two squares in one direction and one square perpendicular. Moves may wrap around the edges of the board, meaning if it moves off one side, it appears on the opposite side.",
    "topic": "Dynamic Programming",
    "subtopic": "Combinatorial Game Theory",
    "tags": [
      "Dynamic Programming",
      "Backtracking",
      "Chess"
    ],
    "input_format": "Three integers n (1 <= n <= 100), k (0 <= k <= 100), and the initial position (startRow, startColumn) of the knight followed by the target position (targetRow, targetColumn).",
    "output_format": "An integer representing the number of valid ways to reach the target position in exactly k moves.",
    "constraints": [
      "1 <= n <= 100",
      "0 <= k <= 100",
      "0 <= startRow, startColumn, targetRow, targetColumn < n"
    ],
    "examples": [
      {
        "input": "n = 3, k = 2, startRow = 0, startColumn = 0, targetRow = 1, targetColumn = 2",
        "output": "2",
        "explanation": "The knight can reach (1, 2) in two moves by moving to (2, 1) and then to (1, 2) or moving to (1, 0) and then to (2, 1)."
      },
      {
        "input": "n = 1, k = 0, startRow = 0, startColumn = 0, targetRow = 0, targetColumn = 0",
        "output": "1",
        "explanation": "The knight is already at the target position without needing any moves."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to track the number of ways to reach each position over k moves.",
      "Utilize modulo operations to handle boundaries for knight movements."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Meeting Scheduler",
    "description": "You are given two lists of intervals representing the availability of two people. Each interval represents a time range where a person is free to meet. Your goal is to find a common interval where both people are available to meet. If there are multiple common intervals, return all of them. If there is no common time range, return an empty list.",
    "topic": "Interval Scheduling",
    "subtopic": "Overlapping Intervals",
    "tags": [
      "Intervals",
      "Scheduling",
      "Array"
    ],
    "input_format": "Two lists of intervals, where each interval is represented as [start, end].",
    "output_format": "A list of intervals representing the common available times.",
    "constraints": [
      "1 <= intervals1.length, intervals2.length <= 10^4",
      "0 <= intervals1[i][0] < intervals1[i][1] <= 10^9",
      "0 <= intervals2[j][0] < intervals2[j][1] <= 10^9"
    ],
    "examples": [
      {
        "input": "intervals1 = [[1, 3], [5, 6]], intervals2 = [[2, 4], [7, 8]]",
        "output": "[[2, 3]]",
        "explanation": "The common available time is from 2 to 3."
      },
      {
        "input": "intervals1 = [[1, 2]], intervals2 = [[1, 3]]",
        "output": "[[1, 2]]",
        "explanation": "The only common available time is from 1 to 2."
      },
      {
        "input": "intervals1 = [[1, 5]], intervals2 = [[6, 8]]",
        "output": "[]",
        "explanation": "There are no common available times."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider merging or comparing the intervals in some way.",
      "Sort the intervals based on start times to handle overlaps."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Maximum Frequency Score of a Subarray",
    "description": "Given an array of integers, you need to find the maximum frequency score of any contiguous subarray. The frequency score of a subarray is defined as the product of the maximum element and the frequency count of that element in the subarray. Return the maximum frequency score found among all possible subarrays.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Subarray",
      "Frequency"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum frequency score of any contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2, 3, 3, 3]",
        "output": "9",
        "explanation": "The subarray [3, 3, 3] gives a maximum element of 3 with a frequency of 3, resulting in a score of 3 * 3 = 9."
      },
      {
        "input": "nums = [1, 3, 2, 1, 2, 2]",
        "output": "6",
        "explanation": "The subarray [2, 2] gives a maximum element of 2 with a frequency of 3, resulting in a score of 2 * 3 = 6."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a sliding window approach to efficiently keep track of the maximum element and its frequency.",
      "Utilize a frequency map or hash map to count the occurrences of each element."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Graph",
    "subtopic": "DFS/BFS",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Matrix"
    ],
    "input_format": "A 2D grid represented as a list of lists, where each element is either '1' or '0'.",
    "output_format": "An integer representing the number of islands in the grid.",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[i].length <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "grid = [['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]",
        "output": "1",
        "explanation": "There is one island formed by the '1's in the grid."
      },
      {
        "input": "grid = [['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]",
        "output": "3",
        "explanation": "There are three distinct islands formed by the '1's in the grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use DFS or BFS to explore the grid.",
      "Mark visited land as water to prevent counting again.",
      "Count each connected component of '1's as an island."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Maximum Number of Integers to Choose From a Range I",
    "description": "Given a range defined by two integers [left, right] and an array of unique integers nums, your task is to find the maximum number of integers from nums that can be chosen such that all the chosen integers fall within the specified range [left, right].",
    "topic": "Array",
    "subtopic": "Range Queries",
    "tags": [
      "Array",
      "Range",
      "Counting"
    ],
    "input_format": "Two integers left and right, followed by an array of unique integers nums.",
    "output_format": "An integer representing the maximum number of integers that can be chosen from nums within the range [left, right].",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5",
      "-10^5 <= left <= right <= 10^5"
    ],
    "examples": [
      {
        "input": "left = 1, right = 5, nums = [1, 3, 5, 7, 9]",
        "output": "3",
        "explanation": "The integers in nums within the range [1, 5] are [1, 3, 5]. Thus, the maximum count is 3."
      },
      {
        "input": "left = -2, right = 2, nums = [-3, -1, 0, 1, 2, 3]",
        "output": "4",
        "explanation": "The integers in nums within the range [-2, 2] are [-1, 0, 1, 2]. Thus, the maximum count is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to quickly find the bounds of the range.",
      "Iterate through the array and use conditions to count the valid numbers."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Time Needed to Rearrange a Binary String",
    "description": "You are given a binary string s that represents a simple arrangement of '0's and '1's. Your task is to determine the minimum number of operations needed to rearrange the string such that all '0's are at the start and all '1's are at the end. An operation consists of choosing a '0' and a '1' and swapping them. If it is not possible to completely rearrange the string, return -1.",
    "topic": "String Manipulation",
    "subtopic": "Binary String Operations",
    "tags": [
      "String",
      "Binary",
      "Swap"
    ],
    "input_format": "A string s consisting of '0's and '1's.",
    "output_format": "An integer representing the minimum number of swaps needed, or -1 if rearrangement is not possible.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s[i] is either '0' or '1'."
    ],
    "examples": [
      {
        "input": "s = '0101'",
        "output": "2",
        "explanation": "We need to swap the first '1' with the last '0', and the second '1' with the second '0', leading to '0001'."
      },
      {
        "input": "s = '1110'",
        "output": "1",
        "explanation": "We swap the last '0' with the first '1' to get '0111'."
      },
      {
        "input": "s = '1111'",
        "output": "0",
        "explanation": "The binary string is already sorted."
      },
      {
        "input": "s = '0000'",
        "output": "0",
        "explanation": "The binary string is already sorted."
      },
      {
        "input": "s = '111000'",
        "output": "3",
        "explanation": "We need to swap the three '1's with the three '0's to get '000111'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Count the number of '0's and '1's to check if rearrangement is possible.",
      "Consider the positions of '0's and '1's to determine the swaps needed.",
      "Use a two-pointer technique for optimal swapping."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers, return the indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Two Sum"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "0 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 2 + 7 = 9."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "nums[1] + nums[2] = 2 + 4 = 6."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hashmap to store the difference between the target and each element."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Count Array Pairs Divisible by K",
    "description": "Given an array of integers and an integer K, your task is to count the number of unique pairs (i, j) in the array such that i < j and (nums[i] + nums[j]) is divisible by K. The order of the pairs does not matter, and you should not count duplicate pairs. Return the count of such pairs.",
    "topic": "Array",
    "subtopic": "Pair Counting",
    "tags": [
      "Array",
      "Mathematics",
      "Counting"
    ],
    "input_format": "An array of integers nums and an integer K.",
    "output_format": "An integer representing the count of unique pairs (i, j) that are divisible by K.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9",
      "1 <= K <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5], K = 3",
        "output": "4",
        "explanation": "The valid pairs are (1, 2), (1, 5), (2, 4), and (3, 3) as their sums are divisible by 3."
      },
      {
        "input": "nums = [1, 1, 1, 1], K = 2",
        "output": "6",
        "explanation": "All pairs (1, 1) are valid and contribute to 6 unique pairs."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a map to track remainders when divided by K.",
      "Think about how to efficiently count pairs using the properties of modular arithmetic."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Smallest Greater Multiple Made of Two Digits",
    "description": "Given a positive integer n, you need to find the smallest number that is a multiple of n and is composed entirely of two digits. A two-digit number is defined as an integer in the range from 10 to 99, inclusive. If no such number exists, return -1.",
    "topic": "Mathematics",
    "subtopic": "Number Theory",
    "tags": [
      "Math",
      "Multiples",
      "Two Digits"
    ],
    "input_format": "A single integer n (1 <= n <= 1000).",
    "output_format": "An integer representing the smallest multiple of n that consists only of two digits, or -1 if no such multiple exists.",
    "constraints": [
      "1 <= n <= 1000"
    ],
    "examples": [
      {
        "input": "n = 12",
        "output": "12",
        "explanation": "The multiples of 12 are 12, 24, 36,... 12 is a two-digit number and is the smallest."
      },
      {
        "input": "n = 11",
        "output": "22",
        "explanation": "The multiples of 11 closest to two digits are 11, 22, 33,... 22 is the smallest two-digit number that is a multiple of 11."
      },
      {
        "input": "n = 55",
        "output": "55",
        "explanation": "55 is a multiple of 55 and it is also a two-digit number."
      },
      {
        "input": "n = 100",
        "output": "-1",
        "explanation": "100 is the smallest multiple of 100, which is not a two-digit number."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Check for multiples of n starting from 10 up to 99.",
      "Use a loop to iterate through numbers and check their properties."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Minimum Non-Zero Product of the Array Elements",
    "description": "You are given an array of integers where each integer represents an element in the array. Your task is to calculate the minimum non-zero product of the array elements after any number of operations. An operation consists of selecting two distinct positive integers in the array, removing them, and inserting their product back into the array. You need to return the minimum possible product of non-zero integers left in the array.",
    "topic": "Array",
    "subtopic": "Mathematics",
    "tags": [
      "Array",
      "Mathematics",
      "Product"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the minimum non-zero product of the array elements.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "6",
        "explanation": "We can combine 2 and 3 to get 6 (2 * 3), leaving us with only 1 remaining. The minimum non-zero product is 6."
      },
      {
        "input": "nums = [4, 5, 6]",
        "output": "120",
        "explanation": "The product of all elements (4 * 5 * 6) gives 120, which is the minimum non-zero product."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of multiplication.",
      "Think about how to minimize the product when combining elements.",
      "You might want to focus on pairing the largest numbers."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Return a list of groups of anagrams, where each group is a list of words that are anagrams of each other.",
    "topic": "Hash Table",
    "subtopic": "Grouping",
    "tags": [
      "Hash Table",
      "String",
      "Anagrams"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A list of lists, where each inner list contains strings that are anagrams of each other.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
        "output": "[[\"ate\",\"eat\",\"tea\"],[\"nat\",\"tan\"],[\"bat\"]]",
        "explanation": "The words 'eat', 'tea', and 'ate' are anagrams of each other; 'nat' and 'tan' are anagrams; 'bat' stands alone."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "The input has only one empty string, which is an anagram of itself."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "The input consists of a single character, which is an anagram of itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort each string and use the sorted string as a key.",
      "Use a dictionary to collect groups of anagrams."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Maximum Number of Integers to Choose From a Range II",
    "description": "You are given two integers, `low` and `high`, representing the inclusive range of possible integers. Your task is to determine the maximum number of distinct integers that you can choose from this range such that the absolute difference between any two chosen integers does not exceed a specified threshold, `d`. You should return this maximum count of integers. If the range contains fewer than `d` integers, then it is impossible to choose them as per the constraint. Hence, return 0 in such cases.",
    "topic": "Greedy",
    "subtopic": "Interval Scheduling",
    "tags": [
      "Greedy",
      "Interval",
      "Range"
    ],
    "input_format": "Two integers `low`, `high` (1 <= low <= high <= 10^9) and an integer `d` (1 <= d <= high - low + 1).",
    "output_format": "An integer representing the maximum count of distinct integers that can be chosen.",
    "constraints": [
      "1 <= low <= high <= 10^9",
      "1 <= d <= high - low + 1"
    ],
    "examples": [
      {
        "input": "low = 1, high = 10, d = 3",
        "output": "3",
        "explanation": "You can choose integers 1, 4, and 7. The absolute difference between any two chosen integers is not greater than 3."
      },
      {
        "input": "low = 5, high = 10, d = 6",
        "output": "0",
        "explanation": "Since the range contains only 6 integers (5 to 10) but the threshold is 6, you cannot choose a distinct set that satisfies the condition."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the range size and how many integers fit within the difference constraint.",
      "Think about selecting integers at regular intervals to maximize the count."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Paint House III",
    "description": "You are given a list of houses and a cost array representing the cost of painting each house with different colors. Each house can be painted with one of K colors, and you have to follow certain constraints. The goal is to paint all houses such that no two adjacent houses have the same color while minimizing the total cost. Additionally, at least one house must be painted with a specific color. Determine the minimum cost to achieve this.",
    "topic": "Dynamic Programming",
    "subtopic": "Optimization",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Graph"
    ],
    "input_format": "An integer n (the number of houses), an integer K (the number of colors), a 2D list costs where costs[i][j] is the cost of painting house i with color j, and an integer targetColor (the specific color that must be used at least once).",
    "output_format": "An integer representing the minimum cost to paint all houses while satisfying the constraints.",
    "constraints": [
      "1 <= n <= 100",
      "2 <= K <= 20",
      "0 <= costs[i][j] <= 10^4",
      "1 <= targetColor <= K"
    ],
    "examples": [
      {
        "input": "n = 3, K = 3, costs = [[1, 2, 3], [10, 11, 12], [4, 5, 6]], targetColor = 1",
        "output": "8",
        "explanation": "Paint house 0 with color 1 (cost 1), house 1 with color 2 (cost 11), house 2 with color 1 (cost 4), Total cost = 1 + 11 + 4 = 16."
      },
      {
        "input": "n = 4, K = 2, costs = [[8, 10], [7, 5], [3, 9], [5, 6]], targetColor = 2",
        "output": "21",
        "explanation": "A valid painting strategy is to paint house 0 with color 1 (cost 10), house 1 with color 2 (cost 5), house 2 with color 1 (cost 3), and house 3 with color 2 (cost 6), Total cost = 10 + 5 + 3 + 6 = 24."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to keep track of costs for each house and color combination.",
      "Keep track of the houses painted with the target color."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Maximum Sum Obtained of Any Permutation",
    "description": "You are given an array of integers and you can permute the elements of this array in any way. Your goal is to find the maximum sum obtainable by performing the following operation: choose two numbers, `a` and `b`, and replace them with their sum `a + b` until only one number remains. Return this maximum sum that can be obtained from the array permutations.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Permutations",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum sum obtainable.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "6",
        "explanation": "The maximum sum is obtained by performing the operations (1 + 2) + 3 = 6."
      },
      {
        "input": "nums = [5, 1, 3, 4]",
        "output": "13",
        "explanation": "The maximum sum is obtained by performing the operations (5 + 4) + (3 + 1) = 13."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how combining elements affects the total sum.",
      "Look for patterns in sums when elements are combined in different orders."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Maximal Square",
    "description": "Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "2D Matrix",
    "tags": [
      "Dynamic Programming",
      "Matrix",
      "Binary Search"
    ],
    "input_format": "A binary matrix represented as a 2D list of integers (0s and 1s).",
    "output_format": "An integer representing the area of the largest square containing only 1's.",
    "constraints": [
      "1 <= matrix.length <= 300",
      "1 <= matrix[i].length <= 300",
      "matrix[i][j] is either '0' or '1'."
    ],
    "examples": [
      {
        "input": "[['1', '0', '1', '0', '0'], ['1', '0', '1', '1', '1'], ['1', '1', '1', '1', '1'], ['1', '0', '0', '1', '0']]",
        "output": "4",
        "explanation": "The largest square has a side length of 2 and an area of 2 x 2 = 4."
      },
      {
        "input": "[['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0']]",
        "output": "0",
        "explanation": "There are no 1's, thus the area of the largest square is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to keep track of squares ending at each cell.",
      "Use the minimum of the three neighboring squares to determine the size of the square."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Longest Increasing Subsequence",
    "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence.\n\nA subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, [3, 6, 2, 7] is a subsequence of [10, 9, 2, 3, 6, 5, 7].",
    "topic": "Dynamic Programming",
    "subtopic": "Subsequence",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Subsequence"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the length of the longest increasing subsequence.",
    "constraints": [
      "1 <= nums.length <= 2500",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [10, 9, 2, 5, 3, 7, 101, 18]",
        "output": "4",
        "explanation": "The longest increasing subsequence is [2, 3, 7, 101], hence the length is 4."
      },
      {
        "input": "nums = [0, 1, 0, 3, 2, 3]",
        "output": "4",
        "explanation": "The longest increasing subsequence is [0, 1, 2, 3], hence the length is 4."
      },
      {
        "input": "nums = [7, 7, 7, 7, 7, 7, 7]",
        "output": "1",
        "explanation": "The longest increasing subsequence is [7], hence the length is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to solve this problem.",
      "You can also use binary search to optimize the solution."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Coin Change",
    "description": "You are given an array of integers coins representing coins of different denominations and an integer amount representing a total amount of money. You want to determine the number of combinations that make up that amount. You may assume that you have an infinite number of each kind of coin. The order of coins in combinations does not matter.",
    "topic": "Dynamic Programming",
    "subtopic": "Combinatorial Sum",
    "tags": [
      "Dynamic Programming",
      "Combinations",
      "Coin Change"
    ],
    "input_format": "An integer array coins representing different denominations and an integer amount representing the total amount.",
    "output_format": "An integer representing the number of combinations that make up the amount.",
    "constraints": [
      "1 <= coins.length <= 300",
      "1 <= coins[i] <= 5000",
      "0 <= amount <= 5000"
    ],
    "examples": [
      {
        "input": "coins = [1, 2, 5], amount = 5",
        "output": "4",
        "explanation": "There are four combinations that make up the amount 5: [1,1,1,1,1], [1,1,1,2], [1,2,2], and [5]."
      },
      {
        "input": "coins = [2], amount = 3",
        "output": "0",
        "explanation": "No combination can make up the amount 3 with only coin of denomination 2."
      },
      {
        "input": "coins = [10], amount = 10",
        "output": "1",
        "explanation": "Only one combination: [10]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to solve this problem.",
      "You might want to create a dp array to store number of combinations."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Product of Array Except Self",
    "description": "Given an array nums of n integers where n > 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n).",
    "topic": "Array",
    "subtopic": "Prefix and Suffix Products",
    "tags": [
      "Array",
      "Product",
      "Prefix Sums"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An array of integers representing the product of all elements except the self.",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-30 <= nums[i] <= 30",
      "The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer."
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "[24, 12, 8, 6]",
        "explanation": "For example, output[0] is equal to the product of all elements except nums[0] which is 2 * 3 * 4 = 24."
      },
      {
        "input": "nums = [-1, 1, 0, -3, 3]",
        "output": "[0, 0, 9, 0, 0]",
        "explanation": "For index 2 (which is 0), the product of other elements (-1, 1, -3, 3) is 9."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using prefix and suffix products.",
      "You can calculate the left and right products separately."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Pairs of Songs With Total Durations Divisible by 60",
    "description": "You are given an array of integers where each integer represents the duration of a song in seconds. Your task is to find the number of pairs of songs that have a total duration which is divisible by 60 seconds. A pair is defined as two different songs, and the order of the songs in the pair does not matter.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Counting Pairs"
    ],
    "input_format": "An array of integers representing the durations of songs.",
    "output_format": "An integer representing the number of pairs of songs whose total duration is divisible by 60 seconds.",
    "constraints": [
      "1 <= songs.length <= 10000",
      "0 <= songs[i] <= 5000"
    ],
    "examples": [
      {
        "input": "songs = [30, 20, 150, 100, 40]",
        "output": "3",
        "explanation": "The valid pairs are (30, 150), (20, 100), and (30, 30) (the same song can pair with itself)."
      },
      {
        "input": "songs = [60, 60, 60]",
        "output": "3",
        "explanation": "Each pair of the three 60-second songs will create a valid pair: (60, 60), (60, 60), and (60, 60)."
      },
      {
        "input": "songs = [10, 50, 70, 30]",
        "output": "1",
        "explanation": "The only valid pair is (10, 50), since 10 + 50 = 60."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a frequency array to count remainders.",
      "Utilize the concept of complementary pairs."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Merge Sorted Array",
    "description": "Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Initially, nums1 has a length of m, which represents the number of elements in the array, and nums2 has a length of n, which is the number of elements to be merged. The merge should be done in-place, and you must not use any extra space besides a few variables.",
    "topic": "Array",
    "subtopic": "Merging Arrays",
    "tags": [
      "Array",
      "Merging",
      "Two Pointers"
    ],
    "input_format": "Two integer arrays nums1 and nums2, where nums1 has enough space to hold additional elements from nums2.",
    "output_format": "The merged array nums1 in sorted order.",
    "constraints": [
      "0 <= m, n <= 10^4",
      "-10^9 <= nums1[i], nums2[j] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3",
        "output": "[1, 2, 2, 3, 5, 6]",
        "explanation": "After merging, the nums1 array becomes [1, 2, 2, 3, 5, 6]."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "Since nums2 is empty, nums1 remains unchanged."
      },
      {
        "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
        "output": "[1]",
        "explanation": "We replace zeros in nums1 with elements from nums2, resulting in [1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers starting from the end of each array.",
      "Merge in reverse to overwrite nums1 without losing its initial values."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Minimum Absolute Difference",
    "description": "Given an array of integers, find the minimum absolute difference between any two elements in the array. The absolute difference between two numbers a and b is defined as |a - b|. You must return this minimum absolute difference among all pairs (i, j) where i < j.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Difference"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the minimum absolute difference.",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [3, 8, 15, 1]",
        "output": "2",
        "explanation": "The pairs (3, 1) have an absolute difference of 2, which is the minimum."
      },
      {
        "input": "nums = [4, 2, 1, 3]",
        "output": "0",
        "explanation": "There are no duplicate elements, so the minimum absolute difference is between pairs of the closest numbers, which is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Sort the array first to make it easier to find the minimum difference.",
      "Calculate the difference only between consecutive elements after sorting."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. For example, if intervals = [[1,3],[2,6],[8,10],[15,18]], the result should be [[1,6],[8,10],[15,18]]. The intervals [1,3] and [2,6] overlap, so we merge them into [1,6].",
    "topic": "Array",
    "subtopic": "Sorting and Merging",
    "tags": [
      "Array",
      "Sorting",
      "Interval"
    ],
    "input_format": "A list of intervals, where each interval is represented as a pair of integers [start, end].",
    "output_format": "A list of merged intervals.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "The intervals [1,3] and [2,6] overlap, thus they are merged into [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "The intervals [1,4] and [4,5] touch at 4, thus they are merged into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on the start time.",
      "Use a loop to check for overlapping intervals and merge them."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Subarray Sum Equals K",
    "description": "Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k.",
    "topic": "Array",
    "subtopic": "Prefix Sum",
    "tags": [
      "Array",
      "HashMap",
      "Prefix Sum"
    ],
    "input_format": "An integer array nums and an integer k.",
    "output_format": "An integer representing the total number of continuous subarrays whose sum equals to k.",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-1000 <= nums[i] <= 1000",
      "-10^7 <= k <= 10^7"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 1], k = 2",
        "output": "2",
        "explanation": "The subarrays [1, 1] (from index 0 to 1) and [1, 1] (from index 1 to 2) sum up to 2."
      },
      {
        "input": "nums = [1, 2, 3], k = 3",
        "output": "2",
        "explanation": "The subarrays [3] (from index 2 to 2) and [1, 2] (from index 0 to 1) sum up to 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a HashMap to store the prefix sums.",
      "Think about how you can reduce the problem space using cumulative sums."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters. A substring is a contiguous sequence of characters within a string. You need to return the length of the longest substring that does not contain any repeating characters.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A string s consisting of English letters, digits, symbols and spaces.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 10^5",
      "s consists of English letters, digits, symbols and spaces."
    ],
    "examples": [
      {
        "input": "s = 'abcabcbb'",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'abc', which has a length of 3."
      },
      {
        "input": "s = 'bbbbb'",
        "output": "1",
        "explanation": "The longest substring without repeating characters is 'b', with a length of 1."
      },
      {
        "input": "s = 'pwwkew'",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'wke', with a length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window technique to maintain a substring.",
      "Utilize a HashMap to track the last seen position of each character."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Reorganize String",
    "description": "Given a string s, rearrange the characters of the string so that no two adjacent characters are the same. If such arrangement is not possible, return an empty string. The rearranged string should be in lexicographical order if multiple valid answers exist.",
    "topic": "String",
    "subtopic": "Rearrangement",
    "tags": [
      "String",
      "Rearrangement",
      "Greedy"
    ],
    "input_format": "A string s consisting of lowercase English letters.",
    "output_format": "A string representing the rearranged characters or an empty string if rearrangement is not possible.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "aabbcc",
        "output": "abcabc",
        "explanation": "One valid rearrangement is 'abcabc', where no adjacent characters are the same."
      },
      {
        "input": "aaabc",
        "output": "",
        "explanation": "It is not possible to rearrange the string such that no two adjacent characters are the same."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Count the frequency of each character.",
      "Use a max-heap to store characters by frequency.",
      "Ensure the most frequent character does not exceed half the length of the string."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of bars in a histogram, compute the amount of water that can be trapped after raining. The water can only be trapped if there's a bar on both sides of the current bar, forming a container.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Two Pointers"
    ],
    "input_format": "An array of integers representing the height of the bars.",
    "output_format": "An integer representing the total units of water that can be trapped.",
    "constraints": [
      "n == height.length",
      "1 <= n <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The water can be trapped in the spaces between the bars: 1 unit between bars 1 and 3, 2 units between bars 3 and 5, and 3 units between bars 8 and 11."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The water can be trapped in the spaces between the bars, totaling 9 units."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using an efficient two-pointer approach.",
      "Keep track of the maximum heights from both sides."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Find the Smallest Divisor Given a Threshold",
    "description": "Given an array of positive integers nums and a positive integer threshold, you need to find the smallest divisor such that the sum of the division of each element in nums by this divisor, rounded up to the nearest integer, is less than or equal to threshold. The division should be rounded up, meaning that for a value x, the result should be ceil(x). You need to return the smallest divisor that meets this condition.",
    "topic": "Binary Search",
    "subtopic": "Searching",
    "tags": [
      "Binary Search",
      "Math",
      "Array"
    ],
    "input_format": "An array of positive integers nums and a positive integer threshold.",
    "output_format": "An integer representing the smallest divisor.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i], threshold <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 5, 9], threshold = 6",
        "output": "5",
        "explanation": "For divisor = 5, the rounded results are [1, 1, 1, 2]. Sum is 1 + 1 + 1 + 2 = 5 which is <= 6."
      },
      {
        "input": "nums = [2, 3, 5, 7, 11], threshold = 11",
        "output": "3",
        "explanation": "For divisor = 3, the rounded results are [1, 1, 2, 3, 4]. Sum is 1 + 1 + 2 + 3 + 4 = 11 which meets the threshold."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of divisors.",
      "Utilize binary search to optimize the process of finding the smallest divisor."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Loud and Rich",
    "description": "In a world where individuals have a loudness level that influences their richness, you're tasked with finding out how much richer a person can become given their loudness and the loudness of their friends. Each person is represented by an integer. If Person A is louder than Person B, then Person A can contribute to Person B's richness according to their respective loudness levels. Given an array of loudness levels for each person and a 2D array indicating their friendships, return an array of integers where each index represents the total richness of that person after accounting for contributions from their friends.",
    "topic": "Graph",
    "subtopic": "Depth First Search",
    "tags": [
      "Graph",
      "Depth First Search",
      "Simulation"
    ],
    "input_format": "An integer array loudness representing the loudness level of each person, and a 2D array richer representing friend relationships.",
    "output_format": "An integer array where each element corresponds to the total richness of each person.",
    "constraints": [
      "1 <= loudness.length <= 1000",
      "1 <= loudness[i] <= 1000",
      "0 <= richer.length <= 1000",
      "0 <= richer[i][0], richer[i][1] < loudness.length"
    ],
    "examples": [
      {
        "input": "loudness = [1, 2, 3, 4], richer = [[0, 1], [1, 2], [2, 3]]",
        "output": "[1, 3, 6, 10]",
        "explanation": "In this case, person 0 contributes to person 1 (1), person 1 contributes to person 2 (2), and person 2 contributes to person 3 (3). Thus the total richness for person 1 is 1 + 2 = 3, for person 2 it is 1 + 2 + 3 = 6, and for person 3 it is 1 + 2 + 3 + 4 = 10."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth First Search to explore contributions from friends.",
      "Keep track of visited nodes to avoid cycles."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Meeting Rooms III",
    "description": "You are given an array of meeting time intervals where intervals[i] = [start_i, end_i]. A meeting time interval consists of a start time and an end time. You have a total of 'k' meeting rooms available. Your task is to determine if all meetings can be attended at the given times with the available meeting rooms. If you can attend all meetings, return true; otherwise, return false.",
    "topic": "Interval Management",
    "subtopic": "Meeting Scheduling",
    "tags": [
      "Array",
      "Greedy",
      "Sorting",
      "Intervals"
    ],
    "input_format": "An array of integer arrays intervals, and an integer k representing the number of rooms available.",
    "output_format": "A boolean value indicating whether all meetings can be attended with the available rooms.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= start_i < end_i <= 10^6",
      "1 <= k <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[0,30],[5,10],[15,20]], k = 2",
        "output": "false",
        "explanation": "At time 5, meeting [0,30] overlaps with meeting [5,10], and only 2 rooms are available."
      },
      {
        "input": "intervals = [[7,10],[2,4]], k = 2",
        "output": "true",
        "explanation": "Both meetings can be attended in the available 2 rooms since they don't overlap."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Try to sort the meetings by their start time.",
      "Use a priority queue to manage the end times of meetings."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Sort Colors",
    "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function and do it in a single pass.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Sorting",
      "Two Pointers"
    ],
    "input_format": "An integer array nums where each element is either 0, 1, or 2.",
    "output_format": "The input array sorted in-place.",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 300",
      "nums[i] is 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "nums = [2, 0, 2, 1, 1, 0]",
        "output": "[0, 0, 1, 1, 2, 2]",
        "explanation": "By sorting the colors, we get two 0s, two 1s, and two 2s in the correct order."
      },
      {
        "input": "nums = [2, 0, 1]",
        "output": "[0, 1, 2]",
        "explanation": "After sorting, 0 comes first, then 1, and finally 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a two-pointer approach to keep track of the current position and boundaries for each color."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Maximum Number of Events That Can Be Attended",
    "description": "You are given an array of events where each event is represented as a pair of integers [start, end]. Your task is to determine the maximum number of events you can attend. You can only attend one event at a time and can only attend an event if you arrive before it ends. After finishing an event, you can attend another event starting at the same time or later.",
    "topic": "Greedy",
    "subtopic": "Interval Scheduling",
    "tags": [
      "Greedy",
      "Intervals",
      "Sorting"
    ],
    "input_format": "An array of events, where each event is an array of two integers [start, end].",
    "output_format": "An integer representing the maximum number of events that can be attended.",
    "constraints": [
      "1 <= events.length <= 10^5",
      "0 <= events[i][0] < events[i][1] <= 10^6"
    ],
    "examples": [
      {
        "input": "events = [[1, 3], [2, 4], [3, 5]]",
        "output": "2",
        "explanation": "You can attend the first event [1, 3] and the third event [3, 5]."
      },
      {
        "input": "events = [[1, 2], [3, 4], [2, 3]]",
        "output": "3",
        "explanation": "You can attend all three events since they do not overlap."
      },
      {
        "input": "events = [[1, 10], [2, 3], [4, 5], [6, 7]]",
        "output": "3",
        "explanation": "Attend events [2, 3], [4, 5], and [6, 7]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort events by their end times.",
      "Use a greedy approach to pick the next event that can be attended."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Top K Frequent Elements",
    "description": "Given a non-empty array of integers, return the k most frequent elements. You may return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Frequency Count"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An array of the k most frequent elements.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "k is always valid, 1 <= k <= number of unique elements in the array."
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 1, 2, 2, 3], k = 2",
        "output": "[1, 2]",
        "explanation": "1 is the most frequent element and 2 is the second most frequent, hence the output is [1, 2]."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "The only element is 1, thus it is the most frequent, so the output is [1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to count the frequency of each element.",
      "Consider using a priority queue or a heap to find the top k elements efficiently."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "House Robber",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, and adjacent houses have security systems connected to alarm sensors. If two adjacent houses are robbed on the same night, the alarms will automatically trigger. Given an integer array 'nums' representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.",
    "topic": "Dynamic Programming",
    "subtopic": "1D Dynamic Programming",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers nums representing the money at each house.",
    "output_format": "An integer representing the maximum amount of money that can be robbed.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 400"
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 9, 3, 1]",
        "output": "12",
        "explanation": "Robbing houses with money [2, 9, 1] gives a total of 12."
      },
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "4",
        "explanation": "Robbing houses with money [1, 3] or [2] gives a total of 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to keep track of the maximum money you can rob up to each house.",
      "The maximum amount at the current house can depend on whether the previous house was robbed or not."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Count Vowel Substrings of a String",
    "description": "Given a string s, count the number of substrings that contain only vowels. A substring is defined as a contiguous sequence of characters. The vowels are defined as 'a', 'e', 'i', 'o', and 'u'. Return the total count of such substrings.",
    "topic": "String",
    "subtopic": "Substring Counting",
    "tags": [
      "String",
      "Counting",
      "Substrings"
    ],
    "input_format": "A string s consisting of lowercase English letters.",
    "output_format": "An integer representing the count of vowel substrings.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists only of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = \"aeiou\"",
        "output": "15",
        "explanation": "The substrings are 'a', 'e', 'i', 'o', 'u', 'ae', 'ai', 'ao', 'au', 'ei', 'eo', 'eu', 'io', 'iu', 'ou'. Total = 15."
      },
      {
        "input": "s = \"abcde\"",
        "output": "3",
        "explanation": "The only substrings are 'a', 'e', and 'ae'. Total = 3."
      },
      {
        "input": "s = \"zzz\"",
        "output": "0",
        "explanation": "There are no vowels in the string, hence the count is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a sliding window approach.",
      "A single character substring is valid if it's a vowel."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Valid Anagram",
    "description": "Given two strings s and t, return true if t is an anagram of s and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Hash Table",
      "Sorting"
    ],
    "input_format": "Two strings s and t, each consisting of lowercase English letters.",
    "output_format": "A boolean value indicating whether t is an anagram of s.",
    "constraints": [
      "1 <= s.length, t.length <= 5 * 10^4",
      "s and t consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = 'anagram', t = 'nagaram'",
        "output": "true",
        "explanation": "'nagaram' is an anagram of 'anagram'."
      },
      {
        "input": "s = 'rat', t = 'car'",
        "output": "false",
        "explanation": "'car' is not an anagram of 'rat'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider sorting both strings.",
      "Check character counts for both strings."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Random Pick with Weight",
    "description": "You are given an integer array weights where weights[i] represents the weight of the ith index (0-indexed). Write a function pickIndex that randomly selects an index in proportion to its weight. For example, given an array weights = [1, 3], the probability of picking index 0 is 1/(1+3) = 0.25, and the probability of picking index 1 is 3/(1+3) = 0.75. It is guaranteed that the sum of weights will not exceed 10^6. Note that the function pickIndex should be optimized to run in O(log N) time on average, where N is the number of elements in the weights array.",
    "topic": "Random",
    "subtopic": "Weighted Random Sampling",
    "tags": [
      "Random",
      "Sampling",
      "Probability"
    ],
    "input_format": "An array of integers weights of length n (1 <= n <= 10^4) representing weights.",
    "output_format": "An integer representing the randomly picked index based on the weights.",
    "constraints": [
      "1 <= weights.length <= 10^4",
      "1 <= weights[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "weights = [1, 3]",
        "output": "1",
        "explanation": "Index 1 is selected 75% of the time due to higher weight."
      },
      {
        "input": "weights = [1, 1, 1, 1]",
        "output": "0",
        "explanation": "Each index has equal probability of 25% since all weights are the same."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a prefix sum array to represent the weights.",
      "Binary search can help in selecting the index efficiently."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']'. Determine if the input string is valid. An input string is valid if the brackets are closed in the correct order. Note that an empty string is also considered valid.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Parentheses"
    ],
    "input_format": "A string s representing the sequence of parentheses.",
    "output_format": "A boolean value indicating whether the input string is valid.",
    "constraints": [
      "0 <= s.length <= 10^4",
      "s consists of parentheses only '(){}[]'."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "'()' is a valid string of parentheses."
      },
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "'()[]{}' is a valid combination of parentheses."
      },
      {
        "input": "s = '(]')",
        "output": "false",
        "explanation": "'(]' is invalid because the brackets are not closed properly."
      },
      {
        "input": "s = '([)]'",
        "output": "false",
        "explanation": "'([)]' is invalid as the brackets are not nested correctly."
      },
      {
        "input": "s = '{'}",
        "output": "false",
        "explanation": "'{' is invalid because it is not closed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "Check if the closing bracket matches the top of the stack.",
      "An empty stack at the end indicates valid parentheses."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Find First and Last Position of Element in Sorted Array",
    "description": "Given an array of integers sorted in ascending order, find the starting and ending position of a given target value. If the target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Finding Position"
    ],
    "input_format": "An array of integers `nums` sorted in ascending order and an integer `target`.",
    "output_format": "An array of two integers representing the starting and ending position of the target.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i], target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 8",
        "output": "[3, 4]",
        "explanation": "The target value 8 appears starting at index 3 and ending at index 4."
      },
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 6",
        "output": "[-1, -1]",
        "explanation": "The target value 6 is not present in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to find the first and last positions.",
      "After finding the first occurrence, continue searching to find the last occurrence."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Last Stone Weight",
    "description": "You are given an array of integers stones where each integer represents the weight of a stone. You will repeatedly smash the two heaviest stones together. If they have the same weight, both stones are destroyed; if they have different weights, the heavier stone is reduced by the weight of the lighter stone. This process continues until there is at most one stone left. Return the weight of the last stone. If there are no stones left, return 0.",
    "topic": "Heap",
    "subtopic": "Priority Queue",
    "tags": [
      "Heap",
      "Array",
      "Simulation"
    ],
    "input_format": "An array of integers stones.",
    "output_format": "An integer representing the weight of the last stone left, or 0 if no stones are left.",
    "constraints": [
      "1 <= stones.length <= 30",
      "1 <= stones[i] <= 1000"
    ],
    "examples": [
      {
        "input": "stones = [2,7,4,1,8,1]",
        "output": "1",
        "explanation": "We smash 7 and 8 together resulting in 1, then next we smash 2 and 4 leaving us with 1, which is the last stone."
      },
      {
        "input": "stones = [1,3]",
        "output": "2",
        "explanation": "We smash the two stones together and the remaining weight is 2."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a max heap to efficiently get the two heaviest stones.",
      "You may need to convert the weights to negative to utilize a min heap."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Rotate Image",
    "description": "You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). You have to rotate the matrix in place, which means you need to modify the input 2D matrix directly. Do not use an additional matrix.",
    "topic": "Array",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Array",
      "Matrix",
      "In-place"
    ],
    "input_format": "A 2D square matrix of size n x n, where 1 <= n <= 20.",
    "output_format": "The input matrix rotated by 90 degrees clockwise.",
    "constraints": [
      "1 <= n <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]",
        "explanation": "Rotate the matrix 90 degrees clockwise: The first row becomes the last column."
      },
      {
        "input": "matrix = [[1]]",
        "output": "[[1]]",
        "explanation": "Rotating a 1x1 matrix results in the same matrix."
      },
      {
        "input": "matrix = [[1,2],[3,4]]",
        "output": "[[3,1],[4,2]]",
        "explanation": "Rotating this 2x2 matrix swaps positions in a clockwise manner."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to rotate layers of the matrix.",
      "First, reverse the rows, then swap the symmetry."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Kth Largest Element in an Array",
    "description": "Given an integer array, find the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. You must solve it in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Heap"
    ],
    "input_format": "An integer array `nums` and an integer `k`.",
    "output_format": "An integer representing the kth largest element in the array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 1, 5, 6, 4], k = 2",
        "output": "5",
        "explanation": "The second largest element in the sorted order [1, 2, 3, 4, 5, 6] is 5."
      },
      {
        "input": "nums = [3, 2, 3, 1, 2, 4, 5, 5, 6], k = 4",
        "output": "4",
        "explanation": "The fourth largest element in the sorted order [1, 2, 2, 3, 3, 4, 5, 5, 6] is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a max-heap or min-heap to optimize finding the kth largest element.",
      "You can use Quickselect algorithm for an optimal solution."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Palindromic Substrings",
    "description": "Given a string s, return the number of substrings that are palindromes. A substring is a contiguous sequence of characters within the string. A palindrome is a string that reads the same forward and backward.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Palindrome",
      "Dynamic Programming"
    ],
    "input_format": "A string s where 1 <= s.length <= 1000.",
    "output_format": "An integer representing the number of palindromic substrings in s.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = \"abc\"",
        "output": "3",
        "explanation": "The palindromic substrings are: \"a\", \"b\", and \"c\"."
      },
      {
        "input": "s = \"aaa\"",
        "output": "6",
        "explanation": "The palindromic substrings are: \"a\", \"a\", \"a\", \"aa\", \"aa\", and \"aaa\"."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding around potential centers for palindromes.",
      "A single character is always a palindrome, look for longer ones."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "You are given two sorted arrays, nums1 and nums2, of size m and n respectively. Your task is to find the median of the two sorted arrays. The overall run time complexity should be O(log(min(m,n))). If the total number of elements is even, return the average of the two middle numbers. If it is odd, return the middle number.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Median"
    ],
    "input_format": "Two sorted integer arrays, nums1 and nums2.",
    "output_format": "A float representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= nums1.length <= 1000",
      "0 <= nums2.length <= 1000",
      "-10^6 <= nums1[i], nums2[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.0",
        "explanation": "The combined sorted array is [1, 2, 3]. The median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.5",
        "explanation": "The combined sorted array is [1, 2, 3, 4]. The median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using binary search on the smaller array."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Minimum Number of Swaps to Make the String Balanced",
    "description": "Given a string containing only the characters '(' and ')', determine the minimum number of swaps required to make the string balanced. A string is considered balanced if the number of '(' matches the number of ')' and no prefix of the string has more ')' than '('. You can swap any two characters in the string to achieve balance.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Swapping",
      "Balanced Parentheses"
    ],
    "input_format": "A string s consisting of only '(' and ')'.",
    "output_format": "An integer representing the minimum number of swaps required to balance the string.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists only of '(' and ')'."
    ],
    "examples": [
      {
        "input": "s = '()))(('",
        "output": "2",
        "explanation": "To balance the string, we can swap the first ')' with the last '(', resulting in '()()()'."
      },
      {
        "input": "s = '())('",
        "output": "1",
        "explanation": "We can swap the first '(' with the second ')' to get '()()'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Count the imbalance of parentheses.",
      "Use a stack to keep track of the balance."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Subarray"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the largest sum of a contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum = 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The only subarray is [1], with the largest sum = 1."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The subarray [5,4,-1,7,8] has the largest sum = 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to use dynamic programming to keep track of the maximum sum."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Minimum Increment to Make Array Unique",
    "description": "Given an array of integers, you need to make every element in the array unique by incrementing some of the elements. The goal is to minimize the total number of increments you need to perform to achieve this uniqueness. Return the number of increments needed.",
    "topic": "Array",
    "subtopic": "Set Operations",
    "tags": [
      "Array",
      "Greedy",
      "Unique Elements"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the minimum number of increments needed.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 1, 2, 1, 0]",
        "output": "6",
        "explanation": "Incrementing elements to make the array unique: [3, 4, 5, 6, 7, 8] needs 6 increments: (2->4, 1->5, 1->6, 0->7)."
      },
      {
        "input": "nums = [1, 2, 2]",
        "output": "1",
        "explanation": "Incrementing the second 2 to 3 makes all elements unique, requiring 1 increment."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a set to track used numbers.",
      "Sort the array to handle duplicates easily.",
      "Consider using a loop to check for the next available unique number."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Jump Game",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to determine if you are able to reach the last index starting from the first index. You can assume that you can always reach the last index if you are at the last index.",
    "topic": "Array",
    "subtopic": "Greedy Algorithms",
    "tags": [
      "Array",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "A boolean value indicating whether you can reach the last index.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "true",
        "explanation": "Jump 1 step from index 0 to 1, then 2 steps to the last index."
      },
      {
        "input": "nums = [3, 2, 1, 0, 4]",
        "output": "false",
        "explanation": "You will always land on index 3 and cannot make any further jumps."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the maximum reachable index at each step.",
      "Use a greedy approach to check if you can reach the last index."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Flatten Deeply Nested Array",
    "description": "Given a deeply nested array of integers, you need to flatten it into a single-level array containing all the integers in the same order. The nested array can contain other nested arrays as elements, and the depth of nesting can vary significantly.",
    "topic": "Array",
    "subtopic": "Recursion",
    "tags": [
      "Array",
      "Recursion",
      "Flattening"
    ],
    "input_format": "An array containing integers and/or nested arrays.",
    "output_format": "A single-level array containing all the integers in the input array.",
    "constraints": [
      "The input array can contain up to 10^4 elements.",
      "Each element can be either an integer or another array."
    ],
    "examples": [
      {
        "input": "[1, [2, [3]], 4]",
        "output": "[1, 2, 3, 4]",
        "explanation": "The input contains integers and nested arrays. The integers are extracted and flattened into a single array."
      },
      {
        "input": "[[], [1, [2]], 3]",
        "output": "[1, 2, 3]",
        "explanation": "Even though some elements are empty arrays, the integers are flattened out without empty sub-arrays."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion to deal with the nested structure.",
      "An iterative approach using a stack can also be effective."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Koko Eating Bananas",
    "description": "Koko loves to eat bananas. There are n piles of bananas, and the ith pile has piles[i] bananas. Koko can eat up to k bananas per hour. Koko wants to finish eating all the bananas within h hours. You need to determine the minimum integer k such that Koko can eat all the bananas in h hours. If it is impossible to do so, return -1.",
    "topic": "Binary Search",
    "subtopic": "Searching",
    "tags": [
      "Binary Search",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers piles, representing the number of bananas in each pile, and an integer h, representing the number of hours Koko has to eat the bananas.",
    "output_format": "An integer representing the minimum number of bananas Koko can eat per hour.",
    "constraints": [
      "1 <= piles.length <= 10^4",
      "1 <= piles[i] <= 10^9",
      "1 <= h <= 10^9"
    ],
    "examples": [
      {
        "input": "piles = [3, 6, 7, 11], h = 8",
        "output": "4",
        "explanation": "Koko can eat 4 bananas per hour. In 8 hours, she will finish all piles."
      },
      {
        "input": "piles = [30, 11, 23, 4, 20], h = 5",
        "output": "30",
        "explanation": "Koko needs to eat at least 30 bananas per hour to finish in 5 hours."
      },
      {
        "input": "piles = [30, 11, 23, 4, 20], h = 6",
        "output": "23",
        "explanation": "Koko can eat 23 bananas per hour to finish in 6 hours."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how the rate of eating bananas affects time taken.",
      "Binary search can help find the minimum eating speed."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "You are given an integer array 'nums' sorted in ascending order, which is then rotated at an unknown pivot. Write a function to search for a target value in this rotated sorted array. If the target exists, return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Binary Search",
    "subtopic": "Searching in Rotated Array",
    "tags": [
      "Binary Search",
      "Array",
      "Search"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An integer representing the index of the target in the array, or -1 if the target is not found.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "All elements of nums are unique.",
      "nums is rotated at an unknown pivot."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "0 is found at index 4."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "3 does not exist in the array, hence the output is -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how the array is structured after rotation.",
      "Use binary search but modify it to take rotation into account.",
      "Identify which part of the array is sorted for efficient searching."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointer",
    "tags": [
      "Array",
      "Two Pointer",
      "Hash Set"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A list of unique triplets that sum to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that sum to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no triplets in an empty array."
      },
      {
        "input": "nums = [0, 1, 1]",
        "output": "[]",
        "explanation": "There are no triplets that sum to zero."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the array to facilitate easier triplet finding.",
      "Use a two-pointer technique to find pairs that complete the triplet."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Subarray Product Less Than K",
    "description": "Given an array of integers nums and a positive integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.",
    "topic": "Array",
    "subtopic": "Subarray Problems",
    "tags": [
      "Array",
      "Sliding Window",
      "Product"
    ],
    "input_format": "An array of integers nums followed by a positive integer k.",
    "output_format": "An integer representing the number of contiguous subarrays with product less than k.",
    "constraints": [
      "1 <= nums.length <= 1000",
      "1 <= nums[i] <= 100",
      "1 <= k <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [10, 5, 2, 6], k = 100",
        "output": "8",
        "explanation": "The valid subarrays are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]."
      },
      {
        "input": "nums = [1, 2, 3], k = 0",
        "output": "0",
        "explanation": "No subarray has a product less than 0."
      },
      {
        "input": "nums = [1, 2, 3, 4], k = 10",
        "output": "7",
        "explanation": "The valid subarrays are: [1], [2], [3], [4], [1, 2], [2, 3], [1, 2, 3]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sliding window approach to maintain the product of the current subarray.",
      "When the product exceeds or equals k, try to shrink the window from the left."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List",
    "description": "Given the head of a singly linked list, reverse the list and return the reversed list.",
    "topic": "Linked List",
    "subtopic": "Reversing a Linked List",
    "tags": [
      "Linked List",
      "Reversal",
      "Pointer"
    ],
    "input_format": "A singly linked list represented by its head node.",
    "output_format": "The head node of the reversed linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 5000].",
      "-5000 <= Node.val <= 5000"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5]",
        "output": "[5, 4, 3, 2, 1]",
        "explanation": "The linked list is reversed from 1 -> 2 -> 3 -> 4 -> 5 to 5 -> 4 -> 3 -> 2 -> 1."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "An empty list remains empty after reversal."
      },
      {
        "input": "head = [1]",
        "output": "[1]",
        "explanation": "A single node remains itself after reversal."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use three pointers: previous, current, and next.",
      "Iterate through the list and reverse the pointers."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Longest Consecutive Sequence",
    "description": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Consecutive Numbers"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the length of the longest consecutive elements sequence.",
    "constraints": [
      "0 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [100, 4, 200, 1, 3, 2]",
        "output": "4",
        "explanation": "The longest consecutive sequence is [1, 2, 3, 4], which has a length of 4."
      },
      {
        "input": "nums = [0, -1]",
        "output": "2",
        "explanation": "The longest consecutive sequence is [-1, 0], which has a length of 2."
      },
      {
        "input": "nums = []",
        "output": "0",
        "explanation": "There are no elements in the array, so the longest consecutive sequence length is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a HashSet to store the elements for O(1) access.",
      "Iterate through the array and check for consecutive elements."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Count and Say",
    "description": "The 'Count and Say' sequence is a sequence of digit strings defined by the recursion: countAndSay(1) = '1'. To generate the next element of the sequence, we read the previous element and count the number of digits in groups of the same digit. For example, the next element after '1' is '11' (one '1'), followed by '21' (two '1's), then '1211' (one '2', one '1'), and continuing this pattern. Given an integer n, generate the nth term of the 'Count and Say' sequence.",
    "topic": "String",
    "subtopic": "Generating Sequences",
    "tags": [
      "String",
      "Recursion",
      "Pattern"
    ],
    "input_format": "An integer n (1 <= n <= 30), representing the term in the Count and Say sequence to generate.",
    "output_format": "A string representing the nth term in the 'Count and Say' sequence.",
    "constraints": [
      "1 <= n <= 30"
    ],
    "examples": [
      {
        "input": "n = 1",
        "output": "'1'",
        "explanation": "The first term in the Count and Say sequence is '1'."
      },
      {
        "input": "n = 4",
        "output": "'1211'",
        "explanation": "The fourth term in the sequence is generated as follows: '11' (from '21') indicates one '2' followed by one '1', which gives '1211'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how you can divide the string into groups of similar characters.",
      "Iterate through the string to count consecutive characters and generate the next term accordingly."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "LFU Cache",
    "description": "Design and implement a data structure for a Least Frequently Used (LFU) cache. The LFU cache should be able to support the following operations: get(key) and put(key, value). The get(key) operation retrieves the value of the key if the key exists in the cache. If the key does not exist, it returns -1. The put(key, value) operation will insert or update the value of the key. When the cache reaches its capacity, it should invalidate the least frequently used key before inserting a new key-value pair. For both operations, the average time complexity should be O(1).",
    "topic": "Design",
    "subtopic": "Data Structures",
    "tags": [
      "Cache",
      "Data Structure",
      "Design"
    ],
    "input_format": "Operations will be provided as a list of strings, each representing a command. Commands can be 'get key' or 'put key value'.",
    "output_format": "For every 'get' operation, return the value or -1, and for 'put' operations, return nothing.",
    "constraints": [
      "The cache capacity will be at most 10^4.",
      "The keys and values will be in the range of 1 to 10^4."
    ],
    "examples": [
      {
        "input": "['put(1, 1)', 'put(2, 2)', 'get(1)', 'put(3, 3)', 'get(2)', 'get(3)', 'put(4, 4)', 'get(1)', 'get(3)', 'get(4)']",
        "output": "[1, -1, 3, 4]",
        "explanation": "The sequence of operations alters the cache accordingly. The value for key 1 is retrieved successfully. Key 2 is evicted due to lower frequency, and then keys 3 and 4 are retrieved."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a combination of a hash map and a linked list.",
      "Consider frequency as a metric to manage the cache.",
      "A priority queue can help in eviction of the least frequently used items."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Degree of an Array",
    "description": "Given an array of integers, the degree of an array is defined as the maximum frequency of any one element in the array. You need to find the smallest length of a subarray that has the same degree as the array. Return the length of that subarray.",
    "topic": "Array",
    "subtopic": "Frequency Count",
    "tags": [
      "Array",
      "HashMap",
      "Frequency"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the length of the smallest subarray with the same degree as the original array.",
    "constraints": [
      "1 <= nums.length <= 50,000",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2, 3, 1]",
        "output": "2",
        "explanation": "The degree of the array is 2 (the number 1 appears twice). The smallest subarray with the same degree is [1, 2]."
      },
      {
        "input": "nums = [1, 2, 2, 3, 1, 4, 2]",
        "output": "6",
        "explanation": "The degree of the array is 3 (the number 2 appears three times). The smallest subarray with the same degree is [2, 3, 1, 4, 2]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Track the frequency of each element.",
      "Use a hashmap to store the first and last occurrence of each element."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Insert Delete GetRandom O(1)",
    "description": "Design a data structure that supports the following operations in average O(1) time complexity: insert(val), remove(val), and getRandom(). Implement the RandomizedSet class: \n- RandomizedSet() initializes the set object. \n- bool insert(int val) Inserts the value val into the set if not present. Returns true if the element was added to the set, false if it was already present. \n- bool remove(int val) Removes the value val from the set if present. Returns true if the element was removed, false if it was not present. \n- int getRandom() Returns a random element from the current set of elements. It is guaranteed that at least one element exists when this method is called.",
    "topic": "Design",
    "subtopic": "Data Structure",
    "tags": [
      "Design",
      "Data Structure",
      "Random"
    ],
    "input_format": "You will be given a series of operations on the RandomizedSet, represented as strings followed by integers for `insert` and `remove` operations.",
    "output_format": "A list of boolean values indicating the results of `insert` and `remove` operations and an integer for `getRandom`.",
    "constraints": [
      "All values in the set are unique.",
      "-10^6 <= val <= 10^6"
    ],
    "examples": [
      {
        "input": [
          "RandomizedSet",
          "insert",
          "remove",
          "insert",
          "getRandom"
        ],
        "output": [
          null,
          true,
          true,
          false,
          0
        ],
        "explanation": "Here, elements are added or removed, and a random element from the set is returned."
      },
      {
        "input": [
          "RandomizedSet",
          "insert",
          "getRandom",
          "remove",
          "getRandom"
        ],
        "output": [
          null,
          true,
          1,
          false,
          1
        ],
        "explanation": "First, an element is inserted, then a random element is fetched, followed by trying to remove an element that isn't present."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a combination of a list and a hash map for efficient access.",
      "Ensure that your getRandom method does not depend on the order of elements."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Squares of a Sorted Array",
    "description": "Given a sorted integer array nums, return an array of the squares of each number sorted in non-decreasing order.",
    "topic": "Array",
    "subtopic": "Sorting and Squaring",
    "tags": [
      "Array",
      "Sorting",
      "Square"
    ],
    "input_format": "An array of integers nums, sorted in non-decreasing order.",
    "output_format": "An array of integers representing the squares of the numbers in sorted order.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-4, -1, 0, 3, 10]",
        "output": "[0, 1, 9, 16, 100]",
        "explanation": "The squares are [16, 1, 0, 9, 100]. Sorting gives us [0, 1, 9, 16, 100]."
      },
      {
        "input": "nums = [-7, -3, 2, 3, 11]",
        "output": "[4, 9, 9, 49, 121]",
        "explanation": "The squares are [49, 9, 4, 9, 121]. Sorting gives us [4, 9, 9, 49, 121]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how negative numbers' squares compare to positive numbers' squares.",
      "You may want to use two pointers to effectively sort the squares."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Meeting Rooms II",
    "description": "You are given an array of intervals representing meeting time intervals, where intervals[i] = [start_i, end_i]. You need to find the minimum number of conference rooms required to hold all the meetings. Two meetings can be held in the same room if they don't overlap.",
    "topic": "Array",
    "subtopic": "Sorting and Intervals",
    "tags": [
      "Array",
      "Interval",
      "Greedy"
    ],
    "input_format": "An array of intervals where each interval is represented as an array of two integers [start, end].",
    "output_format": "An integer representing the minimum number of conference rooms required.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "0 <= start_i < end_i <= 10^6"
    ],
    "examples": [
      {
        "input": "intervals = [[0, 30],[5, 10],[15, 20]]",
        "output": "2",
        "explanation": "We need two rooms; the meeting from 0 to 30 overlaps with the meeting from 5 to 10 and 15 to 20."
      },
      {
        "input": "intervals = [[7,10],[2,4]]",
        "output": "1",
        "explanation": "The meetings (7,10) and (2,4) do not overlap; thus, only one room is needed."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a priority queue to manage the end times of the meetings.",
      "Sort the intervals by their start times for better management."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Path Sum",
    "description": "Given a binary tree, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals a given sum. A leaf is a node with no children.",
    "topic": "Tree",
    "subtopic": "Depth-First Search",
    "tags": [
      "Tree",
      "DFS",
      "Recursion"
    ],
    "input_format": "The input consists of two parts: the root of the binary tree and an integer sum.",
    "output_format": "Return true if such a path exists, otherwise return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 1000].",
      "-1000 <= Node.val <= 1000",
      "-1000 <= sum <= 1000"
    ],
    "examples": [
      {
        "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], sum = 22",
        "output": "true",
        "explanation": "The path 5 -> 4 -> 11 -> 2 sums to 22."
      },
      {
        "input": "root = [1,2,3], sum = 5",
        "output": "false",
        "explanation": "There is no root-to-leaf path that sums to 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a depth-first search approach.",
      "Subtract the value of the node from the sum at each step.",
      "Check if you reached a leaf node and if the sum is equal to 0."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Valid Sudoku",
    "description": "Determine if a 9x9 Sudoku board is valid according to the rules of Sudoku. The board may be partially filled, where empty cells are represented by the character '.'. A valid Sudoku must satisfy the following conditions: each row must contain the digits 1-9 without repetition, each column must contain the digits 1-9 without repetition, and each of the nine 3x3 sub-boxes must also contain the digits 1-9 without repetition.",
    "topic": "Matrix",
    "subtopic": "Validation",
    "tags": [
      "Matrix",
      "Validation",
      "Backtracking"
    ],
    "input_format": "A 2D character array representing the Sudoku board (9x9). Each character is a digit from '1' to '9' or '.' for an empty cell.",
    "output_format": "A boolean value representing whether the Sudoku board is valid (true) or not (false).",
    "constraints": [
      "The board is a 9x9 matrix.",
      "'0' <= board[i][j] <= '9' or board[i][j] == '.'."
    ],
    "examples": [
      {
        "input": "[['5','3','.','.','7','.','.','.','.'], ['6','.','.','1','9','5','.','.','.'], ['.','9','8','.','.','.','.','6','.'], ['8','.','.','.','6','.','.','.','3'], ['4','.','8','.','.','.','.','4','.'], ['7','.','.','.','2','.','.','.','6'], ['.','6','.','.','.','2','8','.','.'], ['.','.','.','4','1','9','.','.','5'], ['.','.','.','.','8','.','.','7','9']]",
        "output": "true",
        "explanation": "The provided Sudoku board follows all the rules of Sudoku and is therefore valid."
      },
      {
        "input": "[['8','3','.','.','7','.','.','.','.'], ['6','.','.','1','9','5','.','.','.'], ['.','9','8','.','.','.','.','6','.'], ['8','.','.','.','6','.','.','.','3'], ['4','.','8','.','.','.','.','4','.'], ['7','.','.','.','2','.','.','.','6'], ['.','6','.','.','.','2','8','.','.'], ['.','.','.','4','1','9','.','.','5'], ['.','.','.','.','8','.','.','7','9']]",
        "output": "false",
        "explanation": "The provided Sudoku board contains two '8's in the first column, hence it is not valid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use sets to track occurrences of numbers in rows, columns, and boxes.",
      "Iterate through each cell, and check its presence in the corresponding sets."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Happy Number",
    "description": "A happy number is a number which eventually reaches 1 when replaced by the sum of the square of each digit. For example, 19 is a happy number: 1^2 + 9^2 = 82, 8^2 + 2^2 = 68, 6^2 + 8^2 = 100, 1^2 + 0^2 + 0^2 = 1. If it does not reach 1, it will cycle endlessly in a loop that does not include 1. Write a function to determine if a given number is a happy number.",
    "topic": "Math",
    "subtopic": "Number Theory",
    "tags": [
      "Math",
      "Number Theory",
      "Recursion"
    ],
    "input_format": "An integer n.",
    "output_format": "A boolean indicating whether the number is a happy number.",
    "constraints": [
      "1 <= n <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "n = 19",
        "output": "true",
        "explanation": "The number 19 is a happy number as explained in the description."
      },
      {
        "input": "n = 2",
        "output": "false",
        "explanation": "The number 2 is not a happy number as it falls into a loop that does not reach 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a set to track the numbers you've seen to detect cycles.",
      "The sum of the squares of digits can be computed iteratively."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order. The spiral order follows the direction of left to right, top to bottom, right to left, and bottom to top repeatedly until all elements have been visited.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral"
    ],
    "input_format": "An m x n matrix represented as a list of lists, where each inner list represents a row.",
    "output_format": "A list of integers representing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "m * n <= 10^5",
      "0 <= matrix[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The elements are traversed in the spiral order: 1 -> 2 -> 3 -> 6 -> 9 -> 8 -> 7 -> 4 -> 5."
      },
      {
        "input": "matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]",
        "output": "[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]",
        "explanation": "The elements are traversed in the spiral order: 1 -> 2 -> 3 -> 4 -> 8 -> 12 -> 11 -> 10 -> 9 -> 5 -> 6 -> 7."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Keep track of the boundaries of the matrix.",
      "Use a loop to traverse each boundary and adjust the boundaries after each traversal."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Flatten Binary Tree to Linked List",
    "description": "Given the root of a binary tree, flatten the tree into a linked list in-place. The linked list should be created by connecting the right child of each node to the next node in the pre-order traversal sequence. The left child of each node should be set to null.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "DFS",
      "In-place"
    ],
    "input_format": "The root of a binary tree, represented as a TreeNode object.",
    "output_format": "The root of the binary tree after being flattened into a linked list.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "Node.val is unique.",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1, 2, 5, 3, 4, null, 6]",
        "output": "[1, null, 2, null, 3, null, 4, null, 5, null, 6]",
        "explanation": "The tree is flattened to a linked list: 1 -> 2 -> 3 -> 4 -> 5 -> 6."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree remains empty after flattening."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a recursive approach or iterative approach with a stack.",
      "Consider how you can reorganize the pointers while traversing the tree."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Find Median from Data Stream",
    "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no distinct middle value and the median is defined to be the average of the two middle values. Given a data stream (a sequence of integers) that can be received in real-time, implement a data structure that supports the following operations efficiently: 1. `addNum(int num)`: Add a integer number from the data stream to the data structure. 2. `findMedian()`: Return the median of all elements so far.",
    "topic": "Design",
    "subtopic": "Data Structure",
    "tags": [
      "Heap",
      "Design",
      "Median"
    ],
    "input_format": "An integer `num` to be added to the data stream.",
    "output_format": "A float representing the median of all numbers added to the stream.",
    "constraints": [
      "-10^5 <= num <= 10^5",
      "addNum will be called at most 10^4 times."
    ],
    "examples": [
      {
        "input": "addNum(1); addNum(2); findMedian();",
        "output": "1.5",
        "explanation": "The numbers added are [1, 2]. The median is (1 + 2) / 2 = 1.5."
      },
      {
        "input": "addNum(3); findMedian();",
        "output": "2",
        "explanation": "The numbers are [1, 2, 3]. The median is 2."
      },
      {
        "input": "addNum(4); findMedian();",
        "output": "2.5",
        "explanation": "The numbers are [1, 2, 3, 4]. The median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use two heaps to maintain the order of numbers.",
      "One max-heap for the lower half and one min-heap for the upper half.",
      "Balancing the heaps will help in finding the median quickly."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Course Schedule",
    "description": "You are given a total of n courses labeled from 0 to n-1. You are also given an array prerequisites where prerequisites[i] = [a, b] indicates that you must take course b before course a. Return true if you can finish all courses. Otherwise, return false.",
    "topic": "Graph",
    "subtopic": "Topological Sorting",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Topological Sort"
    ],
    "input_format": "An integer n representing the total number of courses, and a 2D array prerequisites representing the prerequisites of the courses.",
    "output_format": "A boolean value indicating whether it is possible to finish all courses.",
    "constraints": [
      "1 <= n <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= prerequisites[i][0], prerequisites[i][1] < n",
      "All prerequisite pairs are unique."
    ],
    "examples": [
      {
        "input": "n = 2, prerequisites = [[1, 0]]",
        "output": "true",
        "explanation": "You can take course 0 first, then take course 1."
      },
      {
        "input": "n = 2, prerequisites = [[1, 0], [0, 1]]",
        "output": "false",
        "explanation": "There is a cycle between courses 0 and 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to represent the courses and prerequisites using a graph.",
      "Check for cycles in the graph to determine if completing all courses is possible."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Search a 2D Matrix II",
    "description": "Write an efficient algorithm that searches for a target value in an m x n integer matrix. This matrix has the following properties: It is sorted in ascending order both row-wise and column-wise. Your task is to implement a function that returns true if the target is found in the matrix, and false otherwise.",
    "topic": "Matrix",
    "subtopic": "Search in a 2D Matrix",
    "tags": [
      "Matrix",
      "Search",
      "Binary Search"
    ],
    "input_format": "An integer matrix matrix of size m x n (1 <= m, n <= 300) followed by an integer target.",
    "output_format": "A boolean value indicating whether the target exists in the matrix.",
    "constraints": [
      "Matrix dimensions: 1 <= m, n <= 300",
      "Matrix elements are integers within the range [-10^9, 10^9].",
      "Each row and each column of the matrix is sorted in ascending order."
    ],
    "examples": [
      {
        "input": "matrix = [[1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17]], target = 5",
        "output": "true",
        "explanation": "The target value 5 is found in the matrix."
      },
      {
        "input": "matrix = [[1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17]], target = 20",
        "output": "false",
        "explanation": "The target value 20 is not found in the matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider starting from the top-right corner or bottom-left corner of the matrix.",
      "If the current element is greater than the target, move left (decrease column index).",
      "If the current element is less than the target, move down (increase row index)."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Lexicographically Smallest Palindrome",
    "description": "Given a string s consisting of lowercase letters, you need to convert this string into a palindrome by modifying at most one character. If it is possible to make the string a palindrome by replacing a single character, you need to return the lexicographically smallest palindrome. If it is not possible, return an empty string.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Palindrome",
      "Greedy"
    ],
    "input_format": "A single string s, consisting of lowercase letters.",
    "output_format": "A string representing the lexicographically smallest palindrome, or an empty string if not possible.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only lowercase letters."
    ],
    "examples": [
      {
        "input": "abca",
        "output": "acca",
        "explanation": "By changing 'b' to 'c', the string becomes 'acca', which is a palindrome and the smallest lexicographically."
      },
      {
        "input": "abc",
        "output": "",
        "explanation": "It's impossible to convert 'abc' into a palindrome by changing only one character."
      },
      {
        "input": "aaa",
        "output": "aaa",
        "explanation": "'aaa' is already a palindrome, hence no changes are needed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Check if the string is already a palindrome.",
      "If not, identify the first mismatching characters."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Min Stack",
    "description": "Design a stack that supports the following operations: push, pop, top, and retrieving the minimum element in constant time. Implement a MinStack class that supports these operations efficiently.",
    "topic": "Stack",
    "subtopic": "Design",
    "tags": [
      "Stack",
      "Data Structure",
      "Design"
    ],
    "input_format": "A sequence of operations (push, pop, top, getMin) on the MinStack.",
    "output_format": "The output should reflect the results of the getMin, pop, and top operations.",
    "constraints": [
      "All operations are guaranteed to be valid.",
      "The stack will contain at least one element when calling pop or top."
    ],
    "examples": [
      {
        "input": "MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); minStack.pop(); minStack.top(); minStack.getMin();",
        "output": "-3\n0\n-2",
        "explanation": "After pushing -2, 0, and -3, the minimum is -3. After popping -3, the top is 0 and the minimum is -2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using an auxiliary stack to keep track of the minimum values.",
      "Pushing into the minimum stack should only happen when the new value is less than or equal to the current minimum."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Find Peak Element",
    "description": "A peak element in an array is defined as an element that is greater than its neighbors. Given an input array nums, you need to find any peak element and return its index. An array element is considered to be a peak if it is greater than or equal to its neighbors. You may assume that the array is non-empty and that there will always be a peak element.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Peak Element"
    ],
    "input_format": "An array of integers nums where nums.length >= 1.",
    "output_format": "An integer representing the index of a peak element.",
    "constraints": [
      "1 <= nums.length <= 1000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "2",
        "explanation": "The peak element is 3 at index 2."
      },
      {
        "input": "nums = [1, 2, 1, 3, 5, 6, 4]",
        "output": "1 or 5",
        "explanation": "The peak elements are 2 and 6. Their indices are either 1 or 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use binary search to optimize the search for a peak element.",
      "Check the middle element against its neighbors."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Process Tasks Using Servers",
    "description": "You are given a list of tasks, each with a processing time, and a number of servers that can each process one task at a time. Your task is to determine the minimum time required to complete all tasks on the available servers. Each server will process tasks in a first-come, first-served manner. If there are no free servers, the task will wait until a server becomes available. You must return the minimum time required to finish all the tasks.",
    "topic": "Concurrency",
    "subtopic": "Task Scheduling",
    "tags": [
      "Concurrency",
      "Task Scheduling",
      "Priority Queue"
    ],
    "input_format": "An array of integers tasks where tasks[i] is the time required to complete task i. An integer n representing the number of servers.",
    "output_format": "An integer representing the minimum time required to process all tasks.",
    "constraints": [
      "1 <= tasks.length <= 1000",
      "1 <= tasks[i] <= 10^4",
      "1 <= n <= 10^4"
    ],
    "examples": [
      {
        "input": "tasks = [1, 2, 3, 4], n = 2",
        "output": "4",
        "explanation": "There are 2 servers. Server 1 processes tasks 1 and 3 (1 + 3 = 4), and Server 2 processes tasks 2 and 4 (2 + 4 = 6). Total time is 6, but as we're looking for the max between servers, the result is 4."
      },
      {
        "input": "tasks = [5, 2, 1], n = 1",
        "output": "8",
        "explanation": "With only 1 server, the server processes each task sequentially, leading to a total time of 5 + 2 + 1 = 8."
      },
      {
        "input": "tasks = [1, 2, 3, 4, 5], n = 3",
        "output": "5",
        "explanation": "The tasks can be processed simultaneously across 3 servers. In optimal distribution, the max time taken by any server is 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a min-heap to keep track of server availability.",
      "Assign tasks to the server that becomes free first."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Word Search II",
    "description": "Given a 2D board of characters and a list of words, return all words on the board. Each word must be constructed from sequentially adjacent cells, where 'adjacent' cells are horizontally or vertically neighboring. The same letter cell may not be used twice in a word. You may assume all inputs are valid and the words in the list are unique.",
    "topic": "Backtracking",
    "subtopic": "Trie",
    "tags": [
      "Backtracking",
      "Trie",
      "Search"
    ],
    "input_format": "A 2D character array board and a list of strings words.",
    "output_format": "A list of strings containing all the words from the list that can be found on the board.",
    "constraints": [
      "1 <= board.length, board[i].length <= 15",
      "1 <= words.length <= 10^4",
      "1 <= words[i].length <= 10"
    ],
    "examples": [
      {
        "input": "board = [['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v']], words = ['oath', 'pea', 'eat', 'rain']",
        "output": "[\"eat\",\"oath\"]",
        "explanation": "The words 'eat' and 'oath' can be found on the board."
      },
      {
        "input": "board = [['a','b'], ['c','d']], words = ['ab', 'cd', 'ad', 'ac']",
        "output": "[\"ab\",\"ac\",\"ad\"]",
        "explanation": "The words 'ab', 'ac', and 'ad' can be found on the board."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a Trie to store the words.",
      "Use a backtrack approach to explore all possible paths in the board."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Delete Node in a Linked List",
    "description": "You are given a reference to a node in a singly-linked list, and you need to delete that node without knowing the head of the list. The node will always be a non-tail node. Your task is to implement a function that deletes this node from the list.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "Linked List",
      "Deletion",
      "Data Structures"
    ],
    "input_format": "A reference to the node (not the head) that needs to be deleted.",
    "output_format": "No return value; the node is deleted in place.",
    "constraints": [
      "The node to be deleted is guaranteed to be not null.",
      "The node to be deleted will not be the last node."
    ],
    "examples": [
      {
        "input": "head = [4,5,1,9], node = 5",
        "output": "[4,1,9]",
        "explanation": "After deleting the node with value 5, the linked list is now 4 -> 1 -> 9."
      },
      {
        "input": "head = [4,5,1,9], node = 1",
        "output": "[4,5,9]",
        "explanation": "After deleting the node with value 1, the linked list is now 4 -> 5 -> 9."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Copy the value from the next node to this node and delete the next node."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Maximum Product Subarray",
    "description": "Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Return the largest product you can get.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Product"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum product of a contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, -2, 4]",
        "output": "6",
        "explanation": "The subarray [2, 3] has the largest product 6."
      },
      {
        "input": "nums = [-2, 0, -1]",
        "output": "0",
        "explanation": "The subarray [0] has the largest product 0."
      },
      {
        "input": "nums = [-2, 3, -4]",
        "output": "24",
        "explanation": "The subarray [3, -4] has the largest product 24."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Keep track of the maximum and minimum products at each position.",
      "Negative numbers can change the sign of the product, affecting the maximum product."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Valid Palindrome",
    "description": "Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. A palindrome is a string that reads the same forward and backward.",
    "topic": "String",
    "subtopic": "Two Pointers",
    "tags": [
      "String",
      "Two Pointers",
      "Palindrome"
    ],
    "input_format": "A single string s consisting of alphanumeric characters and spaces.",
    "output_format": "A boolean value indicating whether the string is a palindrome.",
    "constraints": [
      "0 <= s.length <= 10^5"
    ],
    "examples": [
      {
        "input": "s = \"A man, a plan, a canal: Panama\"",
        "output": "true",
        "explanation": "Ignoring cases and non-alphanumeric characters, the string becomes 'amanaplanacanalpanama', which is a palindrome."
      },
      {
        "input": "s = \"race a car\"",
        "output": "false",
        "explanation": "Ignoring cases and non-alphanumeric characters, the string becomes 'raceacar', which is not a palindrome."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to compare characters from the start and end of the string.",
      "Convert all characters to the same case for comparison."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "First Unique Character in a String",
    "description": "Given a string s, find the index of the first non-repeating character in it and return its index. If it does not exist, return -1.",
    "topic": "String",
    "subtopic": "Character Frequency",
    "tags": [
      "String",
      "Hashing",
      "Frequency Count"
    ],
    "input_format": "A single string s (1 <= s.length <= 10^5) consisting of lowercase English letters.",
    "output_format": "An integer representing the index of the first unique character or -1 if it does not exist.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = \"leetcode\"",
        "output": "0",
        "explanation": "The first unique character is 'l' which is at index 0."
      },
      {
        "input": "s = \"loveleetcode\"",
        "output": "2",
        "explanation": "The first unique character is 'v' which is at index 2."
      },
      {
        "input": "s = \"aabb\"",
        "output": "-1",
        "explanation": "There are no unique characters in this string."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash map to count the frequency of each character.",
      "Iterate through the string to find the first character with a count of 1."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Maximum Frequency Stack",
    "description": "Design a stack-like data structure that supports the following two operations: push and pop. The push operation takes an integer as an argument and pushes it onto the stack. The pop operation removes and returns the most frequent element in the stack. If there is a tie, the element with the highest value should be removed. Implement these operations such that each operation runs in O(1) time on average.",
    "topic": "Design",
    "subtopic": "Data Structures",
    "tags": [
      "Stack",
      "Design",
      "Data Structure"
    ],
    "input_format": "The input consists of a series of operations, represented as a list of pairs, where the first element is the operation ('push' or 'pop') and the second element is an integer for the push operation.",
    "output_format": "Return a list of integers representing the results of the pop operations.",
    "constraints": [
      "1 <= operations.length <= 10000",
      "-10^9 <= value <= 10^9",
      "The same value will not be pushed more than one time consecutively."
    ],
    "examples": [
      {
        "input": "[['push', 5], ['push', 7], ['push', 5], ['push', 7], ['push', 4], ['pop'], ['pop'], ['pop'], ['pop']]",
        "output": "[5, 7, 7, 5]",
        "explanation": "After pushing 5, 7, 5, and 7, we have two 5s and two 7s in the stack. The first pop returns 7 (the most frequent), the second pop returns 7, the third pop returns 5, and the last pop returns 5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a hashmap to count the frequencies.",
      "Utilize a max-heap or priority queue to track the most frequent elements."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Invalid Transactions",
    "description": "You are given a list of transactions where each transaction is represented as a string in the format \"name,amount,timestamp\". A transaction is considered invalid if: 1) The amount is greater than 1000, or 2) There exists another transaction with the same name and timestamp that occurs within 60 minutes of this transaction. Your task is to return a list of invalid transactions sorted by their original order of appearance.",
    "topic": "String",
    "subtopic": "Parsing",
    "tags": [
      "String",
      "Sorting",
      "Parsing"
    ],
    "input_format": "A list of strings representing transactions.",
    "output_format": "A list of strings representing the invalid transactions.",
    "constraints": [
      "1 <= transactions.length <= 20000",
      "Each transaction string has a format of \"name,amount,timestamp\".",
      "-1000000 <= amount <= 1000000",
      "0 <= timestamp <= 10^9"
    ],
    "examples": [
      {
        "input": "transactions = [\"alice,1000,2019-01-01T10:00:00Z\", \"alice,2000,2019-01-01T10:01:00Z\", \"bob,5000,2019-01-01T10:10:00Z\"]",
        "output": "[\"alice,2000,2019-01-01T10:01:00Z\", \"bob,5000,2019-01-01T10:10:00Z\"]",
        "explanation": "The first transaction is valid, but the second transaction is invalid as the amount exceeds 1000 and occurs within 60 minutes of a previous transaction. The third transaction is invalid due to an amount exceeding 1000."
      },
      {
        "input": "transactions = [\"alice,500,2019-01-01T10:00:00Z\", \"alice,3000,2019-01-01T10:01:30Z\", \"alice,100,2019-01-01T10:05:00Z\", \"alice,800,2019-01-01T11:00:00Z\"]",
        "output": "[\"alice,3000,2019-01-01T10:01:30Z\"]",
        "explanation": "Only the second transaction is invalid because the amount exceeds 1000."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Separate each transaction into its components.",
      "Keep track of transactions by name and their timestamps.",
      "Use a data structure that allows for efficient insertion and lookup."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Maximum Population Year",
    "description": "You are given a 2D array representing the birth and death years of a number of people. Each subarray contains two integers: the birth year and the death year of a single person. Your task is to find out the year with the maximum population. If there are multiple years with the same maximum population, return the earliest year.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Population",
      "Timeline"
    ],
    "input_format": "A 2D array `people`, where `people[i] = [birthYear, deathYear]` for each person.",
    "output_format": "An integer representing the year with the maximum population.",
    "constraints": [
      "1 <= people.length <= 1000",
      "1900 <= birthYear <= deathYear <= 2000"
    ],
    "examples": [
      {
        "input": "people = [[1993, 1999], [2000, 2010], [1998, 2002]]",
        "output": "1998",
        "explanation": "In 1998, there were 3 people alive (born in 1993, 1998, and one that died in 2000)."
      },
      {
        "input": "people = [[1950, 1960], [1955, 1970], [1950, 1955], [1960, 1970]]",
        "output": "1955",
        "explanation": "From 1950 to 1955, there are the most people alive, which is 3."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a timeline to track population changes.",
      "You can iterate through each year and keep a count of the population."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Text Justification",
    "description": "Given an array of words and a length maxWidth, format the text such that each line has exactly maxWidth characters and is fully justified. You should insert extra spaces between words so that each line has exactly maxWidth characters. Extra spaces are distributed as evenly as possible among the words. If the number of spaces on a line is not divisible by the number of gaps between words, the extra spaces should be distributed from left to right. The last line of text should be left-justified and no extra space is inserted between words.",
    "topic": "String",
    "subtopic": "Text Processing",
    "tags": [
      "String",
      "Justification",
      "Formatting"
    ],
    "input_format": "An array of strings words and an integer maxWidth.",
    "output_format": "An array of strings representing the fully justified text.",
    "constraints": [
      "1 <= words.length <= 3000",
      "1 <= words[i].length <= 100",
      "1 <= maxWidth <= 100"
    ],
    "examples": [
      {
        "input": {
          "words": [
            "This",
            "is",
            "an",
            "example",
            "of",
            "text",
            "justification."
          ],
          "maxWidth": 16
        },
        "output": [
          "This    is    an",
          "example  of text",
          "justification.  "
        ],
        "explanation": "The first line contains 4 words with 4 extra spaces inserted between them, the second line is also justified, and the last line is left-justified."
      },
      {
        "input": {
          "words": [
            "What",
            "must",
            "be",
            "acknowledgment",
            "shall",
            "be"
          ],
          "maxWidth": 16
        },
        "output": [
          "What   must   be",
          "acknowledgment  ",
          "shall be        "
        ],
        "explanation": "The first line is justified, the second line is exactly maxWidth long, and the last line is left-justified."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to manage the number of spaces needed.",
      "Think about how to distribute remaining spaces when you can't divide evenly."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Merge In Between Linked Lists",
    "description": "You are given two linked lists: the first list contains nodes with values in a non-decreasing order, and the second list contains nodes with values to be inserted in between the first list. Your task is to merge these two lists by inserting the nodes of the second list into the first list at the appropriate positions, preserving the non-decreasing order of the first list.",
    "topic": "Linked List",
    "subtopic": "Merging",
    "tags": [
      "Linked List",
      "Merge",
      "Sorting"
    ],
    "input_format": "Two linked lists represented by their head nodes, the first list with values in non-decreasing order, and the second list with arbitrary values.",
    "output_format": "The head node of the merged linked list.",
    "constraints": [
      "The first list has at most 1000 nodes.",
      "The second list has at most 1000 nodes.",
      "Values of nodes in both lists are in the range of -10^6 to 10^6."
    ],
    "examples": [
      {
        "input": "list1 = 1 -> 3 -> 5; list2 = 2 -> 4 -> 6",
        "output": "1 -> 2 -> 3 -> 4 -> 5 -> 6",
        "explanation": "Insert 2 between 1 and 3, and 4 between 3 and 5 to maintain the order."
      },
      {
        "input": "list1 = 1 -> 2 -> 4; list2 = 1 -> 3 -> 4",
        "output": "1 -> 1 -> 2 -> 3 -> 4 -> 4",
        "explanation": "1 from list2 is inserted before the first 2 in list1, and 3 is inserted before 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using pointers to traverse both lists.",
      "You might need to handle edge cases where one of the lists is empty."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Intersection of Two Arrays",
    "description": "Given two arrays of integers, return an array containing their intersection. Each element in the result must be unique and you may return the answer in any order.",
    "topic": "Array",
    "subtopic": "Set Operations",
    "tags": [
      "Array",
      "Set",
      "Intersection"
    ],
    "input_format": "Two integer arrays nums1 and nums2.",
    "output_format": "An array of unique integers that are present in both nums1 and nums2.",
    "constraints": [
      "0 <= nums1.length, nums2.length <= 1000",
      "-1000 <= nums1[i], nums2[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]",
        "output": "[2]",
        "explanation": "The intersection of the two arrays is 2."
      },
      {
        "input": "nums1 = [4, 9, 5], nums2 = [9, 4, 9, 8, 4]",
        "output": "[4, 9]",
        "explanation": "Both arrays contain 4 and 9 in common."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a set to keep track of unique elements."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Design Twitter",
    "description": "Design a simplified version of the Twitter system where users can post tweets, follow other users, and view their feed. Implement a class `Twitter` that has the following methods:\n\n1. `postTweet(userId: int, tweetId: int)`: Create a new tweet by the user `userId` with tweet ID `tweetId`. Each call to this function will be a new tweet.\n\n2. `getNewsFeed(userId: int)`: Retrieve the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be from a user the user follows or themselves. Tweets must be ordered from most recent to oldest.\n\n3. `follow(followerId: int, followeeId: int)`: User with ID `followerId` starts following the user with ID `followeeId`.\n\n4. `unfollow(followerId: int, followeeId: int)`: User with ID `followerId` stops following the user with ID `followeeId`.",
    "topic": "Design",
    "subtopic": "System Design",
    "tags": [
      "Design",
      "Twitter",
      "System Design"
    ],
    "input_format": "None. The methods will be called sequentially.",
    "output_format": "An integer list representing the tweet IDs in the user's news feed or none.",
    "constraints": [
      "User IDs and tweet IDs are integers in the range [1, 10^4].",
      "The number of tweets can go up to 10^5."
    ],
    "examples": [
      {
        "input": "Twitter tw = new Twitter();\ntw.postTweet(1, 5);\ntw.getNewsFeed(1);",
        "output": "[5]",
        "explanation": "User 1 has posted one tweet with ID 5. The feed for user 1 contains that tweet."
      },
      {
        "input": "tw.follow(1, 2);\ntw.postTweet(2, 6);\ntw.getNewsFeed(1);",
        "output": "[6, 5]",
        "explanation": "User 1 follows user 2, who posted a tweet with ID 6. User 1's feed contains tweet IDs 6 and 5, in that order."
      },
      {
        "input": "tw.unfollow(1, 2);\ntw.getNewsFeed(1);",
        "output": "[5]",
        "explanation": "User 1 unfollowed user 2 and now only sees their own tweet ID 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a data structure to keep track of user feeds.",
      "Think about managing the order of tweets efficiently."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Find Minimum in Rotated Sorted Array",
    "description": "Given an integer array `nums` sorted in ascending order, possibly rotated at an unknown pivot, return the minimum element in that array. You must write an algorithm that runs in O(log n) time complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Sorting"
    ],
    "input_format": "An array of integers nums of length n, where 1 <= n <= 5000.",
    "output_format": "An integer representing the minimum element in the rotated sorted array.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "\u221210^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [3, 4, 5, 1, 2]",
        "output": "1",
        "explanation": "The minimum element is 1."
      },
      {
        "input": "nums = [4, 5, 6, 7, 0, 1, 2]",
        "output": "0",
        "explanation": "The minimum element is 0."
      },
      {
        "input": "nums = [11, 13, 15, 17]",
        "output": "11",
        "explanation": "The array has not been rotated, so the minimum element is at the start."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use binary search to narrow down the search space.",
      "The minimum will be found in the part of the array that is not sorted."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Minimum Number of Removals to Make Mountain Array",
    "description": "A mountain array is defined as an array that has at least three elements and satisfies the following conditions: there exists an index i (1 <= i < n - 1) such that nums[0] < nums[1] < ... < nums[i] and nums[i] > nums[i + 1] > ... > nums[n - 1]. Given an integer array nums, you want to remove the minimum number of elements (possibly zero) from nums to make it a mountain array. Return the minimum number of removals needed.",
    "topic": "Dynamic Programming",
    "subtopic": "Longest Increasing Subsequence",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Greedy"
    ],
    "input_format": "An array of integers nums where 1 <= nums.length <= 10^5 and -10^4 <= nums[i] <= 10^4.",
    "output_format": "An integer representing the minimum number of removals needed to make the array a mountain array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 1, 5, 2, 5, 4]",
        "output": "3",
        "explanation": "We can remove elements [1, 1, 2] to make the array [3, 5, 5, 4], which is a mountain array with 3 elements removed."
      },
      {
        "input": "nums = [2, 1, 1, 5, 6, 2, 3, 1]",
        "output": "3",
        "explanation": "We can remove elements [1, 1, 1] to form the array [2, 5, 6, 3], making it a mountain array."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using the concept of the longest increasing subsequence.",
      "You might need to maintain two sequences - one for increasing and one for decreasing."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Divide Players Into Teams of Equal Skill",
    "description": "You are given an array of integers representing the skill levels of players. Your task is to determine if it is possible to divide the players into two teams such that the sum of skill levels in both teams is equal. Each team must contain at least one player. Return true if it is possible to divide the players into two teams of equal skill, otherwise, return false.",
    "topic": "Dynamic Programming",
    "subtopic": "Subset Sum",
    "tags": [
      "Dynamic Programming",
      "Subset Sum",
      "Array"
    ],
    "input_format": "An array of integers, skills, representing the skill levels of players.",
    "output_format": "A boolean value indicating whether it is possible to divide players into two teams of equal skill.",
    "constraints": [
      "1 <= skills.length <= 200",
      "0 <= skills[i] <= 100"
    ],
    "examples": [
      {
        "input": "skills = [1, 5, 11, 5]",
        "output": "true",
        "explanation": "The players can be divided into two teams [1, 5, 5] and [11], both sum to 11."
      },
      {
        "input": "skills = [1, 2, 3, 5]",
        "output": "false",
        "explanation": "It is not possible to divide the players into two teams of equal skill."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the total skill level and check if it's even.",
      "Use dynamic programming to solve the subset sum problem."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Jump Game II",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Write a function to determine the minimum number of jumps required to reach the last index.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "An integer representing the minimum number of jumps needed to reach the last index.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^4",
      "It's guaranteed that you can reach the last index."
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "2",
        "explanation": "Jump 1 step from index 0 to 1, then jump 3 steps to the last index."
      },
      {
        "input": "nums = [2, 3, 0, 1, 4]",
        "output": "2",
        "explanation": "Jump 1 step from index 0 to 1, then jump 3 steps to the last index."
      },
      {
        "input": "nums = [0]",
        "output": "0",
        "explanation": "Already at the last index; no jumps needed."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a greedy approach to minimize jumps.",
      "Track the farthest point that can be reached at each jump.",
      "Use a variable to count the number of jumps made."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Number of Substrings Containing All Three Characters",
    "description": "Given a string s consisting of only three different characters: 'a', 'b', and 'c', return the number of substrings that contain at least one occurrence of each character. A substring is a contiguous sequence of characters within the string.",
    "topic": "String",
    "subtopic": "Substring Count",
    "tags": [
      "String",
      "Sliding Window",
      "Substring"
    ],
    "input_format": "A string s consisting of characters 'a', 'b', and 'c'.",
    "output_format": "An integer representing the number of valid substrings.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of only the characters 'a', 'b', and 'c'."
    ],
    "examples": [
      {
        "input": "abcabc",
        "output": "10",
        "explanation": "The valid substrings are 'abc', 'abca', 'abcab', 'abcabc', 'bca', 'bcab', 'babc', 'cab', 'abc', and 'bca'."
      },
      {
        "input": "aaacb",
        "output": "3",
        "explanation": "The valid substrings are 'aacb', 'acb', and 'aaacb'."
      },
      {
        "input": "abc",
        "output": "1",
        "explanation": "'abc' is the only valid substring that contains all three characters."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sliding window approach.",
      "Maintain a count of each character in the current window.",
      "Expand the window to include more characters until you meet the requirements."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "Given n non-negative integers a1, a2, ..., an where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Max Area"
    ],
    "input_format": "An array of integers height of length n, where height[i] is the height of the i-th line.",
    "output_format": "An integer representing the maximum amount of water that can be contained.",
    "constraints": [
      "2 <= height.length <= 10^5",
      "0 <= height[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The container with the widest and tallest lines is between the lines at the indices 1 and 8 which holds the maximum water."
      },
      {
        "input": "height = [1,1]",
        "output": "1",
        "explanation": "The container formed by lines at positions 0 and 1 can hold 1 unit of water."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the width and the height when calculating the area.",
      "You can use a two-pointer approach to optimize your traversal."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array nums, return the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses constant extra space.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Mathematic"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the smallest missing positive integer.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3, 4, -1, 1]",
        "output": "2",
        "explanation": "The numbers 1 and 2 are the first two positive integers. 2 is the smallest missing positive integer."
      },
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "The numbers present are 1 and 2. The smallest missing positive integer is 3."
      },
      {
        "input": "nums = [7, 8, 9, 11, 12]",
        "output": "1",
        "explanation": "There are no positive integers less than 7. Thus, 1 is the smallest missing positive integer."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using the index as a way to mark the presence of integers.",
      "For each number, try placing it in its rightful index position.",
      "Iterate through the modified array to find the first place where the index does not match the number."
    ],
    "company": "PayPal"
  },
  {
    "question_id": "",
    "title": "Maximum Profit in Job Scheduling",
    "description": "Given a list of jobs where each job is represented by a start time, end time, and profit, you need to find the maximum profit you can earn by scheduling non-overlapping jobs. You can only schedule a job if it starts after the previous job ends.",
    "topic": "Dynamic Programming",
    "subtopic": "Interval Scheduling",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Interval Scheduling"
    ],
    "input_format": "An array of jobs, where each job is represented as [start_time, end_time, profit].",
    "output_format": "An integer representing the maximum profit you can earn.",
    "constraints": [
      "1 <= jobs.length <= 1000",
      "0 <= start_time < end_time <= 10^9",
      "0 <= profit <= 1000"
    ],
    "examples": [
      {
        "input": "jobs = [[1, 2, 50], [3, 5, 20], [6, 19, 100], [2, 100, 200]]",
        "output": "250",
        "explanation": "The optimal scheduling is to pick jobs [1, 2] and [6, 19], which earn a profit of 50 + 100 = 150."
      },
      {
        "input": "jobs = [[1, 3, 10], [2, 5, 20], [6, 8, 15]]",
        "output": "35",
        "explanation": "The optimal scheduling is to pick jobs [2, 5] and [6, 8], which earn a profit of 20 + 15 = 35."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider sorting the jobs based on their end times.",
      "Use a binary search to find the last non-conflicting job."
    ],
    "company": "PayPal"
  }
]