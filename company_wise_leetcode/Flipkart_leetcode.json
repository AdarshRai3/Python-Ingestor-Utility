[
  {
    "question_id": "",
    "title": "Smallest Range Covering Elements from K Lists",
    "description": "Given k sorted sublists, the task is to find the smallest range that includes at least one number from each of the k lists. The range is defined as [min_num, max_num], meaning you need to return the two integers min_num and max_num that define the smallest range. If there are multiple valid ranges, return any of them.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Heap",
      "Two Pointers",
      "Sliding Window"
    ],
    "input_format": "A list of k sorted lists of integers, where each list can contain duplicates.",
    "output_format": "A list of two integers representing the smallest range.",
    "constraints": [
      "1 <= k <= 10^4",
      "1 <= lists[i].length <= 500",
      "-10^5 <= lists[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "lists = [[1, 2, 3], [4, 5], [1, 2]]",
        "output": "[1, 5]",
        "explanation": "The range [1, 5] includes elements from all three lists."
      },
      {
        "input": "lists = [[10, 20, 30], [5, 15, 25], [2, 12, 22]]",
        "output": "[10, 12]",
        "explanation": "The range [10, 12] includes elements from all three lists."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a min-heap to track the current minimum elements from each list.",
      "Keep a map of the indices to track which element belongs to which list."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Shortest Bridge",
    "description": "You are given a 2D binary grid where 0 represents water and 1 represents land. Your goal is to find the length of the shortest bridge that connects two islands. A bridge is formed by turning some 0s into 1s. The bridge must be built horizontally or vertically. You need to return the minimum number of cells that must be flipped to connect the two islands.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "Graph",
      "BFS",
      "Island"
    ],
    "input_format": "A 2D array grid representing the binary grid.",
    "output_format": "An integer representing the length of the shortest bridge.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 100",
      "grid[i][j] is either 0 or 1.",
      "There are at least two islands in the grid."
    ],
    "examples": [
      {
        "input": "[[0, 1], [1, 0]]",
        "output": "1",
        "explanation": "The two islands are adjacent, so the shortest bridge consists of flipping one water cell (0) to land (1)."
      },
      {
        "input": "[[0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0]]",
        "output": "2",
        "explanation": "The nearest points from each island are at a distance of 2, requiring two flips from water (0) to land (1)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use BFS to find the nearest zeroes to the islands.",
      "Keep track of the distances while exploring."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of integers representing the height of bars in a histogram, compute how much water it can trap after raining. The width of each bar is 1.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers height where height[i] represents the height of the i-th bar.",
    "output_format": "An integer representing the total water trapped.",
    "constraints": [
      "0 <= height.length <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The water trapped above the bars forms a total of 6 units."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "Water can be trapped above certain bars giving a total of 9 units."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a two-pointer technique to find trapped water.",
      "Precompute the maximum heights to the left and right of each bar."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Maximum Points You Can Obtain from Cards",
    "description": "You have a list of points associated with different cards. Each card can be drawn from the top or the bottom of a deck. You have to draw a total of 'k' cards in such a way that the total points obtained are maximized. Write a function to determine the maximum points you can obtain by drawing 'k' cards from the deck.",
    "topic": "Dynamic Programming",
    "subtopic": "Sliding Window",
    "tags": [
      "Dynamic Programming",
      "Sliding Window",
      "Greedy"
    ],
    "input_format": "An integer array points representing the points on the cards, and an integer k indicating the number of cards to draw.",
    "output_format": "An integer representing the maximum points you can obtain by drawing k cards.",
    "constraints": [
      "1 <= points.length <= 1000",
      "0 <= points[i] <= 1000",
      "1 <= k <= points.length"
    ],
    "examples": [
      {
        "input": "points = [1, 2, 3, 4, 5, 6, 1], k = 3",
        "output": "12",
        "explanation": "You can take cards with points 4, 5, and 3 for a total of 12 points."
      },
      {
        "input": "points = [2, 4, 5, 1, 3], k = 2",
        "output": "7",
        "explanation": "You can take cards with points 4 and 5 for a total of 9 points."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the contributions from both ends of the array.",
      "You might want to compute the total possible points and use a prefix sum array."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Minimum Number of Coins to be Added",
    "description": "You are given an array of integers representing the amount of coins in each pile. Your task is to determine the minimum number of coins that must be added to ensure that the number of coins in each pile is at least equal to the average number of coins across all piles. Return the minimum number of coins needed.",
    "topic": "Array",
    "subtopic": "Math",
    "tags": [
      "Array",
      "Math",
      "Greedy"
    ],
    "input_format": "An array of integers coins, where coins[i] represents the number of coins in the i-th pile.",
    "output_format": "An integer representing the minimum number of coins to add.",
    "constraints": [
      "1 <= coins.length <= 10^5",
      "0 <= coins[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "coins = [1, 2, 3]",
        "output": "3",
        "explanation": "The average number of coins is (1 + 2 + 3) / 3 = 2. All piles need at least 2 coins. We need to add 1 coin to the first pile and 1 coin to the second pile, and 1 coin to the third pile to make them all equal to 2."
      },
      {
        "input": "coins = [1, 1, 1]",
        "output": "0",
        "explanation": "The average number of coins is (1 + 1 + 1) / 3 = 1. Each pile already has the average number of coins."
      },
      {
        "input": "coins = [0, 0, 5]",
        "output": "5",
        "explanation": "The average number of coins is (0 + 0 + 5) / 3 = 1.67. Rounding up, each pile needs at least 2 coins, requiring 2 coins for the first pile and 2 coins for the second pile."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Calculate the average and consider how many coins each pile is short of."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Capacity To Ship Packages Within D Days",
    "description": "You are given an array `weights` where `weights[i]` is the weight of the ith package, and an integer `D` representing the maximum number of days allowed for shipping all packages. Your task is to find the minimum capacity of the ship that will allow you to ship all packages within `D` days. A ship can carry at most one package at a time, and it can only ship packages at the end of the day. If it exceeds its capacity on any day, it needs to make an extra trip to deliver the excess packages. Return the minimum integer capacity that satisfies this requirement.",
    "topic": "Binary Search",
    "subtopic": "Min/Max Problems",
    "tags": [
      "Binary Search",
      "Array",
      "Greedy"
    ],
    "input_format": "An array of integers `weights` and an integer `D`.",
    "output_format": "An integer representing the minimum ship capacity to ship all packages within D days.",
    "constraints": [
      "1 <= weights.length <= 50000",
      "1 <= weights[i] <= 500"
    ],
    "examples": [
      {
        "input": "weights = [1,2,3,4,5,6,7,8,9,10], D = 5",
        "output": "15",
        "explanation": "If the ship capacity is 15, it can ship packages in the following manner: days 1-5: [1,2,3,4,5] and [6,7,8,9,10], meeting the D days requirement."
      },
      {
        "input": "weights = [3,2,2,4,1,4], D = 3",
        "output": "6",
        "explanation": "If the ship capacity is 6, it can ship [3,2,1] on day 1, [2,4] on day 2, and [4] on day 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use binary search to determine the minimum capacity.",
      "Start with the maximum weight as the lower bound and the sum of all weights as the upper bound for the search."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Design Movie Rental System",
    "description": "Design a Movie Rental System that allows users to rent movies, return them, and check the availability of movies in real-time. The system should support operations for managing movies, customers, and rental transactions. Implement classes for Movie, Customer, and Rental to encapsulate the data and behavior associated with each entity. The system should also allow tracking of rented movies and enforce rental limits based on user membership levels.",
    "topic": "Design",
    "subtopic": "Object-Oriented Design",
    "tags": [
      "Design",
      "Object-Oriented",
      "System Design",
      "Rental Management"
    ],
    "input_format": "N/A (Class-based design)",
    "output_format": "N/A (Functionality of classes and methods to be tested)",
    "constraints": [
      "The system can hold up to 10,000 movies.",
      "The maximum number of movies any customer can rent at one time is determined by their membership level.",
      "Assume unique identifiers for each movie and customer."
    ],
    "examples": [
      {
        "input": "Create a Movie object with title 'Inception' and genre 'Sci-fi'.\nCreate a Customer object with name 'John Doe' and membership level 'Silver'.\nCustomer rents 'Inception'.",
        "output": "Movie 'Inception' is now rented by John Doe.",
        "explanation": "This operation adds the movie to the customer's rental list and updates its availability status."
      },
      {
        "input": "Customer returns 'Inception'.",
        "output": "Movie 'Inception' has been successfully returned.",
        "explanation": "This operation removes the movie from the customer's rental list and updates its availability."
      },
      {
        "input": "Check availability of movie 'Inception'.",
        "output": "Movie 'Inception' is currently rented.",
        "explanation": "The system checks the rental status of the movie and returns its availability."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a registry or database to manage the movies and customers.",
      "Think about how to handle the movie availability status and rental limits."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Triples with Bitwise AND Equal To Zero",
    "description": "Given an array of integers, find the number of unique triplets (i, j, k) such that i < j < k and nums[i] & nums[j] & nums[k] == 0. The bitwise AND operation will combine the bits of the three numbers, and we need to check if the result is zero.",
    "topic": "Bit Manipulation",
    "subtopic": "Triplets",
    "tags": [
      "Bit Manipulation",
      "Array",
      "Triplets"
    ],
    "input_format": "An array of integers nums of length n.",
    "output_format": "An integer representing the number of unique triplets (i, j, k) satisfying the condition.",
    "constraints": [
      "1 <= nums.length <= 200",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 6, 7]",
        "output": "1",
        "explanation": "The only valid triplet is (2, 3, 7) since 2 & 3 & 7 = 0."
      },
      {
        "input": "nums = [0, 1, 2, 3, 4]",
        "output": "5",
        "explanation": "The valid triplets are (0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4), confirming that the AND is zero."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a set to avoid counting duplicates.",
      "Look for properties of numbers that make AND operation yield zero.",
      "Optimize by avoiding unnecessary calculations for the same number."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Minimum Limit of Balls in a Bag",
    "description": "You have a bag that can hold a certain number of balls, and you want to ensure that it does not go below a specified minimum limit. Given an array of integers where each integer represents the number of balls added or removed from the bag, determine the minimum number of balls that must be in the bag after all operations to satisfy the limit.",
    "topic": "Array",
    "subtopic": "Prefix Sum",
    "tags": [
      "Array",
      "Prefix Sum",
      "Mathematics"
    ],
    "input_format": "An integer array operations where 1 <= operations.length <= 10^4 and -100 <= operations[i] <= 100.",
    "output_format": "An integer representing the minimum number of balls in the bag after all operations.",
    "constraints": [
      "1 <= operations.length <= 10^4",
      "-100 <= operations[i] <= 100"
    ],
    "examples": [
      {
        "input": "operations = [3, -2, 5, -4, -1]",
        "output": "1",
        "explanation": "The sequence of operations causes the bag to have at least 1 ball remaining after all operations."
      },
      {
        "input": "operations = [10, -15, 5, -5, 2]",
        "output": "0",
        "explanation": "After these operations, the bag can have 0 balls remaining."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Keep track of the current number of balls after each operation.",
      "Determine the minimum number of balls at every step to find the answer."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "You are given n vertical lines drawn on a 2D plane, where the ith line is at the point (i, height[i]). Find two lines that together with the x-axis form a container that holds the most water. Return the maximum amount of water a container can store.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "input_format": "An array of integers height where height[i] represents the height of the ith line.",
    "output_format": "An integer representing the maximum area of water that can be contained.",
    "constraints": [
      "2 <= height.length <= 10^5",
      "0 <= height[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The lines at index 1 and 8 can contain water up to the height of 7, resulting in an area of 7 * (8 - 1) = 49."
      },
      {
        "input": "height = [1,1]",
        "output": "1",
        "explanation": "The only lines available are at index 0 and 1, which give an area of 1 * (1 - 0) = 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using two pointers to find the maximum area efficiently.",
      "Moving the pointer that points to the shorter line might yield a larger area."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "The Score of Students Solving Math Expression",
    "description": "You are given a string expression representing a sequence of students' solving scores for a math test. Each student's score is represented as either a non-negative integer or a score that may include additions ('+') or subtractions ('-'). Your task is to compute the total score of all students based on the expression provided. The expression will have no extra spaces, and it may also include validations such as parentheses for grouping scores. Your solution must account for operator precedence and the correct sequence of operations.",
    "topic": "Mathematics",
    "subtopic": "Expression Evaluation",
    "tags": [
      "Math",
      "Expression",
      "Score Calculation",
      "Stack"
    ],
    "input_format": "A string expression representing scores and operations.",
    "output_format": "An integer representing the total score of all students.",
    "constraints": [
      "1 <= expression.length <= 10^5",
      "The expression contains non-negative integers and '+' or '-' operators."
    ],
    "examples": [
      {
        "input": "(1 + 2) - (3 + 4)",
        "output": "-4",
        "explanation": "The expression evaluates to (1 + 2) - (3 + 4) = 3 - 7 = -4."
      },
      {
        "input": "10 + 2 - 5 + (3 - 1)",
        "output": "10",
        "explanation": "The expression evaluates to 10 + 2 - 5 + (3 - 1) = 10 + 2 - 5 + 2 = 10."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to manage the operations and parentheses.",
      "Handle the operator precedence carefully while evaluating the expression."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Minimum Cost to Reach City With Discounts",
    "description": "You are a traveler trying to reach a destination city. You start from city 0 and want to reach city n. There are several roads connecting the cities and each road has a certain cost. You are also given a list of discounts that can be applied to your travel expenses. Each discount can be applied to only one road. Your goal is to find the minimum cost to reach the destination city using any possible combination of the roads and discounts.",
    "topic": "Dynamic Programming",
    "subtopic": "Optimization",
    "tags": [
      "Dynamic Programming",
      "Graph",
      "Cost Optimization"
    ],
    "input_format": "An integer n (the number of cities), an array of integers roads where roads[i] is the cost of traveling between city i and i+1, and an array of integers discounts representing the discounts available for use.",
    "output_format": "An integer representing the minimum cost to reach city n.",
    "constraints": [
      "1 <= n <= 10^5",
      "1 <= roads.length <= n - 1",
      "0 <= roads[i] <= 10^4",
      "0 <= discounts.length <= roads.length",
      "0 <= discounts[i] <= roads[i]"
    ],
    "examples": [
      {
        "input": {
          "n": 5,
          "roads": [
            10,
            20,
            30,
            40
          ],
          "discounts": [
            5,
            10
          ]
        },
        "output": "85",
        "explanation": "The total cost without discounts is 10 + 20 + 30 + 40 = 100. Applying the discounts of 5 on the first road and 10 on the second road gives us 100 - 5 - 10 = 85."
      },
      {
        "input": {
          "n": 4,
          "roads": [
            10,
            15,
            25
          ],
          "discounts": []
        },
        "output": "50",
        "explanation": "No discounts are available, so the cost is 10 + 15 + 25 = 50."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the total cost without discounts as a baseline.",
      "Evaluate the impact of each discount on your path.",
      "Dynamic programming might help in optimizing the solution."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Numbers With Same Consecutive Differences",
    "description": "Given an integer n and an integer k, return all possible numbers of length n such that the absolute difference between every two consecutive digits is k. All the numbers should be non-negative integers, and the first digit of the number cannot be zero.",
    "topic": "Backtracking",
    "subtopic": "Generating Combinations",
    "tags": [
      "Backtracking",
      "Combinations",
      "Recursion"
    ],
    "input_format": "Two integers n and k.",
    "output_format": "A list of integers representing the valid numbers with the same consecutive differences.",
    "constraints": [
      "1 <= n <= 9",
      "0 <= k <= 9"
    ],
    "examples": [
      {
        "input": "n = 3, k = 7",
        "output": "[181, 292, 707, 818, 929]",
        "explanation": "The numbers 181, 292, 707, 818, and 929 all have the same consecutive differences of 7."
      },
      {
        "input": "n = 2, k = 1",
        "output": "[10, 12, 21, 23, 32, 34, 43, 45, 54, 56, 65, 67, 76, 78, 87, 89]",
        "explanation": "These numbers all have consecutive digits differing by 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using depth-first search to build the numbers.",
      "Keep track of the last digit to determine the next possible digits."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Minimum Total Cost to Make Arrays Unequal",
    "description": "You are given two arrays of integers, `A` and `B`, each containing `n` elements. Your task is to make both arrays unequal by performing the minimum total cost operations. Each operation costs `c` and can either add, subtract, or increment the elements of either array. The goal is to ensure that no corresponding elements of `A` and `B` are equal after performing the operations.",
    "topic": "Array",
    "subtopic": "Minimization",
    "tags": [
      "Array",
      "Minimization",
      "Cost Optimization"
    ],
    "input_format": "Two arrays A and B of integers followed by an integer c, denoting the cost of each operation.",
    "output_format": "An integer representing the minimum total cost required to make arrays A and B unequal.",
    "constraints": [
      "1 <= n <= 10^5",
      "-10^6 <= A[i], B[i] <= 10^6",
      "0 <= c <= 1000"
    ],
    "examples": [
      {
        "input": "A = [1, 2, 3]\nB = [1, 3, 2]\nc = 2",
        "output": "2",
        "explanation": "You can increment A[0] to make it 2, which costs 2. Now A = [2, 2, 3] and B = [1, 3, 2], both are unequal."
      },
      {
        "input": "A = [4, 4, 4]\nB = [4, 4, 4]\nc = 1",
        "output": "3",
        "explanation": "You need to increment A[0], A[1], and A[2] by 1, which costs 3 in total. Now A = [5, 5, 5] and B = [4, 4, 4], which are unequal."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the properties of even and odd numbers.",
      "Look for patterns in the values of A and B to determine optimal changes.",
      "Think about minimizing the maximum equal pairs."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Asteroid Collision",
    "description": "We have an array of integers representing asteroids in a row. For each asteroid, the absolute value represents its size, and the sign represents its direction. Positive values represent asteroids moving to the right, while negative values represent asteroids moving to the left. When two asteroids collide, the smaller one (by absolute value) will explode. If both are of the same size, both will explode. Write a function to simulate the collisions and return the final state of the asteroids after all collisions have taken place.",
    "topic": "Stack",
    "subtopic": "Collision Detection",
    "tags": [
      "Stack",
      "Array",
      "Simulation"
    ],
    "input_format": "An array of integers representing the asteroids.",
    "output_format": "An array of integers representing the asteroids after all collisions.",
    "constraints": [
      "1 <= asteroids.length <= 10^4",
      "-1000 <= asteroids[i] <= 1000",
      "At most one asteroid will be present at the same position."
    ],
    "examples": [
      {
        "input": "asteroids = [5, 10, -5]",
        "output": "[5, 10]",
        "explanation": "The right-moving asteroids 5 and 10 do not collide with each other, while -5 collides with 10 and is destroyed."
      },
      {
        "input": "asteroids = [8, -8]",
        "output": "[]",
        "explanation": "Both asteroids collide, and since they are of equal size, both are destroyed."
      },
      {
        "input": "asteroids = [10, 2, -5]",
        "output": "[10]",
        "explanation": "10 collides with -5 and destroys it, while 2 moves in the same direction and remains."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to keep track of the surviving asteroids.",
      "Check for collisions by analyzing the sign of the top of the stack."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Koko Eating Bananas",
    "description": "Koko loves bananas! Every day she eats some bananas, and the number of bananas she eats can vary. Given an array where each element represents the number of bananas Koko has in her possession on day i, your task is to determine the minimum eating speed in bananas per hour at which she can finish all bananas in a given number of hours. Koko can eat any integer number of bananas, but she cannot eat a fraction of a banana. If she doesn't finish the bananas in the allotted time, she will not be happy! You need to calculate the minimum integer speed required such that she finishes all bananas within the given hours.",
    "topic": "Binary Search",
    "subtopic": "Searching",
    "tags": [
      "Binary Search",
      "Greedy",
      "Math"
    ],
    "input_format": "An array of integers piles where piles[i] is the number of bananas Koko has on day i, and an integer h which is the total hours Koko has to finish all the bananas.",
    "output_format": "An integer representing the minimum eating speed in bananas per hour.",
    "constraints": [
      "1 <= piles.length <= 10^4",
      "1 <= piles[i] <= 10^9",
      "1 <= h <= 10^9"
    ],
    "examples": [
      {
        "input": "piles = [3, 6, 7, 11], h = 8",
        "output": "4",
        "explanation": "Koko can eat 4 bananas per hour. In 8 hours, she will finish (4 * 8 = 32) bananas, which is sufficient."
      },
      {
        "input": "piles = [30, 11, 23, 4, 20], h = 5",
        "output": "30",
        "explanation": "Koko needs to eat at least 30 bananas per hour to finish all within 5 hours."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about the maximum number of bananas in a single pile.",
      "Use binary search to optimize the eating speed."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Binary Tree Maximum Path Sum",
    "description": "Given a non-empty binary tree, find the maximum path sum. A path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must be connected. The maximum path sum will not exceed 2^31 - 1.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Depth-First Search",
      "Dynamic Programming"
    ],
    "input_format": "The input is a binary tree represented by a root node.",
    "output_format": "An integer representing the maximum path sum.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 3 * 10^4].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3]",
        "output": "6",
        "explanation": "The path 2 -> 1 -> 3 has the maximum path sum 2 + 1 + 3 = 6."
      },
      {
        "input": "root = [-10, 9, 20, null, null, 15, 7]",
        "output": "42",
        "explanation": "The path 15 -> 20 -> 7 has the maximum path sum 15 + 20 + 7 = 42."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider all possible paths that lead to a node.",
      "Use recursion to calculate the maximum path sum for each node.",
      "Keep track of both single paths and complete paths."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Hashmap"
    ],
    "input_format": "A string s where 1 <= s.length <= 10^5.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of English letters, digits, symbols, and spaces."
    ],
    "examples": [
      {
        "input": "s = 'abcabcbb'",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'abc', which has a length of 3."
      },
      {
        "input": "s = 'bbbbb'",
        "output": "1",
        "explanation": "The longest substring without repeating characters is 'b', with a length of 1."
      },
      {
        "input": "s = 'pwwkew'",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'wke', with a length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window technique to keep track of indices.",
      "A hashmap can help store the last seen index of each character."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Minimum Adjacent Swaps for K Consecutive Ones",
    "description": "You are given a binary array `nums`. Your task is to determine the minimum number of adjacent swaps required to move all `1`s in the array to form a contiguous subarray of length `k`. If it is not possible to form such a subarray, return -1.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Sliding Window"
    ],
    "input_format": "A binary array `nums` and an integer `k` representing the length of the desired contiguous subarray of 1s.",
    "output_format": "An integer representing the minimum number of adjacent swaps needed, or -1 if not possible.",
    "constraints": [
      "1 <= nums.length <= 100,000",
      "0 <= k <= nums.length",
      "nums[i] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "nums = [0, 1, 0, 1, 0, 1], k = 2",
        "output": "1",
        "explanation": "We can swap the second 1 with the first 0 to get [1, 1, 0, 0, 0, 1]."
      },
      {
        "input": "nums = [1, 0, 0, 1, 0, 1], k = 3",
        "output": "-1",
        "explanation": "It is impossible to form a contiguous subarray of three 1s."
      },
      {
        "input": "nums = [1, 1, 0, 0, 1, 1], k = 4",
        "output": "2",
        "explanation": "We can swap the second 0 with the second 1 and then the first 0 with the last 1 to get [1, 1, 1, 1, 0, 0]."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the positions of all the 1s in the array.",
      "Use a greedy approach to count the minimum number of swaps needed.",
      "Think about a sliding window to find the best placement for K ones."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Cherry Pickup II",
    "description": "You are given a grid of size m x n representing a cherry orchard where each cell contains either a cherry '1' or an empty cell '0'. The goal is to collect the maximum number of cherries while moving from the top row to the bottom row, picking up cherries from two separate routes that start from the first row. You can move downwards or diagonally down to the left or right. Each person can start from any cell in the top row and must make it to their respective bottom cell. The paths must remain within the bounds of the grid, and no cell may be visited more than once. You need to return the maximum number of cherries that can be collected by the two people combined.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Depth-First Search",
      "Backtracking"
    ],
    "input_format": "An integer array grid representing the m x n grid.",
    "output_format": "An integer representing the maximum number of cherries that can be collected.",
    "constraints": [
      "1 <= m, n <= 50",
      "grid[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "grid = [[0,1,0],[1,1,1],[0,1,0]]",
        "output": "5",
        "explanation": "Both persons can collect all cherries in this grid, resulting in a total of 5."
      },
      {
        "input": "grid = [[1,1,0],[0,0,1],[0,1,1]]",
        "output": "5",
        "explanation": "One route can go (0,0) -> (1,1) -> (2,1) and the other can go (0,1) -> (1,2) -> (2,2) for a total of 5 cherries."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider simulating the paths of both persons and use a dynamic programming approach.",
      "Make sure to track the positions of both persons to avoid double-counting cherries."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Product of Array Except Self",
    "description": "Given an integer array nums of length n, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].",
    "topic": "Array",
    "subtopic": "Product Calculation",
    "tags": [
      "Array",
      "Product",
      "Prefix-Suffix"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An array of integers representing the product of all elements except the current one.",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-30 <= nums[i] <= 30",
      "The problem can be solved in O(n) time without using division."
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "[24, 12, 8, 6]",
        "explanation": "The product of all elements except nums[0] (1) is 2*3*4=24, and so on for the other indices."
      },
      {
        "input": "nums = [-1, 1, 0, -3, 3]",
        "output": "[0, 0, 9, 0, 0]",
        "explanation": "The product of all elements except nums[2] (0) is -1*1*(-3)*3=9."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using two arrays to store prefix and suffix products.",
      "Try to do it in one pass to save space."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Create Maximum Number",
    "description": "Given two arrays of integers, nums1 and nums2, return the maximum number that can be formed by taking exactly k elements from these arrays in total. The resulting number should be in the form of a string, without leading zeros. You can take elements from nums1 and nums2 in any order, but you have to respect the amount k. If it is impossible to create such a number, return an empty string.",
    "topic": "Greedy",
    "subtopic": "Combinatorial Optimization",
    "tags": [
      "Greedy",
      "String",
      "Array"
    ],
    "input_format": "Two integer arrays nums1 and nums2, and an integer k.",
    "output_format": "A string representing the maximum number that can be formed.",
    "constraints": [
      "1 <= nums1.length, nums2.length <= 100",
      "1 <= k <= nums1.length + nums2.length",
      "0 <= nums1[i], nums2[i] <= 9"
    ],
    "examples": [
      {
        "input": "nums1 = [3, 4, 6, 5], nums2 = [9, 1, 2, 5, 8, 3], k = 5",
        "output": "97543",
        "explanation": "Taking 3 from nums1 and the largest 4 from nums2 gives us 97543."
      },
      {
        "input": "nums1 = [2, 5, 6], nums2 = [3, 8, 3], k = 3",
        "output": "833",
        "explanation": "Choosing 8 and the two 3s from both arrays gives us 833."
      },
      {
        "input": "nums1 = [4, 1, 2], nums2 = [1, 2, 3], k = 4",
        "output": "4312",
        "explanation": "Taking all elements from nums1 and nums2 gives us 4312."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to choose the best elements from both arrays.",
      "Think about a way to merge two lists while maintaining order.",
      "Use a stack-based greedy approach to build the maximum number."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers and a target integer, return the indices of the two numbers such that they add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An array of integers `nums` and an integer `target`.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash table to store the indices of the numbers.",
      "Check if the complement (target - current number) exists in the hash table."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Gas Station",
    "description": "There are `N` gas stations along a circular route, where the amount of gas at each station is given in an array `gas` and the cost to travel to the next station is given in an array `cost`. You need to determine if there is a gas station you can start from, such that you can travel around the circuit once without running out of gas. Return the starting gas station's index if it is possible, otherwise return -1.",
    "topic": "Greedy",
    "subtopic": "Circuit Problem",
    "tags": [
      "Greedy",
      "Array",
      "Simulation"
    ],
    "input_format": "Two arrays, `gas` and `cost`, each containing `N` integers.",
    "output_format": "An integer representing the index of the starting gas station or -1 if it is not possible.",
    "constraints": [
      "N == gas.length == cost.length",
      "1 <= N <= 10^5",
      "0 <= gas[i], cost[i] <= 10^4"
    ],
    "examples": [
      {
        "input": {
          "gas": [
            1,
            2,
            3,
            4,
            5
          ],
          "cost": [
            3,
            4,
            5,
            1,
            2
          ]
        },
        "output": "3",
        "explanation": "Starting at index 3 will allow you to complete the circuit: 5 - 1 + 4 - 2 + 3 - 3 + 2 - 4 + 1 - 5 = 0."
      },
      {
        "input": {
          "gas": [
            2,
            3,
            4
          ],
          "cost": [
            3,
            4,
            3
          ]
        },
        "output": "-1",
        "explanation": "Not enough gas to complete the circuit starting from any station."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "If you can't reach the next station from a start station, you need to start from the next station.",
      "Keep track of the total gas and total cost during the traversal."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Decode Ways",
    "description": "A message containing letters from 'A' to 'Z' can be encoded into numbers using the following mapping: 'A' -> '1', 'B' -> '2', ..., 'Z' -> '26'. Given a string s consisting of digits, return the total number of ways to decode it. A decoding is considered valid if the number can be divided into parts where each part corresponds to a valid character according to the above mapping.",
    "topic": "Dynamic Programming",
    "subtopic": "String Decoding",
    "tags": [
      "Dynamic Programming",
      "String",
      "Recursion"
    ],
    "input_format": "A string s, where 1 <= s.length <= 100 and s consists of digits only.",
    "output_format": "An integer representing the total number of ways to decode the string.",
    "constraints": [
      "s is a non-empty string.",
      "s does not contain any leading zeros."
    ],
    "examples": [
      {
        "input": "s = '12'",
        "output": "2",
        "explanation": "'12' can be decoded as 'AB' (1 2) or 'L' (12), hence there are 2 ways."
      },
      {
        "input": "s = '226'",
        "output": "3",
        "explanation": "'226' can be decoded as 'BZF' (2 26), 'BBF' (2 2 6) or 'VF' (22 6), hence there are 3 ways."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to break down the string into valid substrings.",
      "Use dynamic programming to build solutions from smaller subproblems."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Graph",
    "subtopic": "DFS/BFS",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Union Find"
    ],
    "input_format": "A 2D grid represented as an array of strings where '1' represents land and '0' represents water.",
    "output_format": "An integer indicating the number of islands in the grid.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "grid = [['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]",
        "output": "1",
        "explanation": "There is one island that occupies the entire left section of the grid."
      },
      {
        "input": "grid = [['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]",
        "output": "3",
        "explanation": "There are three islands: one in the top left, one at (2,2), and one at (3,3)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using depth-first search (DFS) or breadth-first search (BFS) to explore the islands.",
      "You can mark visited cells by changing '1' to '0' as you search."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Course Schedule",
    "description": "You are given an integer numCourses representing the total number of courses you have to take, labeled from 0 to numCourses - 1. There are prerequisites for some courses, represented as a pair of integers [a, b] meaning you must take course b before course a. You need to determine if you can finish all courses. Return true if you can, otherwise return false.",
    "topic": "Graph",
    "subtopic": "Topological Sorting",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Topological Sort"
    ],
    "input_format": "An integer numCourses followed by a list of prerequisites, where each prerequisite is a pair [a, b].",
    "output_format": "A boolean indicating whether it is possible to finish all courses.",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= prerequisites[i][0], prerequisites[i][1] < numCourses"
    ],
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = [[1, 0]]",
        "output": "true",
        "explanation": "You can take course 0 first, then take course 1."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1, 0], [0, 1]]",
        "output": "false",
        "explanation": "There is a cycle between course 0 and course 1. Thus, you cannot complete all courses."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using depth-first search (DFS) or breadth-first search (BFS) to detect cycles.",
      "Track in-degrees of all courses, this may help in topological sorting."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Rotting Oranges",
    "description": "You are given an m x n grid where each cell can have one of three values: 0 representing an empty cell, 1 representing a fresh orange, and 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no fresh oranges remain. If this is impossible, return -1.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "Simulation"
    ],
    "input_format": "A 2D array grid representing the orange grid.",
    "output_format": "An integer representing the minimum number of minutes until no fresh oranges remain, or -1 if impossible.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 300",
      "grid[i][j] is 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
        "output": "4",
        "explanation": "It takes 4 minutes for all the fresh oranges to rot."
      },
      {
        "input": "grid = [[2,1,1],[0,1,1],[1,0,2]]",
        "output": "-1",
        "explanation": "Fresh oranges on the bottom row will never rot."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using BFS for this problem.",
      "Keep track of the number of fresh oranges and rotten oranges."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Maximum Profit in Job Scheduling",
    "description": "You are given a list of jobs where each job has a start time, end time, and profit associated with it. The goal is to find the maximum profit you can earn by scheduling jobs such that no two jobs overlap. You need to select jobs such that their end time does not overlap with the start time of another job, and you can choose jobs that contribute to the maximum profit possible.",
    "topic": "Dynamic Programming",
    "subtopic": "Job Scheduling",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Interval Scheduling"
    ],
    "input_format": "An array of jobs, where each job is represented as a tuple (start_time, end_time, profit).",
    "output_format": "An integer representing the maximum profit obtainable by scheduling jobs.",
    "constraints": [
      "1 <= jobs.length <= 1000",
      "0 <= start_time < end_time <= 10^9",
      "0 <= profit <= 10^4"
    ],
    "examples": [
      {
        "input": "jobs = [(1, 3, 50), (2, 5, 20), (3, 10, 100), (6, 19, 70), (7, 8, 30)]",
        "output": "150",
        "explanation": "The optimal jobs to schedule are jobs with profits 50 (1, 3), and 100 (3, 10), giving total profit of 150."
      },
      {
        "input": "jobs = [(1, 2, 10), (1, 3, 20), (2, 5, 15)]",
        "output": "25",
        "explanation": "The optimal jobs to schedule are jobs (1, 2, 10) and (2, 5, 15), yielding a total profit of 25."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Sort the jobs by their end times.",
      "Use binary search to find the last non-conflicting job.",
      "Consider using dynamic programming to store the maximum profit at each job."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Maximum Width of Binary Tree",
    "description": "Given the root of a binary tree, return its maximum width. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the leftmost and rightmost non-null nodes in that level. It is possible that some nodes of the tree may be null, but they should not affect the width calculation. Width is defined as the number of nodes in the longest level of the tree.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Width"
    ],
    "input_format": "A binary tree represented by its root node.",
    "output_format": "An integer representing the maximum width of the binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1,3,2,5,3,null,9]",
        "output": "4",
        "explanation": "The maximum width is between the nodes with values 5 and 9 in the last level."
      },
      {
        "input": "root = [1, 3, null, 5, 4]",
        "output": "2",
        "explanation": "The maximum width is between the nodes with values 5 and null in the last level."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use level order traversal to find widths at each level.",
      "Keep track of the indices of nodes when traversing."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (min(m,n))). You may assume nums1 and nums2 cannot be both empty.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Sorting",
      "Median"
    ],
    "input_format": "Two sorted arrays nums1 and nums2.",
    "output_format": "A single number representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= nums1.length <= 1000",
      "0 <= nums2.length <= 1000",
      "1 <= nums1[i], nums2[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.0",
        "explanation": "The combined sorted array is [1, 2, 3], and the median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.5",
        "explanation": "The combined sorted array is [1, 2, 3, 4], and the median is (2 + 3) / 2 = 2.5."
      },
      {
        "input": "nums1 = [], nums2 = [1]",
        "output": "1.0",
        "explanation": "The only element is 1, thus the median is 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a binary search on the smaller array.",
      "The median is the middle value; how would you partition the arrays to find it?"
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Subarray Sum Equals K",
    "description": "Given an integer array nums and an integer k, return the total number of continuous subarrays whose sum equals to k.",
    "topic": "Array",
    "subtopic": "Subarray",
    "tags": [
      "Array",
      "Prefix Sum",
      "HashMap"
    ],
    "input_format": "An integer array nums and an integer k.",
    "output_format": "An integer representing the total number of continuous subarrays whose sum equals to k.",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-1000 <= nums[i] <= 1000",
      "-10^7 <= k <= 10^7"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 1], k = 2",
        "output": "2",
        "explanation": "The subarrays [1, 1] (from index 0 to 1) and [1, 1] (from index 1 to 2) both sum to 2."
      },
      {
        "input": "nums = [1, 2, 3], k = 3",
        "output": "2",
        "explanation": "The subarrays [3] (from index 2 to 2) and [1, 2] (from index 0 to 1) both sum to 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hashmap to store the cumulative sums.",
      "Keep track of how many times each sum has been seen."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array nums, find the smallest missing positive integer.",
    "topic": "Array",
    "subtopic": "Manipulation",
    "tags": [
      "Array",
      "Searching",
      "Math"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the smallest missing positive integer.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3, 4, -1, 1]",
        "output": "2",
        "explanation": "The numbers present are 1, 3, and 4. The smallest missing positive is 2."
      },
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "The numbers present are 1 and 2. The smallest missing positive is 3."
      },
      {
        "input": "nums = [7, 8, 9, 11, 12]",
        "output": "1",
        "explanation": "No positive integers less than 7 are present, hence 1 is the smallest missing positive."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use index mapping to place each number in its correct position.",
      "Only consider numbers in the range of 1 to n, where n is the length of the array."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Sort Colors",
    "description": "Given an array nums consisting of 0s, 1s, and 2s, sort the array in-place so that all 0s come first, followed by all 1s, and finally all 2s. You must solve this problem without using the library's sort function and with a linear runtime complexity.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "In-place",
      "Two Pointers"
    ],
    "input_format": "An array nums consisting of n integers where each integer is 0, 1, or 2.",
    "output_format": "The same array nums, sorted in-place.",
    "constraints": [
      "1 <= nums.length <= 300",
      "nums[i] is either 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "nums = [2, 0, 2, 1, 1, 0]",
        "output": "[0, 0, 1, 1, 2, 2]",
        "explanation": "After sorting, the array contains all 0s first, followed by all 1s, and all 2s."
      },
      {
        "input": "nums = [2, 0, 1]",
        "output": "[0, 1, 2]",
        "explanation": "The array contains one of each number, and the sorted order is achieved."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a two-pointer approach.",
      "Start categorizing elements by traversing the array just once."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Edit Distance",
    "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You can perform three types of operations: insert a character, delete a character, or replace a character.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Edit Distance"
    ],
    "input_format": "Two strings word1 and word2, each with lengths up to 100.",
    "output_format": "An integer representing the minimum number of operations required to convert word1 to word2.",
    "constraints": [
      "0 <= word1.length, word2.length <= 100",
      "word1 and word2 consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "word1 = 'horse', word2 = 'ros'",
        "output": "3",
        "explanation": "One way to transform 'horse' into 'ros' is: 'horse' -> 'rorse' (replace 'h' with 'r'), 'rorse' -> 'rose' (delete 'r'), and 'rose' -> 'ros' (delete 'e')."
      },
      {
        "input": "word1 = 'intention', word2 = 'execution'",
        "output": "5",
        "explanation": "One way to transform 'intention' into 'execution' is: 'intention' -> 'exintention' (replace 'i' with 'e'), 'exintention' -> 'exectention' (replace 'n' with 'c'), 'exectention' -> 'execution' (delete 't'), and then two other transformations."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a 2D array to store the edit distances.",
      "Look for overlapping subproblems that can be solved using dynamic programming."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Partition Equal Subset Sum",
    "description": "Given a non-empty array of positive integers, you are to determine if the array can be partitioned into two subsets such that the sum of the elements in both subsets is equal. For example, given the array [1, 5, 11, 5], it can be partitioned into subsets [1, 5, 5] and [11] with equal sum of 11. Return true if such a partition is possible, otherwise return false.",
    "topic": "Dynamic Programming",
    "subtopic": "Subset Sum Problem",
    "tags": [
      "Dynamic Programming",
      "Backtracking",
      "Subset Sum"
    ],
    "input_format": "An array of positive integers nums.",
    "output_format": "A boolean value indicating whether the array can be partitioned into two subsets with equal sum.",
    "constraints": [
      "1 <= nums.length <= 200",
      "0 < nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 5, 11, 5]",
        "output": "true",
        "explanation": "The array can be partitioned into subsets [1, 5, 5] and [11] which both sum to 11."
      },
      {
        "input": "nums = [1, 2, 3, 5]",
        "output": "false",
        "explanation": "There is no way to partition the array into two subsets with equal sum."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to solve this problem.",
      "Calculate the total sum and find if it's even.",
      "Try to find if a subset with sum equal to half of the total exists."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Dungeon Game",
    "description": "The Princess is trapped in a dungeon and needs help to escape. You are given a 2D grid representing the dungeon, where each cell can either have a negative value indicating a monster that reduces the player's health or a positive value representing a health potion that increases the player's health. The player starts from the top-left corner of the grid and needs to reach the bottom-right corner. The player can only move right or down. The goal is to find the minimum initial health required so that the player can reach the princess without dying. The player's health cannot drop to zero or below at any point. Note that the health can go above initial health due to health potions.",
    "topic": "Dynamic Programming",
    "subtopic": "2D DP",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Game"
    ],
    "input_format": "A 2D grid of integers representing the dungeon.",
    "output_format": "An integer representing the minimum initial health required.",
    "constraints": [
      "1 <= dungeon.length, dungeon[i].length <= 200",
      "-1000 <= dungeon[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "[[-2,-3,3],[-5,-10,1],[10,30,-5]]",
        "output": "7",
        "explanation": "The minimum health required to reach the bottom-right corner from the top-left corner while avoiding death is 7."
      },
      {
        "input": "[[0]]",
        "output": "1",
        "explanation": "Although the dungeon has no monsters or health potions, the player needs at least 1 health to survive."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider working backward from the princess to determine the required health."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Cut Off Trees for Golf Event",
    "description": "You are given a 2D grid representing a map where each element is a non-negative integer representing the height of the tree at that position. You are tasked with cutting down the trees in the order of their heights (from shortest to tallest). The cost of cutting a tree is determined by the Manhattan distance you need to travel to reach the tree from your current position. Starting from the top-left corner of the grid, can you determine the minimum cost to cut down all the trees except the ones with a height of 0? The grid is guaranteed to have at least one tree to cut down.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "Graph",
      "BFS",
      "Tree",
      "Dynamic Programming"
    ],
    "input_format": "A 2D grid of integers.",
    "output_format": "An integer representing the minimum cost to cut down the trees in the required order.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 100",
      "0 <= grid[i][j] <= 10^9"
    ],
    "examples": [
      {
        "input": "[[1,2,3],[0,0,4],[7,6,5]]",
        "output": "16",
        "explanation": "The optimal path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (2,1) -> (2,0) which costs 16."
      },
      {
        "input": "[[2,3,4],[0,0,5],[8,7,6]]",
        "output": "18",
        "explanation": "The optimal path involves cutting down trees in the order 4, 5, 6, 7, 8, resulting in a total cost of 18."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a priority queue to help manage trees by height.",
      "Track your current position and calculate Manhattan distance efficiently."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Burst Balloons",
    "description": "Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons. If you burst the ith balloon, you will get nums[i] coins. If the i-th balloon is burst, you will earn nums[left] * nums[i] * nums[right] coins if the left and right balloons exist. After bursting a balloon, the left and right neighbors become adjacent. Your goal is to maximize the total coins you can collect by bursting the balloons wisely. Return the maximum coins you can collect after bursting all the balloons.",
    "topic": "Dynamic Programming",
    "subtopic": "Maximization Problems",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Maximization"
    ],
    "input_format": "An array of integers nums representing the balloons.",
    "output_format": "An integer representing the maximum coins that can be collected.",
    "constraints": [
      "1 <= nums.length <= 300",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [3, 1, 5, 8]",
        "output": "167",
        "explanation": "Bursting balloons in the order of 1, 5, 3, 8 gives the maximum coins: 1 * 3 * 5 + 1 * 5 * 8 + 5 * 3 * 8 = 167."
      },
      {
        "input": "nums = [1, 5]",
        "output": "10",
        "explanation": "Bursting the 1 then the 5 gives 1 * 1 * 5 = 5 and then 5 * 1 * 1 = 5, total 10."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a dynamic programming approach to solve the problem.",
      "Think about the order in which to burst the balloons."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Binary Tree Zigzag Level Order Traversal",
    "description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "BFS",
      "Zigzag"
    ],
    "input_format": "The input consists of a binary tree represented by its root node.",
    "output_format": "A list of lists, where each list contains the values of the nodes at that level in zigzag order.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[20,9],[15,7]]",
        "explanation": "The first level is [3]. The second level is [9, 20]. The third level is [15, 7]."
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": "There is only one node."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "The tree is empty."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to aid in level order traversal.",
      "Switch the orientation of adding nodes to the results between levels.",
      "Consider using a stack for the right-to-left level."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Merge Two Sorted Lists",
    "description": "You are given the heads of two sorted linked lists, list1 and list2. Merge the two lists in a single sorted list and return the head of the merged list. The merged list should be made by splicing together the nodes of the first two lists.",
    "topic": "Linked List",
    "subtopic": "Merging Linked Lists",
    "tags": [
      "Linked List",
      "Merging",
      "Sorting"
    ],
    "input_format": "The input consists of two linked list nodes, list1 and list2, representing the heads of the two sorted linked lists.",
    "output_format": "Return the head of the new merged linked list.",
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50]",
      "-100 <= Node.val <= 100",
      "Both list1 and list2 are sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "list1 = [1, 2, 4], list2 = [1, 3, 4]",
        "output": "[1, 1, 2, 3, 4, 4]",
        "explanation": "Merging the two sorted lists results in a single sorted list with elements: 1, 1, 2, 3, 4, 4."
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]",
        "explanation": "Since one of the lists is empty, the merged list contains only the elements from the non-empty list."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a dummy node to simplify the merging process.",
      "Iterate through both lists, comparing their values and attaching the smaller one to the merged list."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Find K-th Smallest Pair Distance",
    "description": "Given an integer array nums and an integer k, return the k-th smallest distance among all pairs (i, j) where 0 <= i < j < nums.length. The distance between a pair is defined as |nums[i] - nums[j]|. Note that for a pair (i, j), the order matters. It is possible that the value of k can be greater than the number of unique distances.",
    "topic": "Binary Search",
    "subtopic": "Sorting and Searching",
    "tags": [
      "Binary Search",
      "Array",
      "Sorting"
    ],
    "input_format": "An integer array nums and an integer k.",
    "output_format": "An integer representing the k-th smallest distance among all pairs.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^6",
      "1 <= k <= n*(n-1)/2"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 1], k = 1",
        "output": "0",
        "explanation": "The distances are [0, 2, 2]. The smallest distance is 0."
      },
      {
        "input": "nums = [1, 2, 3, 4], k = 2",
        "output": "1",
        "explanation": "The distances are [1, 1, 1, 2, 2, 3]. The second smallest distance is 1."
      },
      {
        "input": "nums = [1, 6, 1], k = 3",
        "output": "5",
        "explanation": "The distances are [0, 5, 5]. The third smallest distance is 5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Sort the array first to simplify distance calculations.",
      "Use binary search on the distance value to find the k-th smallest."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Candy",
    "description": "Alice is distributing candies to her friends. Each friend has a rating score associated with them, and she wants to give candies to her friends based on their ratings. Each friend must receive at least one candy. However, friends with a higher rating than their neighbors must receive more candies than those neighbors. Your task is to determine the minimum number of candies Alice must give to her friends.",
    "topic": "Greedy",
    "subtopic": "Array",
    "tags": [
      "Greedy",
      "Array",
      "Dynamic Programming"
    ],
    "input_format": "An integer array ratings where ratings[i] is the rating of the ith friend.",
    "output_format": "An integer representing the minimum number of candies required.",
    "constraints": [
      "1 <= ratings.length <= 2 * 10^4",
      "0 <= ratings[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "[1, 0, 2]",
        "output": "5",
        "explanation": "The ratings are [1, 0, 2]. We give candies as follows: Friend 1 gets 2, Friend 2 gets 1, and Friend 3 gets 2. Total = 2 + 1 + 2 = 5."
      },
      {
        "input": "[1, 2, 2]",
        "output": "4",
        "explanation": "The ratings are [1, 2, 2]. We give candies as follows: Friend 1 gets 1, Friend 2 gets 2, and Friend 3 gets 1. Total = 1 + 2 + 1 = 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Start from both ends of the array to allocate candies based on ratings.",
      "Use a two-pass approach to ensure conditions are satisfied."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Next Greater Element I",
    "description": "Given an array of integers nums and a given integer target, find the next greater element of target in nums. If it does not exist, return -1. You must solve it in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Stack"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An integer representing the next greater element of target, or -1 if it does not exist.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [4, 1, 2], target = 1",
        "output": "2",
        "explanation": "The next greater element for target (1) in the array is 2."
      },
      {
        "input": "nums = [2, 4], target = 2",
        "output": "4",
        "explanation": "The next greater element for target (2) in the array is 4."
      },
      {
        "input": "nums = [1, 2, 1], target = 3",
        "output": "-1",
        "explanation": "There is no greater element for target (3) in the array."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of the elements.",
      "Iterate through the array to find the desired target."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Maximum Performance of a Team",
    "description": "You are given two arrays: 'speed' and 'efficiency' where speed[i] is the speed of the i-th engineer and efficiency[i] is the efficiency of the i-th engineer. You need to form a team of engineers such that the team's performance is defined as the sum of the speeds of the engineers in the team multiplied by the minimum efficiency of those engineers. Your goal is to maximize this performance by selecting at most k engineers, where k is a given integer.",
    "topic": "Greedy",
    "subtopic": "Sorting",
    "tags": [
      "Greedy",
      "Sorting",
      "Array"
    ],
    "input_format": "Two arrays of integers 'speed' and 'efficiency', and an integer k.",
    "output_format": "An integer representing the maximum performance of the team.",
    "constraints": [
      "1 <= speed.length, efficiency.length <= 10^5",
      "1 <= speed[i], efficiency[i] <= 10^8",
      "1 <= k <= speed.length"
    ],
    "examples": [
      {
        "input": {
          "speed": [
            2,
            10,
            3
          ],
          "efficiency": [
            5,
            4,
            3
          ],
          "k": 2
        },
        "output": "60",
        "explanation": "Choosing engineers with speeds 10 and 3 gives a total speed of 13 and minimum efficiency of 4. Thus, performance = 13 * 4 = 52."
      },
      {
        "input": {
          "speed": [
            1,
            2,
            3,
            4,
            5
          ],
          "efficiency": [
            5,
            6,
            7,
            8,
            9
          ],
          "k": 3
        },
        "output": "72",
        "explanation": "Choosing engineers with speeds 3, 4, and 5 gives a total speed of 12 and minimum efficiency of 7. Thus, performance = 12 * 6 = 72."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Sort engineers based on their efficiency in descending order.",
      "Use a min-heap to keep track of the speeds of the selected engineers.",
      "Calculate performance iteratively and keep track of the maximum found."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Rank Teams by Votes",
    "description": "You are given a list of teams and their corresponding scores from votes. Each vote can affect multiple teams, and your task is to rank the teams based on their total votes in descending order. If two teams have the same score, they should be ranked alphabetically. Return the ranked list of teams.",
    "topic": "Sorting",
    "subtopic": "Rankings",
    "tags": [
      "Sorting",
      "Ranking",
      "Strings"
    ],
    "input_format": "A list of strings where each string represents a team's name, followed by their scores as integer values.",
    "output_format": "A list of team names sorted by their scores in descending order. If teams have the same score, they should be sorted alphabetically.",
    "constraints": [
      "1 <= teams.length <= 1000",
      "1 <= teams[i].length <= 100",
      "scores[i] >= 0"
    ],
    "examples": [
      {
        "input": "teams = [['TeamA', 5], ['TeamB', 3], ['TeamC', 5]]",
        "output": "['TeamA', 'TeamC', 'TeamB']",
        "explanation": "TeamA and TeamC have the same highest score of 5, but TeamA comes first alphabetically."
      },
      {
        "input": "teams = [['TeamZ', 1], ['TeamY', 2], ['TeamX', 2]]",
        "output": "['TeamY', 'TeamX', 'TeamZ']",
        "explanation": "TeamY has the highest score of 2 and ranks first, TeamX also has a score of 2 but comes second alphabetically, followed by TeamZ."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sorting algorithm that can handle comparisons on multiple keys."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Open the Lock",
    "description": "You have a lock that opens with a four-digit code. Each digit can be from 0 to 9. The lock can be moved either up or down to change the digits. For example, turning '9' up will give '0' and turning '0' down will give '9'. Your goal is to find the minimum number of turns required to unlock the lock from a given start code to a target code, with some dead ends where certain codes cannot be accessed.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "Graph",
      "Breadth-First Search",
      "Queue"
    ],
    "input_format": "A string representing the start code, a string representing the target code, and an array of strings representing the deadlocked codes.",
    "output_format": "An integer representing the minimum number of turns required to unlock the lock. Return -1 if it is impossible to reach the target code.",
    "constraints": [
      "start.length == 4",
      "target.length == 4",
      "deadends[i].length == 4",
      "start and target are not in deadends",
      "0 <= deadends.length <= 500"
    ],
    "examples": [
      {
        "input": {
          "start": "0000",
          "target": "8888",
          "deadends": [
            "0001",
            "0002",
            "0003"
          ]
        },
        "output": "6",
        "explanation": "The sequence of turns would be 0000 -> 0001 -> 0002 -> 0003 -> 1003 -> 8003 -> 8883 -> 8888."
      },
      {
        "input": {
          "start": "0000",
          "target": "0001",
          "deadends": []
        },
        "output": "1",
        "explanation": "Only one turn is needed to go from 0000 to 0001."
      },
      {
        "input": {
          "start": "0000",
          "target": "8888",
          "deadends": [
            "8888"
          ]
        },
        "output": "-1",
        "explanation": "Since 8888 is a deadend, it is impossible to reach the target."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a breadth-first search approach.",
      "Think about how each of the digits can be modified."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "You are given a rotated sorted array `nums` and a target value `target`. Your task is to search for the target in the array. If the target exists, return its index. Otherwise, return -1. You must write an algorithm with a time complexity of O(log n).",
    "topic": "Binary Search",
    "subtopic": "Searching in Rotated Arrays",
    "tags": [
      "Binary Search",
      "Array",
      "Searching"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An integer representing the index of the target if found, otherwise return -1.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "\u221210^4 <= nums[i] <= 10^4",
      "All elements in nums are unique."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "The target 0 is located at index 4 in the rotated sorted array."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "The target 3 does not exist in the array, so we return -1."
      },
      {
        "input": "nums = [1], target = 0",
        "output": "-1",
        "explanation": "The array has only one element (1) and the target (0) is not in the array, so we return -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of a rotated array.",
      "Use binary search and carefully determine which side of the array is sorted."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Cherry Pickup",
    "description": "In a grid of size n x n, where each cell contains either a cherry or is empty, you start at the top-left corner and want to collect as many cherries as possible by moving to the bottom-right corner. You can only move towards the right or down at each step. Additionally, if you collect cherries from a cell, they will disappear for another path. Your goal is to find the maximum number of cherries you can collect. If two paths produce the same number of cherries, you should only count them once.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Backtracking"
    ],
    "input_format": "A 2D grid of integers representing the number of cherries in each cell.",
    "output_format": "An integer representing the maximum number of cherries that can be collected.",
    "constraints": [
      "1 <= n <= 50",
      "0 <= grid[i][j] <= 100"
    ],
    "examples": [
      {
        "input": "grid = [[0, 1, 1], [1, 0, 0], [1, 1, 0]]",
        "output": "3",
        "explanation": "The optimal path is to collect cherries from (0,1), (1,0), and (2,0) for a total of 3 cherries."
      },
      {
        "input": "grid = [[1, 1, 1], [0, 1, 0], [1, 1, 1]]",
        "output": "5",
        "explanation": "Collect cherries from (0,0), (0,1), (1,1), (2,1), and (2,0) for a total of 5 cherries."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider dynamic programming to avoid recalculating paths.",
      "Think about how to decompose the grid into smaller sub-problems.",
      "Try to maximize the number of cherries collected at each step."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. For example, if the input is '[[1,3],[2,6],[8,10],[15,18]]', the result should be '[[1,6],[8,10],[15,18]]' because the first two intervals overlap and are merged into one.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Interval",
      "Sorting"
    ],
    "input_format": "A list of intervals, where each interval is represented by a pair of integers [start, end].",
    "output_format": "A list of merged intervals.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "[[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "The first two intervals [1,3] and [2,6] overlap, so they are merged into [1,6]. The intervals [8,10] and [15,18] do not overlap."
      },
      {
        "input": "[[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "The intervals [1,4] and [4,5] overlap and are merged into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on their starting times.",
      "Use a loop to check for overlaps between intervals."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Number of Students Unable to Eat Lunch",
    "description": "You are given two arrays: 'students' and 'sandwiches'. The 'students' array represents the preferences of the students, where 0 indicates a student prefers a cheese sandwich and 1 indicates they prefer a jelly sandwich. The 'sandwiches' array contains the sandwiches stacked in order: 0 for cheese and 1 for jelly. Each student can take only the top sandwich from the stack. If the sandwich doesn't match their preference, the student will leave the queue. Your task is to determine how many students will be unable to eat their lunch after all the sandwiches have been served.",
    "topic": "Greedy",
    "subtopic": "Queue",
    "tags": [
      "Greedy",
      "Queue",
      "Simulation"
    ],
    "input_format": "Two integer arrays 'students' and 'sandwiches'.",
    "output_format": "An integer representing the number of students who are unable to eat lunch.",
    "constraints": [
      "1 <= students.length <= 100",
      "1 <= sandwiches.length <= 100",
      "students.length == sandwiches.length"
    ],
    "examples": [
      {
        "input": "students = [1, 1, 0, 0], sandwiches = [0, 1, 0, 1]",
        "output": "0",
        "explanation": "All students can eat their preferred sandwich."
      },
      {
        "input": "students = [1, 0, 1], sandwiches = [0, 1, 0]",
        "output": "1",
        "explanation": "Only one student preferences can match as they both leave when the sandwich isn't theirs."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Count the number of students preferring cheese and jelly.",
      "Serve sandwiches from the top of the stack one at a time."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "House Robber",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. However, adjacent houses have security systems connected, and if two adjacent houses are broken into on the same night, the security system will automatically alert the police. Given an integer array `money` representing the amount of money at each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "topic": "Dynamic Programming",
    "subtopic": "Memoization",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An integer array `money`, where `1 <= money.length <= 100`, and `0 <= money[i] <= 400.",
    "output_format": "An integer representing the maximum amount of money that can be robbed without alerting the police.",
    "constraints": [
      "1 <= money.length <= 100",
      "0 <= money[i] <= 400"
    ],
    "examples": [
      {
        "input": "money = [2, 7, 9, 3, 1]",
        "output": "12",
        "explanation": "Robbing house 1 (2) and 3 (9) and 5 (1) gives a total of 2 + 9 + 1 = 12."
      },
      {
        "input": "money = [1, 2, 3, 1]",
        "output": "4",
        "explanation": "Robbing house 1 (1) and house 3 (3) gives a total of 1 + 3 = 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to keep track of the maximum amount of money obtainable up to each house.",
      "If you rob a house, you cannot rob the previous house."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Reconstruct Itinerary",
    "description": "You are given a list of airline tickets represented by pairs of departure and arrival airports. Each ticket is represented as a two-element list [from, to]. You need to reconstruct the itinerary in order such that you use all the tickets exactly once. The itinerary must begin at 'JFK'. If multiple valid itineraries exist, you should return the one that is the smallest in lexical order.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "Backtracking"
    ],
    "input_format": "A list of lists representing tickets, where each inner list contains two strings [from, to].",
    "output_format": "A list of strings representing the reconstructed itinerary in the correct order.",
    "constraints": [
      "1 <= tickets.length <= 300",
      "All strings in tickets are non-empty and consist of uppercase English letters only.",
      "The input will always contain a valid itinerary."
    ],
    "examples": [
      {
        "input": "[['MUC', 'LHR'], ['JFK', 'MUC'], ['SFO', 'SJC'], ['LHR', 'SFO'], ['JFK', 'ATL'], ['ATL', 'JFK']]",
        "output": "['JFK', 'ATL', 'JFK', 'MUC', 'LHR', 'SFO', 'SJC']",
        "explanation": "The itinerary starting from JFK is JFK -> ATL -> JFK -> MUC -> LHR -> SFO -> SJC."
      },
      {
        "input": "[['JFK', 'SFO'], ['JFK', 'ATL'], ['SFO', 'JFK'], ['ATL', 'JFK']]",
        "output": "['JFK', 'ATL', 'JFK', 'SFO', 'JFK']",
        "explanation": "There are multiple valid itineraries, but 'JFK', 'ATL', 'JFK', 'SFO', 'JFK' is lexicographically smaller."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a graph to represent the tickets.",
      "Implement depth-first search (DFS) to construct the itinerary.",
      "Sort the neighbors to ensure lexicographical order."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Find Peak Element",
    "description": "An element in an array is called a peak if it is greater than or equal to its neighbors. Given an integer array nums, you need to find one peak element and return its index. If the array contains multiple peaks, return the index of any of the peaks. You may assume that the first and last elements of the array are not considered as peak elements.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Peak Element"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the index of one peak element.",
    "constraints": [
      "1 <= nums.length <= 1000",
      "\u22122^31 <= nums[i] <= 2^31 \u2212 1"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 20, 4, 1]",
        "output": "2",
        "explanation": "The peak element is 20 at index 2."
      },
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "2",
        "explanation": "The peak element is 3 at index 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a binary search approach to optimize your solution.",
      "If nums[mid] is greater than nums[mid + 1], then the peak lies on the left of mid (including mid).",
      "If nums[mid] is less than nums[mid + 1], then the peak lies on the right of mid."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Path Sum III",
    "description": "You are given a binary tree where each node has an integer value. You need to count the number of paths that sum to a given value. A path is defined as a sequence of nodes such that each adjacent pair of nodes in the path shares the same parent. The path does not need to start or end at the root or a leaf node.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "DFS",
      "Backtracking"
    ],
    "input_format": "The root of the binary tree and an integer targetSum.",
    "output_format": "An integer representing the number of paths that sum to targetSum.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 1000].",
      "-1000 <= Node.val <= 1000",
      "-1000 <= targetSum <= 1000"
    ],
    "examples": [
      {
        "input": "root = [10,5,-3,3,2,null,11], targetSum = 8",
        "output": "3",
        "explanation": "The three paths that sum up to 8 are: 5->3, 2->3, and 10->-3->11."
      },
      {
        "input": "root = [1,-2,-3,1,3,-2,null,-1], targetSum = -1",
        "output": "1",
        "explanation": "There is one path: 1->-2->-1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using depth-first search to explore all paths.",
      "You can use a hashmap to store cumulative sums."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Word Break",
    "description": "Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Backtracking"
    ],
    "input_format": "A string s and a list of strings wordDict.",
    "output_format": "Return true if s can be segmented into one or more dictionary words, otherwise false.",
    "constraints": [
      "1 <= s.length <= 300",
      "1 <= wordDict.length <= 1000",
      "1 <= wordDict[i].length <= 100",
      "s and wordDict[i] consist of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = 'leetcode', wordDict = ['leet', 'code']",
        "output": "true",
        "explanation": "The string 'leetcode' can be segmented as 'leet code'."
      },
      {
        "input": "s = 'applepenapple', wordDict = ['apple', 'pen']",
        "output": "true",
        "explanation": "The string 'applepenapple' can be segmented as 'apple pen apple'."
      },
      {
        "input": "s = 'catsandog', wordDict = ['cats', 'dog', 'sand', 'and', 'cat']",
        "output": "false",
        "explanation": "The string 'catsandog' cannot be segmented into the given dictionary words."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store results of subproblems.",
      "You might need a boolean array to keep track of valid segmentations."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Maximal Rectangle",
    "description": "Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "Matrix",
    "tags": [
      "Dynamic Programming",
      "Matrix",
      "Area"
    ],
    "input_format": "A 2D binary matrix represented as a list of lists.",
    "output_format": "An integer representing the area of the largest rectangle containing only 1's.",
    "constraints": [
      "1 <= matrix.length <= 200",
      "1 <= matrix[i].length <= 200",
      "matrix[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "[['1','0','1','0','0'], ['1','0','1','1','1'], ['1','1','1','1','1'], ['1','0','0','1','0']]",
        "output": "6",
        "explanation": "The maximal rectangle is formed by the 1's in the last two rows and spans 3 columns. Hence, the area is 3 * 2 = 6."
      },
      {
        "input": "[['0','0'], ['0','0']]",
        "output": "0",
        "explanation": "There are no 1's in the matrix, so the area of the largest rectangle is 0."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a histogram approach to track the heights of consecutive 1's.",
      "Apply a stack-based solution to find the largest rectangle in a histogram."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Largest Rectangle in Histogram",
    "description": "Given an array of integers representing the heights of bars in a histogram, find the area of the largest rectangle that can be formed within the histogram. The rectangle can be formed by using one or more contiguous bars.",
    "topic": "Array",
    "subtopic": "Stack",
    "tags": [
      "Array",
      "Stack",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers heights where 1 <= heights.length <= 10^5 and 0 <= heights[i] <= 10^4.",
    "output_format": "An integer representing the area of the largest rectangle that can be formed.",
    "constraints": [
      "1 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [2, 1, 5, 6, 2, 3]",
        "output": "10",
        "explanation": "The largest rectangle has an area of 10 with height 5 and width 2."
      },
      {
        "input": "heights = [2, 4]",
        "output": "4",
        "explanation": "The largest rectangle has an area of 4 with height 2 and width 2."
      },
      {
        "input": "heights = [1, 1, 1, 1, 1]",
        "output": "5",
        "explanation": "The entire histogram can be used as one rectangle with an area of 5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to keep track of the indices of the bars.",
      "For each bar, compute the width of the rectangle with that height and update the maximum area.",
      "Don't forget to handle the bars left in the stack after the histogram is traversed."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Lowest Common Ancestor of a Binary Tree",
    "description": "Given a binary tree, define the lowest common ancestor (LCA) of two nodes p and q as the lowest node that has both p and q as descendants (where we allow a node to be a descendant of itself). Implement a function that returns the LCA of the two given nodes in the binary tree.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Lowest Common Ancestor"
    ],
    "input_format": "The function takes the root of the binary tree and two nodes p and q.",
    "output_format": "Return the node that is the lowest common ancestor of p and q.",
    "constraints": [
      "The number of nodes in the tree is in the range [2, 10^5].",
      "All nodes' values are unique.",
      "p and q are distinct nodes and both values will exist in the tree."
    ],
    "examples": [
      {
        "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1",
        "output": "3",
        "explanation": "The lowest common ancestor of nodes 5 and 1 is 3."
      },
      {
        "input": "root = [1,2,3], p = 2, q = 3",
        "output": "1",
        "explanation": "The lowest common ancestor of nodes 2 and 3 is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of binary trees.",
      "A post-order traversal could help find the LCA."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Copy List with Random Pointer",
    "description": "Given a linked list where each node contains an additional random pointer which could point to any node in the list or null, create a deep copy of the list. Each node in the new list must be a separate copy of the corresponding node in the original list, and the random pointers in the new list should point to the correct nodes in the copied list.",
    "topic": "Linked List",
    "subtopic": "Deep Copy",
    "tags": [
      "Linked List",
      "Clone",
      "Deep Copy"
    ],
    "input_format": "A head node of a singly linked list where each node has a random pointer.",
    "output_format": "The head node of the deep copied linked list.",
    "constraints": [
      "The number of nodes in the list is between 0 and 1000.",
      "Each node's random pointer is either null or points to a node in the list."
    ],
    "examples": [
      {
        "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "explanation": "The returned linked list is a deep copy of the original list, preserving the random pointers."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hashmap to keep track of the old nodes and their copies.",
      "You can first copy the next pointers and then the random pointers."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Amount of Time for Binary Tree to Be Infected",
    "description": "You are given a binary tree rooted at a node, where each node represents a person. Each node has an infection state: if the node is infected, it can spread the infection to its children nodes. You need to determine the total time taken for the entire binary tree to become infected starting from the root node. The time taken for infection to spread from a node to its children is 1 unit for each step. Return the amount of time it takes for the entire tree to be infected.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "DFS",
      "BFS"
    ],
    "input_format": "The root of the binary tree as a TreeNode.",
    "output_format": "An integer representing the total time for the binary tree to be fully infected.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 1000].",
      "Each node's value is a unique integer."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, null, 4, null, 5]",
        "output": "4",
        "explanation": "The infection starts at node 1. At time 1, nodes 2 and 3 get infected. At time 2, node 4 (child of 2) gets infected. At time 3, node 5 (child of 3) gets infected. Finally, the whole tree is infected at time 4."
      },
      {
        "input": "root = [1, 2, 3, 4]",
        "output": "3",
        "explanation": "The infection starts at node 1. At time 1, nodes 2 and 3 get infected. At time 2, node 4 gets infected. The entire tree is infected at time 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a depth-first search to traverse the tree.",
      "You can calculate the time taken by considering each level of the tree."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Jump Game",
    "description": "You are given an array of integers nums. Each integer represents your maximum jump length at that position. Your task is to determine if you can reach the last index starting from the first index. You can assume that you can always reach the last index if you're at the last element.",
    "topic": "Array",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Array",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers nums where 0 <= nums[i] <= 10^5.",
    "output_format": "A boolean value indicating whether you can reach the last index.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "true",
        "explanation": "You can jump to index 1 (value = 3), then jump to index 4 (value = 4)."
      },
      {
        "input": "nums = [3, 2, 1, 0, 4]",
        "output": "false",
        "explanation": "You will not be able to jump to the last index (4) as there is a 0 at index 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the farthest index you can reach at each step.",
      "Use a greedy approach to track the maximum reach."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Predict the Winner",
    "description": "You are given an integer array 'nums' where 'nums[i]' represents the score of the i-th player. Player 1 and Player 2 take turns picking numbers from either end of the array. Player 1 always goes first. The player with the higher score at the end of the game wins. Your task is to determine whether Player 1 can guarantee a win with optimal play from both players.",
    "topic": "Dynamic Programming",
    "subtopic": "Game Theory",
    "tags": [
      "Dynamic Programming",
      "Game Theory",
      "Greedy"
    ],
    "input_format": "An array of integers nums, where 1 <= nums.length <= 20.",
    "output_format": "Return true if Player 1 can guarantee a win, otherwise return false.",
    "constraints": [
      "1 <= nums.length <= 20",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 5, 2]",
        "output": "false",
        "explanation": "Player 1 can pick 1 or 2; no matter what Player 2 picks, Player 1 cannot guarantee a win."
      },
      {
        "input": "nums = [1, 5, 233, 7]",
        "output": "true",
        "explanation": "Player 1 can pick 1 or 7. If Player 1 picks 1, then Player 2 will pick 5; Player 1 then picks 233, winning the game."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to simulate the game.",
      "Think about the scores' difference between the two players."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "01 Matrix",
    "description": "Given a binary matrix filled with 0's and 1's, modify it in place such that if an element is 1, its entire row and entire column are filled with 1's. The operation should be done in-place without using additional space apart from the input matrix.",
    "topic": "Matrix",
    "subtopic": "In-place Modification",
    "tags": [
      "Matrix",
      "In-place",
      "Modification"
    ],
    "input_format": "A binary matrix of size m x n where 0 <= m, n <= 200.",
    "output_format": "The modified binary matrix after performing the operations.",
    "constraints": [
      "The matrix has at least 1 and at most 200 rows.",
      "The matrix has at least 1 and at most 200 columns.",
      "Each element of the matrix is either 0 or 1."
    ],
    "examples": [
      {
        "input": [
          [
            0,
            1,
            0
          ],
          [
            1,
            1,
            1
          ],
          [
            0,
            0,
            0
          ]
        ],
        "output": [
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            0,
            1,
            0
          ]
        ],
        "explanation": "The first row and first column are filled with 1's due to the 1 at (0, 1) and (1, 0) positions."
      },
      {
        "input": [
          [
            1
          ]
        ],
        "output": [
          [
            1
          ]
        ],
        "explanation": "The single element is 1, so the output remains the same."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to track which rows and columns need to be modified.",
      "You might need to traverse the matrix multiple times."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an array of integers, return all the unique triplets (a, b, c) such that a + b + c = 0, where a, b, and c are distinct elements from the array. The solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Hashing",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A list of unique triplets which sum to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that sum to zero are: [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "No triplets can be formed from an empty array."
      },
      {
        "input": "nums = [0, 1, 1]",
        "output": "[]",
        "explanation": "There are no triplets that sum to zero."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using sorting first.",
      "Use two pointers to find pairs that sum to a fixed value."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array",
    "description": "Given a sorted array of integers, remove the duplicates in-place such that each element appears only once and return the new length of the array. Do not allocate extra space for another array, you must do this by modifying the input array in-place.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An array of integers nums, sorted in non-decreasing order.",
    "output_format": "An integer representing the new length of the array after duplicates have been removed.",
    "constraints": [
      "0 <= nums.length <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "2",
        "explanation": "After removing duplicates, the array is [1, 2] and the new length is 2."
      },
      {
        "input": "nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]",
        "output": "5",
        "explanation": "After removing duplicates, the array is [0, 1, 2, 3, 4] and the new length is 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to track unique elements.",
      "The first pointer can iterate through the array, while the second pointer keeps track of the position to insert unique elements."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Longest Consecutive Sequence",
    "description": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence. The algorithm should run in O(n) time complexity. For example, for an input array of [100, 4, 200, 1, 3, 2], the longest consecutive sequence is 4 (1, 2, 3, 4).",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "HashTable",
      "Consecutive Sequence"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the length of the longest consecutive sequence.",
    "constraints": [
      "0 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [100, 4, 200, 1, 3, 2]",
        "output": "4",
        "explanation": "The longest consecutive elements sequence is [1, 2, 3, 4]."
      },
      {
        "input": "nums = [10, 4, 5, 2, 3, 1, 6, 8]",
        "output": "6",
        "explanation": "The longest consecutive elements sequence is [1, 2, 3, 4, 5, 6]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash set to store the elements for quick access.",
      "Check each number to see if it is the beginning of a sequence."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices where 1 <= prices.length <= 10^5.",
    "output_format": "An integer representing the maximum profit. If no profit can be made, return 0.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), the profit is 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate the potential profit at each price point."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Populating Next Right Pointers in Each Node",
    "description": "Given a perfect binary tree, populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Pointers"
    ],
    "input_format": "The root of the perfect binary tree.",
    "output_format": "The same tree with next pointers populated.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2^12 - 1].",
      "0 <= node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, 4, 5, 6, 7]",
        "output": "[1:#, 2:3, 3:#, 4:5, 5:6, 6:7, 7:#]",
        "explanation": "In the tree, each node points to its immediate right node, where '#' indicates the end of the level."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree should remain empty."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a level order traversal.",
      "You can utilize the 'next' pointers to connect the nodes."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Same Tree",
    "description": "Given two binary trees, write a function to determine if they are structurally identical and the nodes have the same value. Two binary trees are considered the same if they are structurally identical and the nodes have the same value.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Recursion"
    ],
    "input_format": "Two binary tree nodes, represented as root1 and root2.",
    "output_format": "A boolean indicating whether the two trees are the same (true) or not (false).",
    "constraints": [
      "The number of nodes in both trees is in the range [0, 100].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root1 = [1, 2, 3], root2 = [1, 2, 3]",
        "output": "true",
        "explanation": "Both trees are identical with the same structure and values."
      },
      {
        "input": "root1 = [1, 2], root2 = [1, null, 2]",
        "output": "false",
        "explanation": "The structure of the trees is different."
      },
      {
        "input": "root1 = [], root2 = []",
        "output": "true",
        "explanation": "Both trees are empty, hence they are considered identical."
      },
      {
        "input": "root1 = [1, 2, 1], root2 = [1, 1, 2]",
        "output": "false",
        "explanation": "The values of nodes are different although the structures are the same."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use recursion to compare the nodes of both trees.",
      "Check for null nodes before comparing values."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Majority Element",
    "description": "Given an array of size n, find the majority element. The majority element is the element that appears more than n/2 times in the array. You may assume that the majority element always exists in the array.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Majority Element"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the majority element.",
    "constraints": [
      "1 <= n <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2,2,1,1,1,2,2]",
        "output": "2",
        "explanation": "2 appears 4 times, which is more than n/2 (3.5) times."
      },
      {
        "input": "nums = [3,2,3]",
        "output": "3",
        "explanation": "3 appears 2 times out of 3 elements, which is more than n/2 (1.5) times."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Try using a hash map to count occurrences.",
      "Consider using Boyer-Moore Voting Algorithm."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Longest String Chain",
    "description": "Given a list of words, you need to determine the length of the longest possible string chain. A string chain is formed by linking words together with the condition that each subsequent word must be formed by adding exactly one letter to the previous word. For example, 'a' -> 'at' -> 'ate' is a valid chain.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "Strings",
      "Graph"
    ],
    "input_format": "An array of strings words representing the list of words.",
    "output_format": "An integer representing the length of the longest string chain.",
    "constraints": [
      "1 <= words.length <= 1000",
      "1 <= words[i].length <= 16",
      "All strings in words are unique."
    ],
    "examples": [
      {
        "input": "words = [\"a\", \"b\", \"ba\", \"bca\", \"bda\", \"bdca\"]",
        "output": "5",
        "explanation": "The longest chain is 'a' -> 'ba' -> 'bda' -> 'bdca', which has a length of 5."
      },
      {
        "input": "words = [\"xbc\", \"pc\", \"xbcg\", \"pbc\", \"c\", \"bc\", \"b\"]",
        "output": "5",
        "explanation": "The longest chain is 'b' -> 'bc' -> 'pc' -> 'xbc' -> 'xbcg', which has a length of 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using memoization to store the lengths of chains.",
      "Look for potential words that can be formed by removing one letter."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Unique Paths II",
    "description": "A robot is located at the top-left corner of an m x n grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. Now, some cells in the grid are obstacles that the robot cannot cross. Given a grid represented by a 2D array, return the number of unique paths from the top-left corner to the bottom-right corner, considering the obstacles.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Pathfinding"
    ],
    "input_format": "A 2D grid of size m x n (where 1 <= m, n <= 100) representing the grid where 0 represents a free cell and 1 represents an obstacle.",
    "output_format": "An integer representing the number of unique paths from the top-left corner to the bottom-right corner.",
    "constraints": [
      "1 <= m, n <= 100",
      "grid[i][j] is either 0 (free) or 1 (obstacle)."
    ],
    "examples": [
      {
        "input": "grid = [[0,0,0],[0,1,0],[0,0,0]]",
        "output": "2",
        "explanation": "There are two unique paths to reach the bottom-right corner: down -> down -> right -> right and right -> right -> down -> down."
      },
      {
        "input": "grid = [[0,1],[0,0]]",
        "output": "1",
        "explanation": "There is only one unique path to reach the bottom-right corner."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to solve the problem.",
      "Think about how to accumulate paths from the starting point.",
      "Edges of the grid need special handling."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Path Sum II",
    "description": "Given a binary tree, find all root-to-leaf paths where each path's sum equals a given target. The binary tree is represented as a collection of nodes, where each node contains an integer value, and links to left and right child nodes. A root-to-leaf path is any path from the root node down to a leaf node, where a leaf is defined as a node with no children.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "DFS",
      "Backtracking"
    ],
    "input_format": "A binary tree represented as a List of integers, where 'null' values indicate the absence of a node, and an integer target representing the target sum.",
    "output_format": "A list of lists, where each inner list represents a path from the root to a leaf node that sums up to the target.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 1000].",
      "Each node's value is in the range [-1000, 1000].",
      "Target sum is an integer in the range [-2000, 2000]."
    ],
    "examples": [
      {
        "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], target = 22",
        "output": "[[5,4,11,2],[5,8,4,5]]",
        "explanation": "The paths that sum up to 22 are [5,4,11,2] and [5,8,4,5]."
      },
      {
        "input": "root = [1,2,3], target = 5",
        "output": "[]",
        "explanation": "There are no paths that sum to 5."
      },
      {
        "input": "root = [1], target = 1",
        "output": "[[1]]",
        "explanation": "The only path [1] equals the target sum of 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use Depth First Search (DFS) to explore all the paths.",
      "Track the current sum along the path and the current node.",
      "When you reach a leaf node, check if the current sum equals the target."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "All Nodes Distance K in Binary Tree",
    "description": "Given a binary tree, the target node, and an integer K, return all nodes that are K distance from the target node. You may assume that the given target node is a node in the binary tree. The result can be returned in any order.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Graph"
    ],
    "input_format": "A binary tree and an integer K representing the distance from the target node.",
    "output_format": "A list of node values that are K distance away from the target node.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 100].",
      "The values of the tree nodes are unique.",
      "0 <= K <= the height of the tree."
    ],
    "examples": [
      {
        "input": "root = [1,2,3,4,5,6,7], target = 3, K = 1",
        "output": "[2, 6, 7]",
        "explanation": "The nodes at distance 1 from node 3 are 2 (its parent) and 6, 7 (its children)."
      },
      {
        "input": "root = [1], target = 1, K = 0",
        "output": "[1]",
        "explanation": "The only node is the target node itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how you can traverse the tree.",
      "You may need to consider the parent nodes as well."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Filling Bookcase Shelves",
    "description": "You are given a list of books with various heights and a bookcase with a fixed width. Your task is to determine the minimum number of shelves needed to fit all the books into the bookcase, considering that the height of a shelf is determined by the tallest book placed on that shelf. Books can only be placed on a shelf if they fit within the width limit of the shelf. Additionally, each shelf has to hold at least one book.",
    "topic": "Greedy",
    "subtopic": "Bin Packing",
    "tags": [
      "Greedy",
      "Bin Packing",
      "Height",
      "Books"
    ],
    "input_format": "An integer width of the bookcase and an array of integers representing the heights of the books.",
    "output_format": "An integer representing the minimum number of shelves required.",
    "constraints": [
      "1 <= width <= 10^6",
      "1 <= heights.length <= 1000",
      "1 <= heights[i] <= 1000"
    ],
    "examples": [
      {
        "input": "width = 5, heights = [1, 2, 3, 4, 5]",
        "output": "3",
        "explanation": "The first shelf can hold books of heights 1 and 2, the second shelf can hold the book of height 3, and the last shelf can hold books of heights 4 and 5."
      },
      {
        "input": "width = 8, heights = [5, 3, 4, 2, 6]",
        "output": "4",
        "explanation": "Each book can be placed individually without exceeding the width, therefore we need 4 shelves."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a greedy approach to fill the shelves optimally.",
      "Track the current shelf width as you iterate through the books."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Longest Repeating Character Replacement",
    "description": "Given a string s that consists of only uppercase English letters, you can perform at most k character replacements. Find the length of the longest substring that contains the same letter after performing at most k replacements.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Two Pointers"
    ],
    "input_format": "A string s and an integer k.",
    "output_format": "An integer representing the length of the longest substring with the same letter after at most k replacements.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of only uppercase English letters.",
      "0 <= k <= s.length"
    ],
    "examples": [
      {
        "input": "s = \"AABABBA\", k = 1",
        "output": "4",
        "explanation": "You can replace one 'B' with 'A' to form the substring 'AAAA'."
      },
      {
        "input": "s = \"AAABBA\", k = 2",
        "output": "5",
        "explanation": "You can replace both 'B's with 'A's to form the substring 'AAAAA'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sliding window to keep track of the count of characters.",
      "The length of the window minus the count of the most frequent character should not exceed k."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Jump Game II",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to jump from the first index to the last index in the minimum number of jumps. If you cannot reach the last index, return -1. Write a function that returns the minimum number of jumps needed to reach the end of the array.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Greedy",
      "Dynamic Programming",
      "Array"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "An integer representing the minimum number of jumps to reach the last index, or -1 if it is not possible.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "2",
        "explanation": "The minimum jumps to reach the end are: 1 -> 2 (index 0 to index 1) -> 4 (index 1 to index 4), hence 2 jumps."
      },
      {
        "input": "nums = [3, 2, 1, 0, 4]",
        "output": "-1",
        "explanation": "It is not possible to reach the last index from index 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the farthest you can reach with each jump.",
      "Use a greedy approach to track the farthest reachable index."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Surrounded Regions",
    "description": "Given a 2D board containing 'X' and 'O', capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. The 'O's that are on the border or connected to an 'O' on the border should not be captured.",
    "topic": "DFS/BFS",
    "subtopic": "Graph Traversal",
    "tags": [
      "DFS",
      "BFS",
      "Grid"
    ],
    "input_format": "A 2D char array board representing the game board.",
    "output_format": "The input board modified in-place with all captured regions flipped to 'X'.",
    "constraints": [
      "board.length >= 1",
      "board[i].length >= 1",
      "board[i][j] is either 'X' or 'O'."
    ],
    "examples": [
      {
        "input": [
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "O",
            "O",
            "X"
          ],
          [
            "X",
            "X",
            "O",
            "X"
          ],
          [
            "X",
            "O",
            "X",
            "X"
          ]
        ],
        "output": [
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "O",
            "X",
            "X"
          ]
        ],
        "explanation": "The 'O's not connected to the border are surrounded and flipped to 'X'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using DFS or BFS to explore and mark regions.",
      "Start from the border and work inwards."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Daily Temperatures",
    "description": "Given an array of integers representing the daily temperatures, return an array such that, for each day in the input, tells you how many days you have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. For example, if the input is [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].",
    "topic": "Array",
    "subtopic": "Stack",
    "tags": [
      "Array",
      "Stack",
      "Temperature"
    ],
    "input_format": "An array of integers temperatures representing the daily temperatures.",
    "output_format": "An array of integers where each integer represents the days to wait for a warmer day.",
    "constraints": [
      "1 <= temperatures.length <= 30000",
      "30 <= temperatures[i] <= 100"
    ],
    "examples": [
      {
        "input": "temperatures = [73, 74, 75, 71, 69, 72, 76, 73]",
        "output": "[1, 1, 4, 2, 1, 1, 0, 0]",
        "explanation": "For each day, we check the temperatures ahead until we find a warmer day. If no warmer day exists, we record a 0."
      },
      {
        "input": "temperatures = [30, 40, 50, 60]",
        "output": "[1, 1, 1, 0]",
        "explanation": "Each day is warmer than the previous one, so the output reflects that we have to wait 1 day for the next warmer temperature, except the last one."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to keep track of the indices of the temperatures.",
      "Traverse the temperatures array from the end to the beginning."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Minimum Number of Refueling Stops",
    "description": "You are driving a car that can cover a maximum distance on a full tank of gas. Given the total distance to your destination, the maximum distance you can travel on a full tank, and a list of gas stations with their distances from the starting point, your task is to determine the minimum number of refueling stops needed to reach the destination. If it's not possible to reach the destination, return -1.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithms",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Graphs"
    ],
    "input_format": "An integer target representing the total distance to the destination, an integer startFuel representing the initial fuel capacity, and an array of integers stations where each station[i] is the distance from the start to the i-th gas station.",
    "output_format": "An integer representing the minimum number of refueling stops needed to reach the destination or -1 if the destination cannot be reached.",
    "constraints": [
      "1 <= target <= 10^9",
      "1 <= startFuel <= 10^9",
      "0 <= stations.length <= 10^4",
      "0 <= stations[i] <= target"
    ],
    "examples": [
      {
        "input": {
          "target": 100,
          "startFuel": 10,
          "stations": [
            10,
            20,
            30,
            40,
            50
          ]
        },
        "output": 2,
        "explanation": "The car can travel 10 miles initially, refuel at station 10 to travel 30 miles, and finally refuel at station 30 to reach the destination, making 2 refueling stops."
      },
      {
        "input": {
          "target": 100,
          "startFuel": 1,
          "stations": [
            10
          ]
        },
        "output": -1,
        "explanation": "The car cannot reach any station, as it can only travel 1 mile."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a priority queue to keep track of the refueling options.",
      "Calculate how far you can go with your current fuel, and refuel strategically."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Car Pooling",
    "description": "You are given an array trips where trips[i] = [numPassengersi, startLocationi, endLocationi] indicates that the ith trip has numPassengersi passengers and the trip starts at startLocationi and ends at endLocationi. You are also given an integer capacity, which is the maximum number of passengers that can be in the car at the same time. Return true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise.",
    "topic": "Greedy",
    "subtopic": "Interval Management",
    "tags": [
      "Greedy",
      "Carpooling",
      "Array"
    ],
    "input_format": "An array of trips, where each trip is represented as an array of three integers [numPassengers, startLocation, endLocation]. A single integer capacity.",
    "output_format": "Return a boolean indicating whether all trips can be completed within the given capacity.",
    "constraints": [
      "1 <= trips.length <= 1000",
      "1 <= numPassengersi <= 100",
      "0 <= startLocationi < endLocationi <= 10^9",
      "1 <= capacity <= 1000"
    ],
    "examples": [
      {
        "input": "trips = [[2, 1, 5], [3, 3, 7]], capacity = 4",
        "output": "false",
        "explanation": "At startLocation 1, 2 passengers are picked up. At startLocation 3, 3 additional passengers are picked up, making a total of 5, which exceeds the capacity."
      },
      {
        "input": "trips = [[2, 1, 5], [3, 5, 7]], capacity = 5",
        "output": "true",
        "explanation": "At startLocation 1, 2 passengers are picked up. At startLocation 5, 3 passengers are dropped off, keeping the car within the capacity."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use an array to keep track of the number of passengers at each location.",
      "You may need to sort the trips based on start locations."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Maximum Sum Circular Subarray",
    "description": "Given a circular array of integers, find the maximum possible sum of a non-empty subarray. A circular array means that the end of the array is connected to the beginning of the array. The sum of a subarray can wrap around and include elements from both ends of the array.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Subarray"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum sum of a circular subarray.",
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, -2, 3, -2]",
        "output": "3",
        "explanation": "The maximum sum circular subarray is [3]."
      },
      {
        "input": "nums = [5, -3, 5]",
        "output": "10",
        "explanation": "The maximum sum circular subarray is [5, -3, 5] which wraps around."
      },
      {
        "input": "nums = [-3, -2, -3]",
        "output": "-2",
        "explanation": "The maximum subarray is simply the highest element in the array, which is -2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider both the maximum subarray sum and the total sum of the array.",
      "Apply Kadane's algorithm to find the maximum subarray sum.",
      "Think about how to handle the circular behavior."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Sliding Window Median",
    "description": "Given an array of integers 'nums' and an integer 'k', return the median of the sliding window of size 'k' as it moves from the start to the end of the array. The median is defined as the middle element in a sorted array. If the size of the array is even, then the median is the average of the two middle elements.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Median"
    ],
    "input_format": "An array of integers nums and an integer k (1 <= k <= nums.length).",
    "output_format": "An array of double representing the medians of each sliding window.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 5, 2, 8, 7], k = 3",
        "output": "[3.0, 5.0, 7.0, 8.0]",
        "explanation": "The sliding windows are [1, 3, 5], [3, 5, 2], [5, 2, 8], [2, 8, 7]. Their medians are 3, 5, 7, and 8 respectively."
      },
      {
        "input": "nums = [1, 2, 3, 4, 5], k = 2",
        "output": "[1.5, 2.5, 3.5, 4.5]",
        "explanation": "The sliding windows are [1, 2], [2, 3], [3, 4], and [4, 5]. Their medians are 1.5, 2.5, 3.5, and 4.5 respectively."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a balanced data structure to maintain the order of the elements.",
      "You can use a max-heap and a min-heap to efficiently find the median."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Minimum Area Rectangle",
    "description": "Given a list of points in a 2D plane, write a function to find the minimum area of a rectangle formed by four of these points. If there are no such rectangles, return 0. A rectangle is defined by its two diagonal points.",
    "topic": "Geometry",
    "subtopic": "Minimum Area",
    "tags": [
      "Geometry",
      "Rectangle",
      "Area",
      "HashMap"
    ],
    "input_format": "A list of points, where each point is represented as a pair of integers [x, y].",
    "output_format": "An integer representing the minimum area of the rectangle formed by the points, or 0 if no rectangle can be formed.",
    "constraints": [
      "1 <= points.length <= 500",
      "-10^4 <= x, y <= 10^4",
      "All points are distinct."
    ],
    "examples": [
      {
        "input": "points = [[1,1],[1,3],[3,1],[3,3],[2,2]]",
        "output": "4",
        "explanation": "The rectangle is formed by points (1,1), (1,3), (3,1), (3,3) with area 4."
      },
      {
        "input": "points = [[1,1],[2,2],[1,3],[4,4]]",
        "output": "0",
        "explanation": "No rectangle can be formed with the given points."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a set to store points for O(1) lookup.",
      "Check for every pair of points if they can form opposite corners of a rectangle."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Minimum Number of Arrows to Burst Balloons",
    "description": "You are given an array points where points[i] = [xstart, xend] represents the horizontal diameter of a balloon. Burst balloons by shooting arrows. An arrow can be shot at any point along the horizontal axis and will burst all balloons that intersect that point. Return the minimum number of arrows that must be shot to burst all balloons.",
    "topic": "Greedy",
    "subtopic": "Interval Scheduling",
    "tags": [
      "Greedy",
      "Intervals",
      "Sorting"
    ],
    "input_format": "An array of points, where each point is an array of two integers [xstart, xend].",
    "output_format": "An integer representing the minimum number of arrows needed to burst all balloons.",
    "constraints": [
      "1 <= points.length <= 10^4",
      "-10^9 <= xstart < xend <= 10^9"
    ],
    "examples": [
      {
        "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
        "output": "2",
        "explanation": "Two arrows are enough to burst all balloons. One arrow can be shot at point 6 to burst balloons [1,6],[2,8],[7,12], and another can be shot at point 15 to burst [10,16]."
      },
      {
        "input": "points = [[1,2],[3,4],[5,6],[7,8]]",
        "output": "4",
        "explanation": "Each balloon does not overlap with any other, so we need four arrows, one for each balloon."
      },
      {
        "input": "points = [[1,2],[2,3],[3,4],[4,5]]",
        "output": "2",
        "explanation": "Two arrows can be used to burst all balloons: one at point 2 and another at point 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the balloons based on their end points.",
      "Use a greedy approach to shoot arrows at the end points."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Minimum Cost For Tickets",
    "description": "You are planning a trip and need to purchase tickets for a set of travel days. You have three options for purchasing tickets: a 1-day pass, a 7-day pass, and a 30-day pass. Given an array of days where you plan to travel, your goal is to determine the minimum cost required to cover all travel days. Each option has a fixed cost: the 1-day pass costs $2, the 7-day pass costs $7, and the 30-day pass costs $25. You may not need to purchase an option for every day in the array if consecutive days can be covered by a longer pass.",
    "topic": "Dynamic Programming",
    "subtopic": "Optimization",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Cost Minimization"
    ],
    "input_format": "A list of integers days where 1 <= days.length <= 365 and 1 <= days[i] <= 365.",
    "output_format": "An integer representing the minimum cost required to cover all travel days.",
    "constraints": [
      "1 <= days.length <= 365",
      "1 <= days[i] <= 365",
      "The days array is sorted in increasing order."
    ],
    "examples": [
      {
        "input": "days = [1, 4, 6, 7, 8]",
        "output": "11",
        "explanation": "Buying one 7-day pass covering days 1-7 and a 1-day pass for day 8 results in a total cost of $7 + $2 = $9."
      },
      {
        "input": "days = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30]",
        "output": "17",
        "explanation": "Buying one 7-day pass for days 1-7 ($7) and another 7-day pass for days 8-14 ($7) covers the period. Finally, a 1-day pass for day 30 ($2) makes the total $7 + $7 + $2 = $16."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dynamic programming approach to store minimum costs for specific travel days.",
      "Think about overlapping periods when using the 7-day or 30-day passes.",
      "You can use an array to keep track of the minimum costs at each travel day."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Last Stone Weight",
    "description": "You are given an array of integers stones where each integer represents the weight of a stone. You will now crush stones until at most one stone is left. Each time you select the two heaviest stones and crush them together. If the stones have the same weight, both stones are destroyed, and if they have different weights, the smaller stone is destroyed and the larger stone's weight is reduced by the smaller stone's weight. Return the weight of the last stone. If there are no stones left, return 0.",
    "topic": "Heap",
    "subtopic": "Max Heap",
    "tags": [
      "Heap",
      "Greedy",
      "Simulation"
    ],
    "input_format": "An array of integers stones where 1 <= stones.length <= 30 and 1 <= stones[i] <= 1000.",
    "output_format": "An integer representing the weight of the last stone or 0 if no stones are left.",
    "constraints": [
      "1 <= stones.length <= 30",
      "1 <= stones[i] <= 1000"
    ],
    "examples": [
      {
        "input": "stones = [2,7,4,1,8,1]",
        "output": "1",
        "explanation": "We combine 7 and 8 to get 1, then combine 2 and 4 to get 1 which leaves us with stones [1,1,1]."
      },
      {
        "input": "stones = [1,3]",
        "output": "2",
        "explanation": "We combine the stones 1 and 3 to obtain 2."
      },
      {
        "input": "stones = [3,3]",
        "output": "0",
        "explanation": "Both stones have equal weights and are destroyed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a max heap to efficiently get the two largest stones.",
      "Keep track of the weights while combining the stones."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Patching Array",
    "description": "Given a sorted array of positive integers nums sorted in ascending order, you are allowed to insert any positive integer into the array to make the sum of the first k positive integers equal to k for all k from 1 to n (1-indexed). Return the minimum number of patches required to achieve that.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "An integer n (the length of array) and an array of integers nums.",
    "output_format": "An integer representing the minimum number of patches required.",
    "constraints": [
      "1 <= n <= 10000",
      "1 <= nums.length <= 10000",
      "1 <= nums[i] <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "n = 5, nums = [1, 2, 2]",
        "output": "1",
        "explanation": "We can insert the number 3 to make the sum of the first 5 integers equal to 5."
      },
      {
        "input": "n = 8, nums = [1, 5, 10]",
        "output": "2",
        "explanation": "We can insert the numbers 2 and 4 to make the sum of the first 8 integers equal to 8."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a greedy approach to check for missing sums.",
      "Keep track of the current sum and the next expected value."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Sliding Window Maximum",
    "description": "Given an integer array nums and an integer k, return the maximum sliding window for each sliding window of size k. You must solve it in linear time complexity.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Queue"
    ],
    "input_format": "An integer array nums followed by an integer k.",
    "output_format": "An array of integers representing the maximum value in each sliding window.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3",
        "output": "[3, 3, 5, 5, 6, 7]",
        "explanation": "The sliding windows are [1, 3, -1], [3, -1, -3], [-1, -3, 5], [-3, 5, 3], [5, 3, 6], [3, 6, 7]. The maximums are 3, 3, 5, 5, 6, and 7."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "With one element in the array, the maximum in the sliding window is that element itself."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a deque to keep track of indices of useful elements.",
      "Make sure to maintain the order of elements as you slide the window."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Course Schedule III",
    "description": "You are given an array of pairs where each pair represents a course with a start time and an end time. You can take a course if the end time of the last course you took is less than or equal to the start time of the current course. Your goal is to maximize the number of courses you can take without overlapping. Implement a function to calculate the maximum number of courses you can take.",
    "topic": "Greedy",
    "subtopic": "Interval Scheduling",
    "tags": [
      "Greedy",
      "Interval",
      "Scheduling"
    ],
    "input_format": "An array of pairs representing courses, where each pair is [start, end].",
    "output_format": "An integer representing the maximum number of courses that can be taken.",
    "constraints": [
      "1 <= courses.length <= 10^5",
      "0 <= start < end <= 10^9"
    ],
    "examples": [
      {
        "input": "[[0, 2], [1, 3], [2, 4], [3, 5]]",
        "output": "3",
        "explanation": "You can take courses [0, 2], then [2, 4], and finally [4, 5]. You cannot take [1, 3] because it overlaps with [0, 2]."
      },
      {
        "input": "[[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]",
        "output": "5",
        "explanation": "All courses can be taken as they do not overlap."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Sort the courses by their end times.",
      "Use a greedy approach to select non-overlapping courses."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Minimum Number of Taps to Open to Water a Garden",
    "description": "You have a garden represented by a number line from 0 to n. There are n + 1 taps located at positions 0 through n, where the ith tap can water the area from position i - radius[i] to i + radius[i]. Given an integer n and an array of integers radius of length n + 1, return the minimum number of taps that need to be opened to water the entire garden. If it is not possible to water the garden, return -1.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithms",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Intervals"
    ],
    "input_format": "An integer n for the length of the garden and an array of integers radius of length n + 1.",
    "output_format": "An integer representing the minimum number of taps required to water the entire garden or -1 if it cannot be done.",
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= radius[i] <= n"
    ],
    "examples": [
      {
        "input": "n = 5, radius = [3,4,1,1,0,0]",
        "output": "1",
        "explanation": "Opening tap 1 can water the entire garden."
      },
      {
        "input": "n = 5, radius = [0,0,0,0,0,0]",
        "output": "-1",
        "explanation": "None of the taps can water any part of the garden."
      },
      {
        "input": "n = 7, radius = [1,2,1,0,2,1,0,1]",
        "output": "3",
        "explanation": "Open taps 1, 2, and 5 to cover the whole garden."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a greedy approach to choose taps optimally.",
      "Think about how you can create intervals from the tap ranges."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Maximum Running Time of N Computers",
    "description": "You are given N computers, each with a certain power consumption capacity. You need to determine the maximum total running time of these computers while respecting their individual capacities. The computers can be turned on or off, but the total running time across all computers cannot exceed their combined power capacity. Additionally, the power capacity decreases linearly over time. Your goal is to calculate the maximum running time if all computers are started together.",
    "topic": "Greedy",
    "subtopic": "Interval Problems",
    "tags": [
      "Greedy",
      "Interval",
      "Simulation"
    ],
    "input_format": "An integer array capacities where capacities[i] represents the power consumption capacity of the i-th computer.",
    "output_format": "An integer representing the maximum running time all computers can run simultaneously.",
    "constraints": [
      "1 <= capacities.length <= 100",
      "1 <= capacities[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "capacities = [3, 2, 5]",
        "output": "2",
        "explanation": "The total capacity is 10, and the computers can run for maximum 2 units of time (3 + 2 + 5 = 10). After 2 units, they will start exceeding their capacities."
      },
      {
        "input": "capacities = [4, 4, 4]",
        "output": "4",
        "explanation": "All computers can run for 4 units of time equally, using up their entire capacity."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how the power consumption affects the running time.",
      "You may need to balance the usage between all computers."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Kth Largest Element in an Array",
    "description": "Given an array of integers nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Heap",
      "Binary Search"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An integer representing the kth largest element in the array.",
    "constraints": [
      "1 <= k <= nums.length",
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 1, 5, 6, 4], k = 2",
        "output": "5",
        "explanation": "The second largest element in the sorted array [1, 2, 3, 4, 5, 6] is 5."
      },
      {
        "input": "nums = [3, 2, 3, 1, 2, 4, 5, 5, 6], k = 4",
        "output": "4",
        "explanation": "The fourth largest element in the sorted array [1, 2, 2, 3, 3, 4, 5, 5, 6] is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a max heap or sorting technique to find the kth largest element.",
      "Remember that you can use the quickselect algorithm for a more efficient solution."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Crawler Log Folder",
    "description": "You are given a list of strings, where each string represents a log entry generated by a web crawler. Each log entry can either be a folder or a file. A folder starts with a name followed by '/', whereas a file does not. Your task is to determine the total number of files in all subfolders within the given folder structure. A subfolder can contain more folders and files, and you need to count files recursively.",
    "topic": "Tree",
    "subtopic": "Recursion",
    "tags": [
      "Tree",
      "Recursion",
      "String Handling"
    ],
    "input_format": "A list of strings logs, where each string is a log entry.",
    "output_format": "An integer representing the total number of files in all subfolders.",
    "constraints": [
      "1 <= logs.length <= 200",
      "1 <= logs[i].length <= 100"
    ],
    "examples": [
      {
        "input": "logs = [\"d1/\", \"d2/\", \"d3/\", \"d1/a.txt\", \"d1/b.dat\", \"d2/c.txt\"]",
        "output": "3",
        "explanation": "There are 3 files: 'd1/a.txt', 'd1/b.dat', and 'd2/c.txt'."
      },
      {
        "input": "logs = [\"a/\", \"b/\", \"c/\", \"a/d/e/\", \"a/d/f.txt\", \"b/g.txt\"]",
        "output": "2",
        "explanation": "The files are 'a/d/f.txt' and 'b/g.txt'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a stack or recursion to navigate through the folders.",
      "Check if a log entry ends with '/' to identify folders."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Furthest Building You Can Reach",
    "description": "You are given an integer array heights representing the heights of buildings and an integer bricks. You start climbing from the first building. Each time you move from building i to building i + 1 (i < heights.length), if the building at i + 1 is taller than the building at i, you need to use bricks equal to the difference in height. If the building at i + 1 is not taller, you can move without using bricks. Your task is to determine the furthest building index you can reach, starting from building 0, given the height array and the amount of bricks you have.",
    "topic": "Greedy",
    "subtopic": "Climbing",
    "tags": [
      "Greedy",
      "Simulation",
      "Array"
    ],
    "input_format": "Two inputs: an integer array heights, and an integer bricks.",
    "output_format": "An integer representing the furthest building index you can reach.",
    "constraints": [
      "1 <= heights.length <= 10^4",
      "1 <= heights[i] <= 10^6",
      "0 <= bricks <= 10^9"
    ],
    "examples": [
      {
        "input": "heights = [1, 2, 3, 4, 5], bricks = 3",
        "output": "3",
        "explanation": "You can reach building 3 using 1 brick to move from 1 to 2, 1 brick to move from 2 to 3 (total 2 bricks). You cannot reach building 4 as it requires 2 more bricks."
      },
      {
        "input": "heights = [5, 1, 2, 3, 4], bricks = 0",
        "output": "0",
        "explanation": "You cannot move to any building because you need bricks to go from 5 to 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the difference in height when moving between buildings.",
      "Keep track of how many bricks you have used and how many are left."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Binary Tree Right Side View",
    "description": "Given a binary tree, imagine yourself standing on the right side of it. Return the values of the nodes you can see ordered from top to bottom. The right side view of a binary tree is the list of nodes visible from the right side.",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Binary Tree",
      "Traversal"
    ],
    "input_format": "The root of a binary tree given as a TreeNode.",
    "output_format": "A list of integers representing the values of the nodes visible from the right side.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, null, 5, null, 4]",
        "output": "[1, 3, 4]",
        "explanation": "The right side view is 1 (root), then 3 (right child of 1), and finally 4 (right child of 3)."
      },
      {
        "input": "root = [1, null, 3]",
        "output": "[1, 3]",
        "explanation": "The right side view is 1 (root) and then 3 (right child of 1)."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "If the tree is empty, there are no nodes to see from the right side."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a breadth-first search (BFS) or depth-first search (DFS).",
      "Keep track of the last node visited at each level."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Rotate Array",
    "description": "Given an integer array `nums`, rotate the array to the right by `k` steps, where `k` is a non-negative integer. You must do this in-place, meaning you must not allocate extra space for another array.",
    "topic": "Array",
    "subtopic": "Rotation",
    "tags": [
      "Array",
      "In-place",
      "Rotation"
    ],
    "input_format": "An array of integers nums followed by a non-negative integer k.",
    "output_format": "The modified array after rotating to the right by k steps.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= k <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5, 6, 7], k = 3",
        "output": "[5, 6, 7, 1, 2, 3, 4]",
        "explanation": "Rotating the array [1, 2, 3, 4, 5, 6, 7] to the right by 3 steps gives [5, 6, 7, 1, 2, 3, 4]."
      },
      {
        "input": "nums = [-1, -100, 3, 99], k = 2",
        "output": "[3, 99, -1, -100]",
        "explanation": "Rotating the array [-1, -100, 3, 99] to the right by 2 steps results in [3, 99, -1, -100]."
      },
      {
        "input": "nums = [1, 2], k = 0",
        "output": "[1, 2]",
        "explanation": "Rotating the array [1, 2] by 0 steps does not change the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to handle k when it is greater than the length of the array.",
      "You might want to reverse parts of the array to achieve the rotation."
    ],
    "company": "Flipkart"
  },
  {
    "question_id": "",
    "title": "Put Marbles in Bags",
    "description": "You are given a collection of marbles represented by their respective colors. You want to put these marbles into a specified number of bags. Your task is to determine the maximum number of bags that can be filled with the same count of each marble color such that no bag has more than a specified maximum capacity. It is guaranteed that you can always fill the bags uniformly if possible. The result should be the total number of bags that can be created.",
    "topic": "Greedy",
    "subtopic": "Distribution",
    "tags": [
      "Greedy",
      "Count",
      "Distribution"
    ],
    "input_format": "An integer array `marbles`, where each element represents the count of marbles of a specific color, and an integer `maxCapacity` representing the maximum capacity of each bag.",
    "output_format": "An integer representing the maximum number of bags that can be filled uniformly.",
    "constraints": [
      "1 <= marbles.length <= 100",
      "1 <= marbles[i] <= 10^4",
      "1 <= maxCapacity <= 10^4"
    ],
    "examples": [
      {
        "input": "marbles = [2, 4, 6], maxCapacity = 4",
        "output": "4",
        "explanation": "You can create 4 bags with 2 marbles of one color in each bag."
      },
      {
        "input": "marbles = [1, 1, 1], maxCapacity = 1",
        "output": "3",
        "explanation": "You can create 3 bags, each containing 1 marble of a different color."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the total number of marbles and divide by the bag capacity.",
      "Use a greedy approach to maximize the usage of each bag."
    ],
    "company": "Flipkart"
  }
]