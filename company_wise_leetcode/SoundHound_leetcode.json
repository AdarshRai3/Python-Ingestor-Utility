[
  {
    "question_id": "",
    "title": "Linked List in Binary Tree",
    "description": "Given a binary tree, check if there exists a root-to-leaf path such that the sequence of values along the path represents a given linked list. The linked list is specified by its head node and the tree nodes have integer values. A root-to-leaf path is defined as a path starting from the root node down to any leaf node, where each node along the path must match a node in the linked list in the same sequence.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Linked List",
      "Depth-First Search"
    ],
    "input_format": "Two inputs: a binary tree represented as a root node and a linked list represented as the head node.",
    "output_format": "A boolean value indicating whether a matching path exists.",
    "constraints": [
      "The number of nodes in the binary tree is in the range [1, 1000].",
      "The linked list length does not exceed 100."
    ],
    "examples": [
      {
        "input": "tree = [1, 2, 3], linked_list = [1, 2]",
        "output": "true",
        "explanation": "The path from root (1) to left child (2) matches the linked list."
      },
      {
        "input": "tree = [1, 2, 3], linked_list = [1, 3]",
        "output": "true",
        "explanation": "The path from root (1) to right child (3) matches the linked list."
      },
      {
        "input": "tree = [1, 2, 3], linked_list = [1, 4]",
        "output": "false",
        "explanation": "There is no path in the tree that continues from 1 to 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Utilize Depth-First Search (DFS) to traverse the tree.",
      "Keep track of the current position in the linked list while traversing.",
      "A leaf node is identified when both child nodes are null."
    ],
    "company": "SoundHound"
  },
  {
    "question_id": "",
    "title": "Check if Array Is Sorted and Rotated",
    "description": "Given an array of integers, determine if the array is sorted in non-decreasing order and then rotated at some pivot. An array is considered sorted if it is sorted in ascending order. For example, the arrays [3, 4, 5, 1, 2] and [1, 2, 3, 4, 5] are sorted and rotated, while [2, 1, 3, 4] is not. Your task is to implement a function that checks for this condition.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Rotation"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A boolean value, true if the array is sorted and rotated, false otherwise.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [3, 4, 5, 1, 2]",
        "output": "true",
        "explanation": "The array is sorted and rotated. It was originally [1, 2, 3, 4, 5]."
      },
      {
        "input": "nums = [1, 2, 3, 4, 5]",
        "output": "true",
        "explanation": "The array is sorted and not rotated. It is originally [1, 2, 3, 4, 5]."
      },
      {
        "input": "nums = [2, 1, 3, 4]",
        "output": "false",
        "explanation": "The array is not sorted. The order does not meet the non-decreasing condition."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Check if the array meets the conditions for being sorted.",
      "Look for the point of rotation where the order breaks.",
      "Consider edge cases with single or duplicate elements."
    ],
    "company": "SoundHound"
  },
  {
    "question_id": "",
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array nums, find the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses constant extra space.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Math"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the smallest missing positive integer.",
    "constraints": [
      "0 < nums.length <= 30000",
      "-2^31 <= nums[i] <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "The positive integers in the array are 1 and 2. The smallest missing positive integer is 3."
      },
      {
        "input": "nums = [3, 4, -1, 1]",
        "output": "2",
        "explanation": "The positive integers in the array are 1 and 3. The smallest missing positive integer is 2."
      },
      {
        "input": "nums = [7, 8, 9, 11, 12]",
        "output": "1",
        "explanation": "There are no positive integers less than 1 in the array. Hence, the smallest missing positive is 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a strategy that takes advantage of the properties of the array.",
      "You can use the indices of the array itself to store information about the presence of numbers."
    ],
    "company": "SoundHound"
  }
]