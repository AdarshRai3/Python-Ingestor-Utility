[
  {
    "question_id": "",
    "title": "Burst Balloons",
    "description": "You are given n balloons, indexed from 0 to n-1. Each balloon is painted with a number associated with it. When you burst a balloon, you gain points equal to the product of the numbers on the balloon and the numbers on the adjacent balloons. If there is no adjacent balloon, you expand the boundaries of the array to include a virtual balloon with a value of 1. Your goal is to maximize the total points you can obtain by bursting all the balloons. Write a function to determine the maximum points you can earn.",
    "topic": "Dynamic Programming",
    "subtopic": "Memoization",
    "tags": [
      "DynamicProgramming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers nums where 1 <= nums.length <= 300 and 0 <= nums[i] <= 100.",
    "output_format": "An integer representing the maximum points obtainable by bursting all the balloons.",
    "constraints": [
      "1 <= nums.length <= 300",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "[3, 1, 5, 8]",
        "output": "167",
        "explanation": "Optimal bursting order is to burst balloons in the sequence: 1 (gaining 3*5 + 5*8 = 55) then 5 (gaining 3*8 = 24), then 3 (gaining 1*8 = 8) and finally 8 to gain 1. The total points are 55 + 24 + 8 + 1 = 167."
      },
      {
        "input": "[1, 5]",
        "output": "10",
        "explanation": "Bursting in order gives points for bursting 5 first (1*1 + 1*5 = 5), and bursting 1 yields an additional 5 for a total of 10."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use dynamic programming to store the results of subproblems.",
      "Consider the bounds of the array when calculating adjacent balloons."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Longest Increasing Subsequence",
    "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence. A subsequence is derived from the array by deleting some or no elements without changing the order of the remaining elements. For example, from the array [10, 9, 2, 5, 3, 7, 101, 18], the longest increasing subsequence is [2, 3, 7, 101] with a length of 4.",
    "topic": "Dynamic Programming",
    "subtopic": "Binary Search",
    "tags": [
      "Dynamic Programming",
      "Binary Search",
      "Sequence",
      "Array"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the length of the longest increasing subsequence.",
    "constraints": [
      "1 <= nums.length <= 2500",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [10, 9, 2, 5, 3, 7, 101, 18]",
        "output": "4",
        "explanation": "The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4."
      },
      {
        "input": "nums = [0, 1, 0, 3, 2, 3]",
        "output": "4",
        "explanation": "The longest increasing subsequence is [0, 1, 2, 3], which has a length of 4."
      },
      {
        "input": "nums = [7, 7, 7, 7, 7, 7, 7]",
        "output": "1",
        "explanation": "The longest increasing subsequence can only be any of the '7's, which has a length of 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to solve this problem using dynamic programming.",
      "Consider using binary search to optimize your solution."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are covered by water.",
    "topic": "Graph",
    "subtopic": "Depth-First Search (DFS)",
    "tags": [
      "Graph",
      "DFS",
      "Matrix"
    ],
    "input_format": "A 2D grid represented as a list of lists of characters, where each character is either '1' or '0'.",
    "output_format": "An integer representing the number of islands in the grid.",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[0].length <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "[['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1']]",
        "output": "3",
        "explanation": "There are three islands in the grid: the first island forms the top left corner, the second island is in the middle, and the third island is in the bottom right corner."
      },
      {
        "input": "[['1', '1', '1'], ['0', '0', '0'], ['1', '1', '1']]",
        "output": "1",
        "explanation": "There is one island that covers the entire first row and part of the last row."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using DFS or BFS to explore all land cells connected to a given cell.",
      "Mark visited land cells to avoid counting them multiple times."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Partition Array Into Two Arrays to Minimize Sum Difference",
    "description": "Given an array of integers, you need to partition it into two non-empty subsets such that the absolute difference between the sums of the two subsets is minimized. Return the minimum possible sum difference. You can return the difference or any one of the subset sums directly if you choose to calculate it dynamically.",
    "topic": "Dynamic Programming",
    "subtopic": "Subset Sum",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Subset Sum"
    ],
    "input_format": "An array of integers nums, where nums[i] represents the ith element of the array.",
    "output_format": "An integer representing the minimum possible absolute sum difference between the two subsets.",
    "constraints": [
      "1 <= nums.length <= 200",
      "1 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [1, 6, 11, 5]",
        "output": "1",
        "explanation": "The optimal partition is [1, 5, 6] and [11]. Their sums are 12 and 11, respectively. The difference is |12 - 11| = 1."
      },
      {
        "input": "nums = [2, 4, 6, 8]",
        "output": "0",
        "explanation": "The optimal partition is [2, 4, 6] and [8]. Their sums are 12 and 8, respectively. The difference is |12 - 8| = 4. However, if we take [2, 8] and [4, 6], the difference becomes |10 - 10| = 0."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to keep track of possible sums.",
      "Think about how to split the total sum into two equal parts."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "LRU Cache",
    "description": "Design a data structure that implements a Least Recently Used (LRU) Cache. It should support the following operations: `get(key)` and `put(key, value)`. The `get` method should return the value of the key if the key exists in the cache, otherwise return -1. The `put` method should insert or update the value of the key. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item.",
    "topic": "Data Structures",
    "subtopic": "Cache",
    "tags": [
      "Cache",
      "Data Structure",
      "Design"
    ],
    "input_format": "The input consists of a maximum capacity and a series of operations to perform (get or put).",
    "output_format": "The output should reflect the results of the operations performed on the cache.",
    "constraints": [
      "1 <= capacity <= 3000",
      "0 <= key, value <= 10^4",
      "The number of operations will not exceed 10^4."
    ],
    "examples": [
      {
        "input": "cache = new LRUCache(2); cache.put(1, 1); cache.put(2, 2); cache.get(1); cache.put(3, 3); cache.get(2); cache.put(4, 4); cache.get(1); cache.get(3); cache.get(4);",
        "output": "[1,-1,-1,4]",
        "explanation": "After performing a series of operations, the cache returns results specific to the get operations. The key 2 was evicted when key 3 was added, so cache.get(2) returns -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map combined with a doubly linked list.",
      "The recently used items should be at the head of the list, while the least recently used should be at the tail."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Minimum Cost of a Path With Special Roads",
    "description": "You are given a grid representing a field, where each cell has a cost associated with traversing that cell. Additionally, there are special roads that allow you to travel between specific cells at a reduced cost. Your task is to find the minimum cost to travel from the top-left corner of the grid to the bottom-right corner. You can move to adjacent cells (up, down, left, right) and take the special roads if applicable. The output should be the minimum cost required.",
    "topic": "Graph",
    "subtopic": "Shortest Path",
    "tags": [
      "Graph",
      "Shortest Path",
      "Dynamic Programming"
    ],
    "input_format": "A 2D array of integers representing the grid costs and a list of special roads in the format [(x1, y1, x2, y2, cost)].",
    "output_format": "An integer representing the minimum cost to reach the bottom-right corner cell.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 100",
      "0 <= grid[i][j] <= 10^4",
      "1 <= special_roads.length <= 10^4",
      "0 <= cost <= 10^4"
    ],
    "examples": [
      {
        "input": "grid = [[1,3,1],[1,5,1],[4,2,1]], special_roads = [(0,0,1,1,2)]",
        "output": "7",
        "explanation": "The minimum cost path is to use the special road from (0,0) to (1,1) with cost 2, then move to (1,2) with cost 1, and finally to (2,2) with cost 1, totaling 7."
      },
      {
        "input": "grid = [[1,2],[1,1]], special_roads = []",
        "output": "4",
        "explanation": "Without any special roads, the minimum cost is moving down and then right, which costs 1 + 2 + 1 = 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Dijkstra's algorithm to find the shortest path.",
      "You can maintain a priority queue to explore neighboring cells efficiently."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of walls, compute how much water can be trapped after raining. The water trapped above each wall is determined by the height of the walls to the left and right.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers representing the heights of walls.",
    "output_format": "An integer representing the total amount of trapped rainwater.",
    "constraints": [
      "n == height.length",
      "1 <= n <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The water trapped is 6 units."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The water trapped is 9 units."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Think about how to calculate the water trapped at each position.",
      "Consider using two pointers to keep track of the left and right walls."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Minimize Deviation in Array",
    "description": "You are given an array of integers, where each integer represents the height of a building. The goal is to minimize the difference between the maximum height and the minimum height after performing some operations. You can either double the height of any building or reduce the height of any building to half (if it is even). Your task is to find the minimum possible deviation between the tallest and shortest buildings after performing these operations optimally.",
    "topic": "Array",
    "subtopic": "Heap",
    "tags": [
      "Array",
      "Heap",
      "Greedy"
    ],
    "input_format": "An array of integers heights representing the heights of the buildings.",
    "output_format": "An integer representing the minimum possible deviation between the maximum and minimum heights.",
    "constraints": [
      "1 <= heights.length <= 10^5",
      "1 <= heights[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "heights = [1, 2, 3, 4]",
        "output": "1",
        "explanation": "By doubling 1 to 2 and reducing 4 to 2, the heights become [2, 2, 3, 2]. The maximum height is 3 and minimum is 2, giving a deviation of 3 - 2 = 1."
      },
      {
        "input": "heights = [10, 20, 30, 40]",
        "output": "10",
        "explanation": "By reducing 40 to 20, the heights become [10, 20, 30, 20]. The maximum height is 30 and minimum is 10, giving a deviation of 30 - 20 = 10."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a max heap to keep track of the tallest building.",
      "Consider both operations (doubling and halving) to explore all possibilities."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Vertical Order Traversal of a Binary Tree",
    "description": "Given a binary tree, return the vertical order traversal of its nodes' values. For each node at position (x, y), the vertical order traversal consists of all nodes with the same x coordinate sorted by their y coordinate (nodes with a higher y coordinate come first). If two nodes have the same (x, y) coordinate, return the values in ascending order.",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Binary Tree",
      "Traversal"
    ],
    "input_format": "A root node of a binary tree.",
    "output_format": "A list of lists of integers representing the vertical order traversal.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[9],[3,15],[20],[7]]",
        "explanation": "The binary tree is: \n      3\n     / \\\n    9  20\n       /  \\\n      15   7\nThe vertical order traversal is: [9] for x = -1, [3,15] for x = 0, [20] for x = 1, [7] for x = 2."
      },
      {
        "input": "root = [1,2,3,4,5,6,7]",
        "output": "[[4],[2],[1,5,6],[3],[7]]",
        "explanation": "The binary tree is: \n        1\n      /   \\\n     2     3\n    / \\   / \\\n   4   5 6   7\nThe vertical order traversal is: [4] for x = -2, [2] for x = -1, [1,5,6] for x = 0, [3] for x = 1, [7] for x = 2."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a data structure to store nodes along with their x and y coordinates.",
      "Sort the nodes based on their coordinates before returning the output."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Maximum Height by Stacking Cuboids",
    "description": "Given a list of cuboids, each defined by three dimensions (width, length, height), your task is to determine the maximum possible height of stacked cuboids. A cuboid can be placed on top of another cuboid if its dimensions are less than or equal to those of the cuboid below it in all three dimensions.",
    "topic": "Dynamic Programming",
    "subtopic": "Longest Increasing Subsequence",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Sorting"
    ],
    "input_format": "A list of cuboids represented by a list of tuples, where each tuple contains three integers (width, length, height).",
    "output_format": "An integer representing the maximum height that can be achieved by stacking the cuboids.",
    "constraints": [
      "1 <= cuboids.length <= 100",
      "1 <= cuboids[i][j] <= 100"
    ],
    "examples": [
      {
        "input": "cuboids = [[1, 2, 3], [3, 2, 1], [2, 3, 4]]",
        "output": "5",
        "explanation": "The best way to stack is to place [1, 2, 3] under [2, 3, 4], giving a total height of 3 + 2 = 5."
      },
      {
        "input": "cuboids = [[4, 5, 6], [1, 2, 3], [7, 8, 9]]",
        "output": "15",
        "explanation": "The optimal stacking is [1, 2, 3] on top of [4, 5, 6] plus the height of [7, 8, 9], resulting in 3 + 6 + 9 = 15."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Sort the cuboids based on their dimensions.",
      "Use dynamic programming to calculate the maximum height."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Minimum Number of Operations to Make String Sorted",
    "description": "Given a string s, you can perform the following operation: remove one character from s. Your goal is to make the string sorted in non-decreasing order by performing the minimum number of operations. A string is considered sorted if for every i (0 <= i < s.length - 1), s[i] <= s[i + 1]. Return the minimum number of operations required to achieve this.",
    "topic": "String",
    "subtopic": "Sorting",
    "tags": [
      "String",
      "Sorting",
      "Dynamic Programming"
    ],
    "input_format": "A single string s consisting of lowercase English letters.",
    "output_format": "An integer representing the minimum number of operations required to make the string sorted.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of lowercase English letters only."
    ],
    "examples": [
      {
        "input": "s = 'cba'",
        "output": "2",
        "explanation": "By removing 'c' and 'b', we can make the string sorted as 'a'."
      },
      {
        "input": "s = 'aaa'",
        "output": "0",
        "explanation": "The string is already sorted, so no operations are required."
      },
      {
        "input": "s = 'bacd'",
        "output": "1",
        "explanation": "By removing 'b', we can make the string sorted as 'acd'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how many characters are out of place.",
      "Try to find the length of the longest sorted subsequence."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Substring with Concatenation of All Words",
    "description": "You are given a string s and an array of strings words of the same length. Each string in words is of the same length. You need to determine the starting indices of substring(s) in s that are a concatenation of each word in words exactly once and without any additional characters in between. The order of the words in the substring must match the order of the words in words. Return the starting indices of all such substrings in ascending order.",
    "topic": "String",
    "subtopic": "Substring",
    "tags": [
      "String",
      "Substring",
      "Sliding Window"
    ],
    "input_format": "A string s and an array of strings words.",
    "output_format": "A list of integers representing the starting indices of the substrings.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 100",
      "All words[i] have the same length."
    ],
    "examples": [
      {
        "input": {
          "s": "barfoothefoobarman",
          "words": [
            "foo",
            "bar"
          ]
        },
        "output": [
          0,
          9
        ],
        "explanation": "The substring starting at index 0 is 'barfoo' and the substring starting at index 9 is 'foobar'."
      },
      {
        "input": {
          "s": "wordgoodgoodgoodbestword",
          "words": [
            "word",
            "good",
            "best",
            "word"
          ]
        },
        "output": [],
        "explanation": "There are no substrings that match the concatenation of all words."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a sliding window to find the start index.",
      "Keep track of the count of each word."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Largest 1-Bordered Square",
    "description": "Given a 2D binary grid (0s and 1s), find the largest square containing only 1s and return its area. A square is '1-bordered' if its borders are all made up of 1s.",
    "topic": "Matrix",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Matrix",
      "Dynamic Programming",
      "Square",
      "Largest"
    ],
    "input_format": "A 2D binary grid represented as a list of lists, where each inner list contains 0s and 1s.",
    "output_format": "An integer representing the area of the largest 1-bordered square.",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[i].length <= 300",
      "grid[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "[[1,0,1],[1,1,1],[1,0,1]]",
        "output": "1",
        "explanation": "The largest 1-bordered square has an area of 1, as the cell (0,0) contains '1'."
      },
      {
        "input": "[[1,1,1],[1,1,1],[1,1,1]]",
        "output": "9",
        "explanation": "The entire grid is filled with 1s, so the largest 1-bordered square has an area of 3x3 = 9."
      },
      {
        "input": "[[0,0,0],[0,1,1],[0,1,1]]",
        "output": "4",
        "explanation": "The largest 1-bordered square is the 2x2 square at coordinates (1,1) to (2,2) with an area of 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider checking for square borders using dynamic programming.",
      "You might want to keep track of the size of the largest square ending at each cell."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Number of Paths with Max Score",
    "description": "You are given a 2D grid of integers where each cell represents a score. You can only move down or right from the top-left cell to the bottom-right cell. The score you can gather is the sum of the scores of the cells you pass through. Your task is to find the number of distinct paths that yield the maximum score possible.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Pathfinding",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Pathfinding"
    ],
    "input_format": "A 2D grid of integers, where grid[i][j] represents the score at cell (i, j).",
    "output_format": "An integer representing the number of distinct paths yielding the maximum score.",
    "constraints": [
      "1 <= grid.length, grid[0].length <= 100",
      "0 <= grid[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
        "output": "2",
        "explanation": "The two paths with maximum scores are: (0,0) -> (0,1) -> (1,1) -> (2,1) and (0,0) -> (1,0) -> (1,1) -> (2,1). Both yield a score of 9."
      },
      {
        "input": "grid = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "1",
        "explanation": "There is only one path from (0,0) to (2,2) that gives the maximum score of 21."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to store the maximum score up to each cell.",
      "Keep track of the number of ways to reach each cell with the maximum score."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Maximum Product of Two Elements in an Array",
    "description": "Given an integer array nums, you need to find the maximum product of any two distinct elements in the array. The maximum product is defined as the highest product obtained by multiplying two different elements in the array.",
    "topic": "Array",
    "subtopic": "Math",
    "tags": [
      "Array",
      "Math",
      "Product"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum product of two distinct elements.",
    "constraints": [
      "2 <= nums.length <= 100",
      "1 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [3, 5, 2, 8]",
        "output": "40",
        "explanation": "The two largest numbers are 5 and 8. Their product is 5 * 8 = 40."
      },
      {
        "input": "nums = [1, 4, 3, 6, 7, 0]",
        "output": "42",
        "explanation": "The two largest numbers are 6 and 7. Their product is 6 * 7 = 42."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Sort the array and pick the two largest elements.",
      "Consider using a single traversal to find the two largest elements."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Number of Nodes in the Sub-Tree With the Same Label",
    "description": "You are given a rooted tree where each node has a label represented as a lowercase English letter. For each node, you need to determine the number of nodes in its sub-tree that have the same label as that node. A node's sub-tree includes the node itself and all its descendants. Return an array where the i-th element is the count of nodes in the sub-tree with the same label for the node at index i.",
    "topic": "Tree",
    "subtopic": "Depth-First Search",
    "tags": [
      "Tree",
      "DFS",
      "Count"
    ],
    "input_format": "A list of labels representing the nodes of a tree, along with an array of edges denoting the parent-child relationships.",
    "output_format": "An array of integers representing the count of nodes with the same label in the sub-tree for each node.",
    "constraints": [
      "1 <= labels.length <= 10^5",
      "0 <= edges.length <= labels.length - 1",
      "labels[i] is a lowercase English letter."
    ],
    "examples": [
      {
        "input": {
          "labels": "abaac",
          "edges": [
            [
              0,
              1
            ],
            [
              0,
              2
            ],
            [
              2,
              3
            ],
            [
              2,
              4
            ]
          ]
        },
        "output": [
          3,
          1,
          3,
          1,
          1
        ],
        "explanation": "For node 0 (label 'a'), the sub-tree has nodes [0,1,2,3,4] with label 'a' counted 3 times. For node 1 (label 'b'), there are 1 such node (itself). For node 2 (label 'a'), there are 3 such nodes (0,2,3,4). And so on."
      },
      {
        "input": {
          "labels": "aaab",
          "edges": [
            [
              0,
              1
            ],
            [
              0,
              2
            ],
            [
              1,
              3
            ]
          ]
        },
        "output": [
          3,
          1,
          1,
          1
        ],
        "explanation": "For node 0, the count of 'a' in its sub-tree is 3, and so forth."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth-First Search (DFS) for traversing the tree.",
      "Count the occurrences of labels as you explore each node's sub-tree.",
      "You may need to maintain a count of labels as you traverse upwards."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Guess Number Higher or Lower",
    "description": "You are playing a game where you have to guess a number between 1 and a picked number 'n' (inclusive). The game will provide feedback whether your guess is too low, too high, or correct. Implement a function to find the number that the game is hiding based on your guesses.",
    "topic": "Binary Search",
    "subtopic": "Guessing Game",
    "tags": [
      "Binary Search",
      "Game",
      "Guessing"
    ],
    "input_format": "An integer n (1 <= n <= 2^31 - 1), representing the upper bound of the range.",
    "output_format": "An integer representing the correct number that has to be guessed.",
    "constraints": [
      "1 <= n <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "n = 10",
        "output": "6",
        "explanation": "Assuming the hidden number is 6, the guesses could be 3 (too low), 7 (too high), then 6 (correct)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a binary search approach to minimize the number of guesses.",
      "Maintain low and high pointers to adjust the search range."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Design Graph With Shortest Path Calculator",
    "description": "You are tasked with designing a graph where nodes represent cities and edges represent roads between them. You need to implement a shortest path calculator that can efficiently find the shortest distance between two cities. Your graph will support the addition of roads and the retrieval of shortest path distances. Given two cities (nodes), return the minimum distance to travel from the first city to the second city using Dijkstra's algorithm.",
    "topic": "Graph",
    "subtopic": "Shortest Path",
    "tags": [
      "Graph",
      "Dijkstra",
      "Shortest Path",
      "Design"
    ],
    "input_format": "Two city identifiers as strings and a list of roads represented as tuples, where each tuple contains two city identifiers and a distance.",
    "output_format": "An integer representing the shortest distance between the two specified cities.",
    "constraints": [
      "1 <= number of roads <= 10^4",
      "1 <= distance <= 10^6",
      "All city identifiers are unique strings."
    ],
    "examples": [
      {
        "input": {
          "roads": [
            [
              "A",
              "B",
              5
            ],
            [
              "B",
              "C",
              4
            ],
            [
              "A",
              "C",
              10
            ]
          ],
          "start_city": "A",
          "end_city": "C"
        },
        "output": "9",
        "explanation": "The shortest path from A to C is A -> B -> C with a total distance of 5 + 4 = 9."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a priority queue to efficiently retrieve the next node with the smallest tentative distance.",
      "Make sure to handle edge cases, such as non-connected nodes."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Find the Width of Columns of a Grid",
    "description": "Given a 2D grid of characters, return an array of integers where each integer represents the width of the corresponding column in the grid. The width of a column is defined as the maximum width of the characters in that column across all rows.",
    "topic": "Array",
    "subtopic": "2D Array",
    "tags": [
      "Array",
      "2D Array",
      "Grid"
    ],
    "input_format": "A 2D grid represented as an array of strings, where each string contains characters of the same length.",
    "output_format": "An array of integers representing the width of each column.",
    "constraints": [
      "1 <= grid.length <= 100",
      "1 <= grid[i].length <= 100",
      "grid[i].length == grid[j].length for all 0 <= i, j < grid.length"
    ],
    "examples": [
      {
        "input": "grid = [\"abc\", \"de\", \"fgh\"]",
        "output": "[3, 2]",
        "explanation": "The widths of the columns are 3 and 2 respectively."
      },
      {
        "input": "grid = [\"a\", \"b\", \"c\", \"d\"]",
        "output": "[1]",
        "explanation": "There is only one column, and its width is 1."
      },
      {
        "input": "grid = [\"hello\", \"world\", \"hi\"]",
        "output": "[5]",
        "explanation": "The width of the single column is 5, as 'hello' is the longest."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Iterate through each column and calculate the maximum width by checking the length of each character in that column."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Faulty Keyboard",
    "description": "You are given a string that represents a text typed on a faulty keyboard. In this keyboard, some characters may not show up correctly: every time a character is typed, it might appear either correctly or as a sequence of asterisks ('*'). Your task is to determine if the original text can be reconstructed from the typed string, considering that two identical characters cannot occur after an asterisk unless they are typed again correctly in the following characters.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Validation"
    ],
    "input_format": "A single string `typed` which is the output from the faulty keyboard.",
    "output_format": "A boolean value indicating whether the original text can be reconstructed.",
    "constraints": [
      "1 <= typed.length <= 10^5",
      "The string contains only lowercase letters and asterisks."
    ],
    "examples": [
      {
        "input": "typed = 'a*b*a**'",
        "output": "true",
        "explanation": "The possible reconstruction can be 'aba', where 'a' appears before and after the '*' characters."
      },
      {
        "input": "typed = 'a**b*a'",
        "output": "false",
        "explanation": "The 'b' followed by 'a' is invalid because they cannot appear after the asterisks without being typed again."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a stack to track the characters.",
      "Iterate through the string while handling the asterisks appropriately."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Mark Elements on Array by Performing Queries",
    "description": "You are given an array of integers and a list of queries. Each query contains two integers, start and end, representing the inclusive range of indices in the array. Your task is to mark the elements in the specified range of the array for each query. After processing all queries, return the modified array where marked elements are represented by -1. If an element is marked by more than one query, keep it as -1.",
    "topic": "Array",
    "subtopic": "Range Queries",
    "tags": [
      "Array",
      "Queries",
      "Marking"
    ],
    "input_format": "An array of integers arr followed by an array of queries where each query is represented as a list of two integers [start, end].",
    "output_format": "An array of integers with the marked elements replaced by -1.",
    "constraints": [
      "1 <= arr.length <= 10^5",
      "-10^5 <= arr[i] <= 10^5",
      "1 <= queries.length <= 10^4",
      "0 <= start <= end < arr.length"
    ],
    "examples": [
      {
        "input": {
          "arr": [
            1,
            2,
            3,
            4,
            5
          ],
          "queries": [
            [
              0,
              2
            ],
            [
              1,
              3
            ]
          ]
        },
        "output": [
          -1,
          -1,
          -1,
          -1,
          5
        ],
        "explanation": "The first query marks the elements at indices 0 to 2 (1, 2, 3) as -1. The second query marks elements at indices 1 to 3 (2, 3, 4) as -1. Thus, the final array is [-1, -1, -1, -1, 5]."
      },
      {
        "input": {
          "arr": [
            10,
            20,
            30,
            40,
            50
          ],
          "queries": [
            [
              1,
              4
            ],
            [
              0,
              2
            ]
          ]
        },
        "output": [
          -1,
          -1,
          -1,
          -1,
          -1
        ],
        "explanation": "Both queries cover the range of all elements in the array, so everything is marked as -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a boolean array to track which indices should be marked.",
      "You can iterate through the queries and update the boolean array accordingly."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Stone Game IX",
    "description": "Alice and Bob are playing a game with a pile of stones. Initially, there are `n` stones in the pile. They take turns removing stones from the pile according to the following rules: on their turn, a player can remove either 1 or 2 stones. The player who removes the last stone wins the game. Alice always goes first. The goal is to determine if Alice can guarantee her win given the total number of stones in the pile.",
    "topic": "Game Theory",
    "subtopic": "Turn-based Game",
    "tags": [
      "Game Theory",
      "Dynamic Programming",
      "Recursion"
    ],
    "input_format": "An integer n, representing the total number of stones in the pile.",
    "output_format": "Return true if Alice can guarantee her victory, otherwise return false.",
    "constraints": [
      "1 <= n <= 10^5"
    ],
    "examples": [
      {
        "input": "n = 1",
        "output": "true",
        "explanation": "Alice can take the only stone and win."
      },
      {
        "input": "n = 2",
        "output": "true",
        "explanation": "Alice can take both stones and win."
      },
      {
        "input": "n = 3",
        "output": "false",
        "explanation": "No matter how many stones Alice takes (1 or 2), Bob can always take the remaining stones and win."
      },
      {
        "input": "n = 4",
        "output": "true",
        "explanation": "Alice can take 1 stone, leaving 3 for Bob. Bob has to leave 1 or 2 for Alice to win."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the throw quantities Alice can take and how Bob will react.",
      "Look for patterns in the winning and losing positions."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Count Prefix and Suffix Pairs II",
    "description": "You are given an array of strings. Your task is to count the number of pairs (i, j) such that the concatenation of the two strings, strings[i] + strings[j], is a prefix of another string in the array. The pairs (i, j) must be distinct and can be in any order. Return the total count of such pairs.",
    "topic": "String",
    "subtopic": "Prefix and Suffix",
    "tags": [
      "String",
      "Prefix",
      "Suffix",
      "Counting"
    ],
    "input_format": "An array of strings 'strings'.",
    "output_format": "An integer representing the count of valid (i, j) pairs.",
    "constraints": [
      "1 <= strings.length <= 1000",
      "1 <= strings[i].length <= 100"
    ],
    "examples": [
      {
        "input": "strings = [\"a\", \"ab\", \"abc\", \"bc\", \"b\"]",
        "output": "3",
        "explanation": "The valid pairs are ('a', 'b'), ('a', 'ab'), and ('ab', 'b') making the total count 3."
      },
      {
        "input": "strings = [\"hello\", \"he\", \"hell\", \"lo\", \"o\"]",
        "output": "2",
        "explanation": "The valid pairs are ('he', 'llo') and ('hell', 'o')."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a hash map to store the string combinations.",
      "Focus on how concatenation affects string prefixes."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Two Sum IV - Input is a BST",
    "description": "Given a binary search tree (BST) and a target value, return true if there exist two elements in the BST such that their sum is equal to the target value. Your solution should have a time complexity of O(n), where n is the number of nodes in the tree.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Two Pointers",
      "Hash Table"
    ],
    "input_format": "The function receives the root of a binary search tree and an integer target.",
    "output_format": "Return true if there are two numbers in the BST that add up to the target, otherwise return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 10^4].",
      "Each node's value is unique.",
      "-10^4 <= root.val <= 10^4",
      "-10^4 <= target <= 10^4"
    ],
    "examples": [
      {
        "input": "root = [5, 3, 6, 2, 4, null, 7], target = 9",
        "output": "true",
        "explanation": "The values 4 and 5 from the tree add up to 9."
      },
      {
        "input": "root = [5, 3, 6, 2, 4, null, 7], target = 28",
        "output": "false",
        "explanation": "No two elements in the BST add up to 28."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a set to track the complements of the target as you traverse the tree.",
      "In a BST, in-order traversal will give you a sorted order of values."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Dynamic Programming",
    "subtopic": "Maximizing Profit",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices representing stock prices on different days.",
    "output_format": "An integer representing the maximum profit possible.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price encountered so far.",
      "Update the maximum profit based on the current price and the minimum price."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Is Graph Bipartite?",
    "description": "Given an undirected graph, determine if it is bipartite. A graph is bipartite if you can split its set of vertices into two groups such that no two vertices within the same group are adjacent. You can represent the graph as an adjacency list or adjacency matrix.",
    "topic": "Graph",
    "subtopic": "Bipartite Check",
    "tags": [
      "Graph",
      "Bipartite",
      "Breadth-First Search"
    ],
    "input_format": "An integer n representing the number of nodes, followed by a 2D array edges where each edge represents a connection between two nodes.",
    "output_format": "A boolean value indicating whether the graph is bipartite.",
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= edges.length <= 10^4",
      "0 <= edges[i][0], edges[i][1] < n"
    ],
    "examples": [
      {
        "input": "n = 4, edges = [[0, 1], [0, 3], [1, 2], [2, 3]]",
        "output": "false",
        "explanation": "The graph is not bipartite because nodes 1 and 3 have the same color in the bipartite coloring."
      },
      {
        "input": "n = 5, edges = [[0, 1], [0, 2], [1, 3], [2, 4]]",
        "output": "true",
        "explanation": "The graph can be colored with two colors, satisfying the bipartite condition."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using BFS or DFS for graph traversal.",
      "Keep track of the color assigned to each vertex."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers and a target integer, return the indices of the two numbers such that they add up to the target. Assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Sum"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "A list containing the indices of the two numbers that add up to the target.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 2 + 7 = 9."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "nums[1] + nums[2] = 2 + 4 = 6."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 3 + 3 = 6."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a hash map to store the indices of the numbers."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Maximum Subarray",
      "Kadane's Algorithm"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum sum of the contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum = 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The only subarray is [1], which has a sum of 1."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The subarray [5,4,-1,7,8] has the largest sum = 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the current element and the maximum sum ending at that element.",
      "Use a variable to keep track of the maximum sum so far."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Hashing"
    ],
    "input_format": "An integer array nums with n elements.",
    "output_format": "A list of unique triplets that sum up to zero.",
    "constraints": [
      "0 <= n <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that give a sum of zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "No triplets can be formed."
      },
      {
        "input": "nums = [0, 1, 1]",
        "output": "[]",
        "explanation": "No triplets can be formed that sum to zero."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array to facilitate finding triplets.",
      "Use a two-pointer technique to find pairs that complement a specific number."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Rotting Oranges",
    "description": "In a grid of oranges represented by a 2D array, some oranges are fresh (represented by 1), some are rotten (represented by 2), and some are empty (represented by 0). Every minute, any fresh orange that is adjacent (horizontally or vertically) to a rotten orange becomes rotten. Your task is to determine the minimum number of minutes needed for all fresh oranges to become rotten. If it is not possible for all fresh oranges to rot, return -1.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "Matrix"
    ],
    "input_format": "A 2D grid with integers where 0 = empty, 1 = fresh orange, 2 = rotten orange.",
    "output_format": "An integer representing the minimum number of minutes required for all fresh oranges to rot, or -1 if not possible.",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[i].length <= 300",
      "grid[i][j] is either 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
        "output": "4",
        "explanation": "In 4 minutes, all fresh oranges become rotten."
      },
      {
        "input": "grid = [[2,1,1],[0,1,1],[1,0,2]]",
        "output": "-1",
        "explanation": "It is not possible for all fresh oranges to rot."
      },
      {
        "input": "grid = [[0,2]]",
        "output": "0",
        "explanation": "There are no fresh oranges to rot."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to perform BFS.",
      "Count fresh oranges initially and keep track of them.",
      "For every rotten orange processed, increment time for adjacent fresh oranges."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Possible Bipartition",
    "description": "You are given a graph represented as an integer n representing the number of nodes and a 2D array of connections where connections[i] = [ai, bi] indicates that there is a connection between nodes ai and bi. Your task is to determine if it is possible to partition the graph into two groups such that no two nodes in the same group share an edge. If it is possible to do so, return true; otherwise, return false.",
    "topic": "Graph",
    "subtopic": "Bipartite Graph",
    "tags": [
      "Graph",
      "Bipartite",
      "DFS",
      "BFS"
    ],
    "input_format": "An integer n followed by a 2D array connections of size m.",
    "output_format": "A boolean value: true if the graph can be bipartitioned, false otherwise.",
    "constraints": [
      "1 <= n <= 100",
      "0 <= m <= 1000",
      "1 <= connections[i][0], connections[i][1] <= n"
    ],
    "examples": [
      {
        "input": "n = 4, connections = [[1,2],[1,3],[2,4]]",
        "output": "true",
        "explanation": "The nodes can be divided into two groups: {1, 4} and {2, 3}."
      },
      {
        "input": "n = 3, connections = [[1,2],[1,3],[2,3]]",
        "output": "false",
        "explanation": "There are edges between nodes 2 and 3, so they cannot be in the same group."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using DFS or BFS to color the graph.",
      "If you find a conflict in coloring, return false."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Maximize Distance to Closest Person",
    "description": "You are given an array representing a row of seats where 1 represents a person sitting in that seat and 0 represents an empty seat. Your task is to determine the maximum distance from a person sitting to the closest empty seat. The distance is defined as the number of empty seats between two seats. If there are empty seats at both ends, consider them as well in the distance calculation.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Greedy"
    ],
    "input_format": "An array of integers seats, where each integer is either 0 or 1.",
    "output_format": "An integer representing the maximum distance to the closest person.",
    "constraints": [
      "1 <= seats.length <= 2 * 10^4",
      "seats[i] is 0 or 1",
      "At least one seat will be empty."
    ],
    "examples": [
      {
        "input": "seats = [1,0,0,0,1,0,1]",
        "output": "2",
        "explanation": "The maximum distance is 2, which is the distance between the two people at index 0 and index 4, with the empty seats at index 1, 2, and 3."
      },
      {
        "input": "seats = [1,0,0,0]",
        "output": "3",
        "explanation": "The only person is at index 0, and the maximum distance to the closest person is 3, which is the distance from index 0 to index 3."
      },
      {
        "input": "seats = [0,0,0,1]",
        "output": "3",
        "explanation": "The only person is at index 3, and the maximum distance to the closest person is 3, from index 0 to index 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the gaps between seated persons.",
      "Use two pointers to track distances."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Palindrome Number",
    "description": "Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome while 123 is not.",
    "topic": "Math",
    "subtopic": "Integer Manipulation",
    "tags": [
      "Palindrome",
      "Math",
      "Integer"
    ],
    "input_format": "An integer x.",
    "output_format": "Return true if x is a palindrome, otherwise return false.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 121",
        "output": "true",
        "explanation": "121 reads the same backward as forward."
      },
      {
        "input": "x = -121",
        "output": "false",
        "explanation": "-121 reads backward as 121-, which is not the same."
      },
      {
        "input": "x = 10",
        "output": "false",
        "explanation": "10 reads backward as 01, which is not the same."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how to reverse the number.",
      "You can ignore negative signs since they cannot be palindromic."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "Stack",
      "String",
      "Validation"
    ],
    "input_format": "A string s consisting of parentheses symbols.",
    "output_format": "A boolean value indicating whether the string is valid.",
    "constraints": [
      "0 <= s.length <= 10^4",
      "s consists of parentheses only '(){}[]'."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The parentheses are closed in the correct order, making the string valid."
      },
      {
        "input": "s = '([)]'",
        "output": "false",
        "explanation": "The brackets are closed in the wrong order, making the string invalid."
      },
      {
        "input": "s = '{[]}'",
        "output": "true",
        "explanation": "All brackets are validly closed and nested."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "For every closing bracket, check if the top of the stack matches the corresponding opening bracket."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Coin Change",
    "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. You want to determine the number of combinations that make up that amount. You may assume that you have an infinite number of each kind of coin. The answer is guaranteed to be less than or equal to 2^31 - 1.",
    "topic": "Dynamic Programming",
    "subtopic": "Combinatorial Problems",
    "tags": [
      "Dynamic Programming",
      "Combinatorics",
      "Array"
    ],
    "input_format": "An integer array coins[] representing coin denominations and an integer amount.",
    "output_format": "An integer representing the number of combinations that make up the amount.",
    "constraints": [
      "0 <= coins.length <= 300",
      "1 <= coins[i] <= 5000",
      "0 <= amount <= 5000"
    ],
    "examples": [
      {
        "input": "coins = [1, 2, 5], amount = 5",
        "output": "4",
        "explanation": "There are four combinations to make up the amount 5: [1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 2, 2], [5]."
      },
      {
        "input": "coins = [2], amount = 3",
        "output": "0",
        "explanation": "No combinations can make up the amount 3 since the only coin is 2."
      },
      {
        "input": "coins = [10], amount = 10",
        "output": "1",
        "explanation": "There is one combination to make up the amount 10: [10]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store the number of ways to form amounts.",
      "Start filling up the ways for the smallest amounts and work your way up.",
      "Think about how to use existing combinations to build up to larger amounts."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Implement Trie (Prefix Tree)",
    "description": "Design a data structure that implements a prefix tree (or trie) and supports the following operations:\n\n1. **insert(word)**: Inserts the word into the trie.\n2. **search(word)**: Returns true if the word is in the trie.\n3. **startsWith(prefix)**: Returns true if there is any word in the trie that starts with the given prefix.\n\nYou may assume that all inputs are lowercase alphabets and the operations will be called only with valid inputs.",
    "topic": "Data Structure",
    "subtopic": "Trie",
    "tags": [
      "Trie",
      "Data Structure",
      "String"
    ],
    "input_format": "There are three types of operations: insert, search, and startsWith. Each operation takes a string as input.",
    "output_format": "For search and startsWith operations, return a boolean value indicating the result.",
    "constraints": [
      "1 <= word.length <= 200",
      "1 <= prefix.length <= 200",
      "The trie should support up to 1000 distinct words."
    ],
    "examples": [
      {
        "input": "insert(\"apple\"); search(\"apple\"); search(\"app\"); startsWith(\"app\"); insert(\"app\"); search(\"app\");",
        "output": "[null,true,false,true,null,true]",
        "explanation": "After inserting \"apple\", the search for \"apple\" returns true. However, searching for \"app\" returns false since it hasn't been inserted yet. 'startsWith' returns true as there is a word starting with \"app\". After inserting \"app\", searching for \"app\" returns true."
      },
      {
        "input": "insert(\"banana\"); search(\"ban\"); startsWith(\"ban\");",
        "output": "[null,false,true]",
        "explanation": "After inserting \"banana\", searching for \"ban\" returns false because \"ban\" is not a complete word in the trie. But 'startsWith' returns true since \"banana\" starts with \"ban\"."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to represent each node in the trie.",
      "Use a hash map or an array to store child nodes.",
      "Think about how to handle the end of a word."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list.",
    "topic": "Linked List",
    "subtopic": "Addition",
    "tags": [
      "Linked List",
      "Math",
      "Simulation"
    ],
    "input_format": "The input consists of two linked lists l1 and l2 where l1 and l2 are the head nodes of the linked lists.",
    "output_format": "Return the head node of the new linked list representing the sum.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the result will not exceed the maximum possible value of a 32-bit integer."
    ],
    "examples": [
      {
        "input": "l1 = [2, 4, 3], l2 = [5, 6, 4]",
        "output": "[7, 0, 8]",
        "explanation": "The numbers represented by the linked lists are 342 and 465. Their sum is 807, which is represented by the linked list [7, 0, 8]."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "The sum of 0 and 0 is 0, represented by the linked list [0]."
      },
      {
        "input": "l1 = [9, 9, 9, 9, 9, 9, 9], l2 = [9, 9, 9, 9]",
        "output": "[8, 9, 9, 9, 0, 0, 1]",
        "explanation": "The sum of the two numbers is 9999999 and 9999, which equals 10009998, represented by the linked list [8, 9, 9, 9, 0, 0, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how you typically add numbers manually, starting from the least significant digit.",
      "Use a carry variable to handle sums greater than 9."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Make Sum Divisible by P",
    "description": "Given an integer array nums and another integer p, return the minimum number of elements that need to be removed from the array such that the sum of the remaining elements is divisible by p. If it is not possible, return -1.",
    "topic": "Array",
    "subtopic": "Modular Arithmetic",
    "tags": [
      "Array",
      "Mathematics",
      "Modular Arithmetic"
    ],
    "input_format": "An array of integers nums followed by an integer p.",
    "output_format": "An integer indicating the minimum number of elements to remove, or -1 if it is not possible.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i] <= 10^9",
      "1 <= p <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3, 6, 2, 5], p = 7",
        "output": "1",
        "explanation": "Removing 5 leaves us with the sum 3 + 6 + 2 = 11, which is divisible by 7."
      },
      {
        "input": "nums = [1, 2, 3], p = 3",
        "output": "0",
        "explanation": "The sum of all elements (1 + 2 + 3 = 6) is already divisible by 3."
      },
      {
        "input": "nums = [1, 2, 3], p = 7",
        "output": "-1",
        "explanation": "There is no way to remove elements to make the sum divisible by 7."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try calculating the total sum of the array first.",
      "Consider the remainders of the elements when divided by p.",
      "Look for patterns in removing elements to achieve divisibility."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. An interval is defined by a start and an end time, represented as [start, end]. If two intervals overlap, they should be combined into a single interval. For example, if you have two intervals [1, 3] and [2, 4], they overlap and should be merged into [1, 4].",
    "topic": "Array",
    "subtopic": "Sorting and Merging",
    "tags": [
      "Array",
      "Sorting",
      "Intervals",
      "Merge"
    ],
    "input_format": "A list of intervals, where each interval is represented as a list of two integers [start, end].",
    "output_format": "A list of merged intervals, where each interval is represented as a list of two integers [start, end].",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "[[1,3],[2,6],[8,10],[15,18]]",
        "output": [
          [
            1,
            6
          ],
          [
            8,
            10
          ],
          [
            15,
            18
          ]
        ],
        "explanation": "The intervals [1,3] and [2,6] overlap, so they are merged into [1,6]. The other intervals do not overlap."
      },
      {
        "input": "[[1,4],[4,5]]",
        "output": [
          [
            1,
            5
          ]
        ],
        "explanation": "The intervals [1,4] and [4,5] touch each other, hence they are merged into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on the start time.",
      "Use a result list to hold merged intervals.",
      "Only merge intervals if they overlap."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Word Search",
    "description": "Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where 'adjacent' cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "topic": "Backtracking",
    "subtopic": "Depth-First Search",
    "tags": [
      "Backtracking",
      "DFS",
      "Matrix"
    ],
    "input_format": "A 2D grid of characters board and a string word.",
    "output_format": "True if the word exists in the grid; otherwise, false.",
    "constraints": [
      "m == board.length",
      "n == board[i].length",
      "1 <= m, n <= 6",
      "1 <= word.length <= 15",
      "board[i][j] is a lowercase English letter."
    ],
    "examples": [
      {
        "input": "board = [['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']]\nword = 'ABCCED'",
        "output": "true",
        "explanation": "The word 'ABCCED' can be constructed by the following path: A -> B -> C -> C -> E -> D."
      },
      {
        "input": "board = [['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']]\nword = 'SEE'",
        "output": "true",
        "explanation": "The word 'SEE' can be constructed by the following path: S -> E -> E."
      },
      {
        "input": "board = [['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']]\nword = 'ABCB'",
        "output": "false",
        "explanation": "The word 'ABCB' cannot be constructed because the letter B is being used more than once."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth-First Search to explore possible paths.",
      "Track the path taken to avoid reusing the same cell."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "N-Queens",
    "description": "The N-Queens puzzle is the problem of placing N chess queens on an N\u00d7N chessboard so that no two queens threaten each other. This means that no two queens can be in the same row, the same column, or on the same diagonal. Implement a function that returns all distinct solutions to the N-Queens puzzle.",
    "topic": "Backtracking",
    "subtopic": "Combinatorial Problem",
    "tags": [
      "Backtracking",
      "Depth-First Search",
      "Combinatorial"
    ],
    "input_format": "An integer n representing the size of the chessboard (n x n).",
    "output_format": "A list of solutions, where each solution is represented as an array of strings. Each string represents a row of the chessboard and contains 'Q' for a queen and '.' for an empty square.",
    "constraints": [
      "1 <= n <= 15"
    ],
    "examples": [
      {
        "input": "4",
        "output": [
          [
            ".Q..",
            "...Q",
            "Q...",
            "..Q."
          ],
          [
            "..Q.",
            "Q...",
            "...Q",
            ".Q.."
          ]
        ],
        "explanation": "There are two distinct solutions to the 4-Queens problem."
      },
      {
        "input": "1",
        "output": [
          [
            "Q"
          ]
        ],
        "explanation": "There is only one solution for the 1-Queens problem."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how a queen's movement affects placement on the board.",
      "Use backtracking to try placing queens and check for conflicts."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Jump Game II",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Write a function that returns the minimum number of jumps needed to reach the last index. If it is not possible to reach the last index, return -1.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "An integer representing the minimum number of jumps to reach the last index, or -1 if it is not possible.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "2",
        "explanation": "Jump 1 step from index 0 to 1, then 1 jump to the last index."
      },
      {
        "input": "nums = [2,3,0,1,4]",
        "output": "2",
        "explanation": "Jump 1 step from index 0 to 1, then 1 jump to reach the last index."
      },
      {
        "input": "nums = [0]",
        "output": "0",
        "explanation": "You are already at the last index."
      },
      {
        "input": "nums = [1,0,0,0]",
        "output": "-1",
        "explanation": "It is not possible to reach the last index."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how far you can jump from each position.",
      "Keep track of the maximum reachable index.",
      "Use a greedy approach to minimize the number of jumps."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Binary Tree Maximum Path Sum",
    "description": "Given a non-empty binary tree, return the maximum path sum. The path must be connected and can start and end at any node in the tree. A path sum is defined as the sum of the values of the nodes in the path. Note that the path does not need to pass through the root.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth-First Search"
    ],
    "input_format": "A non-empty binary tree represented by its root node, where each node contains an integer value.",
    "output_format": "An integer representing the maximum path sum.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 3 * 10^4].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3]",
        "output": "6",
        "explanation": "The path is: 2 -> 1 -> 3, which gives a maximum path sum of 2 + 1 + 3 = 6."
      },
      {
        "input": "root = [-10, 9, 20, null, null, 15, 7]",
        "output": "42",
        "explanation": "The path is: 15 -> 20 -> 7, which gives a maximum path sum of 15 + 20 + 7 = 42."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider paths that can start and end at any node.",
      "Use recursion to calculate the max path sum at each node.",
      "Keep track of the maximum path sum found during the recursion."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Find Median from Data Stream",
    "description": "The median is the value separating the higher half from the lower half of a data sample. Given a continuous stream of integers, implement a data structure that supports the following operations: `addNum(int num)` - Add a number to the data stream and `findMedian()` - Find the median of all numbers added so far. The median can be defined as: if the total number of numbers is odd, the median is the middle number. If it is even, the median is the average of the two middle numbers.",
    "topic": "Design",
    "subtopic": "Data Structure",
    "tags": [
      "Heap",
      "Design",
      "Streaming"
    ],
    "input_format": "You will be given a series of integers in a single stream.",
    "output_format": "An integer or a float representing the median of the numbers in the stream.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "addNum(1)\naddNum(2)\nfindMedian()",
        "output": "1.5",
        "explanation": "The numbers added are 1 and 2. The median is (1 + 2) / 2 = 1.5."
      },
      {
        "input": "addNum(3)\nfindMedian()",
        "output": "2.0",
        "explanation": "After adding 3, the numbers are 1, 2, and 3. The median is 2."
      },
      {
        "input": "addNum(4)\naddNum(5)\nfindMedian()",
        "output": "3.0",
        "explanation": "The numbers added are 1, 2, 3, 4, and 5. The median is 3."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using two heaps to maintain the lower and upper halves of the stream.",
      "The max-heap can store the lower half and the min-heap for the upper half."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Meeting Rooms II",
    "description": "Given an array of meeting time intervals where intervals[i] = [start_i, end_i], return the minimum number of meeting rooms required to hold all the meetings.",
    "topic": "Greedy",
    "subtopic": "Sorting",
    "tags": [
      "Greedy",
      "Sorting",
      "Interval"
    ],
    "input_format": "An array of intervals, where each interval is represented as a pair of integers [start, end].",
    "output_format": "An integer representing the minimum number of meeting rooms required.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "0 <= start_i < end_i <= 10^6"
    ],
    "examples": [
      {
        "input": "intervals = [[0, 30], [5, 10], [15, 20]]",
        "output": "2",
        "explanation": "At time 5, there are two meetings happening simultaneously: [0, 30] and [5, 10]. Thus, a minimum of 2 rooms are required."
      },
      {
        "input": "intervals = [[7, 10], [2, 4]]",
        "output": "1",
        "explanation": "Both meetings do not overlap and can be held in the same room."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals by their start time to manage overlapping meetings effectively."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Word Ladder",
    "description": "Given two words (beginWord and endWord), and a dictionary's word list, find the length of the shortest transformation sequence from beginWord to endWord. A transformation sequence is defined as a sequence of words starting with beginWord, where each word in the sequence must differ by exactly one letter from the previous word, and all the words in the sequence (except the first and last) must be in the word list. Note that beginWord is not a word in the word list. If there is no such transformation sequence, return 0.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "Graph",
      "BFS",
      "Word Ladder"
    ],
    "input_format": "A string beginWord, a string endWord, and a list of strings wordList.",
    "output_format": "An integer representing the length of the shortest transformation sequence, or 0 if no such sequence exists.",
    "constraints": [
      "1 <= beginWord.length <= 10",
      "1 <= endWord.length <= 10",
      "1 <= wordList.length <= 5000",
      "beginWord, endWord, and all words in wordList consist of lowercase English letters.",
      "beginWord != endWord",
      "All words are distinct.",
      "endWord will not be in the wordList."
    ],
    "examples": [
      {
        "input": {
          "beginWord": "hit",
          "endWord": "cog",
          "wordList": [
            "hot",
            "dot",
            "dog",
            "lot",
            "log",
            "cog"
          ]
        },
        "output": 5,
        "explanation": "One shortest transformation sequence is 'hit' -> 'hot' -> 'dot' -> 'dog' -> 'cog', which has a length of 5."
      },
      {
        "input": {
          "beginWord": "hit",
          "endWord": "cog",
          "wordList": [
            "hot",
            "dot",
            "dog",
            "lot",
            "log"
          ]
        },
        "output": 0,
        "explanation": "The endWord 'cog' is not present in the wordList, hence no transformation sequence exists."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a queue to facilitate breadth-first search.",
      "Think about generating all possible words by changing each letter."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "4Sum",
    "description": "Given an array of integers nums and an integer target, return all unique quadruplets (a, b, c, d) such that a + b + c + d = target. The solution set must not contain duplicate quadruplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Hash Table"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "A list of unique quadruplets that sum to the target.",
    "constraints": [
      "0 <= nums.length <= 200",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 0, -1, 0, -2, 2], target = 0",
        "output": "[[-2, -1, 0, 1], [0, 0, 0, 0]]",
        "explanation": "The quadruplets that sum to 0 are [-2, -1, 0, 1] and [0, 0, 0, 0]."
      },
      {
        "input": "nums = [] , target = 0",
        "output": "[]",
        "explanation": "Since the input array is empty, there are no quadruplets."
      },
      {
        "input": "nums = [2, 2, 2, 2], target = 8",
        "output": "[[2, 2, 2, 2]]",
        "explanation": "The only quadruplet is [2, 2, 2, 2] which sums to 8."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array first to make it easier to avoid duplicates.",
      "Use a four-pointer approach to efficiently find quadruplets.",
      "Consider combinations and track unique results using a set."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \" \" .",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Prefix",
      "Array"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A string representing the longest common prefix.",
    "constraints": [
      "0 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "All strings consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The common prefix among 'flower', 'flow', and 'flight' is 'fl'."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among 'dog', 'racecar', and 'car'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Check the first string and compare it with others.",
      "Use vertical scanning method or horizontal scanning method."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "Given n non-negative integers a1, a2, ..., an where each represents a point at the coordinates (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with the x-axis forms a container, such that the container contains the most water. Return the area of the largest container.",
    "topic": "Two Pointers",
    "subtopic": "Container With Most Water",
    "tags": [
      "Two Pointers",
      "Array",
      "Greedy"
    ],
    "input_format": "An integer array heights representing the heights of the lines.",
    "output_format": "An integer representing the maximum area of water that can be contained.",
    "constraints": [
      "2 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The max area is between lines at index 1 and 8 which has height 7, and the distance between them is 7. Thus, area = min(8, 7) * (8 - 1) = 49."
      },
      {
        "input": "heights = [1,1]",
        "output": "1",
        "explanation": "The area formed is 1 because both heights are 1 and the distance is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the width and the height when calculating the area.",
      "Try to optimize by moving from both ends towards the center."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A palindromic substring is a substring that reads the same backward as forward. If there are multiple longest palindromic substrings, return any one of them.",
    "topic": "String",
    "subtopic": "Palindrome",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A single string s with length in the range [1, 1000].",
    "output_format": "A string representing the longest palindromic substring in s.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consist of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "babad",
        "output": "bab",
        "explanation": "Both 'bab' and 'aba' are valid longest palindromic substrings."
      },
      {
        "input": "cbbd",
        "output": "bb",
        "explanation": "'bb' is the longest palindromic substring."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding around the center of the palindrome.",
      "A palindrome can be of even or odd length."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of k linked lists, each linked list is sorted in ascending order. Merge all the linked lists into one sorted linked list and return it. The merged list should be made by splicing together the nodes of the given k lists.",
    "topic": "Linked List",
    "subtopic": "Merging",
    "tags": [
      "Linked List",
      "Sorting",
      "Merge"
    ],
    "input_format": "An array of k linked lists, where each linked list is represented as a head node.",
    "output_format": "A single linked list that represents the merged sorted linked list.",
    "constraints": [
      "0 <= k <= 10^4",
      "0 <= n <= 500",
      "The total number of nodes in all lists combined is at most 10^4."
    ],
    "examples": [
      {
        "input": "[1->4->5, 1->3->4, 2->6]",
        "output": "1->1->2->3->4->4->5->6",
        "explanation": "The merged linked list is obtained by splicing the nodes together in sorted order."
      },
      {
        "input": "[]",
        "output": "",
        "explanation": "An empty input list should return an empty linked list."
      },
      {
        "input": "[ ] -> [ 0 ]",
        "output": "0",
        "explanation": "Merging a non-empty list with an empty one should return the non-empty list."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a priority queue to efficiently merge the lists.",
      "Iterate through each list, adding the nodes to a heap based on their values."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Subarray Product Less Than K",
    "description": "Given an array of positive integers nums and a positive integer k, return the number of continuous subarrays where the product of all the elements in the subarray is strictly less than k.",
    "topic": "Array",
    "subtopic": "Subarray Product",
    "tags": [
      "Array",
      "Sliding Window",
      "Product"
    ],
    "input_format": "An array of positive integers nums and a positive integer k.",
    "output_format": "An integer representing the number of continuous subarrays with a product less than k.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i] < k <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [10, 5, 2, 6], k = 100",
        "output": "8",
        "explanation": "The subarrays with products less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], and [10, 5, 2]."
      },
      {
        "input": "nums = [1, 2, 3], k = 0",
        "output": "0",
        "explanation": "No subarray can have a product less than 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use the sliding window technique to maintain the product of the current subarray.",
      "If the product is not less than k, move the left pointer to reduce the product."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Reverse Integer",
    "description": "Given a signed 32-bit integer, return the integer obtained by reversing its digits. If the reversed integer overflows, return 0. The integer should be treated as a signed 32-bit integer.",
    "topic": "Mathematics",
    "subtopic": "Integer Manipulation",
    "tags": [
      "Integer",
      "Mathematics",
      "String Manipulation"
    ],
    "input_format": "A single signed 32-bit integer x.",
    "output_format": "A signed 32-bit integer representing the reversed number, or 0 if it overflows.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 123",
        "output": "321",
        "explanation": "Reversing 123 gives 321."
      },
      {
        "input": "x = -123",
        "output": "-321",
        "explanation": "Reversing -123 gives -321."
      },
      {
        "input": "x = 120",
        "output": "21",
        "explanation": "Reversing 120 gives 21 (the leading zero is dropped)."
      },
      {
        "input": "x = 1534236469",
        "output": "0",
        "explanation": "The reversed integer 9646324351 overflows, so the output is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to handle negative numbers.",
      "Think about how to avoid overflow."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Rotate Array",
    "description": "Given an array of integers and a number k, rotate the array to the right by k steps, where k is non-negative. You need to modify the input array in place.",
    "topic": "Array",
    "subtopic": "Manipulating Arrays",
    "tags": [
      "Array",
      "Rotation",
      "In-Place"
    ],
    "input_format": "An integer array nums and a non-negative integer k.",
    "output_format": "The modified array, rotated to the right by k steps.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= k <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5], k = 2",
        "output": "[4, 5, 1, 2, 3]",
        "explanation": "Rotating the array [1, 2, 3, 4, 5] by 2 steps results in [4, 5, 1, 2, 3]."
      },
      {
        "input": "nums = [-1, -100, 3, 99], k = 2",
        "output": "[3, 99, -1, -100]",
        "explanation": "After rotating [-1, -100, 3, 99] by 2 steps, we get [3, 99, -1, -100]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using the reverse method to achieve the rotation in place.",
      "Handle cases where k is greater than the length of the array."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Remove K Digits",
    "description": "Given a string num representing a non-negative integer and an integer k, return the smallest possible integer after removing k digits from num. The resulting number should not have leading zeros, and if the result is an empty string, return '0'.",
    "topic": "String",
    "subtopic": "Greedy",
    "tags": [
      "String",
      "Greedy",
      "Stack"
    ],
    "input_format": "A string num representing a non-negative integer, and an integer k (0 <= k <= num.length).",
    "output_format": "A string representing the smallest possible integer after removing k digits.",
    "constraints": [
      "1 <= num.length <= 10^5",
      "0 <= k <= num.length"
    ],
    "examples": [
      {
        "input": "num = '1432219', k = 3",
        "output": "1219",
        "explanation": "Remove the digits '4', '3', and '2' to get the smallest number."
      },
      {
        "input": "num = '10200', k = 1",
        "output": "200",
        "explanation": "Remove the first '1' to get '0200', which is '200' after removing leading zeros."
      },
      {
        "input": "num = '10', k = 2",
        "output": "0",
        "explanation": "Remove both digits '1' and '0' to get an empty string, which should return '0'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to use a stack to maintain the order of digits.",
      "Iterate through the number and remove digits from the top of the stack when they are larger than the current digit."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Binary Search",
    "description": "Given a sorted array of integers and a target value, write a function to search for the target value in the array. If the target exists, return its index; otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Search",
    "subtopic": "Binary Search",
    "tags": [
      "Search",
      "Binary Search",
      "Algorithm"
    ],
    "input_format": "A sorted array of integers nums and an integer target.",
    "output_format": "An integer representing the index of target in nums, or -1 if target is not found.",
    "constraints": [
      "0 <= nums.length <= 10^4",
      "-10^5 <= nums[i] <= 10^5",
      "nums is sorted in ascending order."
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5], target = 3",
        "output": "2",
        "explanation": "The target 3 is found at index 2."
      },
      {
        "input": "nums = [1, 2, 3, 4, 5], target = 6",
        "output": "-1",
        "explanation": "The target 6 is not in the array."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider the middle element to narrow down the search space.",
      "If the middle element is less than the target, search the right half.",
      "If the middle element is greater than the target, search the left half."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Kth Largest Element in an Array",
    "description": "Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. You must solve it in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Heap"
    ],
    "input_format": "An integer array nums and an integer k.",
    "output_format": "An integer representing the kth largest element.",
    "constraints": [
      "1 <= k <= nums.length",
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 1, 5, 6, 4], k = 2",
        "output": "5",
        "explanation": "The 2nd largest element in the sorted array [1, 2, 3, 4, 5, 6] is 5."
      },
      {
        "input": "nums = [3, 2, 3, 1, 2, 4, 5, 5, 6], k = 4",
        "output": "4",
        "explanation": "The 4th largest element in the sorted array [1, 2, 2, 3, 3, 4, 5, 5, 6] is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a max heap or quick select algorithm.",
      "You can also sort the array and then access the kth largest element."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Insert Delete GetRandom O(1)",
    "description": "Design a data structure that supports all following operations in average O(1) time complexity. Implement the RandomizedSet class: \n\n- `bool insert(int val)`: Inserts an item val into the set. Returns true if the item was not already in the set and false otherwise. \n- `bool remove(int val)`: Removes an item val from the set. Returns true if the item was in the set and false otherwise. \n- `int getRandom()`: Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.",
    "topic": "Design",
    "subtopic": "Data Structure Design",
    "tags": [
      "Design",
      "Hash Table",
      "Random"
    ],
    "input_format": "Each operation is a command followed by an integer (for insert and remove) or no integer (for getRandom).",
    "output_format": "For each `insert` and `remove` operation, return true or false. For `getRandom`, return an integer.",
    "constraints": [
      "-2^31 <= val <= 2^31 - 1",
      "The number of calls to insert, remove, and getRandom is at most 2 * 10^4.",
      "There will be at least one element in the set when getRandom is called."
    ],
    "examples": [
      {
        "input": "obj = RandomizedSet(); \nobj.insert(1); \nobj.remove(2); \nobj.insert(2); \nobj.getRandom();",
        "output": "1 or 2",
        "explanation": "Since 1 was inserted before and 2 was also inserted after, getRandom could return either value with equal probability."
      },
      {
        "input": "obj = RandomizedSet(); \nobj.insert(1); \nobj.remove(1); \nobj.getRandom();",
        "output": "Error",
        "explanation": "getRandom cannot be called as the set is empty after removing the only element."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash table for tracking elements efficiently.",
      "An array can help you achieve the O(1) requirement for random access."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "K-th Smallest in Lexicographical Order",
    "description": "Given two integers n and k, return the k-th smallest integer in the lexicographical order of all integers from 1 to n. For example, if n = 13 and k = 2, the k-th smallest integer in lexicographical order is 10 because the integers from 1 to 13 in lexicographical order are [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9].",
    "topic": "Strings",
    "subtopic": "Lexicographical Order",
    "tags": [
      "String",
      "Lexicographical",
      "Sorting"
    ],
    "input_format": "Two integers n and k.",
    "output_format": "An integer representing the k-th smallest integer in lexicographical order.",
    "constraints": [
      "1 <= n <= 10^9",
      "1 <= k <= n"
    ],
    "examples": [
      {
        "input": "n = 13, k = 2",
        "output": "10",
        "explanation": "In lexicographical order: [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], the 2nd smallest is 10."
      },
      {
        "input": "n = 1, k = 1",
        "output": "1",
        "explanation": "The only integer is 1 itself."
      },
      {
        "input": "n = 20, k = 7",
        "output": "13",
        "explanation": "The lexicographical order contains: [1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 4, 5, 6, 7, 8, 9, 20], the 7th smallest is 13."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to construct the numbers in lexicographical order.",
      "Think about how numbering works with prefixes.",
      "Use a systematic way to count the numbers that have a common prefix."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List",
    "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    "topic": "Linked List",
    "subtopic": "Reversing a Linked List",
    "tags": [
      "Linked List",
      "Reversal",
      "Pointer"
    ],
    "input_format": "A single list node, representing the head of a singly linked list.",
    "output_format": "The head of the reversed singly linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 5000].",
      "-5000 <= Node.val <= 5000"
    ],
    "examples": [
      {
        "input": "[1, 2, 3, 4, 5]",
        "output": "[5, 4, 3, 2, 1]",
        "explanation": "Reversing the linked list yields 5 -> 4 -> 3 -> 2 -> 1."
      },
      {
        "input": "[1, 2]",
        "output": "[2, 1]",
        "explanation": "Reversing the linked list yields 2 -> 1."
      },
      {
        "input": "[]",
        "output": "[]",
        "explanation": "An empty list remains empty when reversed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a previous pointer to help reverse the links.",
      "You can use an iterative or recursive approach."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Linked List Cycle",
    "description": "Given a linked list, determine if it has a cycle in it. A cycle occurs when a node's next pointer points to one of its previous nodes, creating a loop. Your task is to implement a function that checks for the presence of such a cycle.",
    "topic": "Linked List",
    "subtopic": "Cycle Detection",
    "tags": [
      "Linked List",
      "Cycle",
      "Two Pointers"
    ],
    "input_format": "The head of a linked list, which may contain a cycle.",
    "output_format": "Return true if there is a cycle in the linked list, otherwise return false.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 10^4].",
      "The value of each node is in the range [-10^5, 10^5]."
    ],
    "examples": [
      {
        "input": "head = [3, 2, 0, -4], pos = 1",
        "output": "true",
        "explanation": "The list contains a cycle, with the tail connecting back to the second node."
      },
      {
        "input": "head = [1, 2], pos = 0",
        "output": "true",
        "explanation": "The list contains a cycle, with the tail connecting back to the first node."
      },
      {
        "input": "head = [1], pos = -1",
        "output": "false",
        "explanation": "The list contains no cycle, as it contains only one node."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers moving at different speeds.",
      "If the fast pointer meets the slow pointer, there is a cycle."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Unique Binary Search Trees",
    "description": "Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 to n. The generated trees must be distinct in structure, even if they possess the same node values.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Dynamic Programming",
      "Recursion"
    ],
    "input_format": "A single integer n representing the number of nodes in the BST.",
    "output_format": "A list of all structurally unique BSTs represented as trees.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
        "explanation": "There are five distinct BSTs that can be made with nodes 1, 2, and 3."
      },
      {
        "input": "n = 1",
        "output": "[[1]]",
        "explanation": "Only one BST can be made with a single node."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion to build trees for each possible root value.",
      "Acknowledge the left and right subtrees when choosing a root."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Sqrt(x)",
    "description": "Given a non-negative integer x, return the square root of x as an integer. The returned result should be truncated to the integer part (i.e., the decimal part should be discarded). You must not use any built-in exponentiation functions, such as pow or **.",
    "topic": "Math",
    "subtopic": "Binary Search",
    "tags": [
      "Math",
      "Binary Search",
      "Square Root"
    ],
    "input_format": "A single non-negative integer x.",
    "output_format": "An integer representing the truncated square root of x.",
    "constraints": [
      "0 <= x <= 10^7"
    ],
    "examples": [
      {
        "input": "x = 4",
        "output": "2",
        "explanation": "The square root of 4 is 2."
      },
      {
        "input": "x = 8",
        "output": "2",
        "explanation": "The square root of 8 is approximately 2.828, truncated to 2."
      },
      {
        "input": "x = 0",
        "output": "0",
        "explanation": "The square root of 0 is 0."
      },
      {
        "input": "x = 9",
        "output": "3",
        "explanation": "The square root of 9 is 3."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using binary search to find the square root efficiently.",
      "The square root of x lies between 0 and x."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Largest Submatrix With Rearrangements",
    "description": "Given an m x n binary matrix filled with 0's and 1's, you need to find the largest rectangle containing only 1's and return its area. The catch is that you can rearrange the rows of the matrix in any order. You need to determine the area of the largest rectangle that can be formed with 1's after any possible row rearrangement.",
    "topic": "Dynamic Programming",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Binary Matrix",
      "Dynamic Programming",
      "Rectangle"
    ],
    "input_format": "A 2D binary matrix with m rows and n columns, where each cell is either a 0 or a 1.",
    "output_format": "An integer representing the area of the largest rectangle that can be formed.",
    "constraints": [
      "1 <= m, n <= 100",
      "matrix[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "[[1,0,1],[1,1,1],[1,0,0]]",
        "output": "3",
        "explanation": "After rearranging the rows, the matrix can become [[1,1,1],[1,1,1],[1,0,0]]. The largest rectangle of 1's has an area of 3."
      },
      {
        "input": "[[0,0,0],[0,1,1],[1,1,1]]",
        "output": "4",
        "explanation": "The rows can be rearranged to [[1,1,1],[0,1,1],[0,0,0]]. The largest rectangle of 1's has an area of 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you might calculate the height of columns if rows can be rearranged.",
      "Think about sorting or aggregating column heights as you iterate through the matrix."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Best Meeting Point",
    "description": "You are given a set of points on a 2D grid representing people's locations. Your goal is to find the optimal meeting point, such that the sum of the Manhattan distances from all the points to this meeting point is minimized. The Manhattan distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|. Return the minimum sum of the Manhattan distances to the best meeting point.",
    "topic": "Geometry",
    "subtopic": "Manhattan Distance",
    "tags": [
      "Geometry",
      "Dynamic Programming",
      "Grid"
    ],
    "input_format": "A list of points where each point is represented by an array of two integers [x, y].",
    "output_format": "An integer representing the minimum sum of Manhattan distances.",
    "constraints": [
      "1 <= points.length <= 1000",
      "-10^4 <= points[i][0], points[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "[[0, 1], [1, 0], [1, 2], [2, 1]]",
        "output": "4",
        "explanation": "The best meeting point is (1, 1) which minimizes the total distance to all points."
      },
      {
        "input": "[[1, 0], [0, 1], [2, 0], [0, 2]]",
        "output": "4",
        "explanation": "The best meeting point (1, 1) results in minimal total distance of 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider sorting the coordinates to find the median.",
      "Calculate the total distance to median points."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array, find the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses constant extra space.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Mathematics"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the first missing positive integer.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [3, 4, -1, 1]",
        "output": "2",
        "explanation": "The positive integers less than or equal to 4 are 1, 2, 3, and 4. The smallest missing positive integer is 2."
      },
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "The positive integers in the array are 1 and 2. The smallest missing positive integer is 3."
      },
      {
        "input": "nums = [7, 8, 9, 11, 12]",
        "output": "1",
        "explanation": "The positive integers in the array are 7, 8, 9, 11, and 12. The smallest missing positive integer is 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use the indices of the array to place numbers in their correct positions.",
      "Ignore non-positive numbers and numbers larger than the length of the array."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "All Nodes Distance K in Binary Tree",
    "description": "Given a binary tree, your task is to find all nodes that are at a distance K from a target node. The distance between two nodes is defined as the number of edges in the path connecting them. You need to return a list of values representing these nodes in any order.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth-First Search",
      "Breadth-First Search"
    ],
    "input_format": "The input consists of the root of the binary tree and an integer target representing the value of the target node, and an integer K.",
    "output_format": "A list of integers representing the node values at distance K from the target node.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 10^4].",
      "0 <= Node.val <= 1000.",
      "The target node is guaranteed to be in the tree."
    ],
    "examples": [
      {
        "input": "root = [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4], target = 5, K = 2",
        "output": "[7, 4, 1]",
        "explanation": "From node 5, nodes 7 and 4 are at distance 2 and node 1 is at distance 2 as well."
      },
      {
        "input": "root = [1], target = 1, K = 0",
        "output": "[1]",
        "explanation": "The only node is the target itself, which is at distance 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use Depth-First Search to traverse the tree.",
      "You may want to use a parent pointer to track parent nodes."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "You are given an integer array `nums` sorted in ascending order, but then rotated at some pivot unknown to you beforehand. Write a function to search for a given target in `nums` and return its index. If the target is not in the array, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An integer array `nums`, followed by an integer `target`.",
    "output_format": "An integer representing the index of `target` in `nums`, or -1 if `target` is not found.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "0 <= nums[i] <= 10^4",
      "All elements of nums are unique.",
      "The array is guaranteed to be rotated."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "The target 0 is found at index 4."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "The target 3 is not in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how the rotation affects the binary search.",
      "Identify which part of the array is sorted.",
      "Adjust your search range based on the sorted subarray."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Nearest Exit from Entrance in Maze",
    "description": "You are given an m x n maze represented by a 2D grid. Each cell can either be an open space represented by '.' or a wall represented by '+'. You are also given the entrance of the maze. The entrance is an open space that is not in the border of the grid. The goal is to find the nearest exit from the entrance in the maze. An exit is defined as an open space on the border of the maze. You can only move in four directions: up, down, left, or right. Return the number of steps in the shortest path to the nearest exit, or -1 if there is no exit accessible from the entrance.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "BFS",
      "Graph",
      "Maze"
    ],
    "input_format": "A 2D grid representing the maze and the coordinates of the entrance.",
    "output_format": "An integer representing the number of steps to the nearest exit, or -1 if no exit is accessible.",
    "constraints": [
      "1 <= maze.length, maze[i].length <= 100",
      "maze[i][j] is either '.' or '+'",
      "The entrance will always be a '.' and will not be on the border of the maze.",
      "You may assume that the entrance is valid and there is at least one exit."
    ],
    "examples": [
      {
        "input": {
          "maze": [
            [
              "+",
              "+",
              ".",
              "+"
            ],
            [
              ".",
              ".",
              ".",
              "+"
            ],
            [
              "+",
              "+",
              "+",
              "+"
            ],
            [
              "+",
              ".",
              "+",
              "+"
            ]
          ],
          "entrance": [
            1,
            1
          ]
        },
        "output": "3",
        "explanation": "The nearest exit is located at (0, 2). The path is: (1,1) -> (1,2) -> (0,2)."
      },
      {
        "input": {
          "maze": [
            [
              "+",
              "+",
              "+"
            ],
            [
              "+",
              ".",
              "+"
            ],
            [
              "+",
              "+",
              "+"
            ]
          ],
          "entrance": [
            1,
            1
          ]
        },
        "output": "-1",
        "explanation": "There is no exit accessible from the entrance."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use BFS to explore all possible paths from the entrance.",
      "Keep track of visited cells to avoid cycles."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Sort Colors",
    "description": "Given an array of integers representing colors, where 0 is red, 1 is white, and 2 is blue, sort the array in-place so that all 0s come first, followed by all 1s, and all 2s come last. You must solve this problem in a single pass and without using any additional space for another array.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums, where each integer is either 0, 1, or 2.",
    "output_format": "The sorted input array in-place.",
    "constraints": [
      "1 <= nums.length <= 300",
      "nums[i] is either 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "nums = [2,0,2,1,1,0]",
        "output": "[0,0,1,1,2,2]",
        "explanation": "After sorting, all 0s are at the beginning, followed by all 1s, and then all 2s."
      },
      {
        "input": "nums = [0,1,2,0,1,2]",
        "output": "[0,0,1,1,2,2]",
        "explanation": "Even though the array was not sorted initially, the result groups all 0s, 1s, and 2s together."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a three-pointer technique to sort the colors in a single pass.",
      "Think about how you can maintain the counts of each color while swapping elements."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Robot Collisions",
    "description": "You are tasked with simulating robot movements in a one-dimensional space. Each robot can either move left or right and will collide with each other if they meet at the same position. Collisions result in the destruction of one or both robots based on their directions: if they move towards each other, they both are destroyed. Given an array representing the initial positions of robots, along with their directions, return the final positions of the robots remaining after all collisions have occurred. Assume all robots are represented by integers in the array, where positive represents a robot moving right and negative represents a robot moving left.",
    "topic": "Simulation",
    "subtopic": "Collision Detection",
    "tags": [
      "Simulation",
      "Stack",
      "Collision"
    ],
    "input_format": "An array of integers representing the initial positions and directions of the robots.",
    "output_format": "An array of integers representing the final positions of robots remaining after all collisions.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^6 <= nums[i] <= 10^6",
      "The initial direction of the robots can be represented as positive (right) or negative (left)."
    ],
    "examples": [
      {
        "input": "nums = [5, 10, -5]",
        "output": "[5, 10]",
        "explanation": "The robot at position 5 and 10 move away from each other, while the robot at position -5 collides with the robot at 5 and is destroyed."
      },
      {
        "input": "nums = [8, -8]",
        "output": "[]",
        "explanation": "Both robots collide and are destroyed."
      },
      {
        "input": "nums = [10, 2, -5, -10]",
        "output": "[10, -10]",
        "explanation": "The robots at positions 2 and -5 collide, resulting in the only robots remaining being at positions 10 and -10."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a stack to manage the collision dynamics.",
      "A positive number indicates a right-moving robot, while a negative number indicates a left-moving robot."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Lowest Common Ancestor of a Binary Search Tree",
    "description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on a BST, the LCA is the deepest node that is an ancestor of both nodes. You may assume that both nodes are present in the BST.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Lowest Common Ancestor"
    ],
    "input_format": "The root of the binary search tree and the two nodes (p and q).",
    "output_format": "The node representing the lowest common ancestor of the two nodes.",
    "constraints": [
      "The number of nodes in the tree is in the range [2, 10^5].",
      "Each node has a unique value.",
      "p and q are distinct nodes in the BST."
    ],
    "examples": [
      {
        "input": "root = [6, 2, 8, 0, 4, 7, 9], p = 2, q = 8",
        "output": "6",
        "explanation": "The LCA of nodes 2 and 8 is 6 since 6 is their common ancestor."
      },
      {
        "input": "root = [6, 2, 8, 0, 4, 7, 9], p = 2, q = 4",
        "output": "2",
        "explanation": "The LCA of nodes 2 and 4 is 2 since 2 is the ancestor of 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of a Binary Search Tree.",
      "If both nodes are in the left subtree, the LCA must be on the left.",
      "If both nodes are in the right subtree, the LCA must be on the right."
    ],
    "company": "Samsung"
  },
  {
    "question_id": "",
    "title": "Subsets",
    "description": "Given a set of distinct integers, return all possible subsets (the power set). The solution set must not contain duplicate subsets. You may return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Generating Subsets",
    "tags": [
      "Backtracking",
      "Subsets",
      "Recursion"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "A list of lists representing all possible subsets.",
    "constraints": [
      "0 <= nums.length <= 10",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]",
        "explanation": "The subsets of [1, 2, 3] include the empty set, single element sets, sets of two elements, and the set containing all three elements."
      },
      {
        "input": "nums = [0]",
        "output": "[[], [0]]",
        "explanation": "The subsets of [0] include the empty set and the set containing the single element."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how subsets are formed by either including or excluding each element.",
      "Use recursion or iterative methods to generate subsets."
    ],
    "company": "Samsung"
  }
]