[
  {
    "question_id": "",
    "title": "Merge Sorted Array",
    "description": "You are given two sorted integer arrays nums1 and nums2. You should merge nums2 into nums1 as one sorted array. The merge should be done in place and should not use any additional space for another array. The final sorted array should replace the contents of nums1. You may assume that nums1 has enough space (size that is greater than or equal to m + n) to hold additional elements from nums2, where m is the number of elements initialized in nums1 and n is the number of elements in nums2.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Sorting",
      "Two Pointers"
    ],
    "input_format": "Two sorted integer arrays, nums1 and nums2, where nums1 has additional space at the end.",
    "output_format": "A single sorted array, nums1, containing all elements from nums1 and nums2.",
    "constraints": [
      "0 <= m, n <= 200",
      "1 <= m + n <= 200",
      "-10^9 <= nums1[i], nums2[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3",
        "output": "[1, 2, 2, 3, 5, 6]",
        "explanation": "After merging, nums1 will be [1, 2, 2, 3, 5, 6]."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "No elements to merge, nums1 stays the same."
      },
      {
        "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
        "output": "[1]",
        "explanation": "Only elements from nums2 are merged into nums1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to keep track of the elements in nums1 and nums2.",
      "Fill nums1 from the back to avoid overwriting existing values."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Pow(x, n)",
    "description": "Implement a function that calculates x raised to the power n (x^n). This function should handle both positive and negative exponents and return the result as a floating-point number. You are not allowed to use the built-in power function or the ** operator.",
    "topic": "Mathematics",
    "subtopic": "Exponentiation",
    "tags": [
      "Mathematics",
      "Recursion",
      "Exponentiation"
    ],
    "input_format": "Two parameters: a float x and an integer n.",
    "output_format": "A float representing x raised to the power n.",
    "constraints": [
      "-100.0 <= x <= 100.0",
      "-10^4 <= n <= 10^4"
    ],
    "examples": [
      {
        "input": "x = 2.0, n = 10",
        "output": "1024.0",
        "explanation": "2 raised to power 10 is 1024."
      },
      {
        "input": "x = 2.1, n = 3",
        "output": "9.261",
        "explanation": "2.1 raised to power 3 is approximately 9.261."
      },
      {
        "input": "x = 2.0, n = -2",
        "output": "0.25",
        "explanation": "2 raised to power -2 is 1/(2^2) = 1/4 = 0.25."
      },
      {
        "input": "x = 0.0, n = 5",
        "output": "0.0",
        "explanation": "0 raised to any positive power is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion to reduce the problem size.",
      "Handle the case when n is negative separately.",
      "Utilize the properties of exponents: x^n = (x^(n/2))^2 if n is even."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Simplify Path",
    "description": "Given a string representing an absolute path for a file (Unix-style), simplify it. The path may contain several levels of directories and include sequences like '..' for the parent directory and '.' for the current directory. The output should be the canonical path you would take to reach the file.",
    "topic": "String",
    "subtopic": "Path Manipulation",
    "tags": [
      "String",
      "Path",
      "Unix"
    ],
    "input_format": "A string representing the absolute path.",
    "output_format": "A string representing the simplified absolute path.",
    "constraints": [
      "The input string will have at most 3000 characters.",
      "The input string will always be a valid absolute path."
    ],
    "examples": [
      {
        "input": "/a/b/./c/../..",
        "output": "/a",
        "explanation": "The path '/a/b/./c/../..' moves to 'a', stays in 'b', goes to 'c', then back two levels to 'a'."
      },
      {
        "input": "/../",
        "output": "/",
        "explanation": "The path '/..' leads to the root directory, so the output is '/' (root)."
      },
      {
        "input": "/home//foo/",
        "output": "/home/foo",
        "explanation": "The double slashes '//' are treated as a single slash, simplifying to '/home/foo'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to handle directory levels effectively.",
      "Remember to ignore '.' and process '..' correctly."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. An interval is defined by a pair of integers representing its start and end. If two intervals overlap, you should merge them into a single interval with a start as the minimum start and an end as the maximum end.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Intervals"
    ],
    "input_format": "A list of intervals, where each interval is represented as a pair of integers [start, end].",
    "output_format": "A list of merged intervals, where each interval is represented as a pair of integers [start, end].",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "-10^5 <= intervals[i][0] <= intervals[i][1] <= 10^5"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "The intervals [1,3] and [2,6] overlap and thus should be merged into [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "The intervals [1,4] and [4,5] overlap at 4, resulting in the merged interval [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on the start time.",
      "Use a list to keep track of the merged intervals.",
      "Iterate through the sorted intervals and compare with the last merged interval."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums followed by an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 2 + 7 = 9."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "nums[1] + nums[2] = 2 + 4 = 6."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a hash table to store the indices of the numbers.",
      "You can iterate through the array and check if the complement exists."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Next Permutation",
    "description": "Implement the next permutation algorithm, which rearranges numbers into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order). The solution must be performed in-place, meaning it should use only constant extra memory.",
    "topic": "Array",
    "subtopic": "Permutation",
    "tags": [
      "Array",
      "Permutation",
      "In-place",
      "Next Greater"
    ],
    "input_format": "An array of integers nums representing the current permutation.",
    "output_format": "The array of integers nums modified to its next permutation.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[1, 3, 2]",
        "explanation": "The next permutation of [1, 2, 3] is [1, 3, 2]."
      },
      {
        "input": "nums = [3, 2, 1]",
        "output": "[1, 2, 3]",
        "explanation": "The next permutation of [3, 2, 1] is the lowest possible order, which is [1, 2, 3]."
      },
      {
        "input": "nums = [1, 1, 5]",
        "output": "[1, 5, 1]",
        "explanation": "The next permutation of [1, 1, 5] is [1, 5, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Look for the rightmost ascent in the array.",
      "Swap the ascent element with the smallest element on its right that is larger.",
      "Reverse the elements to the right of the ascent element."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Note that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Hash Table"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A list of unique triplets that sum up to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that sum to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "No triplets exist in an empty list."
      },
      {
        "input": "nums = [0, 1, 1]",
        "output": "[]",
        "explanation": "No triplets exist that sum to zero."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the array to simplify the process of finding triplets.",
      "Use a two-pointer approach to find pairs that sum to a specific target."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of k linked lists, each linked list is sorted in ascending order. Merge all the linked lists into one sorted linked list and return it. The resulting linked list should also be sorted in ascending order.",
    "topic": "Linked List",
    "subtopic": "Merge Sort",
    "tags": [
      "Linked List",
      "Sorting",
      "Merge"
    ],
    "input_format": "An array of k linked lists, where each linked list is represented by its head node.",
    "output_format": "The head node of the merged linked list.",
    "constraints": [
      "0 <= k <= 10^4",
      "0 <= n <= 500",
      "The total number of nodes in all linked lists is at most 10^4."
    ],
    "examples": [
      {
        "input": "[1 -> 4 -> 5, 1 -> 3 -> 4, 2 -> 6]",
        "output": "1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6",
        "explanation": "The merged linked list is sorted as follows: 1, 1, 2, 3, 4, 4, 5, 6."
      },
      {
        "input": "[]",
        "output": "",
        "explanation": "An empty input returns an empty linked list."
      },
      {
        "input": "[5 -> 10, 1 -> 4 -> 6, 2 -> 3 -> 8]",
        "output": "1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 8 -> 10",
        "explanation": "The merged linked list is sorted as follows: 1, 2, 3, 4, 5, 6, 8, 10."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a min-heap to efficiently merge the lists.",
      "Think about how to maintain the order while popping the smallest elements."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Find First and Last Position of Element in Sorted Array",
    "description": "Given an array of integers nums sorted in non-decreasing order and an integer target, return the starting and ending position of target in nums. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An array of two integers representing the starting and ending positions of target.",
    "constraints": [
      "0 <= nums.length <= 10^5",
      "10^4 <= nums[i] <= 10^4",
      "The array is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 8",
        "output": "[3, 4]",
        "explanation": "The first occurrence of 8 is at index 3 and the last occurrence is at index 4."
      },
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 6",
        "output": "[-1, -1]",
        "explanation": "Target 6 is not present in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to find the target.",
      "You will need a second search to find the last occurrence."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Valid Number",
    "description": "Implement a function to determine if a given string is a valid number. A valid number can be an integer or a floating-point number, and it can also include an optional sign (+ or -), an optional decimal point, and an optional exponent (e.g., e or E followed by an integer). The number can be in the form of '123', '-123', '123.456', '+.5', '1.0e10', or '2E-5'. It should not include invalid formats such as '1..2', '1e', '1 1', or '.5.5'.",
    "topic": "String",
    "subtopic": "Validation",
    "tags": [
      "String",
      "Validation",
      "Regular Expressions"
    ],
    "input_format": "A string representing the number to be validated.",
    "output_format": "A boolean indicating whether the string is a valid number.",
    "constraints": [
      "The input string length will not exceed 20."
    ],
    "examples": [
      {
        "input": "'0'",
        "output": "true",
        "explanation": "The string '0' is a valid integer number."
      },
      {
        "input": "'-123.456e+789'",
        "output": "true",
        "explanation": "The string represents a valid floating-point number with an exponent."
      },
      {
        "input": "'12.3.4'",
        "output": "false",
        "explanation": "The string contains two decimal points, making it invalid."
      },
      {
        "input": "'abc'",
        "output": "false",
        "explanation": "The string contains only non-numeric characters, making it invalid."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using regular expressions to validate the format.",
      "Handle optional sign, decimal point, and exponent carefully."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if the brackets are closed in the correct order. Note that an empty string is also considered valid.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Parentheses"
    ],
    "input_format": "A string s containing only the characters '(', ')', '{', '}', '[' and ']'",
    "output_format": "A boolean value indicating whether the input string is valid or not.",
    "constraints": [
      "0 <= s.length <= 10^4"
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The parentheses are correctly matched and closed."
      },
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "All types of brackets are matched and closed correctly."
      },
      {
        "input": "s = '(]')",
        "output": "false",
        "explanation": "The brackets are not closed in the correct order."
      },
      {
        "input": "s = '([)]'",
        "output": "false",
        "explanation": "The brackets are closed in the wrong order."
      },
      {
        "input": "s = '{[]}'",
        "output": "true",
        "explanation": "The brackets are correctly matched and closed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "Ensure that every closing bracket matches the last opened bracket."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Minimum Window Substring",
    "description": "Given two strings 's' and 't', return the minimum window substring of 's' such that every character in 't' (including duplicates) is included in the window. If there is no such substring, return an empty string. The input strings are non-empty and 's' will always be a longer string than or equal to 't'.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Hash Table"
    ],
    "input_format": "Two strings s and t, where 1 <= s.length, t.length <= 1000.",
    "output_format": "A string representing the minimum window substring of 's' that contains all characters from 't'.",
    "constraints": [
      "1 <= s.length, t.length <= 1000",
      "s and t consist of English letters."
    ],
    "examples": [
      {
        "input": "s = 'ADOBECODEBANC', t = 'ABC'",
        "output": "'BANC'",
        "explanation": "The minimum window substring is 'BANC' which contains all characters of 't'."
      },
      {
        "input": "s = 'A', t = 'AA'",
        "output": "''",
        "explanation": "There is no such window that contains all characters of 't'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use two pointers to represent the current window.",
      "Maintain a frequency count of the characters in 't'.",
      "Expand the window until all characters in 't' are included, then contract."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string.",
    "topic": "String",
    "subtopic": "Prefix",
    "tags": [
      "String",
      "Prefix",
      "Array"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A string representing the longest common prefix.",
    "constraints": [
      "0 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "All strings consist of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The longest common prefix is 'fl'."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among the strings."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use horizontal scanning to compare prefixes.",
      "Start with the prefix of the first string and reduce it as you check other strings."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contains a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.",
    "topic": "Linked List",
    "subtopic": "Addition of Numbers",
    "tags": [
      "Linked List",
      "Addition",
      "Simulation"
    ],
    "input_format": "The input consists of two non-empty linked lists, l1 and l2, where each node contains a single digit.",
    "output_format": "Return the sum of the two numbers as a linked list.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= node.val <= 9",
      "It is guaranteed that the result does not have leading zeros."
    ],
    "examples": [
      {
        "input": "l1 = [2, 4, 3], l2 = [5, 6, 4]",
        "output": "[7, 0, 8]",
        "explanation": "The numbers represented by the linked lists are 342 and 465. Adding them gives 807, which is represented as the linked list [7, 0, 8]."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "Both numbers are 0, hence the output is just [0]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a carry variable to handle sums greater than 9.",
      "Traverse both lists until you reach the end of both."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Letter Combinations of a Phone Number",
    "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n   2: abc\n   3: def\n   4: ghi\n   5: jkl\n   6: mno\n   7: pqrs\n   8: tuv\n   9: wxyz\n\nThe output combinations may be returned in any order.",
    "topic": "Backtracking",
    "subtopic": "Combinations",
    "tags": [
      "Recursion",
      "Backtracking",
      "String"
    ],
    "input_format": "A string containing digits (2-9).",
    "output_format": "A list of strings representing all possible letter combinations.",
    "constraints": [
      "0 <= digits.length <= 4",
      "digits[i] is a digit in '23456789'."
    ],
    "examples": [
      {
        "input": "digits = '23'",
        "output": "['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']",
        "explanation": "The digit '2' maps to 'abc' and '3' maps to 'def'. The combinations are formed by taking one letter from 'abc' and one letter from 'def'."
      },
      {
        "input": "digits = ''",
        "output": "[]",
        "explanation": "An empty input leads to no combinations."
      },
      {
        "input": "digits = '2'",
        "output": "['a', 'b', 'c']",
        "explanation": "The digit '2' maps to 'abc'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think of applying recursion to explore all possible combinations.",
      "Use a mapping array or dictionary to translate digits to letters."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Subsets",
    "description": "Given a set of distinct integers, return all possible subsets (the power set). The solution set must not contain duplicate subsets. You may return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Generating Subsequences",
    "tags": [
      "Backtracking",
      "Subsets",
      "Recursion"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "A list of lists containing all possible subsets.",
    "constraints": [
      "0 <= nums.length <= 10",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]",
        "explanation": "The subsets of the set [1, 2, 3] are: [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]."
      },
      {
        "input": "nums = [0]",
        "output": "[[], [0]]",
        "explanation": "The subsets of the set [0] are: [], [0]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to explore all possible combinations.",
      "Starting with an empty subset can help.",
      "Iterate through elements to either include or exclude each in the subset."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Remove Nth Node From End of List",
    "description": "Given the head of a singly linked list, remove the n-th node from the end of the list and return its head. It is guaranteed that the number of nodes is greater than n.",
    "topic": "Linked List",
    "subtopic": "Two Pointers",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Removal"
    ],
    "input_format": "The input consists of a linked list and an integer n.",
    "output_format": "Return the head of the modified linked list.",
    "constraints": [
      "The number of nodes in the list is greater than n.",
      "1 <= n <= 30",
      "The list has a maximum of 100 nodes."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], n = 2",
        "output": "[1, 2, 3, 5]",
        "explanation": "Removing the 2nd node from the end (value 4) results in the list [1, 2, 3, 5]."
      },
      {
        "input": "head = [1], n = 1",
        "output": "[]",
        "explanation": "Removing the only node in the list results in an empty list."
      },
      {
        "input": "head = [1, 2], n = 1",
        "output": "[1]",
        "explanation": "Removing the 1st node from the end (value 2) results in the list [1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use two pointers to identify the node to remove.",
      "Consider using a dummy node to simplify edge cases."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A string s consisting of English letters, digits, symbols, and spaces.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 5 * 10^4",
      "s consists of characters in the ASCII range."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"abc\" with length 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The longest substring without repeating characters is \"b\" with length 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"wke\" with length 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window approach to keep track of the substring.",
      "Utilize a HashMap to store the last index of each character."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "DP",
      "Water Trapping"
    ],
    "input_format": "An array of non-negative integers heights representing the elevation map.",
    "output_format": "An integer representing the total amount of water trapped.",
    "constraints": [
      "0 <= heights.length <= 2 * 10^4",
      "0 <= heights[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "heights = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The water trapped is 1 unit above index 2, 2 units above index 4, and 3 units above index 8 for a total of 6 units."
      },
      {
        "input": "heights = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The water trapped is 2 units above index 2, 1 unit above index 3, and 6 units above index 5 for a total of 9 units."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the left max array and right max array.",
      "You can use two pointers to optimize the space complexity.",
      "Think about the boundaries when calculating water at each bar."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "String to Integer (atoi)",
    "description": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function). The algorithm for myAtoi(string s) is as follows: 1. Read in and ignore any leading whitespace. 2. Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character if it exists and is then followed by a number. 3. Convert the following characters to digits until either a non-digit character is encountered or the end of the string is reached. The resulting number should be interpreted as a signed integer (positive or negative). 4. If the integer is out of the 32-bit signed integer range [-2^31, 2^31 - 1], clamp the integer so that it remains in this range. Specifically, integers less than -2^31 should be clamped to -2^31, and integers greater than 2^31 - 1 should be clamped to 2^31 - 1. 5. Return the integer as the final result.",
    "topic": "String",
    "subtopic": "Parsing",
    "tags": [
      "String",
      "Parsing",
      "Conversion"
    ],
    "input_format": "A string s, which may contain leading whitespaces and signs.",
    "output_format": "An integer representing the parsed integer from the string.",
    "constraints": [
      "0 <= s.length <= 200",
      "s consists of English letters (lower-case and upper-case), digits, ' ', '+', '-' and '.'"
    ],
    "examples": [
      {
        "input": "s = '   -42'",
        "output": "-42",
        "explanation": "Leading whitespace is ignored, then the negative sign and the number 42 are parsed."
      },
      {
        "input": "s = '4193 with words'",
        "output": "4193",
        "explanation": "Leading numbers are parsed until a non-numeric character 'w' is reached."
      },
      {
        "input": "s = 'words and 987'",
        "output": "0",
        "explanation": "No numbers found at the beginning, so the result is 0."
      },
      {
        "input": "s = '-91283472332'",
        "output": "-2147483648",
        "explanation": "Out of range, so it is clamped to the minimum of 32-bit signed integer."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Handle leading whitespace and signs carefully.",
      "Use a loop to iterate through the characters for digit conversion.",
      "Check for overflows in the final result."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A palindromic substring is a substring that reads the same forward and backward.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A string s of length n (1 <= n <= 1000).",
    "output_format": "A string representing the longest palindromic substring within s.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consist of only digits and English letters (lowercase and uppercase)."
    ],
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\"",
        "explanation": "Both \"bab\" and \"aba\" are valid longest palindromic substrings."
      },
      {
        "input": "s = \"cbbd\"",
        "output": "\"bb\"",
        "explanation": "The longest palindromic substring is \"bb\"."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Check all possible center points for palindrome expansion.",
      "Consider both odd-length and even-length palindromic substrings."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Median"
    ],
    "input_format": "Two sorted arrays nums1 and nums2.",
    "output_format": "A float representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= m <= 1000",
      "0 <= n <= 1000",
      "1 <= m + n <= 2000",
      "All elements of nums1 and nums2 are in the range of 10^5."
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.0",
        "explanation": "The merged array is [1, 2, 3], thus the median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.5",
        "explanation": "The merged array is [1, 2, 3, 4], thus the median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use binary search to partition the arrays.",
      "Consider edge cases where one array is empty.",
      "The median is influenced by the max of left partition and min of right partition."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array",
    "description": "Given a sorted array of integers, you need to remove the duplicates in-place such that each element appears only once and returns the new length of the array. It does not matter what you leave beyond the new length.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "A sorted array of integers nums.",
    "output_format": "An integer representing the new length of the array after removing duplicates.",
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums is sorted in ascending order."
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "2",
        "explanation": "After removing the duplicates, the array will be [1, 2]. The new length is 2."
      },
      {
        "input": "nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]",
        "output": "5",
        "explanation": "After removing the duplicates, the array will be [0, 1, 2, 3, 4]. The new length is 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to track unique elements.",
      "Consider the length of the final array after duplicates are removed."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Palindrome Number",
    "description": "Given an integer x, return true if x is a palindrome, and false otherwise. A palindrome is a number that remains the same when its digits are reversed. For example, 121 is a palindrome, but 123 is not.",
    "topic": "Math",
    "subtopic": "Number Theory",
    "tags": [
      "Math",
      "Palindrome",
      "Integer"
    ],
    "input_format": "An integer x.",
    "output_format": "A boolean value indicating whether x is a palindrome.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 121",
        "output": "true",
        "explanation": "Reversing 121 gives 121, which is the same as the original number."
      },
      {
        "input": "x = -121",
        "output": "false",
        "explanation": "Reversing -121 gives 121-, which is not the same as the original number."
      },
      {
        "input": "x = 10",
        "output": "false",
        "explanation": "Reversing 10 gives 01, which is not the same as the original number."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how negative numbers are handled in the context of palindromes.",
      "Think about converting the integer to a string for easier manipulation."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "You are given a rotated sorted array 'nums' and an integer 'target'. Write a function to search for 'target' in 'nums' and return its index if found. Otherwise, return -1. The array 'nums' is guaranteed to be rotated at some pivot, and you must achieve O(log n) time complexity.",
    "topic": "Binary Search",
    "subtopic": "Searching in Rotated Arrays",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An array of integers nums followed by an integer target.",
    "output_format": "An integer representing the index of the target in nums, or -1 if not found.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "All integers in nums are unique.",
      "nums is guaranteed to be a rotated sorted array."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "The target 0 is located at index 4."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "The target 3 is not in the array, so we return -1."
      },
      {
        "input": "nums = [1], target = 0",
        "output": "-1",
        "explanation": "The target 0 is not present in the array, hence we return -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of binary search.",
      "Identify the indices of the array where the pivot might be.",
      "Use the midpoint to determine which side is sorted."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Roman to Integer",
    "description": "Given a string containing a roman numeral, convert it to an integer. The valid roman numerals are represented by the characters 'I', 'V', 'X', 'L', 'C', 'D', and 'M', which represent the values 1, 5, 10, 50, 100, 500, and 1000 respectively. In this system, numerals are usually written from largest to smallest from left to right. However, there are instances where a smaller numeral appears before a larger one, indicating subtraction. For example, 'IV' represents 4, because 'I' (1) is before 'V' (5). Your task is to implement a function that takes a roman numeral as input and outputs its integer value.",
    "topic": "String",
    "subtopic": "Parsing",
    "tags": [
      "String",
      "Parsing",
      "Math"
    ],
    "input_format": "A string representing a roman numeral (1 <= length of string <= 15).",
    "output_format": "An integer representing the converted value of the roman numeral.",
    "constraints": [
      "1 <= s.length <= 15",
      "s consists of the characters 'I', 'V', 'X', 'L', 'C', 'D', 'M'."
    ],
    "examples": [
      {
        "input": "III",
        "output": "3",
        "explanation": "The letters I, I, and I represent the values 1, 1, and 1, respectively, so the total is 3."
      },
      {
        "input": "IV",
        "output": "4",
        "explanation": "'I' before 'V' represents 4 (5 - 1)."
      },
      {
        "input": "IX",
        "output": "9",
        "explanation": "'I' before 'X' represents 9 (10 - 1)."
      },
      {
        "input": "LVIII",
        "output": "58",
        "explanation": "'L' is 50, 'V' is 5, and 'III' is 3. Therefore, 50 + 5 + 3 = 58."
      },
      {
        "input": "MCMXCIV",
        "output": "1994",
        "explanation": "'M' is 1000, 'CM' is 900, 'XC' is 90, and 'IV' is 4. Therefore, 1000 + 900 + 90 + 4 = 1994."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a map to associate roman characters with their integer values.",
      "Iterate through the string and apply the subtraction rule when necessary."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. An Anagram is defined as two strings having the same character counts.",
    "topic": "String",
    "subtopic": "Hashing",
    "tags": [
      "String",
      "Hashing",
      "Anagrams"
    ],
    "input_format": "An array of strings words.",
    "output_format": "A list of lists, where each sublist contains strings that are anagrams of each other.",
    "constraints": [
      "1 <= words.length <= 10^4",
      "0 <= words[i].length <= 100",
      "All inputs are in lowercase."
    ],
    "examples": [
      {
        "input": "words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
        "output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
        "explanation": "The strings 'eat', 'tea', and 'ate' are anagrams; 'tan' and 'nat' are also anagrams; 'bat' is alone."
      },
      {
        "input": "words = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "There is one empty string, which is an anagram of itself."
      },
      {
        "input": "words = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "The single character 'a' stands alone."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map to group the words by their sorted character representation.",
      "You can sort each word to form a key for the hash map."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Count and Say",
    "description": "The 'Count and Say' sequence is a sequence of digit strings defined by the recursive formula: countAndSay(1) = '1'. To generate the next term, say the previous term and count the number of digits in groups of the same digit. For example, countAndSay(2) is '11' because the previous term '1' is read as 'one 1'. The third term, countAndSay(3) is '21' because the second term '11' is read as 'two 1s'. The fourth term is '1211', as the third term '21' is read as 'one 2, then one 1'. You need to implement a function that returns the n-th term of the 'Count and Say' sequence.",
    "topic": "Strings",
    "subtopic": "Manipulation",
    "tags": [
      "Strings",
      "Recursion",
      "Count and Say"
    ],
    "input_format": "An integer n (1 <= n <= 30).",
    "output_format": "A string representing the n-th term of the 'Count and Say' sequence.",
    "constraints": [
      "1 <= n <= 30"
    ],
    "examples": [
      {
        "input": "1",
        "output": "'1'",
        "explanation": "The first term of the sequence is '1'."
      },
      {
        "input": "4",
        "output": "'1211'",
        "explanation": "The fourth term is '1211', read from the third term '21'."
      },
      {
        "input": "5",
        "output": "'111221'",
        "explanation": "The fifth term is '111221', read from the fourth term '1211'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a loop to build terms iteratively.",
      "You can use a string to keep track of the current term.",
      "Think about counting consecutive characters effectively."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Merge Two Sorted Lists",
    "description": "You are given two sorted linked lists, list1 and list2, which represent the head of two sorted linked lists. Merge the two lists into one sorted list. The merged list should be made by splicing together the nodes of the two lists. Return the head of the new sorted list.",
    "topic": "Linked List",
    "subtopic": "Merging",
    "tags": [
      "Linked List",
      "Merge",
      "Sorting"
    ],
    "input_format": "The function takes two parameters, list1 and list2, each representing the head of a linked list.",
    "output_format": "Return the head of the merged linked list.",
    "constraints": [
      "The nodes in the input linked lists are sorted in non-decreasing order.",
      "0 <= list1.length, list2.length <= 1000"
    ],
    "examples": [
      {
        "input": "list1 = [1, 2, 4], list2 = [1, 3, 4]",
        "output": "[1, 1, 2, 3, 4, 4]",
        "explanation": "The merged linked list contains the elements 1, 1, 2, 3, 4, 4 in sorted order."
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]",
        "explanation": "The merged list is simply the second list since the first list is empty."
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]",
        "explanation": "Both lists are empty, so the merged list is also empty."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a dummy node to simplify the merging process.",
      "Iterate through both lists and compare their values."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "Given n vertical lines drawn on a 2D plane, where each line i is represented by the integer height[i]. Find two lines that together with the x-axis form a container, such that the container contains the most water. Note that the width of the container is the distance between the lines. Therefore, the amount of water that can be contained between two lines is determined by the shorter of the two lines multiplied by the distance between them.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "input_format": "An array of integers height, where height[i] represents the height of the ith line.",
    "output_format": "An integer representing the maximum amount of water that can be contained.",
    "constraints": [
      "2 <= height.length <= 10^5",
      "0 <= height[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The two lines at indices 1 and 8 (heights 8 and 7) form the container with the most water. Width is 8 - 1 = 7, and the height is min(8, 7) = 7. So the area is 7 * 7 = 49."
      },
      {
        "input": "height = [1,1]",
        "output": "1",
        "explanation": "The only two lines are both of height 1, and the area is 1 * (1) = 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using two pointers to find the max area efficiently.",
      "The maximum area might be found at the edges of the container."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Kadane's Algorithm"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum sum of the contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The contiguous subarray [4,-1,2,1] has the largest sum = 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The only subarray is [1], which has a sum of 1."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The contiguous subarray [5,4,-1,7,8] has the largest sum = 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to keep track of the current maximum sum as you iterate through the array.",
      "Consider using a greedy approach to help determine when to reset your current sum."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "topic": "Dynamic Programming",
    "subtopic": "Fibonacci Sequence",
    "tags": [
      "Dynamic Programming",
      "Fibonacci",
      "Recursion"
    ],
    "input_format": "An integer n representing the number of steps in the staircase.",
    "output_format": "An integer representing the number of distinct ways to climb to the top.",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb 2 steps: (1, 1) or (2)."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb 3 steps: (1, 1, 1), (1, 2), or (2, 1)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Think about how to break the problem into smaller subproblems.",
      "Consider using dynamic programming to store solutions to subproblems."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Sort Colors",
    "description": "Given an array nums containing red, white, and blue colors represented by numbers 0, 1, and 2, respectively, sort the array in place so that all 0's come first, followed by all 1's, and all 2's at the end. You must do this without using the sort function.",
    "topic": "Array",
    "subtopic": "In-place Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Two Pointers"
    ],
    "input_format": "An array nums where each element is either 0, 1, or 2.",
    "output_format": "The sorted array in place with all 0's first, followed by all 1's and all 2's.",
    "constraints": [
      "1 <= nums.length <= 300",
      "nums[i] is either 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "nums = [2, 0, 2, 1, 1, 0]",
        "output": "[0, 0, 1, 1, 2, 2]",
        "explanation": "After sorting, all 0's are moved to the front, followed by all 1's and all 2's."
      },
      {
        "input": "nums = [2, 0, 1]",
        "output": "[0, 1, 2]",
        "explanation": "All elements are sorted in such a way that 0 comes first, followed by 1, and finally 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a two-pointer approach to sort the colors in a single pass.",
      "Keep track of three pointers to segregate the colors."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Set Matrix Zeroes",
    "description": "Given a m x n matrix, if an element is 0, set its entire row and column to 0. You must do it in place.",
    "topic": "Matrix",
    "subtopic": "In-place manipulation",
    "tags": [
      "Matrix",
      "In-place",
      "Array"
    ],
    "input_format": "A 2D matrix represented as an array of arrays, where each element is an integer.",
    "output_format": "The modified 2D matrix with rows and columns set to zero, returned in-place.",
    "constraints": [
      "1 <= m, n <= 200",
      "-10^9 <= matrix[i][j] <= 10^9"
    ],
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": "The element at (1, 1) is 0, so we set its entire row and column to 0."
      },
      {
        "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
        "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
        "explanation": "The element at (0, 0) is 0, affecting the first row and first column."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use the first row and first column to mark zeros.",
      "Process the matrix in two passes: mark first row/column, then set zeros."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Add Binary",
    "description": "Given two binary strings a and b, return their sum as a binary string. The input strings are both non-empty and consist only of characters '0' and '1'.",
    "topic": "Strings",
    "subtopic": "Binary Manipulation",
    "tags": [
      "Binary",
      "Strings",
      "Math"
    ],
    "input_format": "Two binary strings a and b.",
    "output_format": "A binary string representing the sum of a and b.",
    "constraints": [
      "1 <= a.length, b.length <= 10^4",
      "a and b consist only of '0' and '1'."
    ],
    "examples": [
      {
        "input": "a = '1010', b = '1011'",
        "output": "'10101'",
        "explanation": "1010 + 1011 in binary equals 10101 in binary."
      },
      {
        "input": "a = '0', b = '0'",
        "output": "'0'",
        "explanation": "0 + 0 in binary equals 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Start from the end of both strings and remember to handle carry."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Multiply Strings",
    "description": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Note that you cannot use any built-in BigInteger library or convert the inputs to integer directly.",
    "topic": "Math",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Math",
      "Multiplication"
    ],
    "input_format": "Two strings num1 and num2, representing non-negative integers.",
    "output_format": "A string representing the product of num1 and num2.",
    "constraints": [
      "1 <= num1.length, num2.length <= 200",
      "num1 and num2 consist of digits only and do not have leading zeros."
    ],
    "examples": [
      {
        "input": "num1 = '123', num2 = '456'",
        "output": "'56388'",
        "explanation": "123 multiplied by 456 equals 56388."
      },
      {
        "input": "num1 = '2', num2 = '3'",
        "output": "'6'",
        "explanation": "2 multiplied by 3 equals 6."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider multiplication as repeated addition.",
      "You can multiply one digit at a time and handle carries."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Word Search",
    "description": "Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where 'adjacent' cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "topic": "Backtracking",
    "subtopic": "Depth-First Search",
    "tags": [
      "Backtracking",
      "Search",
      "Matrix"
    ],
    "input_format": "A 2D board represented as a list of lists of characters and a string \"word\".",
    "output_format": "A boolean indicating whether the word exists in the grid.",
    "constraints": [
      "1 <= board.length <= 200",
      "1 <= board[i].length <= 200",
      "board[i][j] is a lowercase English letter.",
      "1 <= word.length <= 20"
    ],
    "examples": [
      {
        "input": "board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'ABCCED'",
        "output": "true",
        "explanation": "The word 'ABCCED' can be found starting at (0,0), (0,1), (1,1), (1,2), (2,2), (2,3)."
      },
      {
        "input": "board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'SEE'",
        "output": "true",
        "explanation": "The word 'SEE' can be found starting at (2,0), (1,0), (1,1)."
      },
      {
        "input": "board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'ABCB'",
        "output": "false",
        "explanation": "The word 'ABCB' cannot be constructed from the board."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use Depth-First Search (DFS) to explore each cell.",
      "Keep track of visited cells to avoid using the same cell multiple times."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Reverse Integer",
    "description": "Given a 32-bit signed integer, reverse the digits of the integer. If the reversed integer overflows, return 0.",
    "topic": "Math",
    "subtopic": "Integer Manipulation",
    "tags": [
      "Math",
      "String",
      "Integer"
    ],
    "input_format": "A single integer x, where -2^31 <= x <= 2^31 - 1.",
    "output_format": "The reversed integer, or 0 if it overflows.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 123",
        "output": "321",
        "explanation": "The digits of 123 reversed become 321."
      },
      {
        "input": "x = -123",
        "output": "-321",
        "explanation": "The digits of -123 reversed become -321."
      },
      {
        "input": "x = 120",
        "output": "21",
        "explanation": "The integer 120 reversed is 21, as leading zeros are not counted."
      },
      {
        "input": "x = 1534236469",
        "output": "0",
        "explanation": "The reversed integer 9646324351 exceeds the 32-bit signed integer range, so the output is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to handle negative numbers.",
      "Use integer division and modulo to extract digits.",
      "Check for overflow conditions while reversing."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Generate Parentheses",
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
    "topic": "Backtracking",
    "subtopic": "Generating Combinations",
    "tags": [
      "Backtracking",
      "String",
      "Dynamic Programming"
    ],
    "input_format": "An integer n representing the number of pairs of parentheses.",
    "output_format": "A list of strings, where each string represents a combination of well-formed parentheses.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]",
        "explanation": "For n = 3, the valid combinations of parentheses are generated."
      },
      {
        "input": "n = 1",
        "output": "[\"()\"]",
        "explanation": "For n = 1, the only valid combination is a single pair of parentheses."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use backtracking to explore all possible combinations.",
      "Keep track of the number of open and close parentheses used.",
      "Generate combinations until both counts reach n."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Rotate Image",
    "description": "You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to do it without using any additional space for another matrix.",
    "topic": "Matrix",
    "subtopic": "In-place Array Manipulation",
    "tags": [
      "Matrix",
      "In-place",
      "Array"
    ],
    "input_format": "A 2D list of integers representing the n x n matrix.",
    "output_format": "The input matrix rotated by 90 degrees clockwise.",
    "constraints": [
      "1 <= n <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]",
        "explanation": "Rotating the matrix by 90 degrees clockwise results in [[7,4,1],[8,5,2],[9,6,3]]."
      },
      {
        "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
        "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
        "explanation": "After rotating, the matrix becomes [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to swap elements in layers.",
      "You may want to first transpose the matrix before reversing the rows."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Plus One",
    "description": "Given a non-empty array of digits representing a non-negative integer, increment the integer by one and return the resulting array of digits. The digits are stored such that the most significant digit is at the head of the list, and each element in the array is a single digit.",
    "topic": "Array",
    "subtopic": "Manipulation",
    "tags": [
      "Array",
      "Increment",
      "Digits"
    ],
    "input_format": "An array of integers digits where each digit is in the range [0, 9].",
    "output_format": "An array of integers representing the digits of the resulting integer after adding one.",
    "constraints": [
      "1 <= digits.length <= 100",
      "0 <= digits[i] <= 9",
      "digits does not contain any leading zero."
    ],
    "examples": [
      {
        "input": "digits = [1, 2, 3]",
        "output": "[1, 2, 4]",
        "explanation": "The integer represented is 123. After adding one, we get 124."
      },
      {
        "input": "digits = [9, 9, 9]",
        "output": "[1, 0, 0, 0]",
        "explanation": "The integer represented is 999. After adding one, we get 1000."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how you handle carrying over when a digit becomes 10."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. You should start from the top-left corner, move to the right, then downwards, then to the left, and finally upwards in a spiral manner until all elements are visited.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral"
    ],
    "input_format": "A 2D list of integers representing the matrix.",
    "output_format": "A list of integers representing the elements in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "The total number of elements in the matrix will not exceed 10^4."
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The elements in spiral order start from 1 and move right, then down to 6, left to 7, and up to 5."
      },
      {
        "input": "matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]",
        "output": "[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]",
        "explanation": "The spiral order starts with 1, moves through the first row, down the last column, and continues inwards."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use four pointers to track the boundaries of the spiral.",
      "Iteratively reduce the boundaries after completing each direction."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Regular Expression Matching",
    "description": "Implement a function that performs regular expression matching with support for '.' and '*'. The character '.' matches any single character, and '*' matches zero or more of the preceding element. Given a string 's' and a string 'p' representing the pattern, return true if 's' matches 'p'.",
    "topic": "String",
    "subtopic": "Regular Expressions",
    "tags": [
      "String",
      "Dynamic Programming",
      "Regular Expressions"
    ],
    "input_format": "A string s and a pattern string p.",
    "output_format": "A boolean value indicating whether the string matches the pattern.",
    "constraints": [
      "1 <= s.length, p.length <= 20",
      "s consists only of lowercase English letters.",
      "p consists of lowercase English letters, '.' and '*'."
    ],
    "examples": [
      {
        "input": "s = 'aab', p = 'c*a*b'",
        "output": "true",
        "explanation": "'c' can be ignored, 'a' must match 'a', and 'b' must match 'b'. Result is true."
      },
      {
        "input": "s = 'mississippi', p = 'mis*is*p*.'",
        "output": "false",
        "explanation": "'p' cannot match 'ss' and returns false."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using recursion or dynamic programming.",
      "Think about how to handle the '*' character."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Insert Interval",
    "description": "Given a list of non-overlapping intervals sorted by their start time and a new interval, insert the new interval into the list, merging any overlapping intervals if necessary. The intervals are represented as pairs of integers where each pair [start, end] denotes an interval in the list.",
    "topic": "Array",
    "subtopic": "Intervals",
    "tags": [
      "Array",
      "Intervals",
      "Merge"
    ],
    "input_format": "A list of non-overlapping intervals intervals, and a new interval newInterval.",
    "output_format": "A list of merged intervals after inserting the new interval.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^5",
      "newInterval.length == 2",
      "0 <= newInterval[0] <= newInterval[1] <= 10^5"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
        "output": "[[1,5],[6,9]]",
        "explanation": "The new interval [2,5] overlaps with [1,3], so we merge them into [1,5]."
      },
      {
        "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
        "output": "[[1,2],[3,10],[12,16]]",
        "explanation": "The new interval [4,8] overlaps with [3,5] and [6,7] and merges them into [3,10]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider where the new interval fits in the sorted order of existing intervals.",
      "Keep track of the start and end of the current merged interval."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Find the Index of the First Occurrence in a String",
    "description": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.",
    "topic": "String",
    "subtopic": "Searching",
    "tags": [
      "String",
      "Searching",
      "Index"
    ],
    "input_format": "Two strings: haystack (the string to search within) and needle (the string to find).",
    "output_format": "An integer representing the index of the first occurrence of needle in haystack or -1 if needle is not found.",
    "constraints": [
      "1 <= haystack.length, needle.length <= 10^4",
      "haystack and needle consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "haystack = 'sadbutsad', needle = 'sad'",
        "output": "0",
        "explanation": "The substring 'sad' appears at index 0 in 'sadbutsad'."
      },
      {
        "input": "haystack = 'leetcode', needle = 'leeto'",
        "output": "-1",
        "explanation": "'leeto' is not a substring of 'leetcode'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use the built-in string methods for searching.",
      "Consider edge cases where needle is an empty string."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Search a 2D Matrix",
    "description": "You are given an m x n integer matrix, matrix, where each row is sorted in non-decreasing order and each column is also sorted in non-decreasing order. You need to write a function that searches for a target value in the matrix. If the target exists, return true; otherwise, return false.",
    "topic": "Matrix",
    "subtopic": "Searching in Matrix",
    "tags": [
      "Matrix",
      "Binary Search",
      "Searching"
    ],
    "input_format": "A 2D array of integers matrix and an integer target.",
    "output_format": "A boolean value indicating whether the target exists in the matrix.",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 100",
      "-10^4 <= matrix[i][j], target <= 10^4"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [12, 14, 16]], target = 9",
        "output": "true",
        "explanation": "The target value 9 exists in the matrix."
      },
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [12, 14, 16]], target = 2",
        "output": "false",
        "explanation": "The target value 2 does not exist in the matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of the sorted matrix.",
      "Start searching from the top-right corner."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Sqrt(x)",
    "description": "Implement a function that calculates the square root of a non-negative integer x. The function should return the integer part of the square root. You may not use any built-in exponent function or operator, such as ** or sqrt(). Calculate and return the integer part of the square root of x, which is the largest integer y such that y * y <= x.",
    "topic": "Mathematics",
    "subtopic": "Binary Search",
    "tags": [
      "Math",
      "Binary Search",
      "Square Root"
    ],
    "input_format": "A single non-negative integer x.",
    "output_format": "An integer representing the square root of x.",
    "constraints": [
      "0 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 4",
        "output": "2",
        "explanation": "The square root of 4 is 2."
      },
      {
        "input": "x = 8",
        "output": "2",
        "explanation": "The square root of 8 is approximately 2.828, but we return the integer part, which is 2."
      },
      {
        "input": "x = 0",
        "output": "0",
        "explanation": "The square root of 0 is 0."
      },
      {
        "input": "x = 1",
        "output": "1",
        "explanation": "The square root of 1 is 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using binary search to narrow down the possible values of the square root.",
      "The result needs to be an integer, so think about the condition when to stop searching."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Binary Tree Zigzag Level Order Traversal",
    "description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Breadth-First Search",
      "Traversal"
    ],
    "input_format": "The input is the root of a binary tree.",
    "output_format": "A list of lists of integers representing the zigzag level order traversal.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[20,9],[15,7]]",
        "explanation": "The tree has three levels. The first level is [3]. The second level is [20, 9] (traversed from right to left). The third level is [15, 7]."
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": "The tree has only one node, so the zigzag traversal is just [[1]]."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree results in an empty traversal, so the output is []."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to keep track of the current level's nodes.",
      "Alternate the traversal direction at each level.",
      "You can use a boolean flag to track the direction of traversal."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Divide Two Integers",
    "description": "Given two integers representing the numerator and the denominator, perform division without using the division operator. Return the quotient after dividing numerator by denominator. The result should be truncated towards zero, meaning that there is no rounding. If the result is too large to fit in a 32-bit signed integer, return the maximum value for a 32-bit signed integer (2^31 - 1) or minimum value (-2^31) when the corresponding overflow occurs.",
    "topic": "Math",
    "subtopic": "Bit Manipulation",
    "tags": [
      "Math",
      "Bit Manipulation",
      "Division"
    ],
    "input_format": "Two integers, numerator and denominator.",
    "output_format": "An integer representing the quotient of the division.",
    "constraints": [
      "-2^31 <= numerator, denominator <= 2^31 - 1",
      "denominator != 0"
    ],
    "examples": [
      {
        "input": "numerator = 10, denominator = 3",
        "output": "3",
        "explanation": "10 divided by 3 is 3.3333, which truncated towards zero gives 3."
      },
      {
        "input": "numerator = 7, denominator = -3",
        "output": "-2",
        "explanation": "7 divided by -3 is -2.3333, which truncated towards zero gives -2."
      },
      {
        "input": "numerator = 1, denominator = 1",
        "output": "1",
        "explanation": "1 divided by 1 is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using bit manipulation to achieve division.",
      "Handle the sign of the result separately.",
      "Be cautious of edge cases regarding overflow."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Largest Rectangle in Histogram",
    "description": "Given an array of integers representing the heights of bars in a histogram, find the area of the largest rectangle that can be formed in the histogram. You must solve the problem in O(n) time complexity.",
    "topic": "Stack",
    "subtopic": "Monotonic Stack",
    "tags": [
      "Stack",
      "Array",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers heights where heights[i] represents the height of the i-th bar.",
    "output_format": "An integer representing the area of the largest rectangle that can be formed in the histogram.",
    "constraints": [
      "1 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [2,1,5,6,2,3]",
        "output": "10",
        "explanation": "The largest rectangle can be formed between heights 5 and 6, giving an area of 10."
      },
      {
        "input": "heights = [2,4]",
        "output": "4",
        "explanation": "The largest rectangle can be formed with the height of 4, resulting in an area of 4."
      },
      {
        "input": "heights = [0,9,0,5,0,1,2]",
        "output": "9",
        "explanation": "The tallest bar has a height of 9 and forms the largest rectangle."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a stack to keep track of the indices of the histogram.",
      "When iterating, calculate the area whenever you pop from the stack.",
      "Consider the height of the bars and the width determined by the indices in the stack."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Binary Tree Level Order Traversal",
    "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Breadth-First Search",
      "Traversal"
    ],
    "input_format": "The input consists of a binary tree represented by its root node.",
    "output_format": "A list of lists, where each inner list contains the values of the nodes at that level.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000]",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[9,20],[15,7]]",
        "explanation": "Level order traversal of the tree is: first level [3], second level [9, 20], third level [15, 7]."
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": "Tree with only one node, so the output is [[1]]."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree results in an empty output."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a queue to facilitate level order traversal.",
      "Remember to process nodes level by level."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array II",
    "description": "Given a sorted array of integers, you need to remove duplicates such that each element appears at most twice. The order of elements should be maintained. You must do this in-place and within O(1) extra space. Return the new length of the array after removing duplicates.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "In-place",
      "Two Pointers"
    ],
    "input_format": "An integer array nums, sorted in non-decreasing order.",
    "output_format": "An integer representing the new length of the array after duplicates are removed.",
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3]",
        "output": "5",
        "explanation": "Unique elements allowed are 1, 1, 2, 2, and 3. New array is [1, 1, 2, 2, 3]."
      },
      {
        "input": "nums = [0,0,1,1,1,1,2,3,3]",
        "output": "7",
        "explanation": "Unique elements allowed are 0, 0, 1, 1, 2, 3, 3. New array is [0, 0, 1, 1, 2, 3, 3]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use two pointers to keep track of the position to overwrite.",
      "Count occurrences of each number and manage the count within the limit."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Unique Paths",
    "description": "A robot is situated at the top-left corner of a m x n grid and can only move either down or right at any point in time. The robot is supposed to reach the bottom-right corner of the grid. Given the dimensions of the grid, calculate how many unique paths the robot can take to reach the destination.",
    "topic": "Dynamic Programming",
    "subtopic": "Combinatorics",
    "tags": [
      "Dynamic Programming",
      "Combinatorics",
      "Grid"
    ],
    "input_format": "Two integers m and n, representing the number of rows and columns in the grid.",
    "output_format": "An integer representing the number of unique paths from the top-left to the bottom-right corner.",
    "constraints": [
      "1 <= m, n <= 100"
    ],
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": "There are 28 unique paths to reach the bottom-right corner from the top-left corner."
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "There are 3 unique paths to reach the bottom-right corner from the top-left corner."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store intermediate results.",
      "Think about the combinatorial aspect of path selection."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Jump Game",
    "description": "You are given an array of non-negative integers nums. You are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to determine if you are able to reach the last index. Return true if you can reach the last index, otherwise return false.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers nums, where 1 <= nums.length <= 10^4.",
    "output_format": "A boolean value indicating whether it is possible to reach the last index.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "true",
        "explanation": "You can jump to index 1 (jump 2), then jump to index 4 (jump 3)."
      },
      {
        "input": "nums = [3,2,1,0,4]",
        "output": "false",
        "explanation": "You will always reach index 3, where you cannot jump to reach the last index."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how far you can jump from each position.",
      "Use a greedy approach to keep track of the farthest index you can reach."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Remove Element",
    "description": "Given an array of integers nums and a value val, you need to remove all instances of that value in-place and return the new length of the array. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.",
    "topic": "Array",
    "subtopic": "In-place Modification",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An integer array nums, followed by an integer val.",
    "output_format": "An integer representing the new length of the array after removing val.",
    "constraints": [
      "0 <= nums.length <= 100",
      "-100 <= nums[i] <= 100",
      "0 <= val <= 100"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 2, 3], val = 3",
        "output": "2",
        "explanation": "After removing all instances of 3, the array is [2, 2] with a new length of 2."
      },
      {
        "input": "nums = [0, 1, 2, 2, 3, 0, 4, 2], val = 2",
        "output": "5",
        "explanation": "After removing all instances of 2, the array is [0, 1, 3, 0, 4] with a new length of 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to keep track of the position of the new array."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "3Sum Closest",
    "description": "Given an integer array nums of length n, you want to find three integers in nums such that the sum is closest to a given integer target. Return the sum of the three integers. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An integer representing the sum of the three integers that is closest to the target.",
    "constraints": [
      "3 <= nums.length <= 10^3",
      "-10^10 <= nums[i] <= 10^10",
      "-10^10 <= target <= 10^10"
    ],
    "examples": [
      {
        "input": "nums = [-1, 2, 1, -4], target = 1",
        "output": "2",
        "explanation": "The sum that is closest to the target (1) is (-1) + 2 + 1 = 2."
      },
      {
        "input": "nums = [0, 0, 0], target = 1",
        "output": "0",
        "explanation": "The only three integers are 0, 0, and 0, and their sum is 0, which is closest to 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array first to use two pointers.",
      "Keep track of the closest sum found so far."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Validate Binary Search Tree",
    "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: \n- The left subtree of a node contains only nodes with keys less than the node\u2019s key. \n- The right subtree of a node contains only nodes with keys greater than the node\u2019s key. \n- Both the left and right subtrees must also be binary search trees.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "The input consists of the root node of a binary tree.",
    "output_format": "Return true if it is a valid binary search tree, else return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 104].",
      "Each node's value is in the range [-2^31, 2^31 - 1]."
    ],
    "examples": [
      {
        "input": "root = [2, 1, 3]",
        "output": "true",
        "explanation": "The binary tree is:\n    2\n   / \\\n  1   3\n\nIt meets the criteria for a binary search tree."
      },
      {
        "input": "root = [5, 1, 4, null, null, 3, 6]",
        "output": "false",
        "explanation": "The binary tree is:\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n\nIt violates the BST property (4 > 3)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a recursive function to validate the BST properties.",
      "Track the valid range of values for each node."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Combination Sum",
    "description": "Given an array of distinct integers candidates and a target integer target, return all unique combinations of candidates where the chosen numbers sum to target. You may return the answer in any order. Each number in candidates may be used an unlimited number of times in the combination.",
    "topic": "Backtracking",
    "subtopic": "Combinatorial Search",
    "tags": [
      "Backtracking",
      "Combination",
      "DFS"
    ],
    "input_format": "An array of distinct integers candidates and a target integer target.",
    "output_format": "A list of lists containing all unique combinations that sum to the target.",
    "constraints": [
      "1 <= candidates.length <= 30",
      "1 <= candidates[i] <= 200",
      "All elements in candidates are distinct.",
      "1 <= target <= 500"
    ],
    "examples": [
      {
        "input": "candidates = [2, 3, 6, 7], target = 7",
        "output": "[[2, 2, 3], [7]]",
        "explanation": "The combinations that sum to 7 are [2, 2, 3] and [7]."
      },
      {
        "input": "candidates = [1], target = 2",
        "output": "[[1, 1]]",
        "explanation": "The only combination that sums to 2 is [1, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use backtracking to explore all possibilities.",
      "Consider how to handle duplicates in the results."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Text Justification",
    "description": "Given an array of words and a maximum width, format the text such that each line contains exactly maxWidth characters. The last line should be left-justified and not exceed maxWidth. Each line should start with the first word and be filled with spaces evenly distributed between the words. If the number of spaces is not divisible by the number of gaps between words, the extra spaces should be distributed starting from the leftmost gap.",
    "topic": "String",
    "subtopic": "Text Formatting",
    "tags": [
      "String",
      "Text Justification",
      "Formatting"
    ],
    "input_format": "An array of strings words and an integer maxWidth.",
    "output_format": "An array of strings representing the justified text.",
    "constraints": [
      "1 <= words.length <= 300",
      "1 <= words[i].length <= 20",
      "words[i] consists of only English letters and spaces.",
      "maxWidth is a positive integer and less than or equal to 100."
    ],
    "examples": [
      {
        "input": {
          "words": [
            "This",
            "is",
            "an",
            "example",
            "of",
            "text",
            "justification."
          ],
          "maxWidth": 16
        },
        "output": [
          "This    is    an",
          "example  of text",
          "justification.  "
        ],
        "explanation": "The first line is justified with extra spaces between words. The last line is left-justified."
      },
      {
        "input": {
          "words": [
            "What",
            "must",
            "be",
            "acknowledgment",
            "shall",
            "be"
          ],
          "maxWidth": 16
        },
        "output": [
          "What   must   be",
          "acknowledgment  ",
          "shall be        "
        ],
        "explanation": "Lines are filled with spaces to meet the maxWidth, with the last line left-justified."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to distribute spaces evenly.",
      "Handle the last line as a special case.",
      "Keep track of the number of gaps and spaces remaining."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Subsets II",
    "description": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.",
    "topic": "Backtracking",
    "subtopic": "Combinatorial Generation",
    "tags": [
      "Backtracking",
      "Recursion",
      "Subsets"
    ],
    "input_format": "An integer array nums with potential duplicate elements.",
    "output_format": "A list of lists containing all unique subsets.",
    "constraints": [
      "0 <= nums.length <= 10^8",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2]",
        "output": "[[], [1], [1, 2], [2], [2, 2]]",
        "explanation": "The unique subsets are: {}, {1}, {1,2}, {2}, {2,2}"
      },
      {
        "input": "nums = [0]",
        "output": "[[], [0]]",
        "explanation": "The unique subsets are: {}, {0}"
      },
      {
        "input": "nums = []",
        "output": "[[]]",
        "explanation": "The only subset of an empty array is the empty subset."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the input array to handle duplicates.",
      "Use backtracking to explore all subsets.",
      "Skip over duplicates when generating subsets."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Zigzag Conversion",
    "description": "The input string is to be read line by line in a zigzag pattern on a given number of rows, and then read line by line again to generate a new string. For example, if the input string is 'PAYPALISHIRING' and the number of rows is 3, the zigzag pattern on the rows looks like this:\n\nP   A   H   N\nA P L S I I G\nY   I   \n\nThe output string should be 'PAHNAPLSIIGY'. Write a function to convert a given string into its zigzag pattern based on the specified number of rows and return the resulting string.",
    "topic": "String",
    "subtopic": "Pattern Matching",
    "tags": [
      "String",
      "Zigzag",
      "Pattern"
    ],
    "input_format": "A string s and an integer numRows representing the number of rows.",
    "output_format": "A single string representing the characters rearranged in zigzag order.",
    "constraints": [
      "1 <= s.length <= 1000",
      "1 <= numRows <= 1000"
    ],
    "examples": [
      {
        "input": "s = 'PAYPALISHIRING', numRows = 3",
        "output": "PAHNAPLSIIGY",
        "explanation": "The zigzag pattern will convert the string to 'PAHNAPLSIIGY' when read row-wise."
      },
      {
        "input": "s = 'A', numRows = 1",
        "output": "A",
        "explanation": "With one row, the output will be the same as the input."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a variable to track the current row.",
      "Alternate between going down and going up in the zigzag pattern.",
      "Consider using an array of strings to collect characters for each row."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Valid Sudoku",
    "description": "Determine if a 9x9 Sudoku board is valid. Only the digits 1-9 are allowed in each row, column, and 3x3 sub-box. Empty cells are represented by '.' and do not affect the validity of the board.",
    "topic": "Backtracking",
    "subtopic": "Sudoku Validation",
    "tags": [
      "Backtracking",
      "Matrix",
      "Validation"
    ],
    "input_format": "A 9x9 2D character array representing the Sudoku board.",
    "output_format": "Return true if the Sudoku board is valid, otherwise return false.",
    "constraints": [
      "The board is represented by a 9x9 character array.",
      "Each cell contains either a digit ('1' to '9') or a '.' for an empty cell."
    ],
    "examples": [
      {
        "input": "[['5', '3', '.', '.', '7', '.', '.', '.', '.'], ['6', '.', '.', '1', '9', '5', '.', '.', '.'], ['.', '9', '8', '.', '.', '.', '.', '6', '.'], ['8', '.', '.', '.', '6', '.', '.', '.', '3'], ['4', '.', '.', '8', '.', '3', '.', '.', '1'], ['7', '.', '.', '.', '2', '.', '.', '.', '6'], ['.', '6', '.', '.', '.', '.', '2', '8', '.'], ['.', '.', '.', '4', '1', '9', '.', '.', '5'], ['.', '.', '.', '.', '8', '.', '.', '7', '9']]",
        "output": "true",
        "explanation": "The board follows all Sudoku rules."
      },
      {
        "input": "[['8', '3', '.', '.', '7', '.', '.', '.', '.'], ['6', '.', '.', '1', '9', '5', '.', '.', '.'], ['.', '9', '8', '.', '.', '.', '.', '6', '.'], ['8', '.', '.', '.', '6', '.', '.', '.', '3'], ['4', '.', '.', '8', '.', '3', '.', '.', '1'], ['7', '.', '.', '.', '2', '.', '.', '.', '6'], ['.', '6', '.', '.', '.', '.', '2', '8', '.'], ['.', '.', '.', '4', '1', '9', '.', '.', '5'], ['.', '.', '.', '.', '8', '.', '.', '7', '9']]",
        "output": "false",
        "explanation": "The number '8' appears more than once in the first column."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Make use of sets to track numbers seen in rows, columns, and boxes.",
      "Consider using a nested loop to iterate through the board."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Binary Tree Inorder Traversal",
    "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values. In an inorder traversal, the nodes are recursively visited in this order; left subtree, root node, right subtree.",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Binary Tree",
      "Traversal"
    ],
    "input_format": "The input consists of a root node of a binary tree.",
    "output_format": "An array of integers representing the inorder traversal of the binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[1,3,2]",
        "explanation": "The inorder traversal of the binary tree is 1 -> 3 -> 2."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "The binary tree is empty, so the result is an empty array."
      },
      {
        "input": "root = [1]",
        "output": "[1]",
        "explanation": "The binary tree has only one node, so the result is [1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Think about the recursive nature of trees.",
      "You can also use a stack to simulate the recursion."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Reverse Nodes in k-Group",
    "description": "Given a linked list, reverse the nodes of the list k at a time and return its modified form. If the number of nodes is not a multiple of k, then left-out nodes in the end should remain as they are. You may not alter the values in the list's nodes, only nodes themselves may be changed.",
    "topic": "Linked List",
    "subtopic": "Reversing Linked List",
    "tags": [
      "Linked List",
      "Reversal",
      "Two Pointers"
    ],
    "input_format": "The head of the linked list and an integer k.",
    "output_format": "The head of the modified linked list after reversing nodes in k groups.",
    "constraints": [
      "The number of nodes in the linked list is in the range [0, 5000].",
      "0 <= Node.val <= 1000.",
      "1 <= k <= 5000."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], k = 2",
        "output": "[2, 1, 4, 3, 5]",
        "explanation": "The nodes are reversed for each pair, resulting in [2, 1] and [4, 3]."
      },
      {
        "input": "head = [1, 2, 3], k = 3",
        "output": "[3, 2, 1]",
        "explanation": "The entire list is reversed since its length is equal to k."
      },
      {
        "input": "head = [1, 2, 3, 4, 5], k = 3",
        "output": "[3, 2, 1, 4, 5]",
        "explanation": "The first three nodes are reversed resulting in [3, 2, 1], and the remaining [4, 5] stay as is."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Try to find a method to reverse a portion of the linked list.",
      "Consider using a dummy node to simplify edge cases.",
      "Keep track of the previous group's end to connect with the next reversed group."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Decode Ways",
    "description": "A message containing letters from A-Z can be encoded into numbers using the mapping 'A' = 1, 'B' = 2, ..., 'Z' = 26. Given a string s consisting of digits, return the total number of ways to decode it. For example, the string '12' can be decoded as 'AB' (1 2) or 'L' (12). Your task is to find out how many different ways you can decode the given string.",
    "topic": "Dynamic Programming",
    "subtopic": "Counting Combinations",
    "tags": [
      "Dynamic Programming",
      "String",
      "Counting"
    ],
    "input_format": "A non-empty string s, consisting of digits (1-9) only.",
    "output_format": "An integer representing the total number of valid ways to decode the string.",
    "constraints": [
      "1 <= s.length <= 100",
      "s[i] != '0' (1-indexed)"
    ],
    "examples": [
      {
        "input": "s = '12'",
        "output": "2",
        "explanation": "The string '12' can be decoded as 'AB' (1 2) or 'L' (12), giving a total of 2 ways."
      },
      {
        "input": "s = '226'",
        "output": "3",
        "explanation": "The string '226' can be decoded as 'BBF' (2 2 6), 'BZ' (2 26), or 'VF' (22 6), giving a total of 3 ways."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store previous results.",
      "Think about how to combine one or two digits at a time."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Permutations",
    "description": "Given a collection of distinct integers, return all possible permutations. You can return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Permutations",
      "Recursion"
    ],
    "input_format": "A list of distinct integers.",
    "output_format": "A list of lists, where each sublist is a permutation of the input integers.",
    "constraints": [
      "1 <= nums.length <= 10",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": "The permutations of [1, 2, 3] can be formed by arranging all elements in various orders."
      },
      {
        "input": "nums = [0, 1]",
        "output": "[[0,1],[1,0]]",
        "explanation": "The permutations of [0, 1] are simply the two ways to arrange the two numbers."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a backtracking approach to explore all the permutations.",
      "Use a boolean array to keep track of the elements that have been included in the current permutation."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Maximal Rectangle",
    "description": "Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "Matrix",
    "tags": [
      "Dynamic Programming",
      "Matrix",
      "Rectangle"
    ],
    "input_format": "A 2D binary matrix represented as an array of arrays.",
    "output_format": "An integer representing the area of the largest rectangle containing only 1's.",
    "constraints": [
      "1 <= matrix.length <= 200",
      "1 <= matrix[i].length <= 200",
      "matrix[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "[['1', '0', '1', '0', '0'], ['1', '0', '1', '1', '1'], ['1', '1', '1', '1', '1'], ['1', '0', '0', '1', '0']]",
        "output": "6",
        "explanation": "The largest rectangle containing only 1's has an area of 6."
      },
      {
        "input": "[['0', '0', '0', '0'], ['0', '0', '0', '0']]",
        "output": "0",
        "explanation": "There are no 1's in the matrix, hence the area is 0."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a histogram approach to solve this problem.",
      "Consider the heights of consecutive 1's as you traverse each row."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array nums, return the smallest missing positive integer.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Math"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the smallest missing positive integer.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3, 4, -1, 1]",
        "output": "2",
        "explanation": "The smallest missing positive integer is 2."
      },
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "The smallest missing positive integer is 3."
      },
      {
        "input": "nums = [7, 8, 9, 11, 12]",
        "output": "1",
        "explanation": "The smallest missing positive integer is 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use the array itself for hashing.",
      "Consider swapping elements to their correct positions."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "4Sum",
    "description": "Given an array of integers nums and an integer target, return all unique quadruplets (a, b, c, d) such that a + b + c + d = target. You may return the answer in any order. Each quadruplet must be unique, meaning that the same combination of integers in different orders will not be counted multiple times.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Hashing"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "A list of unique quadruplets that sum up to the target.",
    "constraints": [
      "0 <= nums.length <= 200",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 0, -1, 0, -2, 2], target = 0",
        "output": "[[-2, -1, 0, 1], [-2, 0, 0, 2], [-1, 0, 0, 1]]",
        "explanation": "The unique quadruplets that sum to 0 are [-2, -1, 0, 1] and [-2, 0, 0, 2]."
      },
      {
        "input": "nums = [2, 2, 2, 2, 2], target = 8",
        "output": "[[2, 2, 2, 2]]",
        "explanation": "The only unique quadruplet that sums to 8 is [2, 2, 2, 2]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the array to avoid duplicates.",
      "Use a nested loop structure along with two pointers."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Minimum Depth of Binary Tree",
    "description": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. A leaf is a node with no children.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth"
    ],
    "input_format": "The input is the root node of a binary tree.",
    "output_format": "An integer representing the minimum depth of the binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^5].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "2",
        "explanation": "The minimum depth is 2: the path is 3 -> 9."
      },
      {
        "input": "root = [2,null,3,null,4,null,5,null,6]",
        "output": "5",
        "explanation": "The minimum depth is 5: the path is 2 -> 3 -> 4 -> 5 -> 6."
      },
      {
        "input": "root = []",
        "output": "0",
        "explanation": "The tree has no nodes, so the minimum depth is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a depth-first search approach.",
      "Check for leaf nodes and update the depth accordingly.",
      "Consider edge cases with trees having only one child."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Wildcard Matching",
    "description": "Given a string s and a wildcard pattern p, implement wildcard matching with support for '?' and '*'. The '?' wildcard matches exactly one character, while '*' matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial).",
    "topic": "Dynamic Programming",
    "subtopic": "String Matching",
    "tags": [
      "Dynamic Programming",
      "String",
      "Matching"
    ],
    "input_format": "Two strings s and p, where s is the input string and p is the wildcard pattern.",
    "output_format": "True if s matches p, otherwise False.",
    "constraints": [
      "0 <= s.length, p.length <= 2000",
      "s and p consist of only lowercase letters, '?' and '*'."
    ],
    "examples": [
      {
        "input": "s = \"aa\", p = \"a\"",
        "output": "false",
        "explanation": "Pattern 'a' matches exactly one character, while 's' has two, so it doesn't match."
      },
      {
        "input": "s = \"aa\", p = \"*\"",
        "output": "true",
        "explanation": "Pattern '*' can match any sequence of characters, including the entire string 'aa'."
      },
      {
        "input": "s = \"cb\", p = \"?a\"",
        "output": "false",
        "explanation": "Pattern '?a' requires the second character to be 'a', but the string 'cb' has 'b' at that position."
      },
      {
        "input": "s = \"adceb\", p = \"*a*b\"",
        "output": "true",
        "explanation": "Pattern '*a*b' can match 'adceb' as '*' can represent 'dce' and still allow for 'a' and 'b'."
      },
      {
        "input": "s = \"acdcb\", p = \"a*c?b\"",
        "output": "false",
        "explanation": "Pattern 'a*c?b' does not match 'acdcb' as the third character does not correspond."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use dynamic programming to solve the problem.",
      "Consider using a 2D table to track matching states."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Combination Sum II",
    "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note that the solution set must not contain duplicate combinations.",
    "topic": "Backtracking",
    "subtopic": "Combination Sum",
    "tags": [
      "Backtracking",
      "Combination",
      "DFS"
    ],
    "input_format": "An array of unique integers candidates and an integer target.",
    "output_format": "A list of all unique combinations of candidates that sum to target.",
    "constraints": [
      "1 <= candidates.length <= 100",
      "1 <= candidates[i] <= 50",
      "target is a positive integer."
    ],
    "examples": [
      {
        "input": "candidates = [10, 1, 2, 7, 6, 1, 5], target = 8",
        "output": "[[1, 1, 6], [1, 2, 5], [2, 6], [1, 7]]",
        "explanation": "The combinations that sum to 8 are [1, 1, 6], [1, 2, 5], [2, 6], [1, 7]."
      },
      {
        "input": "candidates = [2, 5, 2, 1, 2], target = 5",
        "output": "[[1, 2, 2], [5]]",
        "explanation": "The valid combinations are [1, 2, 2] and [5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to explore combinations.",
      "You may want to sort the candidates first to handle duplicates."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Unique Paths II",
    "description": "A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). There are some obstacles in the grid that the robot cannot pass through. You need to return the number of unique paths from the top-left corner to the bottom-right corner. An obstacle is represented by 1 and a free space is represented by 0. It is guaranteed that the starting point and the ending point will not be obstacles.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Path Finding"
    ],
    "input_format": "A 2D grid represented as a list of lists of integers, where 0 represents a free cell and 1 represents an obstacle.",
    "output_format": "An integer representing the number of unique paths from the top-left corner to the bottom-right corner.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 100",
      "grid[i][j] is 0 or 1",
      "The starting and ending point will not be obstacles."
    ],
    "examples": [
      {
        "input": "grid = [[0,0,0],[0,1,0],[0,0,0]]",
        "output": "2",
        "explanation": "There are two unique paths: (0,0) \u2192 (0,1) \u2192 (0,2) \u2192 (1,2) \u2192 (2,2) and (0,0) \u2192 (1,0) \u2192 (2,0) \u2192 (2,1) \u2192 (2,2)."
      },
      {
        "input": "grid = [[0,1],[0,0]]",
        "output": "1",
        "explanation": "There is only one path from the top-left to the bottom-right corner."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to keep track of paths.",
      "You can represent the number of ways to reach each cell.",
      "Start from the base case where the robot is at the starting position."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Rotate List",
    "description": "Given a singly linked list, rotate the list to the right by k places, where k is non-negative. For example, if the list is 1 -> 2 -> 3 -> 4 -> 5 and k = 2, the list should become 4 -> 5 -> 1 -> 2 -> 3.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "Linked List",
      "Rotation",
      "Two Pointers"
    ],
    "input_format": "The head of the linked list and an integer k.",
    "output_format": "The head of the rotated linked list.",
    "constraints": [
      "The linked list has at most 5000 nodes.",
      "0 <= k <= 100"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], k = 2",
        "output": "[4, 5, 1, 2, 3]",
        "explanation": "Rotating the list to the right by 2 places results in the list 4 -> 5 -> 1 -> 2 -> 3."
      },
      {
        "input": "head = [1, 2, 3], k = 4",
        "output": "[3, 1, 2]",
        "explanation": "k = 4 is equivalent to k = 1 since rotating by the length of the list returns the same list."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the length of the linked list when determining the rotation.",
      "Try to find the new head of the list after rotating."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array II",
    "description": "Given an integer array nums that is sorted in non-decreasing order and possibly rotated at some pivot unknown to you beforehand, and an integer target, return true if target is in nums, or false if it is not. Note that duplicates may be present in the array.",
    "topic": "Binary Search",
    "subtopic": "Search in Rotated Array",
    "tags": [
      "Binary Search",
      "Array",
      "Searching"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "A boolean value indicating whether target is in nums.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "nums may contain duplicates."
    ],
    "examples": [
      {
        "input": "nums = [2, 5, 6, 0, 0, 1, 2], target = 0",
        "output": "true",
        "explanation": "The target 0 is present in the array."
      },
      {
        "input": "nums = [2, 5, 6, 0, 0, 1, 2], target = 3",
        "output": "false",
        "explanation": "The target 3 is not present in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of the rotated sorted array.",
      "Use binary search but handle the duplicates carefully."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Jump Game II",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Write a function that returns the minimum number of jumps required to reach the last index.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithms",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "An integer representing the minimum number of jumps to reach the last index.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "2",
        "explanation": "Jump 1 step from index 0 to 1, then 1 jump to the last index."
      },
      {
        "input": "nums = [2,3,0,1,4]",
        "output": "2",
        "explanation": "Jump 2 steps from index 0 to index 4."
      },
      {
        "input": "nums = [0]",
        "output": "0",
        "explanation": "You are already at the last index."
      },
      {
        "input": "nums = [1,2,3]",
        "output": "2",
        "explanation": "Jump 1 to index 1, then 1 to index 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the farthest you can reach from each position.",
      "Keep track of the current end of the jump range."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "description": "Given two integer arrays, preorder and inorder, which represent the preorder and inorder traversal of a binary tree, construct the binary tree and return its root. It is guaranteed that the input arrays are valid and represent the same binary tree.",
    "topic": "Tree",
    "subtopic": "Binary Tree Construction",
    "tags": [
      "Tree",
      "Binary Tree",
      "Construction"
    ],
    "input_format": "Two integer arrays, preorder and inorder, representing the preorder and inorder traversal of a binary tree respectively.",
    "output_format": "Return the root node of the constructed binary tree.",
    "constraints": [
      "1 <= preorder.length <= 3000",
      "preorder.length == inorder.length",
      "0 <= preorder[i], inorder[i] <= 3000"
    ],
    "examples": [
      {
        "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",
        "output": "[3,9,20,null,null,15,7]",
        "explanation": "The constructed binary tree is: \n     3\n    / \\\n   9  20\n      / \\\n     15  7"
      },
      {
        "input": "preorder = [1], inorder = [1]",
        "output": "[1]",
        "explanation": "The constructed binary tree is a single node with value 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "The first element of preorder is always the root of the tree.",
      "Use the inorder array to determine the left and right subtrees."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Maximum Depth of Binary Tree",
    "description": "Given a binary tree, return its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "topic": "Tree",
    "subtopic": "Depth-First Search",
    "tags": [
      "Tree",
      "Depth",
      "Recursion"
    ],
    "input_format": "The root node of a binary tree.",
    "output_format": "An integer representing the maximum depth of the binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "3",
        "explanation": "The maximum depth is 3 since the longest path is 3 -> 20 -> 15 or 3 -> 20 -> 7."
      },
      {
        "input": "root = [1,null,2]",
        "output": "2",
        "explanation": "The maximum depth is 2 since there's only the path 1 -> 2."
      },
      {
        "input": "root = []",
        "output": "0",
        "explanation": "An empty tree has a maximum depth of 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a recursive function to explore each node.",
      "The depth of a node is 1 plus the maximum depth of its children."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List II",
    "description": "Given the head of a linked list and two integers left and right where left <= right, reverse the nodes of the linked list from position left to position right, and return the modified list.",
    "topic": "Linked List",
    "subtopic": "Reversal",
    "tags": [
      "Linked List",
      "Reversal",
      "Two Pointers"
    ],
    "input_format": "The input consists of the head of the linked list and two integers left and right.",
    "output_format": "The head of the modified linked list after reversing the specified section.",
    "constraints": [
      "1 <= left <= right <= n",
      "The number of nodes in the list is n.",
      "1 <= n <= 500"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], left = 2, right = 4",
        "output": "[1, 4, 3, 2, 5]",
        "explanation": "Reversing the nodes from position 2 to 4 results in the list: 1 -> 4 -> 3 -> 2 -> 5."
      },
      {
        "input": "head = [1, 2, 3, 4, 5], left = 1, right = 5",
        "output": "[5, 4, 3, 2, 1]",
        "explanation": "Reversing the whole list results in: 5 -> 4 -> 3 -> 2 -> 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dummy node to simplify edge cases.",
      "Use a loop to reach the left position.",
      "When reversing nodes, keep track of the previous node."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Search Insert Position",
    "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Insertion"
    ],
    "input_format": "A sorted array of distinct integers nums and an integer target.",
    "output_format": "An integer representing the index where the target is or would be inserted.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums contains distinct values."
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 5, 6], target = 5",
        "output": "2",
        "explanation": "The target 5 is found at index 2."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 2",
        "output": "1",
        "explanation": "If we were to insert 2, it would be at index 1."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 7",
        "output": "4",
        "explanation": "If we were to insert 7, it would be at index 4."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 0",
        "output": "0",
        "explanation": "If we were to insert 0, it would be at index 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using binary search to achieve better performance."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Edit Distance",
    "description": "Given two strings 'word1' and 'word2', return the minimum number of operations required to convert 'word1' into 'word2'. You may perform the following operations: insert a character, delete a character, or replace a character.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Edit Distance"
    ],
    "input_format": "Two strings 'word1' and 'word2'.",
    "output_format": "An integer representing the minimum number of operations required to convert 'word1' to 'word2'.",
    "constraints": [
      "0 <= word1.length, word2.length <= 100",
      "word1 and word2 consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "word1 = \"horse\", word2 = \"ros\"",
        "output": "3",
        "explanation": "The minimum number of operations is 3. horse -> rorse (replace 'h' with 'r') -> rorese (replace 'r' with 'r') -> ros (remove 'e')."
      },
      {
        "input": "word1 = \"intention\", word2 = \"execution\"",
        "output": "5",
        "explanation": "The minimum number of operations is 5. intention -> inention (remove 't') -> enention (remove 'i') -> exention (replace 'n' with 'x') -> exection (replace 'n' with 'c') -> execution (add 'u')."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a 2D array to store the results of subproblems.",
      "Build the solution from smaller subproblems to larger ones."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Sudoku Solver",
    "description": "Write a program that solves a given Sudoku puzzle by filling the empty cells. A Sudoku puzzle is a 9x9 grid where some cells are filled with digits from 1 to 9, and others are empty (represented by the character '.'). The Sudoku rules are as follows: each row must contain the digits 1-9 without repetition, each column must contain the digits 1-9 without repetition, and each of the nine 3x3 sub-grids must contain the digits 1-9 without repetition.",
    "topic": "Backtracking",
    "subtopic": "Constraint Satisfaction Problem",
    "tags": [
      "Backtracking",
      "Matrix",
      "DFS"
    ],
    "input_format": "A 9x9 2D array (list of lists) representing the Sudoku board where each element is a character ('.' for empty cells, '1'-'9' for filled cells).",
    "output_format": "The same 9x9 2D array with the empty cells filled such that the Sudoku rules are satisfied.",
    "constraints": [
      "The input board is guaranteed to be a valid Sudoku puzzle.",
      "The Sudoku puzzle has only one solution."
    ],
    "examples": [
      {
        "input": [
          [
            "5",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            ".",
            "2",
            "8",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": [
          [
            "5",
            "3",
            "4",
            "6",
            "7",
            "8",
            "9",
            "1",
            "2"
          ],
          [
            "6",
            "7",
            "2",
            "1",
            "9",
            "5",
            "3",
            "4",
            "8"
          ],
          [
            "1",
            "9",
            "8",
            "3",
            "4",
            "2",
            "5",
            "6",
            "7"
          ],
          [
            "8",
            "5",
            "9",
            "7",
            "6",
            "1",
            "4",
            "2",
            "3"
          ],
          [
            "4",
            "2",
            "6",
            "8",
            "5",
            "3",
            "7",
            "9",
            "1"
          ],
          [
            "7",
            "1",
            "3",
            "9",
            "2",
            "4",
            "8",
            "5",
            "6"
          ],
          [
            "9",
            "6",
            "1",
            "2",
            "3",
            "5",
            "2",
            "8",
            "4"
          ],
          [
            "2",
            "8",
            "7",
            "4",
            "1",
            "9",
            "6",
            "3",
            "5"
          ],
          [
            "3",
            "4",
            "5",
            "6",
            "8",
            "2",
            "1",
            "7",
            "9"
          ]
        ],
        "explanation": "The empty cells have been filled following the Sudoku rules, resulting in a valid completed board."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a backtracking algorithm to explore possible numbers for empty cells.",
      "Validate if a number can be placed in a cell without violating Sudoku rules.",
      "Consider using a helper function to handle the validation."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Symmetric Tree",
    "description": "Given the root of a binary tree, determine if it is a mirror of itself (i.e., symmetric around its center). A binary tree is symmetric if the left subtree is a mirror reflection of the right subtree.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Recursion"
    ],
    "input_format": "The root of a binary tree, represented as a TreeNode structure.",
    "output_format": "A boolean value indicating whether the tree is symmetric.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 1000].",
      "Node.val is in the range [-100, 100]."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 2, 3, 4, 4, 3]",
        "output": "true",
        "explanation": "The tree is symmetric because its left and right subtrees are mirror images."
      },
      {
        "input": "root = [1, 2, 2, null, 3, null, 3]",
        "output": "false",
        "explanation": "The tree is not symmetric because the left subtree has a node with value 3, while the right subtree has a null."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using recursion to compare the left and right subtrees.",
      "Two trees are mirror images if their roots have the same value, and their left and right subtrees are also mirrors."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Length of Last Word",
    "description": "Given a string s consisting of words separated by spaces, return the length of the last word in the string. A word is defined as a maximal substring consisting of non-space characters.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Length"
    ],
    "input_format": "A string s containing words separated by spaces.",
    "output_format": "An integer representing the length of the last word.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of only English letters and spaces.",
      "There are no leading or trailing spaces in the input string."
    ],
    "examples": [
      {
        "input": "Hello World",
        "output": "5",
        "explanation": "The last word is 'World' which has a length of 5."
      },
      {
        "input": "   fly me   to   the moon  ",
        "output": "4",
        "explanation": "The last word is 'moon' which has a length of 4."
      },
      {
        "input": "Luffy is still a rookie",
        "output": "6",
        "explanation": "The last word is 'rookie' which has a length of 6."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Trim any trailing spaces and then find the last word."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Convert Sorted List to Binary Search Tree",
    "description": "Given a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree (BST). A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Linked List",
      "Binary Search Tree"
    ],
    "input_format": "A singly linked list with nodes containing sorted integers.",
    "output_format": "The root node of the height-balanced binary search tree.",
    "constraints": [
      "The number of nodes in the linked list is in the range [0, 10^4].",
      "The values of the linked list nodes are in the range [-10^5, 10^5]."
    ],
    "examples": [
      {
        "input": "head = [-10, -3, 0, 5, 9]",
        "output": "[0, -3, 9, -10, null, 5]",
        "explanation": "This represents the balanced BST where 0 is the root, -3 is the left child, and 9 is the right child. The left subtree of -3 has -10 as its left child."
      },
      {
        "input": "head = []",
        "output": "null",
        "explanation": "An empty linked list results in an empty BST."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to use the middle of the list as the root node.",
      "Think about how to recursively build subtrees from the halves of the list."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Integer to Roman",
    "description": "Given an integer, convert it to a Roman numeral. Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. For example, the Roman numeral for 2 is 'II', and the Roman numeral for 12 is 'XII'. The number 1994 is 'MCMXCIV'. For the purpose of this problem, the input is guaranteed to be within the range from 1 to 3999.",
    "topic": "Math",
    "subtopic": "Conversion",
    "tags": [
      "Math",
      "Conversion",
      "String Manipulation"
    ],
    "input_format": "An integer num, where 1 <= num <= 3999.",
    "output_format": "A string representing the Roman numeral equivalent of the input integer.",
    "constraints": [
      "1 <= num <= 3999"
    ],
    "examples": [
      {
        "input": "num = 3",
        "output": "III",
        "explanation": "The integer 3 is represented as 'III' in Roman numerals."
      },
      {
        "input": "num = 58",
        "output": "LVIII",
        "explanation": "The integer 58 is represented as 'LVIII' in Roman numerals (L = 50, V = 5, I = 1)."
      },
      {
        "input": "num = 1994",
        "output": "MCMXCIV",
        "explanation": "The integer 1994 is represented as 'MCMXCIV' in Roman numerals (M = 1000, CM = 900, XC = 90, IV = 4)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how Roman symbols are combined to form numbers.",
      "Build the Roman numeral string from largest to smallest."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Swap Nodes in Pairs",
    "description": "Given a linked list, you need to swap every two adjacent nodes and return its head. You must solve this problem in a single pass without using any extra space for another list.",
    "topic": "Linked List",
    "subtopic": "Swapping Nodes",
    "tags": [
      "Linked List",
      "Swap",
      "Two Pointers"
    ],
    "input_format": "The head of the linked list, represented as ListNode.",
    "output_format": "The head of the modified linked list, represented as ListNode.",
    "constraints": [
      "The number of nodes in the linked list is in the range [0, 100].",
      "0 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4]",
        "output": "[2, 1, 4, 3]",
        "explanation": "The first pair (1, 2) is swapped to become (2, 1) and the second pair (3, 4) is swapped to become (4, 3)."
      },
      {
        "input": "head = [1]",
        "output": "[1]",
        "explanation": "There is only one node, so no swaps can be made."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dummy node to simplify handling of swaps.",
      "Keep track of previous and current nodes to facilitate the swap."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Longest Valid Parentheses",
    "description": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Stack"
    ],
    "input_format": "A string s consisting of characters '(' and ')'.",
    "output_format": "An integer representing the length of the longest valid parentheses substring.",
    "constraints": [
      "0 <= s.length <= 10^5",
      "s[i] is either '(' or ')'."
    ],
    "examples": [
      {
        "input": "s = '(()')",
        "output": "2",
        "explanation": "The longest valid parentheses substring is '()' with length 2."
      },
      {
        "input": "s = ')()())'",
        "output": "4",
        "explanation": "The longest valid parentheses substring is '(())' with length 4."
      },
      {
        "input": "s = '()()'",
        "output": "4",
        "explanation": "The entire string is valid and has length 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a stack to track indices of characters.",
      "Keep track of the last position of a valid substring.",
      "Consider the case of unmatched opening brackets."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Restore IP Addresses",
    "description": "Given a string s containing only digits, return all possible valid IP address combinations that can be created by inserting dots into s. A valid IP address consists of four integers (each ranging from 0 to 255) separated by dots. Leading zeros are not allowed, except for the number 0 itself.",
    "topic": "Backtracking",
    "subtopic": "String Manipulation",
    "tags": [
      "Backtracking",
      "String",
      "IP Address"
    ],
    "input_format": "A string s representing a sequence of digits.",
    "output_format": "A list of valid IP address combinations.",
    "constraints": [
      "1 <= s.length <= 20",
      "s consists of digits only."
    ],
    "examples": [
      {
        "input": "s = '25525511135'",
        "output": "[\"255.255.11.135\",\"255.255.111.35\"]",
        "explanation": "These are the valid IP address combinations that can be derived from the given string."
      },
      {
        "input": "s = '0000'",
        "output": "[\"0.0.0.0\"]",
        "explanation": "The only valid IP address is '0.0.0.0' since leading zeros are not allowed."
      },
      {
        "input": "s = '1111'",
        "output": "[\"1.1.1.1\"]",
        "explanation": "The only valid IP address is '1.1.1.1' since all parts are valid."
      },
      {
        "input": "s = '010010'",
        "output": "[\"0.10.0.10\",\"0.100.1.0\"]",
        "explanation": "These combinations are valid, but '10.010' and '100.10' are not, due to leading zeros."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Divide the string into four parts.",
      "Each part must be between 0-255 and have at most three digits.",
      "Consider using backtracking to generate combinations."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Same Tree",
    "description": "Given two binary trees, write a function to determine if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Recursion"
    ],
    "input_format": "Two binary tree nodes, p and q, where p is the root of the first tree and q is the root of the second tree.",
    "output_format": "A boolean value: true if the two trees are the same, false otherwise.",
    "constraints": [
      "The number of nodes in both trees is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "p = [1, 2, 3], q = [1, 2, 3]",
        "output": "true",
        "explanation": "Both trees have the same structure and values."
      },
      {
        "input": "p = [1, 2], q = [1, null, 2]",
        "output": "false",
        "explanation": "The structures of the two trees are different."
      },
      {
        "input": "p = [], q = []",
        "output": "true",
        "explanation": "Both trees are empty, so they are considered the same."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use recursion to compare the values of the nodes."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Convert Sorted Array to Binary Search Tree",
    "description": "Given an integer array nums sorted in non-decreasing order, convert it to a height-balanced binary search tree. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "An array of integers nums in non-decreasing order.",
    "output_format": "A height-balanced binary search tree represented as the root node.",
    "constraints": [
      "0 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums = [-10, -3, 0, 5, 9]",
        "output": "Expected height-balanced binary search tree.",
        "explanation": "The input array can be converted to a height-balanced BST. One possible BST is: \n        0\n       / \\\n     -3   5\n     /     \\\n   -10      9"
      },
      {
        "input": "nums = []",
        "output": "null",
        "explanation": "An empty array should return a null tree."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using the middle element of the array as the root for the BST.",
      "Recursively apply the same logic to the left and right halves of the array."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Minimum Path Sum",
    "description": "Given a grid filled with non-negative numbers, find a path from the top left to the bottom right, which minimizes the sum of the numbers along the path. You can only move either down or right at any point in time.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Pathfinding"
    ],
    "input_format": "A 2D array grid where grid[i][j] represents the cost of moving to that cell.",
    "output_format": "An integer representing the minimum path sum from the top left to the bottom right.",
    "constraints": [
      "1 <= grid.length <= 200",
      "1 <= grid[0].length <= 200",
      "0 <= grid[i][j] <= 100"
    ],
    "examples": [
      {
        "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7",
        "explanation": "The path 1 \u2192 3 \u2192 1 \u2192 1 has the minimum sum of 7."
      },
      {
        "input": "grid = [[1,2,3],[4,5,6]]",
        "output": "12",
        "explanation": "The path 1 \u2192 2 \u2192 3 \u2192 6 has the minimum sum of 12."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to build up the solution.",
      "You can use a 2D array to keep track of minimum path sums to each cell.",
      "Think about how to combine results from previously computed states."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Balanced Binary Tree",
    "description": "Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Height Balanced"
    ],
    "input_format": "The input consists of the root node of a binary tree.",
    "output_format": "Return true if the binary tree is height-balanced, otherwise return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 5000].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "true",
        "explanation": "The binary tree is balanced, as the left subtree has a height of 1 and the right subtree has a height of 2."
      },
      {
        "input": "root = [1,2,2,3,3,null,null,4,4]",
        "output": "false",
        "explanation": "The binary tree is not balanced, as the left subtree has a height of 3 and the right subtree has a height of 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "You can use a recursive approach to calculate the height of each subtree.",
      "Check the height difference at each node."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Combinations",
    "description": "Given two integers n and k, return all possible combinations of k numbers chosen from the range 1 to n. You may return the combinations in any order. The combinations should not contain any duplicates.",
    "topic": "Backtracking",
    "subtopic": "Combinations",
    "tags": [
      "Backtracking",
      "Combinations",
      "Recursion"
    ],
    "input_format": "Two integers n and k, where 1 <= k <= n <= 20.",
    "output_format": "A list of lists containing all possible k combinations from 1 to n.",
    "constraints": [
      "1 <= k <= n <= 20"
    ],
    "examples": [
      {
        "input": "n = 4, k = 2",
        "output": "[[2, 4], [3, 4], [1, 2], [1, 3], [1, 4], [2, 3]]",
        "explanation": "The combinations of 2 numbers chosen from [1, 2, 3, 4] are [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], and [3, 4]."
      },
      {
        "input": "n = 1, k = 1",
        "output": "[[1]]",
        "explanation": "There is only one combination: [1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to explore all possibilities.",
      "You can build combinations incrementally and backtrack when necessary."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Permutations II",
    "description": "Given a collection of numbers that might contain duplicates, return all possible unique permutations. The order of output does not matter, but the permutations should be represented as lists of numbers.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Permutations",
      "Recursion"
    ],
    "input_format": "A list of integers nums, where the integers may contain duplicates.",
    "output_format": "A list of lists of integers, representing all unique permutations of the given list.",
    "constraints": [
      "1 <= nums.length <= 8",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "[[1, 1, 2], [1, 2, 1], [2, 1, 1]]",
        "explanation": "The unique permutations are [1, 1, 2], [1, 2, 1], and [2, 1, 1]."
      },
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]",
        "explanation": "All permutations of [1, 2, 3] are unique."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a backtracking approach.",
      "Use a set to avoid duplicates."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Unique Binary Search Trees II",
    "description": "Given an integer n, return all the structurally unique BST's (binary search trees) which store values 1 to n. Each tree should be represented as a list of nodes, with each node containing a value and links to left and right children. The output should be a list of all unique trees generated.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "An integer n where 1 <= n <= 8.",
    "output_format": "A list of unique binary search trees represented as lists of nodes.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
        "explanation": "These represent all the structurally unique BST's that can be constructed with values from 1 to 3."
      },
      {
        "input": "n = 1",
        "output": "[[1]]",
        "explanation": "There is only one tree that can be formed with a single node."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the root of the tree as each number from 1 to n in turn.",
      "Split the remaining numbers into left and right subtrees based on the root."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Substring with Concatenation of All Words",
    "description": "You are given a string s and an array of strings words of the same length. Each string in words is of the same length. Your goal is to find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Return the starting indices of these substrings in any order.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Hash Table"
    ],
    "input_format": "A string s and an array of strings words.",
    "output_format": "A list of starting indices where the substrings are found.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 100",
      "The total length of all words combined does not exceed 10^4.",
      "All words are unique."
    ],
    "examples": [
      {
        "input": "s = 'barfoothefoobarman', words = ['foo', 'bar']",
        "output": "[0, 9]",
        "explanation": "'barfoo' is found at index 0 and 'foobar' is found at index 9."
      },
      {
        "input": "s = 'wordgoodgoodgoodbestword', words = ['word', 'good', 'best', 'word']",
        "output": "[]",
        "explanation": "There is no substring in 's' that is the concatenation of all words."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a sliding window to check each substring of the target string.",
      "You might need a frequency count of the words to match them accurately."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix II",
    "description": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n^2 in spiral order. The matrix should begin at the top-left corner and proceed in a clockwise spiral pattern until all numbers are filled.",
    "topic": "Array",
    "subtopic": "Matrix",
    "tags": [
      "Matrix",
      "Spiral",
      "Array"
    ],
    "input_format": "A single integer n representing the size of the matrix.",
    "output_format": "A 2D array representing the generated spiral matrix.",
    "constraints": [
      "1 <= n <= 20"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[[1, 2, 3], [8, 9, 4], [7, 6, 5]]",
        "explanation": "The matrix is filled in a spiral order starting from 1 to 9."
      },
      {
        "input": "n = 1",
        "output": "[[1]]",
        "explanation": "The matrix is a single element, starting and ending with 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use four boundaries (top, bottom, left, right) to control the spiral filling.",
      "Iterate while adjusting these boundaries after filling in each direction."
    ],
    "company": "Meta"
  },
  {
    "question_id": "",
    "title": "Binary Tree Level Order Traversal II",
    "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "DFS",
      "BFS"
    ],
    "input_format": "The root node of a binary tree.",
    "output_format": "A list of lists of integers, where each sublist represents a level of the tree, from bottom to top.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[15,7],[9,20],[3]]",
        "explanation": "The tree has levels 3 (root), 9 and 20 (second level), and 15 and 7 (third level). So the bottom-up level order is [[15,7],[9,20],[3]]."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree returns an empty list."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using breadth-first search (BFS) to traverse the tree.",
      "Consider using a queue to store the current level's nodes."
    ],
    "company": "Meta"
  }
]