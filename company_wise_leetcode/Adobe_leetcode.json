[
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An array of integers `nums` followed by an integer `target`.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash table to store the difference between the target and each number."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an integer array nums, return all the unique triplets [nums[a], nums[b], nums[c]] such that a, b, and c are different indices, and nums[a] + nums[b] + nums[c] == 0. Note that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "An integer array nums.",
    "output_format": "A list of lists containing unique triplets that sum to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The unique triplets that sum to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no numbers to form a triplet."
      },
      {
        "input": "nums = [0, 1, 1]",
        "output": "[]",
        "explanation": "No triplet can sum to zero in this case."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array to make it easier to find unique triplets.",
      "Use a loop to fix one number and find two other numbers using two pointers."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".",
    "topic": "String",
    "subtopic": "Prefix",
    "tags": [
      "String",
      "Prefix",
      "Array"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A string representing the longest common prefix.",
    "constraints": [
      "0 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "All input strings are lower-case letters a-z."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\",\"flow\",\"flight\"]",
        "output": "\"fl\"",
        "explanation": "The common prefix is \"fl\"."
      },
      {
        "input": "strs = [\"dog\",\"racecar\",\"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among the strings."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "\"a\"",
        "explanation": "The single string is the longest common prefix."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Iterate over the characters of the first string.",
      "Stop when a character doesn't match in another string."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log(min(m,n))).",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Median"
    ],
    "input_format": "Two sorted arrays nums1 and nums2.",
    "output_format": "A float representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= m <= 1000",
      "0 <= n <= 1000",
      "1 <= m + n <= 2000",
      "The elements of nums1 and nums2 are integers."
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.0",
        "explanation": "The combined sorted array is [1, 2, 3]. The median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.5",
        "explanation": "The combined sorted array is [1, 2, 3, 4]. The median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using binary search.",
      "Focus on partitioning the arrays."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A string s consisting of English letters, digits, symbols, and spaces.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 50000",
      "s consists of any printable ascii characters."
    ],
    "examples": [
      {
        "input": "abcabcbb",
        "output": "3",
        "explanation": "The answer is 'abc', with the length of 3."
      },
      {
        "input": "bbbbb",
        "output": "1",
        "explanation": "The answer is 'b', with the length of 1."
      },
      {
        "input": "pwwkew",
        "output": "3",
        "explanation": "The answer is 'wke', with the length of 3."
      },
      {
        "input": "",
        "output": "0",
        "explanation": "An empty string has a length of 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sliding window technique.",
      "A HashMap can help track the characters and their indices."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Reverse Integer",
    "description": "Given a 32-bit signed integer, reverse the digits of the integer. If the reversed integer overflows, return 0. Note that the negative sign must be preserved if the integer is negative.",
    "topic": "Math",
    "subtopic": "Integer Manipulation",
    "tags": [
      "Math",
      "Integer",
      "String Manipulation"
    ],
    "input_format": "A single integer x, where -2^31 <= x <= 2^31 - 1.",
    "output_format": "An integer representing the reversed digits of x, or 0 if the result overflows.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 123",
        "output": "321",
        "explanation": "Reversing the digits of 123 gives 321."
      },
      {
        "input": "x = -123",
        "output": "-321",
        "explanation": "Reversing the digits of -123 gives -321."
      },
      {
        "input": "x = 120",
        "output": "21",
        "explanation": "Reversing the digits of 120 gives 021 which is 21."
      },
      {
        "input": "x = 1534236469",
        "output": "0",
        "explanation": "Reversing the digits exceeds the 32-bit integer range, so the output is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to handle negative numbers.",
      "Check for overflow conditions when reversing."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Merge Sorted Array",
    "description": "Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has a size equal to m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. Note that nums1 and nums2 are both sorted in non-decreasing order.",
    "topic": "Array",
    "subtopic": "Merging Arrays",
    "tags": [
      "Array",
      "Merging",
      "Two-Pointers"
    ],
    "input_format": "Two integer arrays nums1 and nums2, where nums1 has a size of m + n and the last n elements are initialized to 0.",
    "output_format": "The merged sorted array in nums1.",
    "constraints": [
      "1 <= m, n <= 100",
      "0 <= nums1[i], nums2[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3",
        "output": "[1, 2, 2, 3, 5, 6]",
        "explanation": "After merging, nums1 becomes [1, 2, 2, 3, 5, 6]."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "No elements to merge from nums2, so nums1 stays [1]."
      },
      {
        "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
        "output": "[1]",
        "explanation": "Merge the only element from nums2 into nums1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a two-pointer approach to merge in-place.",
      "Start merging from the end of nums1 to avoid overwriting elements."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contains a single digit. Add the two numbers and return it as a linked list.",
    "topic": "Linked List",
    "subtopic": "Addition",
    "tags": [
      "Linked List",
      "Addition",
      "Mathematics"
    ],
    "input_format": "Two linked lists where each node contains a single digit.",
    "output_format": "A linked list representing the sum of the two numbers.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the input lists will not have any leading zeros."
    ],
    "examples": [
      {
        "input": "l1 = [2, 4, 3], l2 = [5, 6, 4]",
        "output": "[7, 0, 8]",
        "explanation": "342 + 465 = 807, thus the output linked list represents the number 807."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "0 + 0 = 0, so the output is just a single node linked list with value 0."
      },
      {
        "input": "l1 = [9, 9, 9, 9, 9, 9, 9], l2 = [9, 9, 9, 9]",
        "output": "[8, 9, 9, 9, 0, 0, 1]",
        "explanation": "9999999 + 9999 = 10009998, thus the output linked list represents the number 10009998."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about adding the numbers digit by digit, handling the carry.",
      "Make sure to account for different lengths of the two lists."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of integers representing the height of bars in a histogram, calculate how much water can be trapped after raining. The water trapped above a bar is determined by the height of the tallest bars to its left and right.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers height where 1 <= height.length <= 2 * 10^4 and 0 <= height[i] <= 10^5.",
    "output_format": "An integer representing the total amount of trapped water.",
    "constraints": [
      "1 <= height.length <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The trapped water can be visualized as valleys between the heights. The total water trapped is 6."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The total water trapped is 9 units in the valleys formed by the bars."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the left and right maximum heights for each bar.",
      "Use two pointers to determine the amount of water at each bar."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase with n steps. You can take either 1 step or 2 steps at a time. Write a function to compute how many distinct ways you can climb to the top of the staircase.",
    "topic": "Dynamic Programming",
    "subtopic": "Fibonacci Sequence",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Mathematics"
    ],
    "input_format": "An integer n representing the number of steps in the staircase.",
    "output_format": "An integer representing the number of distinct ways to climb to the top.",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: (1, 1) and (2)."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top: (1, 1, 1), (1, 2), and (2, 1)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a dynamic programming approach to store the number of ways to reach each step.",
      "The number of ways to reach step n can be found by summing ways to reach step n-1 and n-2."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For example, 'anagram' and 'nagaram' are anagrams.",
    "topic": "String",
    "subtopic": "Hashing",
    "tags": [
      "String",
      "Hashing",
      "Anagrams"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A 2D array of strings representing the grouped anagrams.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "All inputs are in lowercase letters.",
      "The order of output does not matter."
    ],
    "examples": [
      {
        "input": "strs = ['eat', 'tea', 'tan', 'ate', 'nat', 'bat']",
        "output": "[['bat'], ['nat', 'tan'], ['ate', 'eat', 'tea']]",
        "explanation": "The anagrams are grouped together: 'eat', 'tea', and 'ate' are anagrams. 'tan' and 'nat' are anagrams. 'bat' has no anagrams."
      },
      {
        "input": "strs = ['']",
        "output": "[['']]",
        "explanation": "There's only one string, so it forms one group of anagrams."
      },
      {
        "input": "strs = ['a']",
        "output": "[['a']]",
        "explanation": "The single character forms its own group."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hashmap to group strings by their sorted character representation.",
      "Sorting each string takes O(n log n) time, but you can improve the efficiency by using a frequency count."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Palindrome Number",
    "description": "Given an integer x, return true if x is a palindrome, and false otherwise. An integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome while 123 is not.",
    "topic": "Mathematics",
    "subtopic": "Number Theory",
    "tags": [
      "Math",
      "Palindrome",
      "Integer"
    ],
    "input_format": "An integer x, where 0 <= x <= 2^31 - 1.",
    "output_format": "A boolean value indicating whether x is a palindrome.",
    "constraints": [
      "0 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 121",
        "output": "true",
        "explanation": "121 reads the same backward as forward."
      },
      {
        "input": "x = -121",
        "output": "false",
        "explanation": "-121 reads 121- backward."
      },
      {
        "input": "x = 10",
        "output": "false",
        "explanation": "10 reads 01 backward."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how you can reverse the digits of the number.",
      "You can convert the integer to a string and check if it's the same when reversed."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if the brackets are closed in the correct order. Every opening bracket must have a corresponding closing bracket of the same type.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A string s consisting of characters '(', ')', '{', '}', '[' and ']'.",
    "output_format": "A boolean value indicating whether the input string is valid.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses only."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The parentheses are correctly matched."
      },
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "All parentheses are correctly matched."
      },
      {
        "input": "s = '(]')",
        "output": "false",
        "explanation": "The brackets are not correctly matched."
      },
      {
        "input": "s = '([)]'",
        "output": "false",
        "explanation": "The brackets are not closed in the correct order."
      },
      {
        "input": "s = '{[]}'",
        "output": "true",
        "explanation": "The brackets are correctly matched."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "Check for matching brackets using a map of closing and opening pairs."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest substring of s that is a palindrome. A palindrome is a string that reads the same forward and backward. If there are multiple longest palindromic substrings, return any one of them.",
    "topic": "String",
    "subtopic": "Substring",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A string s, where 1 <= s.length <= 1000.",
    "output_format": "The longest palindromic substring in s.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "babad",
        "output": "bab",
        "explanation": "Both 'bab' and 'aba' are valid outputs as they are both longest palindromic substrings."
      },
      {
        "input": "cbbd",
        "output": "bb",
        "explanation": "'bb' is the longest palindromic substring."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding around potential centers.",
      "A palindrome mirrors around its center."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Next Permutation",
    "description": "Implement the function nextPermutation that takes an array of integers nums and modifies it in-place to represent the next lexicographical permutation of its numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order). The replacement must be done in-place and use only constant extra memory.",
    "topic": "Array",
    "subtopic": "Permutation",
    "tags": [
      "Array",
      "In-place",
      "Permutation"
    ],
    "input_format": "An array of integers nums of length n.",
    "output_format": "Modify nums to the next permutation in-place.",
    "constraints": [
      "1 <= n <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[1, 3, 2]",
        "explanation": "The next permutation of [1, 2, 3] is [1, 3, 2]."
      },
      {
        "input": "nums = [3, 2, 1]",
        "output": "[1, 2, 3]",
        "explanation": "The next permutation of [3, 2, 1] is [1, 2, 3] because it is the last permutation."
      },
      {
        "input": "nums = [1, 1, 5]",
        "output": "[1, 5, 1]",
        "explanation": "The next permutation of [1, 1, 5] is [1, 5, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to find the largest index k such that nums[k] < nums[k + 1].",
      "If no such index exists, the permutation is the last permutation.",
      "Find the largest index l greater than k such that nums[k] < nums[l].",
      "Swap the values at indices k and l, then reverse the sequence from k + 1 to the end."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Roman to Integer",
    "description": "Given a string representing a Roman numeral, convert it to an integer. Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. The values of these symbols are as follows: I = 1, V = 5, X = 10, L = 50, C = 100, D = 500, and M = 1000. Two special cases are: IV (4) and IX (9), where a smaller numeral appears before a larger one to indicate subtraction.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Conversion",
      "Math"
    ],
    "input_format": "A string s representing a valid Roman numeral (1 <= s.length <= 15).",
    "output_format": "An integer representing the converted integer value from the Roman numeral.",
    "constraints": [
      "The input string is guaranteed to be a valid Roman numeral."
    ],
    "examples": [
      {
        "input": "s = \"III\"",
        "output": "3",
        "explanation": "The Roman numeral III is equal to 1 + 1 + 1 = 3."
      },
      {
        "input": "s = \"IV\"",
        "output": "4",
        "explanation": "The Roman numeral IV is equal to 5 - 1 = 4."
      },
      {
        "input": "s = \"IX\"",
        "output": "9",
        "explanation": "The Roman numeral IX is equal to 10 - 1 = 9."
      },
      {
        "input": "s = \"LVIII\"",
        "output": "58",
        "explanation": "The Roman numeral LVIII is equal to 50 + 5 + 3 = 58."
      },
      {
        "input": "s = \"MCMXCIV\"",
        "output": "1994",
        "explanation": "The Roman numeral MCMXCIV is equal to 1000 + (1000 - 100) + (100 - 10) + 5 = 1994."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider constructing a map of Roman symbols to their integer values.",
      "Iterate through the string and apply the subtraction rule where necessary."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "Given an array of integers where each integer represents the height of a vertical line on a 2D plane, your task is to find two lines that together with the x-axis form a container, such that the container can hold the most water. The width of the container is the distance between the two lines. Return the maximum amount of water that can be contained.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "input_format": "An array of integers heights representing the height of the lines.",
    "output_format": "An integer representing the maximum amount of water that can be contained.",
    "constraints": [
      "2 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The lines at index 1 and index 8 (heights 8 and 7) form a container that can hold 49 units of water."
      },
      {
        "input": "heights = [1,1]",
        "output": "1",
        "explanation": "The only container formed by the lines at index 0 and index 1 can hold 1 unit of water."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using two pointers to maximize the area.",
      "The area is determined by the height of the shorter line."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Remove Element",
    "description": "Given an array of integers nums and an integer val, you need to remove all occurrences of val in nums in-place. The relative order of the elements may be changed. After removing, you should return the new length of the array. Do not allocate extra space for another array, you must do this by modifying the input array in-place.",
    "topic": "Array",
    "subtopic": "In-place Modification",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An integer array nums followed by an integer val.",
    "output_format": "An integer representing the new length of the array after removing the occurrences of val.",
    "constraints": [
      "0 <= nums.length <= 100",
      "0 <= nums[i] <= 50",
      "0 <= val <= 50"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 2, 3], val = 3",
        "output": "2",
        "explanation": "After removing 3, the array becomes [2, 2]. The new length is 2."
      },
      {
        "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
        "output": "5",
        "explanation": "After removing 2, the array becomes [0, 1, 3, 0, 4, ...]. The new length is 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to keep track of the position of elements.",
      "Swap elements instead of shifting them to keep the order."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array",
    "description": "Given a sorted array of integers, you need to remove the duplicates in-place such that each element appears only once and returns the new length of the array. Do not allocate extra space for another array; you must do this by modifying the input array in-place.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-Place"
    ],
    "input_format": "An array of integers nums, sorted in non-decreasing order.",
    "output_format": "An integer representing the new length of the array after removing duplicates.",
    "constraints": [
      "0 <= nums.length <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "2",
        "explanation": "After removing duplicates, the array becomes [1, 2], and the new length is 2."
      },
      {
        "input": "nums = [0, 0, 1, 1, 2, 2, 3, 3, 4]",
        "output": "5",
        "explanation": "After removing duplicates, the array becomes [0, 1, 2, 3, 4], and the new length is 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to track unique elements.",
      "Modify the elements in the input array itself."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order. You start from the top left corner and traverse the matrix in a spiral manner until all elements have been visited.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral"
    ],
    "input_format": "A 2D list of integers representing an m x n matrix.",
    "output_format": "A list of integers representing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "1 <= m * n <= 10^4",
      "-10^5 <= matrix[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The matrix can be traced in the following spiral order: 1 \u2192 2 \u2192 3 \u2192 6 \u2192 9 \u2192 8 \u2192 7 \u2192 4 \u2192 5."
      },
      {
        "input": "matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]",
        "output": "[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]",
        "explanation": "The spiral order of the matrix starts from 1 and traverses around the outer elements before going inwards."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use four pointers to keep track of the boundaries of the current spiral.",
      "Reduce the boundaries after completing a full circle of traversing."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Merge Two Sorted Lists",
    "description": "You are given two linked lists that are both sorted in non-decreasing order. Your task is to merge them into a single sorted linked list and return it. The elements of the merged linked list must be in the same order as they appear in the original lists.",
    "topic": "Linked List",
    "subtopic": "Merging Lists",
    "tags": [
      "Linked List",
      "Sorting",
      "Merge"
    ],
    "input_format": "The input consists of two linked lists, where each list is represented by its head node.",
    "output_format": "A single linked list that represents the merged and sorted list.",
    "constraints": [
      "The number of nodes in both linked lists is in the range [0, 50].",
      "Node values are in the range [-10^4, 10^4].",
      "Both input linked lists are sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "l1 = [1, 2, 4], l2 = [1, 3, 4]",
        "output": "[1, 1, 2, 3, 4, 4]",
        "explanation": "Merging the two lists gives [1, 1, 2, 3, 4, 4]."
      },
      {
        "input": "l1 = [], l2 = [0]",
        "output": "[0]",
        "explanation": "The first list is empty, so the result is just the second list: [0]."
      },
      {
        "input": "l1 = [], l2 = []",
        "output": "[]",
        "explanation": "Both lists are empty, so the result is an empty list."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use pointers to traverse both lists.",
      "Compare the current nodes of both lists and choose the smaller one."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Set Matrix Zeroes",
    "description": "Given an m x n integer matrix, if an element is 0, set its entire row and column to 0. You must do it in place (without using extra space for another matrix).",
    "topic": "Matrix",
    "subtopic": "In-Place Modifications",
    "tags": [
      "Matrix",
      "In-Place",
      "Modification"
    ],
    "input_format": "A 2D matrix of integers with dimensions m x n.",
    "output_format": "The input matrix, modified in place.",
    "constraints": [
      "1 <= m, n <= 200",
      "-10^9 <= matrix[i][j] <= 10^9"
    ],
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": "The element at (1,1) is 0, so we set its entire row and column to 0."
      },
      {
        "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
        "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
        "explanation": "The element at (0,0) is 0, so we set its entire row and column to 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using the first row and first column to track which rows and columns need to be set to zero.",
      "You may need to use additional flags to keep track of whether the first row and column should be set to zero."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Generate Parentheses",
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. Each combination should contain exactly n opening parentheses and n closing parentheses.",
    "topic": "Backtracking",
    "subtopic": "Combination Generation",
    "tags": [
      "Backtracking",
      "Recursion",
      "String"
    ],
    "input_format": "An integer n representing the number of pairs of parentheses.",
    "output_format": "A list of strings containing all combinations of well-formed parentheses.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
        "explanation": "The five combinations of well-formed parentheses for n = 3 are generated."
      },
      {
        "input": "n = 1",
        "output": "[\"()\"]",
        "explanation": "There is only one combination of well-formed parentheses for n = 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursive backtracking to explore all combinations.",
      "Maintain counters for opening and closing parentheses."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Plus One",
    "description": "Given a non-empty array of digits representing a non-negative integer, increment the integer by one and return the resulting array of digits. The digits are stored such that the most significant digit is at the front of the array, and each element in the array is a single digit. You may assume that the integer does not have leading zeros, except for the number zero itself.",
    "topic": "Array",
    "subtopic": "Mathematics",
    "tags": [
      "Array",
      "Math",
      "Increment"
    ],
    "input_format": "An array of integers where each integer is a single digit.",
    "output_format": "An array of integers representing the incremented integer.",
    "constraints": [
      "1 <= digits.length <= 100",
      "0 <= digits[i] <= 9",
      "digits does not contain leading zeros."
    ],
    "examples": [
      {
        "input": "digits = [1, 2, 3]",
        "output": "[1, 2, 4]",
        "explanation": "Incrementing 123 by 1 results in 124, represented as [1, 2, 4]."
      },
      {
        "input": "digits = [4, 3, 2, 1]",
        "output": "[4, 3, 2, 2]",
        "explanation": "Incrementing 4321 by 1 results in 4322, represented as [4, 3, 2, 2]."
      },
      {
        "input": "digits = [9]",
        "output": "[1, 0]",
        "explanation": "Incrementing 9 by 1 results in 10, represented as [1, 0]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how you can handle the carry when incrementing.",
      "You may need to extend the array if a carry is generated at the highest place."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Jump Game",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to determine if you can reach the last index starting from the first index. You can assume you can always reach the last index if you are already at the last index.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "A boolean value indicating whether you can reach the last index.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "true",
        "explanation": "You can jump from index 0 to 1 (2 steps), then jump to the last index."
      },
      {
        "input": "nums = [3, 2, 1, 0, 4]",
        "output": "false",
        "explanation": "You will always land on index 3 and cannot jump to the last index from there."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Check how far you can jump at each position.",
      "Use a greedy approach to track the furthest reachable index."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Letter Combinations of a Phone Number",
    "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. The mapping is as follows: \n2 -> 'abc' \n3 -> 'def' \n4 -> 'ghi' \n5 -> 'jkl' \n6 -> 'mno' \n7 -> 'pqrs' \n8 -> 'tuv' \n9 -> 'wxyz'. \n\nYou may return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Combinatorial Generation",
    "tags": [
      "Backtracking",
      "Recursion",
      "Combinations"
    ],
    "input_format": "A string of digits where each digit is in the range of '2' to '9'.",
    "output_format": "A list of strings containing all possible letter combinations.",
    "constraints": [
      "0 <= digits.length <= 4",
      "digits[i] is a digit in the range ['2', '9']"
    ],
    "examples": [
      {
        "input": "digits = \"23\"",
        "output": "[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]",
        "explanation": "The digits 2 and 3 map to 'abc' and 'def' respectively. Therefore, the combinations are formed by taking each letter from the first digit and combining it with each letter from the second digit."
      },
      {
        "input": "digits = \"\"",
        "output": "[]",
        "explanation": "An empty input will result in an empty array of combinations."
      },
      {
        "input": "digits = \"2\"",
        "output": "[\"a\", \"b\", \"c\"]",
        "explanation": "The digit 2 maps directly to the letters 'a', 'b', and 'c'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to explore all combinations.",
      "Use a mapping of digits to letters to facilitate combination formation."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Rotate Image",
    "description": "You are given an n x n 2D matrix representing an image. You need to rotate the image by 90 degrees (clockwise) in-place. You have to do this without using any extra space for another matrix.",
    "topic": "Matrix",
    "subtopic": "In-place Transformation",
    "tags": [
      "Matrix",
      "In-place",
      "Transformation"
    ],
    "input_format": "An n x n 2D array (matrix) of integers, where n >= 1.",
    "output_format": "The same 2D array is updated in place to represent the matrix rotated by 90 degrees clockwise.",
    "constraints": [
      "1 <= n <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "[[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]",
        "explanation": "Rotating the given matrix 90 degrees clockwise results in the new arrangement."
      },
      {
        "input": "[[1]]",
        "output": "[[1]]",
        "explanation": "A 1x1 matrix remains unchanged when rotated."
      },
      {
        "input": "[[1,2],[3,4]]",
        "output": "[[3,1],[4,2]]",
        "explanation": "Rotating the 2x2 matrix gives the new arrangement."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to move the elements layer by layer.",
      "Use a nested loop for the layers and their elements."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Integer to Roman",
    "description": "Given an integer, convert it to a Roman numeral. Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. For example, 2 is represented as 'II' and 12 is represented as 'XII'. The number zero is not represented in Roman numerals. To see how to write Roman numerals, view the chart below. To convert an integer to a Roman numeral, you need to subtract and append the corresponding symbols for the values until the integer is reduced to zero.",
    "topic": "Mathematics",
    "subtopic": "Number Conversion",
    "tags": [
      "Mathematics",
      "Conversion",
      "Strings"
    ],
    "input_format": "An integer num in the range 1 to 3999.",
    "output_format": "A string representing the Roman numeral corresponding to the given integer.",
    "constraints": [
      "1 <= num <= 3999"
    ],
    "examples": [
      {
        "input": "num = 3",
        "output": "III",
        "explanation": "The integer 3 is represented by the Roman numeral III."
      },
      {
        "input": "num = 4",
        "output": "IV",
        "explanation": "The integer 4 is represented by the Roman numeral IV."
      },
      {
        "input": "num = 9",
        "output": "IX",
        "explanation": "The integer 9 is represented by the Roman numeral IX."
      },
      {
        "input": "num = 58",
        "output": "LVIII",
        "explanation": "The integer 58 is represented by the Roman numeral LVIII, which is 'L' (50) + 'V' (5) + 'III' (3)."
      },
      {
        "input": "num = 1994",
        "output": "MCMXCIV",
        "explanation": "The integer 1994 is represented by the Roman numeral MCMXCIV, which is 'M' (1000) + 'CM' (900) + 'XC' (90) + 'IV' (4)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Break down the integer into corresponding Roman symbols.",
      "Use a mapping of integers to Roman numerals for conversion.",
      "Consider edge cases for subtractive combinations, like IV and IX."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Find First and Last Position of Element in Sorted Array",
    "description": "Given an array of integers, sorted in non-decreasing order, and a target value, return the starting and ending position of the target value in the array. If the target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Binary Search",
    "subtopic": "Searching Algorithms",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "A list of two integers representing the first and last positions of the target.",
    "constraints": [
      "0 <= nums.length <= 10^5",
      "nums is a non-decreasing array.",
      "-10^9 <= nums[i] <= 10^9",
      "You may assume all elements in the array are unique."
    ],
    "examples": [
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 8",
        "output": "[3, 4]",
        "explanation": "The first position of 8 is at index 3 and the last position is at index 4."
      },
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 6",
        "output": "[-1, -1]",
        "explanation": "6 is not present in the array."
      },
      {
        "input": "nums = [], target = 0",
        "output": "[-1, -1]",
        "explanation": "The array is empty, so the target cannot be found."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to find the leftmost and rightmost index of the target."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals and return a list of the merged intervals. Each interval is represented as a pair of integers [start, end]. An interval [a, b] overlaps with another interval [c, d] if and only if a <= d and c <= b.",
    "topic": "Interval",
    "subtopic": "Sorting",
    "tags": [
      "Interval",
      "Sorting",
      "Merge"
    ],
    "input_format": "A list of intervals, where each interval is represented as an array of two integers [start, end].",
    "output_format": "A list of merged intervals, where each interval is represented as an array of two integers [start, end].",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Intervals [1,3] and [2,6] overlap, so they are merged into [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "Intervals [1,4] and [4,5] overlap, so they are merged into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on the starting times.",
      "Iterate through the sorted intervals and merge when necessary."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Sqrt(x)",
    "description": "Implement a function to compute the square root of a non-negative integer x. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.",
    "topic": "Math",
    "subtopic": "Binary Search",
    "tags": [
      "Math",
      "Binary Search",
      "Square Root"
    ],
    "input_format": "A non-negative integer x (0 <= x <= 2^31 - 1).",
    "output_format": "An integer representing the square root of x, truncated to the integer part.",
    "constraints": [
      "0 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 4",
        "output": "2",
        "explanation": "The square root of 4 is 2."
      },
      {
        "input": "x = 8",
        "output": "2",
        "explanation": "The square root of 8 is approximately 2.828, truncated to 2."
      },
      {
        "input": "x = 0",
        "output": "0",
        "explanation": "The square root of 0 is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using binary search to narrow down the possible values of the square root."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array II",
    "description": "Given a sorted array of integers, you need to modify the array in-place such that each element appears at most twice and returns the new length of the array. Do not allocate extra space for another array. The order of elements can be changed, and you do not need to worry about the elements beyond the new length.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place",
      "Modification"
    ],
    "input_format": "A sorted array of integers 'nums'.",
    "output_format": "An integer representing the new length of the modified array.",
    "constraints": [
      "0 <= nums.length <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3]",
        "output": "5",
        "explanation": "The modified array could be [1,1,2,2,3], where the new length is 5."
      },
      {
        "input": "nums = [0,0,1,1,1,1,2,3,3]",
        "output": "7",
        "explanation": "The modified array could be [0,0,1,1,2,3,3], where the new length is 7."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use two pointers to keep track of the insertion index.",
      "Only copy an element if it appears less than twice in the new array."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Permutations",
    "description": "Given an array of distinct integers, return all possible permutations. You can return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Recursion",
      "Array"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "A 2D array containing all possible permutations of the input array.",
    "constraints": [
      "1 <= nums.length <= 6",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]",
        "explanation": "All possible permutations of the array [1, 2, 3] are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion to generate permutations.",
      "Think about how to swap elements in the array."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Sort Colors",
    "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function and have a linear runtime complexity.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Two Pointers"
    ],
    "input_format": "An array nums containing integers 0, 1, and 2.",
    "output_format": "The input array nums sorted in-place.",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 300",
      "nums[i] is either 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "nums = [2,0,2,1,1,0]",
        "output": "[0,0,1,1,2,2]",
        "explanation": "Sorting the colors results in the order: red (0), white (1), blue (2)."
      },
      {
        "input": "nums = [2,0,1]",
        "output": "[0,1,2]",
        "explanation": "After sorting, red (0) comes first, followed by white (1), and blue (2) last."
      },
      {
        "input": "nums = [0]",
        "output": "[0]",
        "explanation": "The array is already sorted as it contains one element."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a two-pointer approach.",
      "One pointer can track the boundary for the red (0) region.",
      "The other pointer can track the boundary for the blue (2) region."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Kadane's Algorithm"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum sum of the contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum = 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The only element is the subarray of maximum sum."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The subarray [5,4,-1,7,8] has the largest sum = 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to keep track of the running sum and reset it when it becomes negative.",
      "Optimal solution has linear time complexity."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of k linked-lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
    "topic": "Linked List",
    "subtopic": "Merge",
    "tags": [
      "Linked List",
      "Sorting",
      "Merge"
    ],
    "input_format": "An array of k linked-lists, where each linked-list node contains an integer value.",
    "output_format": "A sorted linked-list that merges all the input linked-lists.",
    "constraints": [
      "k == lists.length",
      "0 <= k <= 10^4",
      "0 <= lists[i].length <= 500",
      "-10^4 <= lists[i][j] <= 10^4"
    ],
    "examples": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]",
        "explanation": "The merged linked-list is 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6."
      },
      {
        "input": "lists = []",
        "output": "[]",
        "explanation": "Since the input list is empty, the output is also an empty linked-list."
      },
      {
        "input": "lists = [[-1, 5, 11], [2, 6]]",
        "output": "[-1, 2, 5, 6, 11]",
        "explanation": "The merged linked-list is -1 -> 2 -> 5 -> 6 -> 11."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a min-heap to efficiently find the smallest element.",
      "Keep track of the current position in each list."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array nums, return the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses constant extra space.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Positive Integers"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the smallest missing positive integer.",
    "constraints": [
      "0 < nums.length <= 300",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3, 4, -1, 1]",
        "output": "2",
        "explanation": "The numbers 1 and 4 are present, but 2 is missing."
      },
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "The numbers 1 and 2 are present, but 3 is missing."
      },
      {
        "input": "nums = [7, 8, 9, 11, 12]",
        "output": "1",
        "explanation": "No positive integers from 1 are present in the array."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using the indices of the array to represent the presence of numbers.",
      "Ignore negative numbers and zeros, only focus on positive integers.",
      "Use the input array itself to track which positive integers are present."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Valid Sudoku",
    "description": "Determine if a 9x9 Sudoku board is valid according to the rules of Sudoku. A valid Sudoku board must satisfy the following conditions: Each row must contain the digits 1-9 without repetition, each column must contain the digits 1-9 without repetition, and each of the nine 3x3 sub-boxes of the grid must also contain the digits 1-9 without repetition. Empty cells are represented by the '.' character.",
    "topic": "Matrix",
    "subtopic": "Validation",
    "tags": [
      "Matrix",
      "Validation",
      "Sudoku"
    ],
    "input_format": "A 2D array of characters representing the 9x9 Sudoku board.",
    "output_format": "A boolean value stating whether the Sudoku board is valid.",
    "constraints": [
      "board.length == 9",
      "board[i].length == 9",
      "board[i][j] is a digit between '1' and '9' or '.'"
    ],
    "examples": [
      {
        "input": "[['5','3','.','.','7','.','.','.','.'], ['6','.','.','1','9','5','.','.','.'], ['.','9','8','.','.','.','.','6','.'], ['8','.','.','.','6','.','.','.','3'], ['4','.','.','8','.','3','.','.','1'], ['7','.','.','.','2','.','.','.','6'], ['.','6','.','.','.','.','2','8','.'], ['.','.','.','4','1','9','.','.','5'], ['.','.','.','.','8','.','.','7','9']]",
        "output": "true",
        "explanation": "The given board satisfies all the Sudoku constraints."
      },
      {
        "input": "[['8','3','.','.','7','.','.','.','.'], ['6','.','.','1','9','5','.','.','.'], ['.','9','8','.','.','.','.','6','.'], ['8','.','.','.','6','.','.','.','3'], ['4','.','.','8','.','3','.','.','1'], ['7','.','.','.','2','.','.','.','6'], ['.','6','.','.','.','.','2','8','.'], ['.','.','.','4','1','9','.','.','5'], ['.','.','.','.','8','.','.','7','9']]",
        "output": "false",
        "explanation": "The number '8' appears twice in the first column."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use sets to track seen numbers in rows, columns, and boxes.",
      "Remember that each 3x3 box can be identified using integer division."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Unique Paths",
    "description": "A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many unique paths are there from the top-left corner to the bottom-right corner?",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Counting Paths"
    ],
    "input_format": "Two integers m and n, representing the number of rows and columns in the grid.",
    "output_format": "An integer representing the number of unique paths from the top-left corner to the bottom-right corner.",
    "constraints": [
      "1 <= m, n <= 100"
    ],
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": "There are 28 unique paths in a 3x7 grid."
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "There are 3 unique paths in a 3x2 grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a combinatorial approach to count paths.",
      "Dynamic programming can be used to build solutions from simpler subproblems."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Jump Game II",
    "description": "You are given an integer array nums representing the maximum jump length at each position. Your goal is to reach the last index of the array from the first index with the minimum number of jumps. Each element in the array represents the maximum jump length you can take from that position. You must determine the minimum number of jumps needed to reach the last index, or return -1 if you cannot reach the end.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers nums, where 1 <= nums.length <= 10^4 and 0 <= nums[i] <= 1000.",
    "output_format": "An integer representing the minimum number of jumps needed to reach the last index, or -1 if not possible.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "2",
        "explanation": "Start at index 0, jump to index 1 (value 3), and then jump to the last index 4. Total jumps = 2."
      },
      {
        "input": "nums = [2, 3, 0, 1, 4]",
        "output": "2",
        "explanation": "Start at index 0, jump to index 1, and then jump to the last index 4."
      },
      {
        "input": "nums = [0]",
        "output": "0",
        "explanation": "Already at the last index, no jumps needed."
      },
      {
        "input": "nums = [1, 2, 0, 1, 4]",
        "output": "3",
        "explanation": "From index 0 to index 1, then to index 3, and finally to index 4. Total jumps = 3."
      },
      {
        "input": "nums = [3, 2, 1, 0, 4]",
        "output": "-1",
        "explanation": "Cannot reach the last index from the first index. Total jumps = -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how far you can jump from each position.",
      "Use a greedy approach to keep track of the furthest point you can reach.",
      "Count the number of jumps as you progress through the array."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "You are given an integer array 'nums' sorted in ascending order, possibly rotated at an unknown pivot. Write a function to search for a target value in this array. If the target exists, return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Searching"
    ],
    "input_format": "An integer array nums, followed by an integer target.",
    "output_format": "An integer representing the index of the target in nums, or -1 if the target is not found.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "There will be no duplicates in the array."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "The target value 0 is found at index 4."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "The target value 3 does not exist in the array, so the return is -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of a rotated array.",
      "Use binary search to efficiently narrow down the search space."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Binary Tree Zigzag Level Order Traversal",
    "description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "input_format": "A binary tree node represented by a root node.",
    "output_format": "A list of lists of integers, representing the zigzag level order traversal.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[20,9],[15,7]]",
        "explanation": "The first level is [3]. The second level is [9, 20], traversed from right to left, resulting in [20, 9]. The third level is [15, 7], traversed from left to right."
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": "Only one node, so the output is just [[1]]."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree results in an empty output."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to perform level order traversal.",
      "Keep track of the level and use a flag to switch between left-to-right and right-to-left."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Pow(x, n)",
    "description": "Implement a function that calculates x raised to the power n (x^n), where x is a floating-point number and n is an integer. The function should handle negative exponents by returning the reciprocal of the positive exponent. Do not use built-in exponentiation functions.",
    "topic": "Math",
    "subtopic": "Exponential",
    "tags": [
      "Math",
      "Exponential",
      "Recursion"
    ],
    "input_format": "Two values, x (a floating-point number) and n (an integer).",
    "output_format": "A floating-point number representing x raised to the power n.",
    "constraints": [
      "-10^4 <= x <= 10^4",
      "-2^31 <= n <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 2.00000, n = 10",
        "output": "1024.00000",
        "explanation": "2^10 = 1024."
      },
      {
        "input": "x = 2.10000, n = 3",
        "output": "9.26100",
        "explanation": "2.1^3 = 9.261."
      },
      {
        "input": "x = 2.00000, n = -2",
        "output": "0.25000",
        "explanation": "2^-2 = 1/(2^2) = 1/4 = 0.25."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a recursive approach to handle exponentiation.",
      "If n is negative, convert the problem into a positive exponent problem."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "description": "Given two integer arrays, preorder and inorder, which represent the preorder and inorder traversal of a binary tree, construct and return the binary tree. You may assume that all values are distinct.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Recursion"
    ],
    "input_format": "Two integer arrays: preorder and inorder.",
    "output_format": "The root node of the constructed binary tree.",
    "constraints": [
      "1 <= preorder.length <= 3000",
      "preorder.length == inorder.length",
      "preorder and inorder consist of unique values.",
      "Each value of inorder also appears in preorder."
    ],
    "examples": [
      {
        "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",
        "output": "[3,9,20,null,null,15,7]",
        "explanation": "The constructed binary tree is:\n      3\n     / \\\n    9  20\n       /  \\\n      15   7"
      },
      {
        "input": "preorder = [1], inorder = [1]",
        "output": "[1]",
        "explanation": "The constructed binary tree consists of a single node."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use the first element of the preorder array as the root.",
      "Find the index of the root in the inorder array to determine left and right subtrees.",
      "Recursively construct the left and right subtrees."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Combination Sum II",
    "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note that the solution set must not contain duplicate combinations.",
    "topic": "Backtracking",
    "subtopic": "Combination Sum",
    "tags": [
      "Backtracking",
      "Combination",
      "Sum"
    ],
    "input_format": "An array of integers candidates and an integer target.",
    "output_format": "A list of lists, where each list represents a unique combination of candidates that sum to the target.",
    "constraints": [
      "1 <= candidates.length <= 100",
      "10^1 <= target <= 10^7",
      "1 <= candidates[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "candidates = [10,1,2,7,6,1,5], target = 8",
        "output": "[[1,1,6],[1,2,5],[2,6],[7]]",
        "explanation": "The combinations that sum to 8 are [1,1,6], [1,2,5], [2,6], and [7]."
      },
      {
        "input": "candidates = [2,5,2,1,2], target = 5",
        "output": "[[1,2,2],[5]]",
        "explanation": "The valid combinations that sum to 5 are [1,2,2] and [5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a backtracking approach.",
      "Sort the candidates to easily skip duplicates.",
      "Use a set to keep track of already considered combinations."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Find the Index of the First Occurrence in a String",
    "description": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.",
    "topic": "String",
    "subtopic": "Search",
    "tags": [
      "String",
      "Search",
      "Index"
    ],
    "input_format": "Two strings, haystack and needle.",
    "output_format": "An integer representing the index of the first occurrence of needle in haystack, or -1 if not found.",
    "constraints": [
      "1 <= haystack.length, needle.length <= 10^4",
      "haystack and needle consist of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "haystack = \"sadbutsad\", needle = \"sad\"",
        "output": "0",
        "explanation": "The substring \"sad\" occurs at index 0 in \"sadbutsad\"."
      },
      {
        "input": "haystack = \"leetcode\", needle = \"leeto\"",
        "output": "-1",
        "explanation": "The substring \"leeto\" is not found in \"leetcode\"."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Try using a sliding window technique to check for the occurrence."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Divide Two Integers",
    "description": "Implement a function to divide two integers without using the division operator. The function should return the quotient after performing integer division. If the divisor is zero, return the maximum value of a 32-bit signed integer. The result should be truncated towards zero.",
    "topic": "Mathematics",
    "subtopic": "Bit Manipulation",
    "tags": [
      "Mathematics",
      "Division",
      "Bit Manipulation"
    ],
    "input_format": "Two integers, dividend and divisor.",
    "output_format": "An integer representing the quotient of the division.",
    "constraints": [
      "-2^31 <= dividend, divisor <= 2^31 - 1",
      "divisor != 0"
    ],
    "examples": [
      {
        "input": "divide(10, 3)",
        "output": "3",
        "explanation": "10 divided by 3 is 3 with a remainder of 1, so we return 3."
      },
      {
        "input": "divide(7, -3)",
        "output": "-2",
        "explanation": "7 divided by -3 is -2 with a remainder of 1, so we return -2."
      },
      {
        "input": "divide(0, 1)",
        "output": "0",
        "explanation": "0 divided by 1 is 0."
      },
      {
        "input": "divide(1, 0)",
        "output": "2147483647",
        "explanation": "Division by zero is not allowed, so we return the maximum 32-bit signed integer."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use bit manipulation to simulate the division process.",
      "Consider handling negative numbers carefully."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Largest Rectangle in Histogram",
    "description": "Given an array of integers representing the heights of bars in a histogram, return the area of the largest rectangle that can be formed within the histogram. The area is calculated by multiplying the height of the rectangle by its width, where the width is determined by the distance between the bars with the given heights.",
    "topic": "Stack",
    "subtopic": "Monotonic Stack",
    "tags": [
      "Stack",
      "Array",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers heights representing the heights of the histogram bars.",
    "output_format": "An integer representing the area of the largest rectangle that can be formed.",
    "constraints": [
      "1 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [2,1,5,6,2,3]",
        "output": "10",
        "explanation": "The largest rectangle can be formed using the heights 5 and 6, covering two bars, with area 2 * 5 = 10."
      },
      {
        "input": "heights = [2,4]",
        "output": "4",
        "explanation": "The largest rectangle can be formed using the height 4, covering one bar, with area 1 * 4 = 4."
      },
      {
        "input": "heights = [1,1,1,1]",
        "output": "4",
        "explanation": "The largest rectangle can be formed using the height 1, covering all four bars, with area 4 * 1 = 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to keep track of the indices of the bars.",
      "When traversing the heights, calculate areas based on the height of bars popped from the stack.",
      "Make sure to handle the remaining bars in the stack after the initial traversal."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Reverse Nodes in k-Group",
    "description": "Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k, then the remaining nodes at the end should remain in their original order.",
    "topic": "Linked List",
    "subtopic": "Reversal",
    "tags": [
      "Linked List",
      "Reversal",
      "Divide and Conquer"
    ],
    "input_format": "The head of the singly linked list and an integer k.",
    "output_format": "The head of the modified linked list after reversing the nodes in k-group.",
    "constraints": [
      "The number of nodes in the linked list is in the range [1, 10^4].",
      "0 <= Node.val <= 1000",
      "k is a positive integer that is less than or equal to the length of the linked list."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], k = 2",
        "output": "[2, 1, 4, 3, 5]",
        "explanation": "The first two nodes [1, 2] are reversed to [2, 1]. The next two nodes [3, 4] are reversed to [4, 3]. The last node [5] remains as is."
      },
      {
        "input": "head = [1, 2, 3, 4, 5], k = 3",
        "output": "[3, 2, 1, 4, 5]",
        "explanation": "The first three nodes [1, 2, 3] are reversed to [3, 2, 1]. The remaining nodes [4, 5] stay in the same order."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using recursion or an iterative approach.",
      "Keep track of the previous and current nodes while reversing."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Length of Last Word",
    "description": "Given a string s contains only letters and spaces, return the length of the last word (a word is defined as a maximal substring consisting of non-space characters).",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Length"
    ],
    "input_format": "A single string s consisting of lowercase and uppercase letters and spaces.",
    "output_format": "An integer representing the length of the last word in the string.",
    "constraints": [
      "0 <= s.length <= 10^4",
      "s consists of only English letters and spaces",
      "There will be at least one word in s."
    ],
    "examples": [
      {
        "input": "Hello World",
        "output": "5",
        "explanation": "The last word is 'World', which has length 5."
      },
      {
        "input": "   Fly me   to   the moon  ",
        "output": "4",
        "explanation": "The last word is 'moon', which has length 4."
      },
      {
        "input": "Luffy is the Goat",
        "output": "4",
        "explanation": "The last word is 'Goat', which has length 4."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use the split method to separate words.",
      "Trim trailing spaces before processing."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Search Insert Position",
    "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Insertion"
    ],
    "input_format": "A sorted array of distinct integers nums and an integer target.",
    "output_format": "An integer representing the index of the target or the position at which it can be inserted.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums is sorted in ascending order.",
      "All values of nums are distinct."
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 5, 6], target = 5",
        "output": "2",
        "explanation": "Target 5 is found at index 2."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 2",
        "output": "1",
        "explanation": "Target 2 would be inserted at index 1."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 7",
        "output": "4",
        "explanation": "Target 7 would be inserted at index 4."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 0",
        "output": "0",
        "explanation": "Target 0 would be inserted at index 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using binary search to find the appropriate index.",
      "The target will either be found or fit between two elements."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Subsets",
    "description": "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. You may return the solution in any order.",
    "topic": "Backtracking",
    "subtopic": "Subsets Generation",
    "tags": [
      "Backtracking",
      "Subsets",
      "Array"
    ],
    "input_format": "An array of unique integers nums.",
    "output_format": "A 2D array containing all possible subsets of nums.",
    "constraints": [
      "1 <= nums.length <= 10",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]",
        "explanation": "All possible subsets of [1, 2, 3] include the empty subset and all combinations of the elements."
      },
      {
        "input": "nums = [0]",
        "output": "[[], [0]]",
        "explanation": "The only elements are 0, so the subsets are the empty set and the set containing 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use backtracking to explore all possible combinations.",
      "Consider including or excluding each element."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "String to Integer (atoi)",
    "description": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function). The function discards all leading whitespace characters until the first non-whitespace character is found. Then, it can read up to the next whitespace character or non-numeric character and convert it into an integer. The conversion should stop if the next character is not a digit. Finally, the function should check for integer overflow/underflow and return the respective 32-bit signed integer.",
    "topic": "String",
    "subtopic": "Parsing",
    "tags": [
      "String",
      "Parsing",
      "Integer"
    ],
    "input_format": "A string s which may contain leading whitespaces and other characters.",
    "output_format": "A 32-bit signed integer resulting from the conversion.",
    "constraints": [
      "0 <= s.length <= 200",
      "s consists of English letters, digits, symbols, and spaces."
    ],
    "examples": [
      {
        "input": "s = \"   -42\"",
        "output": "-42",
        "explanation": "The string starts with leading spaces, then a minus sign before the number 42."
      },
      {
        "input": "s = \"4193 with words\"",
        "output": "4193",
        "explanation": "The conversion stops at the first non-digit character, resulting in 4193."
      },
      {
        "input": "s = \"words and 987\"",
        "output": "0",
        "explanation": "No valid conversion can be performed; thus the result is 0."
      },
      {
        "input": "s = \"-91283472332\"",
        "output": "-2147483648",
        "explanation": "The number is out of the 32-bit signed integer range, so it returns the minimum value."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the effects of leading whitespace.",
      "Think about how to identify when to stop processing the input.",
      "Ensure proper handling of integer overflow and underflow."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Swap Nodes in Pairs",
    "description": "Given a linked list, swap every two adjacent nodes and return its head. You must do this in-place without changing the values of the nodes. The function should specifically swap pairs of nodes (1-2, 3-4, etc.). If the list has an odd number of nodes, the last node remains unchanged.",
    "topic": "Linked List",
    "subtopic": "Swapping Nodes",
    "tags": [
      "Linked List",
      "In-place",
      "Swap"
    ],
    "input_format": "The head of a singly linked list.",
    "output_format": "The head of the modified linked list after swapping pairs.",
    "constraints": [
      "The number of nodes in the linked list is in the range [0, 100].",
      "Each node's value is in the range of [-100, 100]."
    ],
    "examples": [
      {
        "input": "[1, 2, 3, 4]",
        "output": "[2, 1, 4, 3]",
        "explanation": "Swapping pairs results in [2, 1] and [4, 3]."
      },
      {
        "input": "[1, 2, 3]",
        "output": "[2, 1, 3]",
        "explanation": "Swapping pairs results in [2, 1] and the last node [3] remains unchanged."
      },
      {
        "input": "[]",
        "output": "[]",
        "explanation": "An empty list should remain empty."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to use a dummy node to handle the head of the list.",
      "Think about using pointers to swap nodes efficiently."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List II",
    "description": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the modified list. The 1-indexed positions of the nodes indicate the starting and ending points for the reverse.",
    "topic": "Linked List",
    "subtopic": "Reversal",
    "tags": [
      "Linked List",
      "Reversal",
      "Two Pointers"
    ],
    "input_format": "The head of the singly linked list and two integers left and right.",
    "output_format": "The head of the modified linked list after reversing nodes from position left to right.",
    "constraints": [
      "1 <= left <= right <= n (where n is the number of nodes in the linked list)",
      "The number of nodes in the list is in the range [1, 500]",
      "0 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], left = 2, right = 4",
        "output": "[1, 4, 3, 2, 5]",
        "explanation": "After reversing from position 2 to 4, the nodes 2, 3, 4 become 4, 3, 2."
      },
      {
        "input": "head = [1, 2, 3, 4, 5], left = 1, right = 1",
        "output": "[1, 2, 3, 4, 5]",
        "explanation": "Reversing a single node does not change the list."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dummy node to simplify edge cases.",
      "You can use three pointers to efficiently reverse the sublist."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Minimum Window Substring",
    "description": "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\". The order of output does not matter.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Hash Table"
    ],
    "input_format": "Two strings s and t where s is the source string and t is the target string.",
    "output_format": "A string representing the minimum window substring containing all characters of t.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "1 <= t.length <= 10^5",
      "s and t consist of English letters, digits, and symbols."
    ],
    "examples": [
      {
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
        "output": "\"BANC\"",
        "explanation": "The minimum window substring is \"BANC\" which contains all characters of t."
      },
      {
        "input": "s = \"a\", t = \"a\"",
        "output": "\"a\"",
        "explanation": "The minimum window substring is \"a\" which is the same as t."
      },
      {
        "input": "s = \"a\", t = \"aa\"",
        "output": "\"\"",
        "explanation": "There is no window that contains all characters of t."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a sliding window approach to optimize the search.",
      "Utilize a hash map to track the count of characters in t."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Binary Tree Inorder Traversal",
    "description": "Given the root of a binary tree, return its inorder traversal as an array of values. In an inorder traversal, you first visit the left subtree, then the node itself, and finally the right subtree.",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Traversal",
      "Binary Tree"
    ],
    "input_format": "The input consists of the root node of a binary tree.",
    "output_format": "An array of integers representing the values of the nodes visited in inorder sequence.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[1,3,2]",
        "explanation": "In this case, the traversal goes: visit the left node (null), visit the root (1), visit the right node where we have 2, then proceed to its left (3). Hence, we get [1, 3, 2]."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "The tree is empty, so the inorder traversal returns an empty array."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a stack to help with the traversal.",
      "You can do the traversal iteratively or recursively."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Zigzag Conversion",
    "description": "The string will be written in a zigzag pattern on a given number of rows like this: 'PAYPALISHIRING' with 3 rows: \n\nP   A   H   N\nA P L S I I G\nY   I   \n\nWrite the code that will take a string and converts it to the zigzag pattern on the given number of rows. The output should be read line by line.",
    "topic": "String",
    "subtopic": "Zigzag Conversion",
    "tags": [
      "String",
      "Zigzag",
      "Conversion"
    ],
    "input_format": "A string s and an integer numRows.",
    "output_format": "A single string representing the converted zigzag pattern.",
    "constraints": [
      "1 <= s.length <= 1000",
      "1 <= numRows <= 1000"
    ],
    "examples": [
      {
        "input": "s = 'PAYPALISHIRING', numRows = 3",
        "output": "'PAHNAPLSIIGYIR'",
        "explanation": "The zigzag pattern is as follows:\n\nP   A   H   N\nA P L S I I G\nY   I\n\nReading line by line gives the output 'PAHNAPLSIIGYIR'."
      },
      {
        "input": "s = 'A', numRows = 1",
        "output": "'A'",
        "explanation": "With only one row, the output is the same as the input."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how many characters there are in each full cycle.",
      "You may need to handle the last part of the string separately."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Partition List",
    "description": "Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. The partitioned list should be returned as a new list rather than modifying the original list.",
    "topic": "Linked List",
    "subtopic": "Partitioning",
    "tags": [
      "Linked List",
      "Partitioning",
      "Two-Pointer"
    ],
    "input_format": "The input consists of a linked list represented by its head node and an integer x.",
    "output_format": "Return the head of the newly partitioned linked list.",
    "constraints": [
      "The number of nodes in the linked list is in the range [0, 200].",
      "-10^6 <= Node.val <= 10^6",
      "-10^6 <= x <= 10^6"
    ],
    "examples": [
      {
        "input": "head = 1 -> 4 -> 3 -> 2 -> 5 -> 2, x = 3",
        "output": "1 -> 2 -> 2 -> 4 -> 3 -> 5",
        "explanation": "The nodes less than 3 are 1, 2, and 2. The nodes greater than or equal to 3 are 4, 3, and 5."
      },
      {
        "input": "head = 2 -> 1 -> 3 -> 4 -> 5, x = 3",
        "output": "2 -> 1 -> 3 -> 4 -> 5",
        "explanation": "The linked list remains the same because all nodes less than 3 already appear before nodes greater than or equal to 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use two separate lists for partitioning.",
      "Traverse the list and insert nodes into the appropriate lists based on their values."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Wildcard Matching",
    "description": "Implement a function that takes a string `s` and a pattern `p` and determines if they match. The pattern may contain the wildcard characters `?` and `*`. The `?` character matches any single character, while the `*` character matches any sequence of characters, including the empty sequence.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Backtracking"
    ],
    "input_format": "Two strings: s (the input string) and p (the pattern) where 1 <= s.length, p.length <= 3000.",
    "output_format": "A boolean indicating whether the string matches the pattern.",
    "constraints": [
      "The input strings s and p can have a length from 1 to 3000.",
      "The pattern p may contain characters a-z, A-Z, `?`, and `*`."
    ],
    "examples": [
      {
        "input": "s = 'aa', p = 'a'",
        "output": "false",
        "explanation": "The pattern 'a' does not match the string 'aa'."
      },
      {
        "input": "s = 'aa', p = '*'",
        "output": "true",
        "explanation": "The pattern '*' matches any string, including 'aa'."
      },
      {
        "input": "s = 'cb', p = '?a'",
        "output": "false",
        "explanation": "The pattern '?a' does not match the string 'cb'."
      },
      {
        "input": "s = 'adceb', p = '*a*b'",
        "output": "true",
        "explanation": "The pattern '*a*b' matches the string 'adceb' where '*' can match 'dce'."
      },
      {
        "input": "s = 'acdcb', p = 'a*c?b'",
        "output": "false",
        "explanation": "The pattern 'a*c?b' does not match the string 'acdcb'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to solve this problem.",
      "Think about how to handle the wildcard cases separately."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Remove Nth Node From End of List",
    "description": "Given the head of a singly linked list, remove the Nth node from the end of the list and return its head. You must do this in one pass.",
    "topic": "Linked List",
    "subtopic": "Two Pointers",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Removal"
    ],
    "input_format": "The input is a linked list represented by its head node and an integer N.",
    "output_format": "Return the head of the linked list after removing the Nth node from the end.",
    "constraints": [
      "The number of nodes in the list is in the range [1, 30].",
      "1 <= N <= the number of nodes in the list."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], N = 2",
        "output": "[1, 2, 3, 5]",
        "explanation": "Removing the 2nd node from the end, the list becomes 1 -> 2 -> 3 -> 5."
      },
      {
        "input": "head = [1], N = 1",
        "output": "[]",
        "explanation": "Removing the only node in the list results in an empty list."
      },
      {
        "input": "head = [1, 2], N = 1",
        "output": "[1]",
        "explanation": "Removing the 1st node from the end of the list results in 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use two pointers to find the Nth node from the end.",
      "Keep the first pointer N steps ahead of the second pointer."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "4Sum",
    "description": "Given an array of integers nums and an integer target, return all unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that a, b, c, and d are different indices, and nums[a] + nums[b] + nums[c] + nums[d] == target. You may return the answer in any order. Note that the quadruplets should be returned in ascending order of their indices.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Hash Table"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "A list of unique quadruplets that sum up to the target.",
    "constraints": [
      "0 <= nums.length <= 200",
      "-10^9 <= nums[i] <= 10^9",
      "There are no duplicate quadruplets."
    ],
    "examples": [
      {
        "input": "nums = [1, 0, -1, 0, -2, 2], target = 0",
        "output": "[[-2, -1, 0, 1], [0, 0, 0, 0]]",
        "explanation": "The quadruplets that sum up to 0 are [-2, -1, 0, 1] and [0, 0, 0, 0]."
      },
      {
        "input": "nums = [2, 2, 2, 2, 2], target = 8",
        "output": "[[2, 2, 2, 2]]",
        "explanation": "The only quadruplet that sums up to 8 is [2, 2, 2, 2]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using sorting and the two-pointer technique.",
      "Avoid duplicate quadruplets by skipping over the same numbers."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "3Sum Closest",
    "description": "Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "An integer n followed by an array of integers nums and an integer target.",
    "output_format": "An integer representing the closest sum of three integers to the target.",
    "constraints": [
      "3 <= nums.length <= 10^3",
      "-10^3 <= nums[i] <= 10^3",
      "-10^4 <= target <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-1, 2, 1, -4], target = 1",
        "output": "2",
        "explanation": "The sum that is closest to the target 1 is -1 + 2 + 1 = 2."
      },
      {
        "input": "nums = [0, 0, 0], target = 1",
        "output": "0",
        "explanation": "The only sum can be 0 + 0 + 0 = 0, which is closest to the target 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array to use the Two Pointers technique.",
      "Keep track of the closest sum found so far.",
      "Consider edge cases when the target is out of bounds."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Insert Interval",
    "description": "Given a list of non-overlapping intervals sorted by their start time and a new interval, insert the new interval into the list, merging if necessary. The function should return the resulting list of intervals sorted by their start time.",
    "topic": "Array",
    "subtopic": "Intervals",
    "tags": [
      "Array",
      "Intervals",
      "Sorting"
    ],
    "input_format": "An array of intervals, where each interval is represented as a pair of integers [start, end], and a new interval represented as [start, end].",
    "output_format": "An array of merged intervals sorted by their start values.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "intervals[i][0] < intervals[i][1]",
      "The intervals are sorted by intervals[i][0]."
    ],
    "examples": [
      {
        "input": "intervals = [[1, 3], [6, 9]], newInterval = [2, 5]",
        "output": "[[1, 5], [6, 9]]",
        "explanation": "The new interval [2, 5] overlaps with [1, 3] and can be merged to form [1, 5]."
      },
      {
        "input": "intervals = [[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]], newInterval = [4, 8]",
        "output": "[[1, 2], [3, 10], [12, 16]]",
        "explanation": "The new interval [4, 8] overlaps with [3, 5], [6, 7], and [8, 10] and can be merged into [3, 10]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to insert the new interval while maintaining the order.",
      "You may need to keep track of overlapping intervals."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Permutation Sequence",
    "description": "Given two integers n and k, return the k-th permutation sequence of the numbers 1 to n in lexicographical order. The sequence of permutations is dependent on the position k, where 1 <= k <= n!. You must solve the problem without generating all permutations directly.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Permutations",
      "Math"
    ],
    "input_format": "Two integers n and k.",
    "output_format": "A string representing the k-th permutation sequence.",
    "constraints": [
      "1 <= n <= 9",
      "1 <= k <= n!"
    ],
    "examples": [
      {
        "input": "n = 3, k = 3",
        "output": "213",
        "explanation": "The permutations of the numbers {1, 2, 3} in lexicographic order are: 123, 132, 213, 231, 312, 321. The 3rd permutation is '213'."
      },
      {
        "input": "n = 4, k = 9",
        "output": "2314",
        "explanation": "The permutations for {1, 2, 3, 4} lead to the 9th permutation as '2314'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use factorials to determine the blocks of permutations.",
      "Think about how you can eliminate choices and reduce the problem size iteratively."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Symmetric Tree",
    "description": "Given the root of a binary tree, determine if it is a mirror of itself (i.e., symmetric around its center). A binary tree is symmetric if the left subtree is a mirror reflection of the right subtree.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Recursive"
    ],
    "input_format": "The root of a binary tree.",
    "output_format": "Return true if the tree is symmetric, otherwise return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 1000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1,2,2,3,4,4,3]",
        "output": "true",
        "explanation": "The tree is symmetric because the left and right subtrees are mirror images of each other."
      },
      {
        "input": "root = [1,2,2,null,3,null,3]",
        "output": "false",
        "explanation": "The tree is not symmetric because the left subtree has a node with value 3, but the right subtree does not."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a recursive function to check for symmetry.",
      "Compare the left and right subtree nodes at each level."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Word Search",
    "description": "Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell (horizontally or vertically). The same letter cell may not be used more than once.",
    "topic": "Backtracking",
    "subtopic": "Depth-First Search",
    "tags": [
      "Backtracking",
      "DFS",
      "Matrix"
    ],
    "input_format": "A 2D char array board representing the grid and a string word representing the word to be searched.",
    "output_format": "A boolean indicating whether the word exists in the grid.",
    "constraints": [
      "1 <= board.length <= 200",
      "1 <= board[i].length <= 200",
      "board[i][j] is a lowercase English letter.",
      "1 <= word.length <= 100"
    ],
    "examples": [
      {
        "input": "board = [['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], word = 'ABCCED'",
        "output": "true",
        "explanation": "The word 'ABCCED' can be constructed from the grid."
      },
      {
        "input": "board = [['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], word = 'SEE'",
        "output": "true",
        "explanation": "The word 'SEE' can be constructed from the grid."
      },
      {
        "input": "board = [['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], word = 'ABCCEDX'",
        "output": "false",
        "explanation": "The word 'ABCCEDX' cannot be constructed from the grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using depth-first search (DFS) for traversing the grid.",
      "Use a set to keep track of visited cells to avoid revisiting."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Search a 2D Matrix",
    "description": "Write an efficient algorithm to search for a target value in an m x n integer matrix. This matrix has the following properties: Integers in each row are sorted from left to right. Integers in each column are sorted from top to bottom. Return true if the target exists in the matrix, otherwise return false.",
    "topic": "Matrix",
    "subtopic": "Searching",
    "tags": [
      "Matrix",
      "Binary Search",
      "Search"
    ],
    "input_format": "A 2D matrix of integers and an integer target.",
    "output_format": "A boolean indicating whether the target exists in the matrix.",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 100",
      "-10^4 <= matrix[i][j], target <= 10^4"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [15, 17, 19]], target = 9",
        "output": "true",
        "explanation": "The target 9 is found in the matrix."
      },
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [15, 17, 19]], target = 8",
        "output": "false",
        "explanation": "The target 8 does not exist in the matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider leveraging the properties of the matrix to eliminate rows or columns.",
      "Look for binary search patterns."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Sudoku Solver",
    "description": "Write a program to solve a classic 9x9 Sudoku puzzle by filling the empty cells. A Sudoku solution must satisfy the following rules: each of the digits from 1 to 9 must occur exactly once in each row, in each column, and in each of the nine 3x3 subgrids of the board. The given board contains '0' for empty cells.",
    "topic": "Backtracking",
    "subtopic": "Depth-First Search",
    "tags": [
      "Backtracking",
      "Depth-First Search",
      "Matrix"
    ],
    "input_format": "A 9x9 2D array of integers where 0 represents an empty cell.",
    "output_format": "The solved 9x9 Sudoku board.",
    "constraints": [
      "The input board is a 9x9 grid.",
      "The board may contain digits from 1 to 9 and empty cells represented by 0."
    ],
    "examples": [
      {
        "input": "[[5,3,0,0,7,0,0,0,0],[6,0,0,1,9,5,0,0,0],[0,9,8,0,0,0,0,6,0],[8,0,0,0,6,0,0,0,3],[4,0,0,8,0,3,0,0,1],[7,0,0,0,2,0,0,0,6],[0,6,0,0,0,0,2,8,0],[0,0,0,4,1,9,0,0,5],[0,0,0,0,8,0,0,7,9]]",
        "output": "[[5,3,4,6,7,8,9,1,2],[6,7,2,1,9,5,3,4,8],[1,9,8,3,4,2,5,6,7],[8,5,9,7,6,1,4,2,3],[4,2,6,8,5,3,7,9,1],[7,1,3,9,2,4,8,5,6],[9,6,1,2,3,5,2,8,4],[2,8,7,4,1,9,6,3,5],[3,4,5,1,8,6,7,9,2]]",
        "explanation": "The input Sudoku puzzle is solved, satisfying all the Sudoku rules."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using backtracking.",
      "Try filling in numbers from 1 to 9 for empty cells and check for validity."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Combinations",
    "description": "Given a collection of distinct integers, return all possible subsets (the power set). The subsets should be returned in any order. Note that the empty set is also a subset of any set.",
    "topic": "Backtracking",
    "subtopic": "Power Set",
    "tags": [
      "Backtracking",
      "Recursion",
      "Subsets"
    ],
    "input_format": "A list of distinct integers.",
    "output_format": "A list of lists containing all possible subsets.",
    "constraints": [
      "1 <= nums.length <= 10",
      "-10 <= nums[i] <= 10",
      "All integers are unique."
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]",
        "explanation": "The subsets include the empty set, single elements, pairs, and the full set."
      },
      {
        "input": "nums = [0]",
        "output": "[[], [0]]",
        "explanation": "The only subsets are the empty set and the single element set."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to generate combinations.",
      "Iterate through the numbers, deciding to include or exclude each number."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Same Tree",
    "description": "Given two binary trees, write a function to determine whether they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Recursion"
    ],
    "input_format": "Two binary trees represented by their root nodes, root1 and root2.",
    "output_format": "A boolean value indicating whether the two trees are the same.",
    "constraints": [
      "The number of nodes in both trees is in the range [0, 100].",
      "Each node's value is an integer in the range [-100, 100]."
    ],
    "examples": [
      {
        "input": "root1 = [1,2,3], root2 = [1,2,3]",
        "output": "true",
        "explanation": "Both trees have the same structure and node values."
      },
      {
        "input": "root1 = [1,2], root2 = [1,null,2]",
        "output": "false",
        "explanation": "The trees have different structures."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a recursive function to compare both trees.",
      "Check if both nodes are null. If yes, they are the same at this level."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Maximum Depth of Binary Tree",
    "description": "Given a binary tree, find its maximum depth. The maximum depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Depth",
      "Binary Tree"
    ],
    "input_format": "The input is the root node of a binary tree.",
    "output_format": "An integer representing the maximum depth of the binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "3",
        "explanation": "The longest path is 3 -> 20 -> 15, which has a depth of 3."
      },
      {
        "input": "root = [1,null,2]",
        "output": "2",
        "explanation": "The longest path is 1 -> 2, which has a depth of 2."
      },
      {
        "input": "root = []",
        "output": "0",
        "explanation": "The tree is empty, so the maximum depth is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a recursive approach to traverse the tree.",
      "The depth of a leaf node is 1, while the depth of an empty tree is 0."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Balanced Binary Tree",
    "description": "Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is defined as a binary tree in which the difference between the heights of the left and right subtrees for any node is no more than one.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Recursion"
    ],
    "input_format": "The input is the root node of a binary tree.",
    "output_format": "Return true if the binary tree is height-balanced; otherwise, return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 5000].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root = [3, 9, 20, null, null, 15, 7]",
        "output": "true",
        "explanation": "The tree is balanced because the height difference between the left and right subtrees for all nodes is at most 1."
      },
      {
        "input": "root = [1, 2, 2, 3, 3, null, null, 4, 4]",
        "output": "false",
        "explanation": "The tree is not balanced because the left subtree of the root is higher than the right subtree by more than 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a recursive approach to check the balance of each subtree.",
      "Calculate the height of left and right subtrees and compare them."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Text Justification",
    "description": "Given an array of words and a maximum line width, format the text such that each line has exactly maxWidth characters. You should fill the extra space evenly between the words and place extra spaces at the end if necessary. The last line should be left-justified. Implement a function to achieve this formatting.",
    "topic": "String",
    "subtopic": "Text Formatting",
    "tags": [
      "String",
      "Text Manipulation",
      "Justification"
    ],
    "input_format": "An array of strings words and an integer maxWidth.",
    "output_format": "An array of strings representing the justified text.",
    "constraints": [
      "1 <= words.length <= 3000",
      "1 <= words[i].length <= 20",
      "1 <= maxWidth <= 100"
    ],
    "examples": [
      {
        "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
        "output": "[\"This    is    an\", \"example  of text\", \"justification.  \"]",
        "explanation": "The words are justified such that each line has exactly 16 characters."
      },
      {
        "input": "words = [\"What\", \"must\", \"be\", \"acknowledged\", \"shall\", \"be\", \"acknowledged\"], maxWidth = 16",
        "output": "[\"What   must   be\", \"acknowledged  \", \"shall be        \"]",
        "explanation": "The last line is left-justified, while the other lines are fully justified."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to distribute spaces evenly between words.",
      "Handle the last line as a special case.",
      "Use a greedy approach for line filling."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Add Binary",
    "description": "Given two binary strings a and b, return their sum as a binary string. The input strings are both non-empty and contain only characters '0' or '1'.",
    "topic": "String",
    "subtopic": "Binary Representation",
    "tags": [
      "String",
      "Binary",
      "Addition"
    ],
    "input_format": "Two binary strings a and b.",
    "output_format": "A binary string representing the sum of a and b.",
    "constraints": [
      "1 <= a.length, b.length <= 10^4",
      "a and b consist only of '0' or '1'."
    ],
    "examples": [
      {
        "input": "a = '11', b = '1'",
        "output": "'100'",
        "explanation": "11 (2 in decimal) + 1 (1 in decimal) = 12 (100 in binary)."
      },
      {
        "input": "a = '1010', b = '1011'",
        "output": "'10101'",
        "explanation": "10 (2 in decimal) + 11 (3 in decimal) = 13 (10101 in binary)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a carry variable to account for binary addition.",
      "You can construct the result from the least significant bit to the most significant bit."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Longest Valid Parentheses",
    "description": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Stack"
    ],
    "input_format": "A string s consisting of '(' and ')'.",
    "output_format": "An integer representing the length of the longest valid parentheses substring.",
    "constraints": [
      "0 <= s.length <= 3 * 10^4",
      "s[i] is either '(' or ')'."
    ],
    "examples": [
      {
        "input": "s = \"(()\")",
        "output": "2",
        "explanation": "The longest valid parentheses substring is \"()\" with length 2."
      },
      {
        "input": "s = \")()())\"",
        "output": "4",
        "explanation": "The longest valid parentheses substring is \"()()\" with length 4."
      },
      {
        "input": "s = \"\"",
        "output": "0",
        "explanation": "There are no parentheses hence the length is 0."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to keep track of indices.",
      "You might want to maintain a variable to track the last valid position."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix II",
    "description": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n^2 in spiral order. The matrix should start from the top left corner and fill towards the right, then down, left, and up, spiraling inward.",
    "topic": "Matrix",
    "subtopic": "Matrix Construction",
    "tags": [
      "Matrix",
      "Array",
      "Spiral Order"
    ],
    "input_format": "An integer n representing the size of the matrix.",
    "output_format": "A 2D array representing the n x n matrix filled in spiral order.",
    "constraints": [
      "1 <= n <= 20"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[[1, 2, 3], [8, 9, 4], [7, 6, 5]]",
        "explanation": "The numbers are filled in the matrix in a spiral order starting from 1 to 9."
      },
      {
        "input": "n = 1",
        "output": "[[1]]",
        "explanation": "Only one element 1 will be present in the matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about the direction in which you need to fill the matrix.",
      "Use boundaries to control the spiral filling.",
      "Iterate until you've filled all numbers from 1 to n^2."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Edit Distance",
    "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You may perform three types of operations: insert a character, delete a character, or replace a character.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Edit Distance"
    ],
    "input_format": "Two strings word1 and word2.",
    "output_format": "An integer representing the minimum number of operations required to convert word1 to word2.",
    "constraints": [
      "0 <= word1.length, word2.length <= 100",
      "word1 and word2 consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "word1 = 'horse', word2 = 'ros'",
        "output": "3",
        "explanation": "horse -> rorse (replace 'h' with 'r') -> rose (remove 'r') -> ros (remove 'e')."
      },
      {
        "input": "word1 = 'intention', word2 = 'execution'",
        "output": "5",
        "explanation": "intention -> inention (remove 't') -> enention (replace 'i' with 'e') -> exention (insert 'x') -> exection (replace 'n' with 'c') -> execution (insert 'u')."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a 2D array to store the results of subproblems.",
      "Consider the cost of each operation: insertion, deletion, substitution."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Substring with Concatenation of All Words",
    "description": "You are given a string s and an array of strings words of the same length. The strings in words are all of the same length. Your task is to find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. The order of occurrence does not matter.",
    "topic": "String",
    "subtopic": "Substring Search",
    "tags": [
      "String",
      "Substring",
      "HashTable"
    ],
    "input_format": "A string s and an array of strings words.",
    "output_format": "A list of starting indices of the substring(s) in s that matches the criteria.",
    "constraints": [
      "1 <= s.length <= 1000",
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 100"
    ],
    "examples": [
      {
        "input": {
          "s": "barfoothefoobarman",
          "words": [
            "foo",
            "bar"
          ]
        },
        "output": [
          0,
          9
        ],
        "explanation": "The substring starting at index 0 is 'barfoo' and the substring starting at index 9 is 'foobar'. Both are valid concatenations."
      },
      {
        "input": {
          "s": "wordgoodgoodgoodbestword",
          "words": [
            "word",
            "good",
            "best",
            "word"
          ]
        },
        "output": [],
        "explanation": "There is no valid starting index for the concatenation since 'word' appears twice."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the total length of the concatenated substring.",
      "Use a sliding window technique."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array II",
    "description": "You are given an integer array 'nums' sorted in non-decreasing order, which has been rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6,0] is a rotation of [2,5,6,0,0,1,2]). You need to search for a target value in the array. If the target exists, then return true; otherwise, return false. There may be duplicates in the array.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "A boolean value indicating whether the target exists in the array.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "nums may contain duplicates."
    ],
    "examples": [
      {
        "input": "nums = [2,5,6,0,0,1,2], target = 0",
        "output": "true",
        "explanation": "The target 0 is present in the array."
      },
      {
        "input": "nums = [2,5,6,0,0,1,2], target = 3",
        "output": "false",
        "explanation": "The target 3 is not present in the array."
      },
      {
        "input": "nums = [1,0,1,1,1], target = 0",
        "output": "true",
        "explanation": "The target 0 is present in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how binary search can be adapted for a rotated array.",
      "Handle duplicates carefully to avoid losing the search range."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted List",
    "description": "Given a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "Linked List",
      "Duplicates",
      "Sorting"
    ],
    "input_format": "The input consists of a head node of a sorted linked list, where each node has a value and a pointer to the next node.",
    "output_format": "Return the head of the linked list after removing duplicates.",
    "constraints": [
      "The linked list is guaranteed to be sorted.",
      "The number of nodes in the list is in the range [0, 10^4].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "head = [1, 1, 2]",
        "output": "[1, 2]",
        "explanation": "The list contains duplicates of 1, so we remove one, resulting in [1, 2]."
      },
      {
        "input": "head = [1, 1, 2, 3, 3]",
        "output": "[1, 2, 3]",
        "explanation": "The duplicates of 1 and 3 are removed, resulting in [1, 2, 3]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a temporary pointer to track the last unique node.",
      "If the current node's value matches the next node's value, skip the next node."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Unique Paths II",
    "description": "You are given a m x n grid. Each cell can either be an obstacle or empty. The goal is to find the number of unique paths from the top-left corner to the bottom-right corner of the grid, but you can only move either down or right at any point in time. An obstacle is represented by a 1 and an empty space is represented by a 0. You need to return the number of unique paths to reach the bottom-right corner.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Paths",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Recursion"
    ],
    "input_format": "A 2D array grid where grid[i][j] is either 0 or 1.",
    "output_format": "An integer representing the number of unique paths to reach the bottom-right corner.",
    "constraints": [
      "1 <= m, n <= 100",
      "grid[i][j] is either 0 or 1.",
      "grid[0][0] and grid[m-1][n-1] are guaranteed to be 0."
    ],
    "examples": [
      {
        "input": "grid = [[0,0,0],[0,1,0],[0,0,0]]",
        "output": "2",
        "explanation": "There are two unique paths to reach the bottom-right corner: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) and (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2)."
      },
      {
        "input": "grid = [[0,1],[0,0]]",
        "output": "1",
        "explanation": "There is one unique path: (0,0) -> (1,0) -> (1,1)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about using dynamic programming to solve this problem.",
      "Consider how many paths can lead to a given cell based on its neighbors."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Rotate List",
    "description": "Given a linked list, rotate the list to the right by k places, where k is non-negative. The nodes of the list should be moved to the end according to the specified rotation number.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "Linked List",
      "Rotation",
      "Two Pointers"
    ],
    "input_format": "A linked list head node and an integer k representing the number of places to rotate.",
    "output_format": "The head node of the modified linked list after rotation.",
    "constraints": [
      "The number of nodes in the list will be in the range [0, 500].",
      "-100 <= Node.val <= 100",
      "0 <= k <= 2 * 10^9"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5], k = 2",
        "output": "[4,5,1,2,3]",
        "explanation": "After rotating the list by 2 places, the list is now 4 -> 5 -> 1 -> 2 -> 3."
      },
      {
        "input": "head = [0,1,2], k = 4",
        "output": "[2,0,1]",
        "explanation": "Rotating the list by 4 places is equivalent to rotating it by 1 place, resulting in 2 -> 0 -> 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about the length of the list and how rotations behave when k is greater than the length.",
      "Consider using a two-pointer technique to find the new head."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "N-Queens",
    "description": "The N-Queens puzzle is the problem of placing N queens on an N\u00d7N chessboard so that no two queens threaten each other. That is, no two queens share the same row, column, or diagonal. Write a function to solve the N-Queens problem and return all distinct solutions, where each solution is represented as a list of strings. Each string should represent a row of the chessboard, with '.' indicating an empty space and 'Q' indicating a queen.",
    "topic": "Backtracking",
    "subtopic": "N-Queens",
    "tags": [
      "Backtracking",
      "Recursion",
      "Chess"
    ],
    "input_format": "An integer n representing the number of queens and the size of the chessboard.",
    "output_format": "A list of possible solutions, where each solution is represented as a list of strings.",
    "constraints": [
      "1 <= n <= 9"
    ],
    "examples": [
      {
        "input": "n = 4",
        "output": [
          [
            ".Q..",
            "...Q",
            "Q...",
            "..Q."
          ],
          [
            "..Q.",
            "Q...",
            "...Q",
            ".Q.."
          ]
        ],
        "explanation": "There are two distinct solutions for placing 4 queens on a 4x4 chessboard."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use backtracking to explore all possible positions.",
      "Keep track of columns and diagonals under attack."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Decode Ways",
    "description": "Given a string containing digits, determine the total number of ways to decode it. A mapping of 'A' to '1', 'B' to '2', ..., 'Z' to '26' is provided. The input string may contain leading zeros, which cannot be decoded. For example, '12' could be 'AB' (1,2) or 'L' (12) but '10' can only be 'J' (10). You need to return the number of ways to decode the entire string.",
    "topic": "Dynamic Programming",
    "subtopic": "String Decoding",
    "tags": [
      "Dynamic Programming",
      "String",
      "Decoding"
    ],
    "input_format": "A string s of digits (1 <= s.length <= 100).",
    "output_format": "An integer representing the number of ways to decode the string.",
    "constraints": [
      "The input string will only contain digits and will not have leading zeroes unless it is '0' itself.",
      "1 <= s.length <= 100"
    ],
    "examples": [
      {
        "input": "'226'",
        "output": "3",
        "explanation": "The possible decodings are 'BBF' (2, 2, 6), 'BZ' (2, 26), and 'VF' (22, 6)."
      },
      {
        "input": "'12'",
        "output": "2",
        "explanation": "The possible decodings are 'AB' (1, 2) and 'L' (12)."
      },
      {
        "input": "'0'",
        "output": "0",
        "explanation": "0 cannot be decoded."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider dynamic programming for solving the problem.",
      "Use an array to keep track of the number of ways to decode up to each index."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Validate Binary Search Tree",
    "description": "Given a binary tree, determine if it is a valid binary search tree (BST). A binary search tree is defined as a tree in which for each node, the left subtree contains only nodes with keys less than the node's key, and the right subtree contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "The input is a binary tree represented by its root node.",
    "output_format": "Return true if the binary tree is a valid binary search tree, otherwise return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root = [2, 1, 3]",
        "output": "true",
        "explanation": "The left child (1) is less than the parent (2) and the right child (3) is greater than the parent, so it is a valid BST."
      },
      {
        "input": "root = [5, 1, 4, null, null, 3, 6]",
        "output": "false",
        "explanation": "The right child (4) is not greater than the parent (5), so it is not a valid BST."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use recursive validation to check left and right subtrees.",
      "Keep track of the valid range for each node."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Permutations II",
    "description": "Given a collection of numbers that might contain duplicates, return all possible unique permutations. The order of the output does not matter.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Permutations",
      "Unique"
    ],
    "input_format": "A list of integers nums.",
    "output_format": "A list of lists of integers representing all the unique permutations.",
    "constraints": [
      "1 <= nums.length <= 8",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "[[1, 1, 2], [1, 2, 1], [2, 1, 1]]",
        "explanation": "The unique permutations of the array are: [1, 1, 2], [1, 2, 1], and [2, 1, 1]."
      },
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]",
        "explanation": "All permutations of the array are unique, totaling to 6 permutations."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use backtracking to explore all potential permutations.",
      "Use a set to handle duplicates and ensure uniqueness."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Count and Say",
    "description": "The 'Count and Say' sequence is a sequence of digit strings defined by the recursive formula: starting with '1', each subsequent term is derived from the previous term by describing its digits. For example, the next term after '1' is '11' because we read 'one 1'. The next term after '11' is '21', since we read 'two 1s'. The sequence goes: '1', '11', '21', '1211', '111221', '312211', and so forth. Given an integer n, generate the nth term of the 'Count and Say' sequence.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Recursion",
      "Count and Say"
    ],
    "input_format": "An integer n (1 <= n <= 30).",
    "output_format": "A string representing the nth term of the 'Count and Say' sequence.",
    "constraints": [
      "1 <= n <= 30"
    ],
    "examples": [
      {
        "input": "n = 1",
        "output": "1",
        "explanation": "The first term of the sequence is '1'."
      },
      {
        "input": "n = 4",
        "output": "1211",
        "explanation": "From '21' we get 'one 2 and one 1', which translates to '1211'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to describe the previous term.",
      "You might need to iterate through the previous string while counting consecutive digits."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Simplify Path",
    "description": "Given a string representing an absolute path for a file, simplify it according to the following rules: 1. The '.' directory represents the current directory, while '..' represents the parent directory. 2. If the path is invalid, return an empty string. 3. Any multiple consecutive slashes ('//') should be treated as a single slash. 4. The resulting path should start with a single slash and not end with a slash. 5. The simplified path should not contain any redundant components.",
    "topic": "String",
    "subtopic": "Path Manipulation",
    "tags": [
      "String",
      "Path",
      "Manipulation"
    ],
    "input_format": "A string path representing a file system path.",
    "output_format": "A simplified string representing the canonical path.",
    "constraints": [
      "1 <= path.length <= 3000",
      "path consists of English letters, digits, '/', '.', and '..'."
    ],
    "examples": [
      {
        "input": "/home/../usr//bin/./",
        "output": "/usr/bin",
        "explanation": "The '..' brings us back to the root, removing 'home'. '/usr/bin' is the resulting path."
      },
      {
        "input": "/a/./b/../../c/",
        "output": "/c",
        "explanation": "The path navigates to 'a', then backtracks two steps to get to 'c'."
      },
      {
        "input": "/../",
        "output": "/",
        "explanation": "Navigating to the root from any directory results in the root path."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to manage the path components.",
      "Remember to ignore components that do not lead to a directory."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Subsets II",
    "description": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.",
    "topic": "Backtracking",
    "subtopic": "Subsets",
    "tags": [
      "Array",
      "Backtracking",
      "Subset"
    ],
    "input_format": "An integer array nums that may contain duplicates.",
    "output_format": "A list of lists representing all possible unique subsets.",
    "constraints": [
      "0 <= nums.length <= 10^10",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2]",
        "output": "[[], [1], [1, 2], [2], [2, 2]]",
        "explanation": "The unique subsets are {}, {1}, {2}, {1, 2}, and {2, 2}."
      },
      {
        "input": "nums = [0]",
        "output": "[[], [0]]",
        "explanation": "The unique subsets are {} and {0}."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to generate subsets.",
      "Sort the input to handle duplicates effectively."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Maximal Rectangle",
    "description": "Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Dynamic Programming",
      "Matrix",
      "Rectangle"
    ],
    "input_format": "A 2D binary matrix represented as a list of lists containing 0's and 1's.",
    "output_format": "An integer representing the area of the largest rectangle containing only 1's.",
    "constraints": [
      "Rows and columns of the matrix are in the range [0, 200].",
      "The elements of the matrix are either 0 or 1."
    ],
    "examples": [
      {
        "input": "[[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]",
        "output": "6",
        "explanation": "The maximal rectangle is formed by the 1's in the following area: \n1 1 1 1\n1 1 1 1\nResulting in an area of 3 rows * 2 columns = 6."
      },
      {
        "input": "[[0]]",
        "output": "0",
        "explanation": "There are no 1's in the matrix, so the area is 0."
      },
      {
        "input": "[[1]]",
        "output": "1",
        "explanation": "The matrix contains a single 1, thus the area of the largest rectangle is 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Try to utilize a histogram approach to keep track of heights in columns.",
      "Consider how to calculate the area of rectangles formed at each row level efficiently."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted List II",
    "description": "Given the head of a sorted linked list, remove all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "Linked List",
      "Twice Duplicate",
      "Sorting"
    ],
    "input_format": "The input consists of the head of a sorted linked list, where each node contains an integer value.",
    "output_format": "Return the modified linked list with all duplicates removed.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 10^4].",
      "-10^5 <= Node.val <= 10^5"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 3, 4, 4, 5]",
        "output": "[1, 2, 5]",
        "explanation": "The numbers 3 and 4 are duplicates and should be removed. The remaining list is [1, 2, 5]."
      },
      {
        "input": "head = [1, 1, 1, 2, 3]",
        "output": "[2, 3]",
        "explanation": "All instances of 1 are duplicates and are removed. The remaining list is [2, 3]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dummy node to simplify the handling of the head of the list.",
      "Use two pointers to track the current node and the next distinct node."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Restore IP Addresses",
    "description": "Given a string s consisting of digits, return all possible valid IP address combinations that can be obtained from s. A valid IP address consists of four integers separated by single dots, where each integer is in the range [0, 255] and cannot have leading zeros. The integers can be from 1 to 3 digits long.",
    "topic": "String",
    "subtopic": "Backtracking",
    "tags": [
      "String",
      "Backtracking",
      "IP Address"
    ],
    "input_format": "A string s of digits with a length of n (1 <= n <= 20).",
    "output_format": "A list of strings representing all possible valid IP address combinations.",
    "constraints": [
      "1 <= s.length <= 20",
      "s consists only of digits."
    ],
    "examples": [
      {
        "input": "s = '25525511135'",
        "output": "['255.255.11.135', '255.255.111.35']",
        "explanation": "The valid IP addresses formed by splitting the string into parts are 255.255.11.135 and 255.255.111.35."
      },
      {
        "input": "s = '0000'",
        "output": "['0.0.0.0']",
        "explanation": "The only valid IP address is 0.0.0.0 since any segment larger than 0 cannot have leading zeros."
      },
      {
        "input": "s = '1111'",
        "output": "['1.1.1.1']",
        "explanation": "The only valid IP address formed is 1.1.1.1."
      },
      {
        "input": "s = '010010'",
        "output": "['0.10.0.10', '0.100.1.0']",
        "explanation": "These are the valid addresses formed, where segments like 10 and 100 do not have leading zeros."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use backtracking to explore all segments.",
      "Limit each segment between 0 and 255.",
      "Trim segments with leading zeros."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Unique Binary Search Trees II",
    "description": "Given an integer n, generate all unique binary search trees (BST) that can be constructed using values from 1 to n. Each value must be used exactly once in the tree. Return the list of all these unique BSTs.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Dynamic Programming",
      "Recursion"
    ],
    "input_format": "An integer n (1 <= n <= 8), representing the number of nodes in the BST.",
    "output_format": "A list of unique BST trees represented as the root nodes.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
        "explanation": "The five unique BSTs that can be formed with values 1, 2, and 3 are as shown in the output."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of a BST when generating the trees.",
      "Use recursion to build the trees dynamically."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Unique Binary Search Trees",
    "description": "Given an integer n, return the number of unique binary search trees (BST) that can be formed with n distinct nodes. Each node must hold a unique value from 1 to n. A binary search tree is defined as a binary tree where for each node, all elements in the left subtree are smaller than the node's value, and all elements in the right subtree are larger.",
    "topic": "Dynamic Programming",
    "subtopic": "Combinatorial",
    "tags": [
      "Dynamic Programming",
      "Binary Tree",
      "Combinatorics"
    ],
    "input_format": "An integer n (1 <= n <= 19)",
    "output_format": "An integer representing the number of unique binary search trees that can be formed.",
    "constraints": [
      "1 <= n <= 19"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "5",
        "explanation": "The 5 unique BSTs that can be created with 3 nodes are: (1,2,3), (1,3,2), (2,1,3), (2,3,1), (3,2,1)."
      },
      {
        "input": "n = 1",
        "output": "1",
        "explanation": "There is only one unique BST that can be created with 1 node."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to build solutions from smaller subproblems.",
      "The number of trees can be computed using the Catalan number formula."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Binary Tree Level Order Traversal",
    "description": "Given a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level). You should return the values in a list of lists, where each inner list contains the values of the nodes at that level.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "BFS",
      "Level Order Traversal"
    ],
    "input_format": "The input consists of the root node of a binary tree.",
    "output_format": "A list of lists where each inner list contains the values of the nodes at that level.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [3, 9, 20, null, null, 15, 7]",
        "output": "[[3], [9, 20], [15, 7]]",
        "explanation": "The tree's levels are: 1st level: [3], 2nd level: [9, 20], 3rd level: [15, 7]."
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": "Only one node exists, so the output is just its value."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "Empty tree results in no levels, hence an empty output."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to facilitate level order traversal.",
      "Remember to enqueue the children of each node as you traverse."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Multiply Strings",
    "description": "Given two non-negative integers represented as strings, return the product of these two numbers, also represented as a string. You must not use any built-in BigInteger library or similar feature to handle large integers.",
    "topic": "String",
    "subtopic": "Mathematical Operations",
    "tags": [
      "String",
      "Mathematics",
      "Multiplication"
    ],
    "input_format": "Two strings num1 and num2 representing the non-negative integers.",
    "output_format": "A string representing the product of the two numbers.",
    "constraints": [
      "1 <= num1.length, num2.length <= 200",
      "num1 and num2 consist of digits only and do not contain leading zeros."
    ],
    "examples": [
      {
        "input": "num1 = '123', num2 = '456'",
        "output": "'56088'",
        "explanation": "The product of 123 and 456 is 56088."
      },
      {
        "input": "num1 = '2', num2 = '3'",
        "output": "'6'",
        "explanation": "The product of 2 and 3 is 6."
      },
      {
        "input": "num1 = '0', num2 = '12345'",
        "output": "'0'",
        "explanation": "The product of 0 and any number is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using an array to store the intermediate results.",
      "Think about how to handle the carry during multiplication."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Combination Sum",
    "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may be used an unlimited number of times. The solution set must not contain duplicate combinations.",
    "topic": "Backtracking",
    "subtopic": "Combination Generation",
    "tags": [
      "Backtracking",
      "DFS",
      "Combination"
    ],
    "input_format": "A list of distinct integers candidates and a target integer.",
    "output_format": "A list of lists, where each list represents a unique combination of numbers that sum to the target.",
    "constraints": [
      "1 <= candidates.length <= 30",
      "1 <= candidates[i] <= 200",
      "All elements of candidates are unique.",
      "1 <= target <= 500"
    ],
    "examples": [
      {
        "input": "candidates = [2, 3, 6, 7], target = 7",
        "output": "[[7], [2, 2, 3]]",
        "explanation": "The combinations that sum up to 7 are [7] and [2, 2, 3]."
      },
      {
        "input": "candidates = [2, 3, 5], target = 8",
        "output": "[[2, 2, 2, 2], [2, 3, 3], [3, 5]]",
        "explanation": "The combinations that sum up to 8 are [2, 2, 2, 2], [2, 3, 3], and [3, 5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using backtracking to explore combinations.",
      "Keep track of the current combination and its sum.",
      "To avoid duplicates, ensure to skip over the same numbers in the candidates."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Construct Binary Tree from Inorder and Postorder Traversal",
    "description": "Given two integer arrays `inorder` and `postorder` where `inorder` is the inorder traversal of a binary tree and `postorder` is the postorder traversal of the same tree, construct and return the binary tree.",
    "topic": "Tree",
    "subtopic": "Binary Tree Construction",
    "tags": [
      "Tree",
      "Binary Tree",
      "Traversal",
      "Recursion"
    ],
    "input_format": "Two arrays of integers, `inorder` and `postorder`, representing the inorder and postorder traversal of a binary tree respectively.",
    "output_format": "Return the root node of the constructed binary tree.",
    "constraints": [
      "1 <= inorder.length <= 3000",
      "postorder.length == inorder.length",
      "Both `inorder` and `postorder` consist of unique values.",
      "Each value of `inorder` and `postorder` appears exactly once."
    ],
    "examples": [
      {
        "input": {
          "inorder": [
            9,
            3,
            15,
            20,
            7
          ],
          "postorder": [
            9,
            15,
            7,
            20,
            3
          ]
        },
        "output": "3",
        "explanation": "The constructed binary tree will have the structure: \n        3\n      /   \\\n     9    20\n         /  \\\n        15   7"
      },
      {
        "input": {
          "inorder": [
            1,
            2,
            3
          ],
          "postorder": [
            1,
            3,
            2
          ]
        },
        "output": "2",
        "explanation": "The constructed binary tree will have the structure: \n        2\n      /   \\\n     1    3"
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "The last element of postorder is the root of the tree.",
      "Use the index of the root in inorder to divide left and right subtrees.",
      "You can use recursion to construct the left and right subtrees."
    ],
    "company": "Adobe"
  },
  {
    "question_id": "",
    "title": "Convert Sorted Array to Binary Search Tree",
    "description": "Given an array where elements are sorted in ascending order, convert it to a height-balanced binary search tree (BST). A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "An array of integers nums, sorted in ascending order.",
    "output_format": "The root node of the height-balanced binary search tree.",
    "constraints": [
      "The length of nums will be in the range [0, 10^4].",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-10, -3, 0, 5, 9]",
        "output": "[0,-3,9,-10,null,5]",
        "explanation": "The height-balanced BST is: \n       0 \n      / \\ \n    -3   9 \n    /   / \n  -10  5"
      },
      {
        "input": "nums = []",
        "output": "null",
        "explanation": "An empty array results in a null tree."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a recursive approach to build the tree.",
      "The middle element of the array should be the root of the tree."
    ],
    "company": "Adobe"
  }
]