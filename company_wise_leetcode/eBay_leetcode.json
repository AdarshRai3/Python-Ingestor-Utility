[
  {
    "question_id": "",
    "title": "Partition Equal Subset Sum",
    "description": "Given a non-empty array of positive integers nums, determine if it can be partitioned into two subsets such that the sum of the elements in both subsets is equal. An array can be partitioned if such a division exists. Implement a function that returns true if such a partition is possible, and false otherwise.",
    "topic": "Dynamic Programming",
    "subtopic": "Subset Sum Problem",
    "tags": [
      "Dynamic Programming",
      "Backtracking",
      "Subset Sum"
    ],
    "input_format": "An array of integers nums, where 1 <= nums.length <= 200 and 1 <= nums[i] <= 100.",
    "output_format": "A boolean value indicating whether the array can be partitioned into two equal subsets.",
    "constraints": [
      "1 <= nums.length <= 200",
      "1 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 5, 11, 5]",
        "output": "true",
        "explanation": "The array can be partitioned into two subsets: [1, 5, 5] and [11], both having a sum of 11."
      },
      {
        "input": "nums = [1, 2, 3, 5]",
        "output": "false",
        "explanation": "No partition can create subsets with equal sum. The total sum is 11, which is odd."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to use a dynamic programming approach.",
      "Consider the total sum of the array; if it's odd, a partition is impossible.",
      "You need to check if there exists a subset with a sum equal to half of the total sum."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "LRU Cache",
    "description": "Design and implement a data structure for a Least Recently Used (LRU) cache. It should support the following operations: get and put. The get operation retrieves the value of the key if the key exists in the cache, otherwise returns -1. The put operation will insert or update the value of the key. If the number of keys exceeds the capacity, it should invalidate the least recently used key before inserting a new key. The cache should be initialized with a positive capacity.",
    "topic": "Design",
    "subtopic": "Data Structures",
    "tags": [
      "Cache",
      "Design",
      "Data Structures"
    ],
    "input_format": "The cache is initialized with a positive integer capacity. The `get(key)` method accepts an integer key, while the `put(key, value)` method accepts an integer key and an integer value.",
    "output_format": "For the `get` method, return the value of the key if it exists. For the `put` method, it does not return anything.",
    "constraints": [
      "1 <= capacity <= 3000",
      "0 <= key <= 10^4",
      "0 <= value <= 10^5",
      "At most 10^4 calls will be made to `get` and `put`."
    ],
    "examples": [
      {
        "input": "LRUCache cache = new LRUCache(2);\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);",
        "output": "1",
        "explanation": "Cache is {1=1, 2=2}. Returns 1."
      },
      {
        "input": "cache.put(3, 3);",
        "output": "",
        "explanation": "Evicts key 2 as it is the least recently used, now cache is {1=1, 3=3}."
      },
      {
        "input": "cache.get(2);",
        "output": "-1",
        "explanation": "Returns -1 as key 2 was evicted."
      },
      {
        "input": "cache.put(4, 4);",
        "output": "",
        "explanation": "Evicts key 1, cache is {3=3, 4=4}."
      },
      {
        "input": "cache.get(1);",
        "output": "-1",
        "explanation": "Returns -1 as key 1 was evicted."
      },
      {
        "input": "cache.get(3);",
        "output": "3",
        "explanation": "Returns 3."
      },
      {
        "input": "cache.get(4);",
        "output": "4",
        "explanation": "Returns 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to store the key-value pairs.",
      "Maintain a doubly linked list to track the order of usage."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Design Skiplist",
    "description": "A skip list is a data structure that allows for fast search, insertion, and deletion operations within an ordered sequence of elements. It consists of multiple layers where each layer is an ordered linked list. For the upper layers, elements are chosen randomly from the lower layers. This problem requires you to implement a skip list with the following functionalities: Insert, Search, and Erase. Your implementation should support the following operations: \n\n- `insert(val)`: Inserts a value into the skip list. \n- `search(val)`: Returns true if the value is in the skip list, otherwise false. \n- `erase(val)`: Returns true if the value was removed successfully, otherwise false.",
    "topic": "Data Structures",
    "subtopic": "Skip List",
    "tags": [
      "Data Structures",
      "Skip List",
      "Design"
    ],
    "input_format": "The operations to be performed on the skip list are provided as a list of strings, where each string represents one operation (insert, search, erase) and, if applicable, the value to be inserted or searched for.",
    "output_format": "Return a list of boolean values for each search and erase operation, corresponding to whether the operation was successful or not.",
    "constraints": [
      "0 <= val <= 10^7",
      "The number of operations will not exceed 10^4."
    ],
    "examples": [
      {
        "input": [
          "insert(1)",
          "insert(2)",
          "search(1)",
          "search(3)",
          "erase(1)",
          "search(1)"
        ],
        "output": [
          null,
          null,
          true,
          false,
          true,
          false
        ],
        "explanation": "Initially, the skip list is empty. After inserting 1 and 2, searching for 1 returns true, searching for 3 returns false. Erasing 1 succeeds, thus searching for 1 afterwards returns false."
      },
      {
        "input": [
          "insert(5)",
          "insert(7)",
          "insert(8)",
          "erase(5)",
          "search(5)",
          "search(7)"
        ],
        "output": [
          null,
          null,
          null,
          true,
          false,
          true
        ],
        "explanation": "After inserting 5, 7, and 8, erasing 5 succeeds. Searching for 5 returns false while searching for 7 returns true."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to efficiently manage multiple layers in the skip list.",
      "Utilize randomization to build the skip list layers.",
      "Think about the time complexity for each operation."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Binary Gap",
    "description": "Given a positive integer n, return the length of the longest contiguous segment of 0's in the binary representation of n that is surrounded by 1's at both ends. If there are no such segments, return 0.",
    "topic": "Bit Manipulation",
    "subtopic": "Binary Representation",
    "tags": [
      "Bit Manipulation",
      "Binary",
      "Length"
    ],
    "input_format": "A single integer n (1 <= n <= 2^31 - 1).",
    "output_format": "An integer representing the length of the longest binary gap.",
    "constraints": [
      "1 <= n <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "n = 9",
        "output": "2",
        "explanation": "The binary representation of 9 is '1001'. The longest gap is '00', which has a length of 2."
      },
      {
        "input": "n = 20",
        "output": "1",
        "explanation": "The binary representation of 20 is '10100'. The longest gap is '0', which has a length of 1."
      },
      {
        "input": "n = 15",
        "output": "0",
        "explanation": "The binary representation of 15 is '1111'. There are no gaps between 1's."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use bit manipulation to obtain the binary representation.",
      "Count the contiguous 0's between 1's."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Minimum Window Subsequence",
    "description": "Given two strings S and T, return the minimum window (substring) in S containing all the characters of T in the same order. If there is no such substring, return an empty string. The characters of T must appear in S in the same order, but they do not have to be contiguous. If there are multiple minimum windows, return the one with the smallest starting index. If two windows' starting indices are the same, return the one that is shorter.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Two Pointers"
    ],
    "input_format": "Two strings S and T, where 1 <= S.length, T.length <= 1000.",
    "output_format": "A string representing the minimum window in S containing all characters of T in order, or an empty string if no such window exists.",
    "constraints": [
      "1 <= S.length, T.length <= 1000",
      "S and T consist of English letters, digits, and symbols."
    ],
    "examples": [
      {
        "input": "S = 'abcdebdde', T = 'bde'",
        "output": "'bdde'",
        "explanation": "The smallest substring of S containing all characters of T in order is 'bdde'."
      },
      {
        "input": "S = 'abc', T = 'c'",
        "output": "'c'",
        "explanation": "The substring 'c' is the minimum window that contains 'c'."
      },
      {
        "input": "S = 'a', T = 'aa'",
        "output": "''",
        "explanation": "There is no valid window in S that can contain T."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use two pointers to track the characters.",
      "Consider using a hashmap to keep count.",
      "Expand and contract the window to find the solution."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Alternating Digit Sum",
    "description": "Given a positive integer n, return the alternating sum of its digits. The alternating sum is defined as the sum of the digits at odd indices minus the sum of the digits at even indices, considering the first index as odd (1-based). For example, for n = 4321, the alternating sum would be 4 - 3 + 2 - 1 = 2.",
    "topic": "Mathematics",
    "subtopic": "Digit Manipulation",
    "tags": [
      "Math",
      "Digits",
      "Alternating Sum"
    ],
    "input_format": "A single positive integer n.",
    "output_format": "An integer representing the alternating digit sum.",
    "constraints": [
      "1 <= n <= 10^9"
    ],
    "examples": [
      {
        "input": "n = 1234",
        "output": "2",
        "explanation": "The alternating sum is 1 - 2 + 3 - 4 = -2."
      },
      {
        "input": "n = 4321",
        "output": "2",
        "explanation": "The alternating sum is 4 - 3 + 2 - 1 = 2."
      },
      {
        "input": "n = 10001",
        "output": "2",
        "explanation": "The alternating sum is 1 - 0 + 0 - 0 + 1 = 2."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how to separate the digits of the number.",
      "Use a loop to iterate through the digits of the number.",
      "Keep track of whether the index is odd or even."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Subtree of Another Tree",
    "description": "Given two binary trees, `root` and `subRoot`, determine if `subRoot` is a subtree of `root`. A subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Subtree"
    ],
    "input_format": "Two binary tree nodes, root and subRoot.",
    "output_format": "A boolean value indicating whether subRoot is a subtree of root.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root = [3,4,5,1,2], subRoot = [4,1,2]",
        "output": "true",
        "explanation": "The subtree with root 4 in the tree root matches the entire tree subRoot."
      },
      {
        "input": "root = [3,4,5,1,2,null,null,0], subRoot = [4,1,0]",
        "output": "false",
        "explanation": "The subtree with root 4 in the tree root does not match the entire tree subRoot."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Check if the current node matches the subtree's root.",
      "Use a helper function to check if two trees are identical."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Minimize Maximum Pair Sum in Array",
    "description": "Given an array of integers, you need to pair the numbers such that the maximum sum of each pair is minimized. A pair is formed by selecting two numbers from the array and calculating their sum. Your goal is to find the minimum possible value of the maximum pair sum, by optimally pairing the elements of the array.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Greedy"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the minimized maximum pair sum.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3, 5, 2, 3]",
        "output": "6",
        "explanation": "The pairs can be (2, 5) and (3, 3). The maximum pair sums are 7 and 6. Thus, the minimum possible value of the maximum pair sum is 6."
      },
      {
        "input": "nums = [1, 4, 3, 2]",
        "output": "4",
        "explanation": "The optimal pairs are (1, 4) and (2, 3), with maximum sums of 5 and 5, hence the minimized maximum pair sum is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array to facilitate pairing.",
      "Pair the largest number with the smallest number."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Remove One Element to Make the Array Strictly Increasing",
    "description": "Given an integer array nums, you can remove one element to make the array strictly increasing. An array is considered strictly increasing if nums[i] < nums[i + 1] for all valid i. Return true if you can make the array strictly increasing by removing one element, or false otherwise.",
    "topic": "Array",
    "subtopic": "Validation and Modification",
    "tags": [
      "Array",
      "Greedy",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A boolean value indicating whether it's possible to make the array strictly increasing by removing one element.",
    "constraints": [
      "1 <= nums.length <= 100",
      "-100 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5]",
        "output": "true",
        "explanation": "The array is already strictly increasing, so we can remove any element and it will remain strictly increasing."
      },
      {
        "input": "nums = [1, 5, 3, 4, 2]",
        "output": "false",
        "explanation": "Removing any single element will not make the array strictly increasing."
      },
      {
        "input": "nums = [1, 2, 5, 3, 4]",
        "output": "true",
        "explanation": "By removing the element '5', the array becomes [1, 2, 3, 4], which is strictly increasing."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider situations where the current element is not less than the next.",
      "Keep track of how many removals you need to make.",
      "Check the elements carefully to identify points of failure."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "Grid"
    ],
    "input_format": "A 2D binary grid represented as a list of lists.",
    "output_format": "An integer representing the number of islands.",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[i].length <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "grid = [['1','1','1','1','0'], ['1','1','0','1','0'], ['1','1','0','0','0'], ['0','0','0','0','0']]",
        "output": "1",
        "explanation": "There is one island formed by the land in the grid."
      },
      {
        "input": "grid = [['1','1','0','0','0'], ['1','1','0','0','0'], ['0','0','1','0','0'], ['0','0','0','1','1']]",
        "output": "3",
        "explanation": "There are three distinct islands in the grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use Depth-First Search to explore each land.",
      "Mark visited land cells to avoid counting them multiple times."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Word Ladder",
    "description": "Given two words, beginWord and endWord, and a dictionary's word list, find the length of the shortest transformation sequence from beginWord to endWord, such that only one letter can be changed at a time and each transformed word must exist in the word list. Note that beginWord is not a part of the word list. If there is no such transformation sequence, return 0.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "Graph",
      "BFS",
      "String"
    ],
    "input_format": "A string beginWord, a string endWord, and a list of strings wordList.",
    "output_format": "An integer representing the length of the shortest transformation sequence. Return 0 if no such sequence exists.",
    "constraints": [
      "1 <= beginWord.length <= 10",
      "1 <= endWord.length <= 10",
      "1 <= wordList.length <= 5000",
      "beginWord and endWord consist of lowercase letters.",
      "All the words in the wordList are unique."
    ],
    "examples": [
      {
        "input": {
          "beginWord": "hit",
          "endWord": "cog",
          "wordList": [
            "hot",
            "dot",
            "dog",
            "lot",
            "log",
            "cog"
          ]
        },
        "output": "5",
        "explanation": "The shortest transformation sequence is 'hit' -> 'hot' -> 'dot' -> 'dog' -> 'cog', which has a length of 5."
      },
      {
        "input": {
          "beginWord": "hit",
          "endWord": "cog",
          "wordList": [
            "hot",
            "dot",
            "dog",
            "lot",
            "log"
          ]
        },
        "output": "0",
        "explanation": "The endWord 'cog' is not in the wordList, so there is no transformation."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use BFS for the shortest path.",
      "Consider using a queue to keep track of the current words and their transformation lengths.",
      "For each word, generate all possible transformations."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Move Zeroes",
    "description": "Given an integer array nums, you must move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array.",
    "topic": "Array",
    "subtopic": "In-place Manipulation",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An integer array nums.",
    "output_format": "The modified array nums with all 0's moved to the end.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-2 * 10^9 <= nums[i] <= 2 * 10^9"
    ],
    "examples": [
      {
        "input": "nums = [0, 1, 0, 3, 12]",
        "output": "[1, 3, 12, 0, 0]",
        "explanation": "The non-zero elements are moved to the front maintaining their order, and all zeroes are moved to the end."
      },
      {
        "input": "nums = [0]",
        "output": "[0]",
        "explanation": "There is only one element, which is 0, so the output remains the same."
      },
      {
        "input": "nums = [1, 0, 2, 0, 3]",
        "output": "[1, 2, 3, 0, 0]",
        "explanation": "The non-zero elements are 1, 2, 3 moved to the front with the zeroes at the end."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers to track the current position of non-zero elements."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Course Schedule II",
    "description": "There are `n` courses you have to take, labeled from `0` to `n-1`. Some courses may have prerequisites, represented as pairs of courses. You need to determine the order in which you should take the courses to complete all of them. If it is impossible to finish all courses, return an empty list. Otherwise, return a list of the ordering of courses. The ordering should be such that for every pair (a, b), if course a is a prerequisite of course b, then a appears before b in the list.",
    "topic": "Graph",
    "subtopic": "Topological Sorting",
    "tags": [
      "Graph",
      "Topological Sort",
      "DFS",
      "BFS"
    ],
    "input_format": "An integer `n` representing the number of courses and a list of pairs `prerequisites` where each pair [a, b] indicates that course a must be taken before course b.",
    "output_format": "A list of integers representing the order of courses, or an empty list if it is impossible to finish all courses.",
    "constraints": [
      "1 <= n <= 2000",
      "0 <= prerequisites.length <= n * (n - 1) / 2",
      "prerequisites[i].length == 2"
    ],
    "examples": [
      {
        "input": {
          "n": 4,
          "prerequisites": [
            [
              1,
              0
            ],
            [
              2,
              1
            ],
            [
              3,
              2
            ]
          ]
        },
        "output": [
          0,
          1,
          2,
          3
        ],
        "explanation": "You can take course 0 first, then course 1, followed by course 2, and finally course 3."
      },
      {
        "input": {
          "n": 2,
          "prerequisites": [
            [
              1,
              0
            ],
            [
              0,
              1
            ]
          ]
        },
        "output": [],
        "explanation": "There is a cycle between courses 0 and 1, making it impossible to finish all courses."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use Kahn's algorithm or depth-first search to implement topological sorting.",
      "Keep track of in-degrees of each course to help manage dependencies."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order. The spiral order is defined as traversing the matrix in a circular pattern, starting from the top-left corner and moving right, then down, left, and up, repeatedly until all elements have been included.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral"
    ],
    "input_format": "A 2D list of integers representing the matrix.",
    "output_format": "A list of integers representing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "The total number of elements in the matrix will not exceed 10^4."
    ],
    "examples": [
      {
        "input": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The spiral order traverses the matrix starting from 1, moving right to 3, then down to 6, and so on until all elements are collected."
      },
      {
        "input": "[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]",
        "output": "[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]",
        "explanation": "The traversal starts at 1 and ends at 7, collecting elements in a spiral manner."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider four boundaries: top, bottom, left, and right.",
      "Iteratively reduce the boundaries as you traverse the matrix."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Open the Lock",
    "description": "You have a lock that has a 4-digit combination, represented as a string of four digits. Each digit can be from '0' to '9'. The problem requires you to determine the minimum number of turns to open the lock from a given initial combination to a target combination. You can turn each digit of the lock either up or down, with each turn increasing or decreasing the value of the digit by one. Once you reach the target combination, the lock opens. You are also given a list of invalid combinations that you cannot use. Compute the minimum number of turns required to unlock the lock, or return -1 if it is not possible.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "String"
    ],
    "input_format": "A string `deadends` representing invalid combinations, a string `target` representing the target combination.",
    "output_format": "An integer representing the minimum number of turns to open the lock, or -1 if it is not possible.",
    "constraints": [
      "target.length == 4",
      "target[i] is a digit from '0' to '9'",
      "1 <= deadends.length <= 100",
      "Each item in deadends is a 4-digit combination"
    ],
    "examples": [
      {
        "input": {
          "deadends": [
            "0201",
            "0101",
            "0102",
            "1212",
            "2002"
          ],
          "target": "0202"
        },
        "output": "6",
        "explanation": "Starting from '0000', the quickest path is: 0000 -> 0001 -> 0002 -> 0012 -> 0022 -> 0202, which takes 6 turns."
      },
      {
        "input": {
          "deadends": [
            "8888"
          ],
          "target": "0009"
        },
        "output": "1",
        "explanation": "From '0000' to '0009', only 1 turn is needed. However, since '8888' is a deadend, we ignore it."
      },
      {
        "input": {
          "deadends": [
            "0000"
          ],
          "target": "8888"
        },
        "output": "-1",
        "explanation": "Starting at '0000' cannot reach any other combinations because it is a deadend."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use BFS to explore all possible combinations.",
      "Track visited combinations to avoid cycles."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Return a list of groups of anagrams, where each group is represented as a list of strings.",
    "topic": "String",
    "subtopic": "Grouping",
    "tags": [
      "String",
      "Hashing",
      "Sorting"
    ],
    "input_format": "An array of strings, words[].",
    "output_format": "A list of lists, where each list contains grouped anagrams.",
    "constraints": [
      "1 <= words.length <= 10^4",
      "1 <= words[i].length <= 100",
      "All input strings are in lowercase."
    ],
    "examples": [
      {
        "input": "words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
        "output": "[[\"bat\"], [\"nat\", \"tan\"], [\"ate\", \"eat\", \"tea\"]]",
        "explanation": "The anagrams in the input list form separate groups. 'bat' is alone, 'nat' and 'tan' are anagrams, and 'eat', 'tea', and 'ate' are also anagrams."
      },
      {
        "input": "words = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "There is only one empty string, and it forms a group by itself."
      },
      {
        "input": "words = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "The single character 'a' forms a group by itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use sorting to identify anagrams.",
      "Consider using a hash map to group sorted words."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Binary Tree Zigzag Level Order Traversal",
    "description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "BFS",
      "Binary Tree"
    ],
    "input_format": "The input consists of a binary tree represented by its root node.",
    "output_format": "A list of lists of integers representing the zigzag level order traversal.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[20,9],[15,7]]",
        "explanation": "The first level is just the root node, which is 3. The second level contains nodes 9 and 20, and we traverse it from right to left so it becomes 20, 9. The third level contains 15 and 7, traversed from left to right."
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": "There is only one node, so the zigzag level order is just [[1]]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to perform level order traversal.",
      "Keep track of the current level's order using a boolean flag.",
      "Reverse the level's values before adding to the result."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Word Search II",
    "description": "Given a 2D board and a list of words, you need to return all the words in the list that can be found in the board. Each word must be constructed from letters of sequentially adjacent cells, where 'adjacent' cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in the word search. A word can be constructed from the letters of the cells in the grid if you can trace a path to each letter in the word from a starting cell.",
    "topic": "Backtracking",
    "subtopic": "Trie and Search",
    "tags": [
      "Backtracking",
      "Trie",
      "Search",
      "Grid"
    ],
    "input_format": "A 2D character array board representing the grid, and a list of strings words representing the words to search.",
    "output_format": "A list of strings containing all the words that can be found in the board.",
    "constraints": [
      "1 <= board.length, board[i].length <= 200",
      "1 <= words.length <= 10^4",
      "1 <= words[i].length <= 8",
      "Each word in words is unique.",
      "board[i][j] is a lowercase English letter."
    ],
    "examples": [
      {
        "input": {
          "board": [
            [
              "o",
              "a",
              "a",
              "n"
            ],
            [
              "e",
              "t",
              "a",
              "e"
            ],
            [
              "i",
              "h",
              "k",
              "r"
            ],
            [
              "i",
              "f",
              "l",
              "v"
            ]
          ],
          "words": [
            "oath",
            "pea",
            "eat",
            "rain"
          ]
        },
        "output": [
          "eat",
          "oath"
        ],
        "explanation": "The word 'eat' can be formed by the path 'e' -> 'a' -> 't' in the board. The word 'oath' can be formed by 'o' -> 'a' -> 't' -> 'h'."
      },
      {
        "input": {
          "board": [
            [
              "a",
              "b"
            ],
            [
              "c",
              "d"
            ]
          ],
          "words": [
            "abcd"
          ]
        },
        "output": [],
        "explanation": "The word 'abcd' cannot be formed since it's not possible to traverse the board in that order."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a Trie to store the words.",
      "Use backtracking to explore possible paths on the board.",
      "Keep track of visited cells to avoid using the same cell multiple times."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if the brackets are closed in the correct order. Every opening bracket must have a corresponding closing bracket of the same type.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A string s consisting of characters '(', ')', '{', '}', '[' and ']' representing the parentheses.",
    "output_format": "A boolean indicating whether the input string is valid.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses only."
    ],
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true",
        "explanation": "The parentheses are properly closed."
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true",
        "explanation": "All brackets are closed in the correct order."
      },
      {
        "input": "s = \"(]\"",
        "output": "false",
        "explanation": "The parentheses are not of the same type."
      },
      {
        "input": "s = \"([)]\"",
        "output": "false",
        "explanation": "The brackets are closed in the wrong order."
      },
      {
        "input": "s = \"{[]}\"",
        "output": "true",
        "explanation": "The input string is valid with all brackets properly closed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "Check for matching pairs when encountering closing brackets."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters. A substring is a contiguous sequence of characters within the string.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Substring"
    ],
    "input_format": "A string s consisting of characters.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 10^5",
      "s consists of English letters, digits, symbols, and spaces."
    ],
    "examples": [
      {
        "input": "s = 'abcabcbb'",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'abc', which has a length of 3."
      },
      {
        "input": "s = 'bbbbb'",
        "output": "1",
        "explanation": "The longest substring without repeating characters is 'b', which has a length of 1."
      },
      {
        "input": "s = 'pwwkew'",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'wke', which has a length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window technique to track the characters.",
      "Utilize a set or a hash map to remember characters in the current substring."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit",
    "description": "Given an integer array nums and an integer limit, return the length of the longest continuous subarray such that the absolute difference between the maximum and minimum numbers in the subarray is less than or equal to limit.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums, and an integer limit.",
    "output_format": "An integer representing the length of the longest continuous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5",
      "0 <= limit <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [8, 2, 4, 7], limit = 4",
        "output": "4",
        "explanation": "The longest subarray is [8, 2, 4, 7] with max of 8 and min of 2, and |8 - 2| = 6 which is not <= 4. The valid subarrays are [2, 4], [4, 7] with lengths 2 each. The longest valid subarray with an absolute difference <= 4 is [2, 4] or [4, 7] which have a length of 2."
      },
      {
        "input": "nums = [10, 1, 2, 4, 7, 2], limit = 5",
        "output": "4",
        "explanation": "The longest subarray is [1, 2, 4, 7] which has max of 7 and min of 1, and |7 - 1| = 6, which is not valid. The longest valid subarray with an absolute difference <= 5 is [2, 4, 7] with a length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sliding window approach.",
      "Keep track of the maximum and minimum values in the current window."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Reconstruct Itinerary",
    "description": "Given a list of airline tickets represented by pairs of departure and arrival airports, reconstruct the itinerary in order, starting from 'JFK'. Each ticket can only be used once, and the itinerary must visit all the airports in the order defined by the tickets. The solution must return the reconstructed itinerary as a list of airports in the order they are visited.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "Backtracking"
    ],
    "input_format": "A list of pairs of strings representing the tickets, where each pair contains a departure and an arrival airport.",
    "output_format": "A list of strings representing the reconstructed itinerary in order.",
    "constraints": [
      "1 <= tickets.length <= 3000",
      "All airport codes are 3 uppercase English letters."
    ],
    "examples": [
      {
        "input": "[['MUC', 'LHR'], ['JFK', 'MUC'], ['SFO', 'SJC'], ['LHR', 'SFO'], ['JFK', 'ATL'], ['ATL', 'JFK']]",
        "output": "['JFK', 'ATL', 'JFK', 'MUC', 'LHR', 'SFO', 'SJC']",
        "explanation": "The itinerary starts at 'JFK' and follows the direct flights to 'ATL', returning back to 'JFK', then to 'MUC', 'LHR', 'SFO', and finally 'SJC'."
      },
      {
        "input": "[['JFK', 'SFO'], ['SFO', 'JFK'], ['JFK', 'ATL']]",
        "output": "['JFK', 'ATL', 'JFK', 'SFO', 'JFK']",
        "explanation": "Starting from 'JFK', it goes to 'ATL', then back to 'JFK', and then to 'SFO'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a graph to represent the tickets and their connections.",
      "Consider using a priority queue to maintain the order of departure airports.",
      "Perform a Depth-First Search (DFS) to explore the paths.",
      "Backtrack if you cannot complete an itinerary."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Course Schedule",
    "description": "You are given a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, i.e., prerequisite[i] = [a, b] indicates that to take course b, you must first take course a. Determine if you can finish all courses. Return true if it is possible to finish all courses and false otherwise.",
    "topic": "Graph",
    "subtopic": "Topological Sort",
    "tags": [
      "Graph",
      "Topological Sort",
      "Depth-First Search"
    ],
    "input_format": "An integer n representing the number of courses, followed by a list of prerequisites where prerequisites[i] = [a, b] means to take course b you must complete course a first.",
    "output_format": "A boolean value, true if all courses can be finished, false otherwise.",
    "constraints": [
      "1 <= n <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= a, b < n"
    ],
    "examples": [
      {
        "input": "n = 2, prerequisites = [[1, 0]]",
        "output": "true",
        "explanation": "You can take course 0, then take course 1."
      },
      {
        "input": "n = 2, prerequisites = [[1, 0], [0, 1]]",
        "output": "false",
        "explanation": "You cannot take course 0 before taking course 1 and vice versa."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a graph to represent courses and their prerequisites.",
      "Track the number of incoming edges for each node.",
      "Use a queue to perform topological sorting."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Meeting Rooms II",
    "description": "Given an array of meeting time intervals where each interval consists of a start and end time, you need to determine the minimum number of conference rooms required to hold all the meetings without overlap. Each meeting can be represented as an interval [start, end].",
    "topic": "Array",
    "subtopic": "Interval Scheduling",
    "tags": [
      "Array",
      "Greedy",
      "Sorting"
    ],
    "input_format": "A list of intervals where each interval is represented as a list of two integers [start, end].",
    "output_format": "An integer representing the minimum number of conference rooms required.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "0 <= intervals[i][0] < intervals[i][1] <= 10^6"
    ],
    "examples": [
      {
        "input": "intervals = [[0, 30], [5, 10], [15, 20]]",
        "output": "2",
        "explanation": "The meetings [0,30] and [5,10] overlap, requiring at least 2 rooms."
      },
      {
        "input": "intervals = [[7, 10], [2, 4]]",
        "output": "1",
        "explanation": "The meetings do not overlap, only 1 room is needed."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the intervals by start time.",
      "Use a min-heap to track the end times of the meetings."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Kth Largest Element in an Array",
    "description": "Given an integer array nums and an integer k, return the k-th largest element in the array. Note that it is the k-th largest element in the sorted order, not the k-th distinct element. You must solve it in O(n log n) time complexity or better.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Heap",
      "Divide and Conquer"
    ],
    "input_format": "An integer array nums followed by an integer k.",
    "output_format": "An integer representing the k-th largest element in the array.",
    "constraints": [
      "1 <= k <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 1, 5, 6, 4], k = 2",
        "output": "5",
        "explanation": "The second largest element in the sorted array [1, 2, 3, 4, 5, 6] is 5."
      },
      {
        "input": "nums = [3, 2, 3, 1, 2, 4, 5, 5, 6], k = 4",
        "output": "4",
        "explanation": "The fourth largest element in the sorted array [1, 2, 2, 3, 3, 4, 5, 5, 6] is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a max heap or a min heap to find the k-th largest element efficiently.",
      "You can also sort the array and directly access the k-th largest element."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Longest ZigZag Path in a Binary Tree",
    "description": "Given the root of a binary tree, return the length of the longest ZigZag path from the root down to any leaf node. A ZigZag path for a binary tree is defined as starting at any node and alternating directions each time a node is visited. The length of a ZigZag path is the number of edges traversed. Note that a path can be of length 0 if the node is a leaf.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth First Search"
    ],
    "input_format": "The input consists of the root of a binary tree, represented as a node object with the attributes `val`, `left`, and `right`.",
    "output_format": "An integer representing the length of the longest ZigZag path.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1, 1, 1, null, 1, null, null]",
        "output": "3",
        "explanation": "The longest ZigZag path is from the root to the leaf node 1, with edges traversed in alternating directions."
      },
      {
        "input": "root = [1, null, 1, 1, null, 1, null]",
        "output": "4",
        "explanation": "The longest ZigZag path goes from the root 1 -> right 1 -> left 1 -> right 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "You can use Depth First Search (DFS) to explore the ZigZag paths.",
      "Keep track of the current direction and length as you traverse."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Pow(x, n)",
    "description": "Implement a function that calculates x raised to the power n, where x is a floating-point number and n is an integer. The function should handle both positive and negative integer exponents and should optimize for performance by reducing the number of multiplications, leveraging the properties of powers.",
    "topic": "Mathematics",
    "subtopic": "Exponentiation",
    "tags": [
      "Math",
      "Recursion",
      "Exponents"
    ],
    "input_format": "Two values, a floating-point number x and an integer n.",
    "output_format": "A floating-point number representing x raised to the power of n.",
    "constraints": [
      "-10^4 <= x <= 10^4",
      "-2^31 <= n <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 2.00000, n = 10",
        "output": "1024.00000",
        "explanation": "2 raised to the power of 10 is 1024."
      },
      {
        "input": "x = 2.10000, n = 3",
        "output": "9.26100",
        "explanation": "2.1 raised to the power of 3 is approximately 9.261."
      },
      {
        "input": "x = 2.00000, n = -2",
        "output": "0.25000",
        "explanation": "2 raised to the power of -2 is 1/(2^2) = 1/4 = 0.25."
      },
      {
        "input": "x = 0.00001, n = 3",
        "output": "1.00000e-15",
        "explanation": "0.00001 raised to the power of 3 is approximately 0.000000000001."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion to divide and conquer.",
      "Handle the case when n is negative separately.",
      "Utilize the property of exponents: x^n = (x^(n/2))^2 if n is even."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Rotting Oranges",
    "description": "You are given a grid of `m x n` cells where each cell can have one of three values: 0 (empty cell), 1 (fresh orange), or 2 (rotten orange). Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no fresh oranges remain. If it is impossible to rot all the fresh oranges, return -1.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "BFS",
      "Graph",
      "Matrix"
    ],
    "input_format": "A 2D grid represented as a list of lists of integers.",
    "output_format": "An integer representing the minimum number of minutes until no fresh oranges remain, or -1 if not possible.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "m * n <= 10^4",
      "grid[i][j] is either 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
        "output": "4",
        "explanation": "In the first minute, the rotten oranges can affect their adjacent fresh ones. The process continues until all fresh oranges are rotten."
      },
      {
        "input": "grid = [[2,1,1],[0,1,1],[1,0,2]]",
        "output": "-1",
        "explanation": "There is a fresh orange that cannot reach any rotten oranges."
      },
      {
        "input": "grid = [[0,2]]",
        "output": "0",
        "explanation": "There are no fresh oranges, so the result is 0 minutes."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a BFS approach to explore the grid.",
      "Track the time taken in each step of the BFS.",
      "A deque can be helpful for efficiently popping from the front."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Generate Parentheses",
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
    "topic": "Backtracking",
    "subtopic": "Combination Generation",
    "tags": [
      "Backtracking",
      "Combinations",
      "String"
    ],
    "input_format": "An integer n representing the number of pairs of parentheses.",
    "output_format": "A list of strings, where each string represents a valid combination of parentheses.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]",
        "explanation": "With 3 pairs of parentheses, the valid combinations are as listed."
      },
      {
        "input": "n = 1",
        "output": "[\"()\"]",
        "explanation": "With 1 pair of parentheses, the only valid combination is \"()\"."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about using recursion to build the parentheses.",
      "Track the number of open and close parentheses used."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Concatenated Words",
    "description": "Given a list of words, find all the words in the list that can be formed by concatenating two or more words from the same list. For example, if the list contains 'cat', 'dog', and 'catdog', then 'catdog' is a concatenated word because it is formed by 'cat' + 'dog'.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Dynamic Programming",
      "Trie"
    ],
    "input_format": "An array of strings words, where 1 <= words.length <= 10^4 and 1 <= words[i].length <= 100.",
    "output_format": "An array of strings representing the concatenated words from the input list.",
    "constraints": [
      "1 <= words.length <= 10^4",
      "1 <= words[i].length <= 100"
    ],
    "examples": [
      {
        "input": "words = [\"cat\", \"cats\", \"dog\", \"catsdogcats\"]",
        "output": "[\"catsdogcats\"]",
        "explanation": "\"catsdogcats\" can be formed by concatenating \"cats\" and \"dog\"."
      },
      {
        "input": "words = [\"dog\", \"dogwalker\", \"walker\", \"dogwalkerwalker\"]",
        "output": "[\"dogwalkerwalker\"]",
        "explanation": "\"dogwalkerwalker\" can be formed by concatenating \"dogwalker\" and \"walker\"."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a set for efficient lookup of words.",
      "Consider trying a DFS approach to check if a word can be segmented into valid words.",
      "Using a Trie can help in efficient prefix checking."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Decode String",
    "description": "Given an encoded string, return its decoded form. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. You may assume that the input string is always valid. No extra spaces are present in the input. Each number will be between 1 and 100.",
    "topic": "String",
    "subtopic": "Decoding",
    "tags": [
      "String",
      "Decoding",
      "Stack"
    ],
    "input_format": "A string s representing the encoded string to decode.",
    "output_format": "A string representing the decoded version of the input string.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of digits, lower-case English letters, and square brackets."
    ],
    "examples": [
      {
        "input": "s = \"3[a2[c]]\"",
        "output": "accaccacc",
        "explanation": "This string means 'a' repeated 2 times is 'ac', and that repeated 3 times is 'accaccacc'."
      },
      {
        "input": "s = \"2[abc]3[cd]ef\"",
        "output": "abcabccdcdcdef",
        "explanation": "This means 'abc' repeated 2 times, 'cd' repeated 3 times, followed by 'ef'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to keep track of the characters and numbers.",
      "Be careful to handle nested structures."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock II",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. However, you are allowed to buy and sell the stock multiple times. You need to implement a function that returns the maximum profit you can achieve while following these rules.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Greedy",
      "Dynamic Programming",
      "Array"
    ],
    "input_format": "An array of integers prices representing the stock prices on different days.",
    "output_format": "An integer representing the maximum profit you can achieve.",
    "constraints": [
      "1 <= prices.length <= 3 * 10^4",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "7",
        "explanation": "Buy on day 2 (price = 1) and sell on day 3 (price = 5). Then buy on day 4 (price = 3) and sell on day 5 (price = 6). The total profit is (5 - 1) + (6 - 3) = 7."
      },
      {
        "input": "prices = [1, 2, 3, 4, 5]",
        "output": "4",
        "explanation": "Buy on day 1 (price = 1) and sell on day 5 (price = 5). The total profit is 5 - 1 = 4."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "There is no transaction that can be done, as prices are continuously decreasing."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to buy on a day when the price is lower than the next day's price.",
      "Take advantage of local minima and maxima."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Binary Search Tree to Greater Sum Tree",
    "description": "Given a binary search tree (BST), convert it to a Greater Sum Tree (GST) such that every key of the original tree is changed to the original key plus the sum of all keys greater than the original key. You need to return the root of the GST.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "The input consists of the root node of a binary search tree.",
    "output_format": "Return the root node of the modified greater sum tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "Each node's value is unique.",
      "-10^4 <= Node.val <= 10^4."
    ],
    "examples": [
      {
        "input": "root = [4, 1, 6, 0, 2, 5, 7, null, null, null, 3]",
        "output": "[30, 36, 21, 36, 35, 26, 15, null, null, null, 33]",
        "explanation": "The original BST has values 4, 1, 6, 0, 2, 5, 7. The Greater Sum Tree has values 30, 36, 21, 36, 35, 26, 15 respectively."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider traversing the tree in reverse in-order to accumulate sums.",
      "Use a running total to keep track of the accumulated sums."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "You are given an integer array nums sorted in ascending order, but then it is rotated at some pivot unknown to you beforehand. Write a function to search for a target value in the array. If the target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An integer representing the index of the target if found, otherwise -1.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "nums is guaranteed to be rotated at some pivot.",
      "All integers in nums are unique."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "The target 0 is located at index 4 in the rotated array."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "The target 3 is not present in the array, so the output is -1."
      },
      {
        "input": "nums = [1], target = 0",
        "output": "-1",
        "explanation": "The array has only one element and it does not match the target."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you can leverage the sorted properties of the array.",
      "Use binary search but adjust the conditions for determining which half to search."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Product of Array Except Self",
    "description": "Given an array of integers nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. You must solve it without using the division operator and in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Product",
    "tags": [
      "Array",
      "Product",
      "Prefix-Suffix"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An array of integers representing the product of array except self.",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-30 <= nums[i] <= 30"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "[24, 12, 8, 6]",
        "explanation": "The product of all elements except the first is 2 * 3 * 4 = 24. Similarly for others."
      },
      {
        "input": "nums = [-1, 1, 0, -3, 3]",
        "output": "[0, 0, 9, 0, 0]",
        "explanation": "For index 0, the product is 1 * 0 * -3 * 3 = 0 and so forth."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using two arrays to store prefix and suffix products.",
      "Try to compute the result in a single pass."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Find Peak Element",
    "description": "A peak element in an array is an element that is greater than or equal to its neighbors. Given an array of integers, you need to find any peak element in the array. If the array contains multiple peaks, you can return any of them. You may assume that the array is non-empty and the elements are integers.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Binary Search",
      "Peak Element"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing any peak element in the array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "3",
        "explanation": "The peak element is 3 since it is greater than its neighbors 2 and 1."
      },
      {
        "input": "nums = [1, 2, 1, 3, 5, 6, 4]",
        "output": "2 or 6",
        "explanation": "Both 2 and 6 are peak elements. 2 is greater than its neighbor 1, and 6 is greater than its neighbor 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a binary search approach to find a peak efficiently.",
      "A peak can be found at the boundaries of the array."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Set Matrix Zeroes",
    "description": "Given a m x n matrix, if an element is 0, set its entire row and column to 0. You must do this in place without using extra space for another matrix.",
    "topic": "Array",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Array",
      "Matrix",
      "In-place",
      "Zeroing"
    ],
    "input_format": "A 2D array of integers matrix of size m x n.",
    "output_format": "The modified matrix with the appropriate rows and columns set to zero.",
    "constraints": [
      "1 <= m, n <= 200",
      "-10^7 <= matrix[i][j] <= 10^7"
    ],
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": "The element at (1,1) is 0, so the entire second row and second column become zeros."
      },
      {
        "input": "matrix = [[0,1],[1,1]]",
        "output": "[[0,0],[0,1]]",
        "explanation": "The element at (0,0) is 0, so the entire first row and first column become zeros."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using the first row and column to track which rows and columns need to be zeroed.",
      "You can avoid using extra space by using the matrix itself."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Rank Teams by Votes",
    "description": "You are given a list of teams, each with its name and a string representing the votes it received. Each team can receive multiple votes, and each vote is represented by the team's name. Your task is to rank the teams based on the number of votes they received in descending order. If two teams receive the same number of votes, they should be ranked alphabetically by their names.",
    "topic": "Sorting",
    "subtopic": "Custom Sorting",
    "tags": [
      "Sorting",
      "Ranking",
      "String"
    ],
    "input_format": "A list of strings, where each string represents a team name that has received a vote.",
    "output_format": "A list of team names ranked by the number of votes they received, in descending order. If there is a tie, sort those teams alphabetically.",
    "constraints": [
      "1 <= votes.length <= 10^5",
      "1 <= votes[i].length <= 100",
      "All team names are unique and consist of only alphabetical characters."
    ],
    "examples": [
      {
        "input": "votes = [\"teamA\", \"teamB\", \"teamA\", \"teamC\", \"teamB\", \"teamB\"]",
        "output": "[\"teamB\", \"teamA\", \"teamC\"]",
        "explanation": "teamB has 3 votes, teamA has 2 votes, and teamC has 1 vote. Hence, the ranking is teamB, teamA, teamC."
      },
      {
        "input": "votes = [\"teamX\", \"teamY\", \"teamZ\", \"teamY\", \"teamX\"]",
        "output": "[\"teamX\", \"teamY\", \"teamZ\"]",
        "explanation": "teamX and teamY each have 2 votes. Since teamY comes alphabetically after teamX, the ranking is teamX, teamY, teamZ."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dictionary to count the votes for each team.",
      "Sort the dictionary by values in descending order and keys alphabetically."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix string among an array of strings. If there is no common prefix, return an empty string \"\". The function should compare prefixes character by character until a mismatch is found.",
    "topic": "String",
    "subtopic": "Prefix Matching",
    "tags": [
      "String",
      "Prefix",
      "Array"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A string representing the longest common prefix.",
    "constraints": [
      "0 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "All strings in strs consist of only lowercase letters a-z."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The longest common prefix is \"fl\"."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix, so the result is an empty string."
      },
      {
        "input": "strs = [\"\"]",
        "output": "\"\"",
        "explanation": "There is only one string which is empty."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Compare the first string with others character by character.",
      "Once a mismatch is found, return the common prefix found until that point."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Time Based Key-Value Store",
    "description": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps. It should allow the following operations: 'set' and 'get'. The 'set' operation stores a value associated with a key and a time stamp, while the 'get' operation returns the value of the key at the closest time stamp less than or equal to the given time. If there are no such values, return an empty string.",
    "topic": "Data Structure",
    "subtopic": "Hash Map",
    "tags": [
      "Design",
      "Hash Map",
      "Data Structure"
    ],
    "input_format": "You will implement the following two methods:\n  - `set(key: str, value: str, timestamp: int)`: stores the value at the given timestamp.\n  - `get(key: str, timestamp: int) -> str`: retrieves the value at the given timestamp, or an empty string if no such value exists.",
    "output_format": "The output of the 'get' method is a string representing the value at the requested timestamp or an empty string.",
    "constraints": [
      "All keys and values consist of lowercase alphabetical characters and have a length of at most 100.",
      "The timestamp is a positive integer less than or equal to 10^9.",
      "Set operations will be called at most 10^4 times.",
      "Get operations will be called at most 10^4 times."
    ],
    "examples": [
      {
        "input": "obj = TimeMap(); obj.set('foo', 'bar', 1); obj.get('foo', 1);",
        "output": "'bar'",
        "explanation": "The value associated with the key 'foo' at timestamp 1 is 'bar'."
      },
      {
        "input": "obj.set('foo', 'bar', 1); obj.get('foo', 3);",
        "output": "'bar'",
        "explanation": "The closest timestamp less than or equal to 3 is 1 where the value is 'bar'."
      },
      {
        "input": "obj.get('foo', 0);",
        "output": "''",
        "explanation": "There is no value associated with the key 'foo' at timestamp 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to store multiple timestamps for the same key.",
      "Use a sorted structure for efficiently retrieving values."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Design a Stack With Increment Operation",
    "description": "Design a stack that supports the following operations: push, pop, top, and an additional increment operation. The increment operation increments the bottom k elements of the stack by a given value. Implement the stack using an array-based approach. You need to handle edge cases and ensure the stack behaves according to the specified operations.",
    "topic": "Data Structures",
    "subtopic": "Stack",
    "tags": [
      "Stack",
      "Data Structure",
      "Design"
    ],
    "input_format": "A series of operations as strings, each operation can be one of 'push', 'pop', 'top', or 'increment k value'.",
    "output_format": "An array of results for the operations 'pop' and 'top'. If the operation is 'increment', return null. For other operations, return the corresponding value.",
    "constraints": [
      "The number of operations will not exceed 1000.",
      "0 <= k <= the size of the stack when performing the increment operation.",
      "1 <= value <= 10^5 for push operations."
    ],
    "examples": [
      {
        "input": [
          "push 1",
          "push 2",
          "push 3",
          "top",
          "increment 2 5",
          "pop",
          "top"
        ],
        "output": [
          "3",
          null,
          "7"
        ],
        "explanation": "After pushing 1, 2, and 3, the top is 3. The increment operation increments the bottom 2 elements (1 and 2) by 5. Then pop returns 3, while the new top is now 7."
      },
      {
        "input": [
          "push 1",
          "push 2",
          "increment 1 1",
          "pop",
          "top"
        ],
        "output": [
          null,
          "3"
        ],
        "explanation": "Incrementing the first element by 1 makes it 2. Popping returns the current top 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using an array to implement the stack.",
      "Keep track of the size of the stack for the increment operation.",
      "Think about the time complexity for each operation."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Valid Palindrome II",
    "description": "Given a string s, you can delete at most one character from it. Check if you can make it a palindrome. A palindrome is a string that reads the same forward and backward.",
    "topic": "String",
    "subtopic": "Two Pointers",
    "tags": [
      "String",
      "Palindrome",
      "Two Pointers"
    ],
    "input_format": "A string s (0 <= s.length <= 10^5).",
    "output_format": "A boolean value: return true if it can be a palindrome after deleting at most one character, otherwise return false.",
    "constraints": [
      "The input string will only contain lowercase letters and/or digits.",
      "0 <= s.length <= 10^5"
    ],
    "examples": [
      {
        "input": "s = \"aba\"",
        "output": "true",
        "explanation": "The string is already a palindrome."
      },
      {
        "input": "s = \"abca\"",
        "output": "true",
        "explanation": "Removing 'b' or 'c' can make the string a palindrome."
      },
      {
        "input": "s = \"abc\"",
        "output": "false",
        "explanation": "There is no single character deletion that can make this string a palindrome."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to compare characters from opposite ends.",
      "If a mismatch is found, try skipping one character and see if the rest is a palindrome."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Vertical Order Traversal of a Binary Tree",
    "description": "Given the root of a binary tree, return the vertical order traversal of its nodes' values. For each node at position (row, col), the position is defined by the following rules: \n- The position of the root node is (0, 0). \n- The position of a left child is (row + 1, col - 1) and the position of a right child is (row + 1, col + 1). \nNodes at the same position will be in the order they appear in the traversal (from top to bottom, then left to right). If two nodes are at the same positions, the node that appears first in the traversal must be ordered first in the output. \nReturn the vertical order traversal as a list of lists of integers.",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Binary Tree",
      "DFS",
      "BFS"
    ],
    "input_format": "A binary tree represented by its root node.",
    "output_format": "A list of lists of integers representing the vertical order traversal of the binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1,2,3,4,5,6,7]",
        "output": "[[4],[2],[1,5,6],[3],[7]]",
        "explanation": "The vertical order traversal returns nodes from left to right across the verticals."
      },
      {
        "input": "root = [3,9,8,4,0,1,7]",
        "output": "[[4],[9],[3,0,1],[8],[7]]",
        "explanation": "The nodes are arranged in vertical columns, with nodes from the same column ordered top to bottom."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a map to keep track of the nodes' positions.",
      "Sort the columns before generating the output.",
      "Use BFS or DFS to traverse the tree and record the positions."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Nearest Exit from Entrance in Maze",
    "description": "You are given an m x n grid representing a maze, where '0' represents an open cell and '1' represents a wall. You are also given the entrance of the maze, represented as coordinates (startRow, startCol). Your task is to find the shortest distance from the entrance to the nearest exit. An exit is defined as any cell located on the border of the maze (i.e., any cell in the first row, last row, first column, or last column). You cannot enter a cell with a wall ('1') and can move in four directions: up, down, left, and right. Return the distance to the nearest exit, or -1 if there is no exit reachable from the entrance.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "Graph",
      "BFS",
      "Matrix"
    ],
    "input_format": "A 2D grid of integers representing the maze and two integers for the entrance coordinates (startRow, startCol).",
    "output_format": "An integer representing the shortest distance to the nearest exit, or -1 if no exit is reachable.",
    "constraints": [
      "1 <= m, n <= 100",
      "maze[i][j] is either 0 (open cell) or 1 (wall)",
      "The entrance will always be an open cell and will not be on the border."
    ],
    "examples": [
      {
        "input": "maze = [[0,0,0],[1,0,1],[0,0,0]], startRow = 1, startCol = 1",
        "output": "2",
        "explanation": "The nearest exit is at (0,0) or (2,0), both are 2 steps away."
      },
      {
        "input": "maze = [[0,0,0],[0,1,0],[0,0,0]], startRow = 0, startCol = 1",
        "output": "3",
        "explanation": "Moving to (0,0) then to (1,0) and finally to (2,0)."
      },
      {
        "input": "maze = [[1]], startRow = 0, startCol = 0",
        "output": "-1",
        "explanation": "There are no exits as the only cell is a wall."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use BFS for finding the shortest path.",
      "Track the visited cells to avoid cycles."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Minimum Path Sum",
    "description": "Given a m x n grid filled with non-negative numbers, find a path from the top left to the bottom right, which minimizes the sum of the numbers along the path. You can only move either down or right at any point in time.",
    "topic": "Dynamic Programming",
    "subtopic": "Pathfinding",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Pathfinding"
    ],
    "input_format": "A 2D list of integers grid representing the m x n grid.",
    "output_format": "An integer representing the minimum path sum.",
    "constraints": [
      "1 <= m, n <= 100",
      "0 <= grid[i][j] <= 100"
    ],
    "examples": [
      {
        "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7",
        "explanation": "The path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum to 7."
      },
      {
        "input": "grid = [[1,2,3],[4,5,6]]",
        "output": "12",
        "explanation": "The path 1 \u2192 2 \u2192 3 \u2192 6 minimizes the sum to 12."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use dynamic programming to store intermediate results.",
      "Start from the top-left corner and build up to the bottom-right corner."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an array of integers nums, return all the unique triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointer Technique",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A list of unique triplets that sum to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that sum to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no triplets possible in an empty array."
      },
      {
        "input": "nums = [0, 1, 1]",
        "output": "[]",
        "explanation": "No triplet sums to zero in this input."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array to handle duplicates more easily.",
      "Use a two-pointer approach to find pairs that sum to a target."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Isomorphic Strings",
    "description": "Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must map to the same character while no two characters may map to the same character.",
    "topic": "String Manipulation",
    "subtopic": "Character Mapping",
    "tags": [
      "String",
      "Isomorphic",
      "Mapping"
    ],
    "input_format": "Two strings s and t, each with lengths up to 10^5.",
    "output_format": "A boolean value: true if the strings are isomorphic, otherwise false.",
    "constraints": [
      "0 <= s.length, t.length <= 10^5",
      "s and t consist of any printable ASCII characters."
    ],
    "examples": [
      {
        "input": "s = \"egg\", t = \"add\"",
        "output": "true",
        "explanation": "The character 'e' maps to 'a' and 'g' maps to 'd'."
      },
      {
        "input": "s = \"foo\", t = \"add\"",
        "output": "false",
        "explanation": "The character 'o' cannot map to both 'd' and 'a'."
      },
      {
        "input": "s = \"paper\", t = \"title\"",
        "output": "true",
        "explanation": "The character 'p' maps to 't', 'a' to 'i', 'p' to 't', 'e' to 'l', and 'r' to 'e'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two hash maps to track the mapping of characters from s to t and from t to s.",
      "Check if a character is already mapped before creating a new mapping."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Integer to English Words",
    "description": "Convert a non-negative integer into its English words representation. Given a number in the range [0, 231 - 1], return its corresponding English words. For example, 123 should be converted to 'One Hundred Twenty Three'.",
    "topic": "String",
    "subtopic": "Conversion",
    "tags": [
      "String",
      "Conversion",
      "Numbers"
    ],
    "input_format": "An integer num where 0 <= num < 231.",
    "output_format": "A string representing the English words of the number.",
    "constraints": [
      "0 <= num < 231"
    ],
    "examples": [
      {
        "input": "num = 123",
        "output": "One Hundred Twenty Three",
        "explanation": "The number 123 can be broken down into 'One Hundred' (100) and 'Twenty Three' (23)."
      },
      {
        "input": "num = 1000000",
        "output": "One Million",
        "explanation": "The number 1000000 is represented simply as 'One Million'."
      },
      {
        "input": "num = 0",
        "output": "Zero",
        "explanation": "The number 0 is represented as 'Zero'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider breaking down the number into groups (thousands, millions, etc.).",
      "Use a mapping for numbers less than 20 and tens."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Matchsticks to Square",
    "description": "You are given an integer array matchsticks where matchsticks[i] is the length of the i-th matchstick. You want to use all the matchsticks to make a square. You should return true if you can make it and false otherwise. A square is valid if all four sides have the same length.",
    "topic": "Dynamic Programming",
    "subtopic": "Backtracking",
    "tags": [
      "Backtracking",
      "Dynamic Programming",
      "Recursion"
    ],
    "input_format": "An array of integers matchsticks.",
    "output_format": "A boolean value indicating whether it is possible to form a square using the matchsticks.",
    "constraints": [
      "1 <= matchsticks.length <= 15",
      "0 < matchsticks[i] <= 10^8"
    ],
    "examples": [
      {
        "input": "matchsticks = [1, 1, 2, 2, 2]",
        "output": "true",
        "explanation": "We can create a square with side length 2 using the matchsticks."
      },
      {
        "input": "matchsticks = [3, 3, 3, 3, 4]",
        "output": "false",
        "explanation": "It's not possible to form a square with these matchsticks."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to sort the matchsticks to start building the square.",
      "Use backtracking to explore different combinations of matchstick lengths."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Binary Tree Cameras",
    "description": "Given a binary tree, you need to place cameras to monitor all the nodes of the tree. Each camera can monitor its parent, itself, and all of its children nodes. The goal is to return the minimum number of cameras needed to monitor all the nodes in the binary tree.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "A binary tree represented by the root node.",
    "output_format": "An integer representing the minimum number of cameras needed to monitor all nodes.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 1000].",
      "Node values are unique and represent valid integers."
    ],
    "examples": [
      {
        "input": "root = [0,0,null,0,0]",
        "output": "1",
        "explanation": "Placing one camera at the root node can monitor all nodes."
      },
      {
        "input": "root = [0,0,0,null,null,0,null,null,0]",
        "output": "2",
        "explanation": "Cameras are needed at the left and right child of the root to cover the entire tree."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a recursive function to check coverage.",
      "Think about what each state means in terms of camera placement."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Map",
    "tags": [
      "Array",
      "Hash Map",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash map to store the numbers and their indices.",
      "Check if the complement (target - current number) exists in the map."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Koko Eating Bananas",
    "description": "Koko loves to eat bananas and she can eat up to a certain number of bananas per hour, denoted as 'speed'. Given an array of piles where each pile is the number of bananas in that pile, and a h integer K representing the number of hours Koko has to eat the bananas, determine the minimum speed at which she must eat to finish all the bananas within K hours.",
    "topic": "Binary Search",
    "subtopic": "Search Problems",
    "tags": [
      "Binary Search",
      "Greedy",
      "Array"
    ],
    "input_format": "An integer array 'piles' representing the number of bananas in each pile and an integer K representing the number of hours available.",
    "output_format": "An integer representing the minimum speed Koko needs to eat the bananas.",
    "constraints": [
      "1 <= piles.length <= 10^4",
      "1 <= piles[i] <= 10^9",
      "1 <= K <= 10^7"
    ],
    "examples": [
      {
        "input": "piles = [3, 6, 7, 11], K = 8",
        "output": "4",
        "explanation": "If Koko eats 4 bananas per hour, she can finish all piles in 8 hours: 3 hours for the first pile (3 bananas), 2 hours for the second pile (6 bananas), 2 hours for the third pile (7 bananas), and 1 hour for the last pile (11 bananas)."
      },
      {
        "input": "piles = [30, 11, 23, 4, 20], K = 5",
        "output": "30",
        "explanation": "If Koko eats 30 bananas per hour, she can finish all piles in 5 hours: 1 hour for the first pile (30 bananas), 1 hour for the second pile (11 bananas), 1 hour for the third pile (23 bananas), 0.13 hours for the fourth pile (4 bananas), and the remaining time allows her to finish the last pile."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use binary search to find the minimum speed.",
      "Consider the total time based on chosen speed."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Word Break",
    "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Backtracking"
    ],
    "input_format": "A string s and a list of strings wordDict.",
    "output_format": "A boolean value indicating whether the string can be segmented using the words in the dictionary.",
    "constraints": [
      "1 <= s.length <= 300",
      "1 <= wordDict.length <= 1000",
      "1 <= wordDict[i].length <= 20",
      "All strings in wordDict are lowercase."
    ],
    "examples": [
      {
        "input": {
          "s": "leetcode",
          "wordDict": [
            "leet",
            "code"
          ]
        },
        "output": "true",
        "explanation": "The string 'leetcode' can be segmented as 'leet' and 'code'."
      },
      {
        "input": {
          "s": "applepenapple",
          "wordDict": [
            "apple",
            "pen"
          ]
        },
        "output": "true",
        "explanation": "The string 'applepenapple' can be segmented as 'apple', 'pen', and 'apple'."
      },
      {
        "input": {
          "s": "catsandog",
          "wordDict": [
            "cats",
            "dog",
            "sand",
            "and",
            "cat"
          ]
        },
        "output": "false",
        "explanation": "The string 'catsandog' cannot be segmented into words from the dictionary."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store results of subproblems.",
      "Use a boolean array to track the segmentation possibilities.",
      "Iterate through the string and check for word matches in the dictionary."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Median"
    ],
    "input_format": "Two sorted arrays nums1 and nums2.",
    "output_format": "A float representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= nums1.length <= 1000",
      "0 <= nums2.length <= 1000",
      "1 <= m + n <= 2000",
      "Each element of the arrays is -10^6 <= nums[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.0",
        "explanation": "The merged array is [1, 2, 3], and the median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.5",
        "explanation": "The merged array is [1, 2, 3, 4], and the median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using binary search on the smaller array.",
      "Try to partition the arrays such that the left partition is smaller or equal to the right partition."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A substring is a contiguous sequence of characters within the string. A palindrome is a string that reads the same backward as forward.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A single string s, where 1 <= s.length <= 1000.",
    "output_format": "A string representing the longest palindromic substring in s.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\"",
        "explanation": "Both \"bab\" and \"aba\" are valid longest palindromic substrings, but we return \"bab\"."
      },
      {
        "input": "s = \"cbbd\"",
        "output": "\"bb\"",
        "explanation": "The longest palindromic substring is \"bb\"."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try expanding around potential centers.",
      "Use dynamic programming to remember results of subproblems."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Integer to Roman",
    "description": "Convert an integer to a Roman numeral. Roman numerals are represented by seven symbols: I, V, X, L, C, D and M. For example, 1 is represented as 'I', 2 is 'II', 3 is 'III'. 4 is 'IV', and so on. The number of symbols is unlimited, but the typical range of Roman numerals is from 1 to 3999.",
    "topic": "Math",
    "subtopic": "Conversion",
    "tags": [
      "Math",
      "String",
      "Conversion"
    ],
    "input_format": "An integer num (1 <= num <= 3999).",
    "output_format": "A string representing the Roman numeral equivalent of the integer.",
    "constraints": [
      "1 <= num <= 3999"
    ],
    "examples": [
      {
        "input": "num = 3",
        "output": "III",
        "explanation": "The integer 3 is represented as 'III'."
      },
      {
        "input": "num = 4",
        "output": "IV",
        "explanation": "The integer 4 is represented as 'IV'."
      },
      {
        "input": "num = 9",
        "output": "IX",
        "explanation": "The integer 9 is represented as 'IX'."
      },
      {
        "input": "num = 58",
        "output": "LVIII",
        "explanation": "The integer 58 is represented as 'LVIII': 50 (L) + 5 (V) + 3 (III)."
      },
      {
        "input": "num = 1994",
        "output": "MCMXCIV",
        "explanation": "The integer 1994 is represented as 'MCMXCIV': 1000 (M) + 900 (CM) + 90 (XC) + 4 (IV)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using subtraction with Roman numerals to represent numbers efficiently.",
      "Build the Roman numeral string by iterating from largest to smallest symbols."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Roman to Integer",
    "description": "Given a string s that represents a Roman numeral, convert it to an integer. The Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. The value of each symbol is as follows: I = 1, V = 5, X = 10, L = 50, C = 100, D = 500, and M = 1000. In the case where a smaller value precedes a larger value, it must be subtracted from the larger value, e.g., IV = 4, IX = 9. The input string is guaranteed to be a valid Roman numeral in the range from 1 to 3999.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "Strings",
      "Conversion",
      "Parsing"
    ],
    "input_format": "A string s representing a Roman numeral.",
    "output_format": "An integer representing the converted value.",
    "constraints": [
      "1 <= s.length <= 15",
      "s consists of the characters 'I', 'V', 'X', 'L', 'C', 'D', and 'M'.",
      "The value of s is guaranteed to be within the range from 1 to 3999."
    ],
    "examples": [
      {
        "input": "s = 'III'",
        "output": "3",
        "explanation": "The Roman numeral III is 1 + 1 + 1 = 3."
      },
      {
        "input": "s = 'LVIII'",
        "output": "58",
        "explanation": "The Roman numeral LVIII is 50 + 5 + 1 + 1 + 1 = 58."
      },
      {
        "input": "s = 'MCMXCIV'",
        "output": "1994",
        "explanation": "The Roman numeral MCMXCIV is 1000 + (1000 - 100) + (1000 - 10) + 5 = 1994."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a mapping from Roman numerals to integers.",
      "Think about how to handle subtraction cases."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of k linked-lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. The merged linked-list should be made by splicing together the nodes of the given k lists.",
    "topic": "Linked List",
    "subtopic": "Merge",
    "tags": [
      "Linked List",
      "Sorting",
      "Merge"
    ],
    "input_format": "An array of k linked-lists, where each linked-list node contains an integer value and a reference to the next node.",
    "output_format": "A single linked-list which is the result of merging the k input linked-lists in sorted order.",
    "constraints": [
      "0 <= k <= 10^4",
      "0 <= individual linked-list length <= 10^4",
      "-10^4 <= node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "[1->4->5, 1->3->4, 2->6]",
        "output": "1->1->2->3->4->4->5->6",
        "explanation": "The merged linked-list is formed by combining and sorting the values from the input linked-lists."
      },
      {
        "input": "[]",
        "output": "",
        "explanation": "An empty list of linked-lists results in an empty merged linked-list."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a priority queue to efficiently merge the lists.",
      "Think about how to maintain a pointer to the current smallest node."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Find the Index of the First Occurrence in a String",
    "description": "Given a haystack string and a needle string, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.",
    "topic": "String",
    "subtopic": "Searching",
    "tags": [
      "String",
      "Searching",
      "Index"
    ],
    "input_format": "Two strings, haystack and needle. (1 <= haystack.length <= 10^4, 0 <= needle.length <= 100)",
    "output_format": "An integer representing the index of the first occurrence, or -1 if needle is not found.",
    "constraints": [
      "1 <= haystack.length <= 10^4",
      "0 <= needle.length <= 100"
    ],
    "examples": [
      {
        "input": "haystack = 'hello', needle = 'll'",
        "output": "2",
        "explanation": "The substring 'll' is found at index 2 in 'hello'."
      },
      {
        "input": "haystack = 'aaaaa', needle = 'bba'",
        "output": "-1",
        "explanation": "The substring 'bba' is not found in 'aaaaa'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using string functions to search for the needle.",
      "Remember that the needle can be an empty string."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Longest Valid Parentheses",
    "description": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Stack"
    ],
    "input_format": "A string s consisting only of the characters '(' and ')'.",
    "output_format": "An integer representing the length of the longest valid parentheses substring.",
    "constraints": [
      "0 <= s.length <= 3 * 10^4",
      "s[i] is either '(' or ')'."
    ],
    "examples": [
      {
        "input": "s = '()(()'",
        "output": "2",
        "explanation": "The longest valid parentheses substring is '()', which has a length of 2."
      },
      {
        "input": "s = ')()())'",
        "output": "4",
        "explanation": "The longest valid parentheses substring is '(())', which has a length of 4."
      },
      {
        "input": "s = '(()'",
        "output": "2",
        "explanation": "The longest valid parentheses substring is '()', which has a length of 2."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to keep track of indices.",
      "You can also use a counter for open and close parentheses."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array nums, find the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses constant extra space.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Hashing"
    ],
    "input_format": "An unsorted array of integers nums.",
    "output_format": "An integer representing the smallest missing positive integer.",
    "constraints": [
      "0 <= nums.length <= 30000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "The smallest missing positive integer is 3."
      },
      {
        "input": "nums = [3, 4, -1, 1]",
        "output": "2",
        "explanation": "The smallest missing positive integer is 2."
      },
      {
        "input": "nums = [7, 8, 9, 11, 12]",
        "output": "1",
        "explanation": "The smallest missing positive integer is 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using the array itself to track the presence of positive integers.",
      "Think about placing each number in its correct index based on its value."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Subarray"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum sum of the contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The contiguous subarray [4,-1,2,1] has the largest sum = 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The only element is 1, so the maximum sum is also 1."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The contiguous subarray [5,4,-1,7,8] has the largest sum = 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a variable to keep track of the current sum.",
      "If the current sum becomes negative, reset it to zero."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Validate Binary Search Tree",
    "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is one where for every node, all values in its left subtree are less than the node's value, and all values in its right subtree are greater than the node's value.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "BST",
      "Recursion"
    ],
    "input_format": "The input consists of a binary tree represented by its root node.",
    "output_format": "Return true if the tree is a valid BST, otherwise return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 104].",
      "The value of each node is a unique integer."
    ],
    "examples": [
      {
        "input": "root = [2, 1, 3]",
        "output": "true",
        "explanation": "The left child (1) is less than the root (2) and the right child (3) is greater than the root, thus it is a valid BST."
      },
      {
        "input": "root = [5, 1, 4, null, null, 3, 6]",
        "output": "false",
        "explanation": "The node with value 4 is greater than the root (5), thus it violates the BST property."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use in-order traversal to check the order of values.",
      "Keep track of lower and upper bounds for each node."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices, where 0 <= prices.length <= 10^5.",
    "output_format": "An integer representing the maximum profit you can achieve.",
    "constraints": [
      "0 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate potential profit at each step and keep updating the maximum profit."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Copy List with Random Pointer",
    "description": "You are given a linked list where each node contains an additional random pointer, which could point to any node in the list or null. Your task is to create a deep copy of the linked list. The deep copy should consist of exactly the same nodes as the original list. Each new node has to have the same value as the original node. The next and random pointers in the new list should point to the corresponding nodes in the copied list. Return the head of the copied linked list.",
    "topic": "Linked List",
    "subtopic": "Deep Copy",
    "tags": [
      "Linked List",
      "Depth First Search",
      "Hash Table"
    ],
    "input_format": "A head node of a linked list containing nodes with 'val', 'next', and 'random' pointers.",
    "output_format": "The head of the copied linked list.",
    "constraints": [
      "0 <= n <= 1000",
      "Each node's value is in the range of [-10000, 10000].",
      "The 'random' pointer for any node can be null.",
      "The 'next' pointer for any node does not point to a node more than once."
    ],
    "examples": [
      {
        "input": "Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "output": "Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "explanation": "The input linked list represented by head has the specified random pointers, and the output is the deep copied linked list, preserving the random pointer connections."
      },
      {
        "input": "Input: head = [[1,1],[2,1]]",
        "output": "Output: [[1,1],[2,1]]",
        "explanation": "The nodes in the copied linked list mirror the original, with correct random pointers."
      },
      {
        "input": "Input: head = []",
        "output": "Output: []",
        "explanation": "An empty linked list returns an empty linked list."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to keep track of all the original nodes and their corresponding copied nodes.",
      "Iterate through the original list to make copies of each node without the random pointers."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Find Minimum in Rotated Sorted Array",
    "description": "Given a rotated sorted array, find the minimum element in the array. You may assume that the array does not contain duplicates. A rotated sorted array is an array that is sorted in ascending order but is rotated at some pivot unknown to you beforehand.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Sorting"
    ],
    "input_format": "An array of integers nums, which is a rotated sorted array.",
    "output_format": "An integer representing the minimum element in the array.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-5000 <= nums[i] <= 5000"
    ],
    "examples": [
      {
        "input": "nums = [3, 4, 5, 1, 2]",
        "output": "1",
        "explanation": "The minimum element is 1."
      },
      {
        "input": "nums = [4, 5, 6, 7, 0, 1, 2]",
        "output": "0",
        "explanation": "The minimum element is 0."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The minimum element is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to find the minimum element efficiently.",
      "If the middle element is greater than the right element, the minimum must be in the right half."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Reorganize String",
    "description": "Given a string s, rearrange the characters of s so that no two adjacent characters are the same. If it is not possible to rearrange the string, return an empty string. You may return the answer in any order.",
    "topic": "String",
    "subtopic": "Rearrangement",
    "tags": [
      "String",
      "Rearrangement",
      "Greedy"
    ],
    "input_format": "A string s consisting of lowercase English letters.",
    "output_format": "A rearranged string where no two adjacent characters are the same, or an empty string if not possible.",
    "constraints": [
      "1 <= s.length <= 500",
      "s consists of lowercase letters."
    ],
    "examples": [
      {
        "input": "aaab",
        "output": "",
        "explanation": "It is not possible to rearrange the string so that no two adjacent characters are the same."
      },
      {
        "input": "aab",
        "output": "aba",
        "explanation": "One valid rearrangement is 'aba'."
      },
      {
        "input": "aaabc",
        "output": "abaca",
        "explanation": "One valid rearrangement is 'abaca'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a frequency counter to count the occurrences of each character.",
      "A max heap can help in choosing the character with the highest remaining frequency."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Longest Substring with At Most Two Distinct Characters",
    "description": "Given a string s, find the length of the longest substring T that contains at most two distinct characters. You may assume that the string s is not empty.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Substring"
    ],
    "input_format": "A string s representing the input.",
    "output_format": "An integer representing the length of the longest substring with at most two distinct characters.",
    "constraints": [
      "1 <= s.length <= 10000",
      "s consists of English letters and digits."
    ],
    "examples": [
      {
        "input": "s = 'eceba'",
        "output": "3",
        "explanation": "The longest substring is 'ece', which has a length of 3."
      },
      {
        "input": "s = 'ccaabbb'",
        "output": "5",
        "explanation": "The longest substring is 'aabbb', which has a length of 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window approach.",
      "Maintain a count of distinct characters in the current window."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Two Sum II - Input Array Is Sorted",
    "description": "Given a 1-indexed array of integers `numbers` that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Return the indices of the two numbers in a 1-indexed format. You may assume that each input would have exactly one solution and you may not use the same element twice. Your solution should not exceed O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Binary Search"
    ],
    "input_format": "An array of integers 'numbers' and an integer 'target'.",
    "output_format": "An array of two integers representing the 1-indexed positions of the numbers that add up to the target.",
    "constraints": [
      "2 <= numbers.length <= 3 * 10^4",
      "-1000 <= numbers[i] <= 1000",
      "numbers is sorted in non-decreasing order.",
      "There will always be a solution."
    ],
    "examples": [
      {
        "input": "numbers = [2, 7, 11, 15], target = 9",
        "output": "[1, 2]",
        "explanation": "numbers[0] + numbers[1] = 2 + 7 = 9. Thus, the indices are 1 and 2."
      },
      {
        "input": "numbers = [1, 2, 3, 4, 4, 9, 10], target = 8",
        "output": "[4, 5]",
        "explanation": "numbers[3] + numbers[4] = 4 + 4 = 8. Thus, the indices are 4 and 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider a two-pointer approach since the array is sorted.",
      "Start one pointer at the beginning and another at the end of the array."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Majority Element",
    "description": "Given an array of size n, find the majority element. The majority element is the element that appears more than n/2 times in the array. You may assume that the majority element always exists in the array.",
    "topic": "Array",
    "subtopic": "Counting",
    "tags": [
      "Array",
      "Counting",
      "Majority"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the majority element.",
    "constraints": [
      "1 <= nums.length <= 5 * 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 3]",
        "output": "3",
        "explanation": "The element 3 appears 2 times which is more than n/2 (3/2 = 1.5)."
      },
      {
        "input": "nums = [2, 2, 1, 1, 1, 2, 2]",
        "output": "2",
        "explanation": "The element 2 appears 4 times which is more than n/2 (7/2 = 3.5)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash map to count occurrences of each element.",
      "Consider the Boyer-Moore Voting Algorithm for an optimal solution."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Rotate Array",
    "description": "Given an array of integers and an integer k, rotate the array to the right by k steps, where k is non-negative. Modifications should be made in-place, meaning you should not use extra space better than O(1).",
    "topic": "Array",
    "subtopic": "In-place Operations",
    "tags": [
      "Array",
      "Rotation",
      "In-place"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "The rotated array after k steps to the right.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= k <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5, 6, 7], k = 3",
        "output": "[5, 6, 7, 1, 2, 3, 4]",
        "explanation": "Rotating the array to the right by 3 steps results in the final arrangement of [5, 6, 7, 1, 2, 3, 4]."
      },
      {
        "input": "nums = [-1, -100, 3, 99], k = 2",
        "output": "[3, 99, -1, -100]",
        "explanation": "After rotating by 2 steps, the array's new configuration is [3, 99, -1, -100]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using the reverse method to achieve the rotation.",
      "The effective number of rotations is k % nums.length."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Shortest Palindrome",
    "description": "Given a string 's', you need to find the shortest palindrome that can be formed by adding characters to the front of 's'. A palindrome is a string that reads the same backward as forward. Your task is to determine the minimum number of characters that need to be added in front of the string to make it a palindrome.",
    "topic": "String",
    "subtopic": "Palindrome",
    "tags": [
      "String",
      "Palindrome",
      "Dynamic Programming"
    ],
    "input_format": "A single string 's' consisting of lowercase letters.",
    "output_format": "An integer representing the minimum number of characters to add to the front of 's' to make it a palindrome.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of lowercase English letters"
    ],
    "examples": [
      {
        "input": "s = \"abc\"",
        "output": "2",
        "explanation": "We can add 'cba' in front of 'abc' to make 'cbabc' which is a palindrome. Minimum additions: 2."
      },
      {
        "input": "s = \"aacecaaa\"",
        "output": "1",
        "explanation": "We can add 'a' in front of 'aacecaaa' to make 'aaacecaaa' which is a palindrome. Minimum additions: 1."
      },
      {
        "input": "s = \"abcd\"",
        "output": "3",
        "explanation": "We can add 'dcb' in front of 'abcd' to make 'dcbabcd' which is a palindrome. Minimum additions: 3."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using the KMP algorithm for efficient matching.",
      "Think about the longest palindromic suffix."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Maximal Square",
    "description": "Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "2D Matrix",
    "tags": [
      "Dynamic Programming",
      "Matrix",
      "Square"
    ],
    "input_format": "A 2D binary matrix represented as a list of lists where each element is either '0' or '1'.",
    "output_format": "An integer representing the area of the largest square containing only 1's.",
    "constraints": [
      "1 <= matrix.length <= 300",
      "1 <= matrix[i].length <= 300",
      "matrix[i][j] is '0' or '1'"
    ],
    "examples": [
      {
        "input": [
          [
            "1",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "0",
            "1",
            "1",
            "1"
          ],
          [
            "1",
            "1",
            "1",
            "1",
            "1"
          ],
          [
            "1",
            "0",
            "0",
            "1",
            "0"
          ]
        ],
        "output": "4",
        "explanation": "The largest square of 1's has a side length of 2, hence its area is 2 * 2 = 4."
      },
      {
        "input": [
          [
            "0",
            "1"
          ],
          [
            "1",
            "1"
          ]
        ],
        "output": "1",
        "explanation": "The largest square of 1's has a side length of 1, hence its area is 1 * 1 = 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you can build larger squares using previously computed squares.",
      "Use a dynamic programming table to keep track of the largest square size at each position."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Permutations",
    "description": "Given an array of distinct integers, return all the possible permutations. You can return the answer in any order. The problem requires constructing all the different arrangements of the elements in the given list without any repetitions.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Recursion",
      "Permutations"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "A list of lists, where each list is a permutation of the input array.",
    "constraints": [
      "1 <= nums.length <= 6",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": "The permutations of [1, 2, 3] include all possible arrangements of the 3 numbers."
      },
      {
        "input": "nums = [0, 1]",
        "output": "[[0,1],[1,0]]",
        "explanation": "The permutations of [0, 1] are [0, 1] and [1, 0]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to generate permutations.",
      "Swap elements to create new arrangements."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Meeting Rooms",
    "description": "Given an array of meeting time intervals consisting of start and end times, determine if a person could attend all meetings. A meeting is represented by a pair of integers [start, end], where 'start' is the starting time of the meeting and 'end' is the ending time. The meetings are considered to overlap if the start time of one is less than the end time of another.",
    "topic": "Interval",
    "subtopic": "Interval Overlapping",
    "tags": [
      "Intervals",
      "Greedy",
      "Sorting"
    ],
    "input_format": "An array of intervals, where intervals[i] = [start, end].",
    "output_format": "A boolean value indicating whether a person can attend all meetings.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= start < end <= 10^6"
    ],
    "examples": [
      {
        "input": "intervals = [[0, 30], [5, 10], [15, 20]]",
        "output": "false",
        "explanation": "The meetings at [0, 30] and [5, 10] overlap, so it's not possible to attend all meetings."
      },
      {
        "input": "intervals = [[7, 10], [2, 4]]",
        "output": "true",
        "explanation": "The meetings do not overlap, so it's possible to attend all meetings."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Sort the intervals based on their start times.",
      "Check if the current meeting starts before the previous one ends."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Nested List Weight Sum",
    "description": "You are given a nested list of integers where each integer can be either a single integer or a list of integers. Each list has a depth associated with it, which is determined by how deep the integer is nested inside lists. Your task is to compute the weighted sum of these integers, where the weight of an integer is equal to its depth in the nested list. For instance, integers in an outermost list have a depth of 1, those in a list inside have a depth of 2, and so on.",
    "topic": "Depth-first Search",
    "subtopic": "Recursion",
    "tags": [
      "Recursion",
      "Depth-first Search",
      "Nested List"
    ],
    "input_format": "A nested list of integers.",
    "output_format": "An integer representing the total weighted sum of all integers.",
    "constraints": [
      "The number of elements in the nested list can be up to 10^4.",
      "The integers in the list can range from -10^6 to 10^6."
    ],
    "examples": [
      {
        "input": "[1, [4, [6]]]",
        "output": "27",
        "explanation": "1 is at depth 1, 4 is at depth 2, and 6 is at depth 3. Therefore, the total weighted sum is 1*1 + 4*2 + 6*3 = 1 + 8 + 18 = 27."
      },
      {
        "input": "[1, 2, [3, 4], 5]",
        "output": "26",
        "explanation": "1, 2, and 5 are at depth 1, while 3 and 4 are at depth 2. Therefore, the weighted sum is 1*1 + 2*1 + 3*2 + 4*2 + 5*1 = 1 + 2 + 6 + 8 + 5 = 22."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use recursion to handle nested lists.",
      "Keep track of the depth while traversing."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Top K Frequent Elements",
    "description": "Given a non-empty array of integers, return the k most frequent elements. You may return the answer in any order. Your algorithm should have a linear runtime complexity.",
    "topic": "Hash Table",
    "subtopic": "Frequency Count",
    "tags": [
      "Hash Table",
      "Sorting",
      "Frequency",
      "Heap"
    ],
    "input_format": "An integer array nums and an integer k.",
    "output_format": "An array of the k most frequent elements.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "k is in the range [1, the number of unique elements in the array]"
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3], k = 2",
        "output": "[1,2]",
        "explanation": "1 is the most frequent element and 2 is the second most frequent, both appearing more than 1 time."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "Only one element in the array, so the answer is [1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to count frequencies.",
      "Utilize a priority queue to extract the k most frequent elements efficiently."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Maximum Tastiness of Candy Basket",
    "description": "You have a basket of candies, each with a given tastiness level. Your goal is to select a subset of these candies such that the minimum tastiness level of the selected candies is maximized. You can only choose candies that are adjacent in the basket. Return the maximum possible minimum tastiness level among the candies you select.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Greedy"
    ],
    "input_format": "An array of integers tastiness representing the tastiness levels of the candies.",
    "output_format": "An integer representing the maximum possible minimum tastiness level of the selected candies.",
    "constraints": [
      "1 <= tastiness.length <= 10^5",
      "1 <= tastiness[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "tastiness = [5, 2, 3, 9, 4]",
        "output": "4",
        "explanation": "To maximize the minimum tastiness, we can select candies with tastiness [5, 4]. The minimum tastiness is 4."
      },
      {
        "input": "tastiness = [1, 3, 2, 5, 4]",
        "output": "3",
        "explanation": "Selecting candies with tastiness [3, 2, 5] gives the minimum tastiness of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider evaluating the range of tastiness levels.",
      "Try using binary search on the possible minimum tastiness levels.",
      "Sliding window might help in checking feasible selections."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Find Pivot Index",
    "description": "Given an array of integers `nums`, return the 'pivot index' of this array. The pivot index is the index where the sum of all the elements to the left of the index is equal to the sum of all the elements to the right of the index. If no such index exists, return -1. If there are multiple pivot indexes, return the left-most pivot index.",
    "topic": "Array",
    "subtopic": "Prefix Sum",
    "tags": [
      "Array",
      "Prefix Sum",
      "Index"
    ],
    "input_format": "An array of integers `nums`.",
    "output_format": "An integer representing the pivot index or -1 if no such index exists.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^6 <= nums[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [1, 7, 3, 6, 5, 6]",
        "output": "3",
        "explanation": "At index 3, the sum of the left side is 1 + 7 + 3 = 11 and the sum of the right side is 5 + 6 = 11."
      },
      {
        "input": "nums = [1, 2, 3]",
        "output": "-1",
        "explanation": "There is no index that satisfies the condition."
      },
      {
        "input": "nums = [2, 1, -1]",
        "output": "0",
        "explanation": "At index 0, the sum of the left side is 0 and the sum of the right side is 1 + -1 = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Compute the total sum of the array and use it to find the pivot index.",
      "Track the left sum while iterating through the array."
    ],
    "company": "eBay"
  },
  {
    "question_id": "",
    "title": "Sort Colors",
    "description": "Given an array consisting of red, white, and blue colors represented by the integers 0, 1, and 2 respectively, sort the array in-place so that objects of the same color are adjacent, with the colors in the order red (0), white (1), and blue (2). You must solve this problem without using the library's sort function.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "In-place"
    ],
    "input_format": "An array of integers nums where each integer is either 0, 1, or 2.",
    "output_format": "The sorted array in the same input array.",
    "constraints": [
      "1 <= nums.length <= 300",
      "nums[i] is either 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "nums = [2,0,2,1,1,0]",
        "output": "[0,0,1,1,2,2]",
        "explanation": "After sorting, all 0s come before 1s, which come before 2s."
      },
      {
        "input": "nums = [2,0,1]",
        "output": "[0,1,2]",
        "explanation": "After sorting, the array becomes [0,1,2] which is in correct order."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using the two-pointer technique.",
      "Keep track of the last position of the sorted elements."
    ],
    "company": "eBay"
  }
]