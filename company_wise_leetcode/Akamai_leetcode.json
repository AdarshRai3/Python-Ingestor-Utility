[
  {
    "question_id": "",
    "title": "N-Repeated Element in Size 2N Array",
    "description": "In a given array of size 2N, there is one element that is repeated N times. Your task is to find and return that element. It is guaranteed that the input array will always contain an answer.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Hash Table"
    ],
    "input_format": "An array of integers nums, where 2N is the length of the array.",
    "output_format": "An integer representing the N-repeated element.",
    "constraints": [
      "1 <= nums.length <= 10000",
      "0 <= nums[i] <= 10000"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 3]",
        "output": "3",
        "explanation": "The element 3 is repeated N times (in this case N=2) in the array."
      },
      {
        "input": "nums = [2, 1, 2, 5, 3, 2]",
        "output": "2",
        "explanation": "The element 2 is repeated N times (here N=2) in the array."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "You can use a hash table to count the occurrences of each number."
    ],
    "company": "Akamai"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array where the ith element is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Dynamic Programming",
    "subtopic": "1D Dynamic Programming",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Greedy"
    ],
    "input_format": "An array of integers prices representing the stock prices on different days.",
    "output_format": "An integer representing the maximum profit that can be achieved.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price encountered so far.",
      "Calculate the potential profit at each step."
    ],
    "company": "Akamai"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 2 + 7 = 9"
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "nums[1] + nums[2] = 2 + 4 = 6"
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 3 + 3 = 6"
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hashmap to store the indices of the numbers you have seen."
    ],
    "company": "Akamai"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Median"
    ],
    "input_format": "Two sorted arrays of integers nums1 and nums2.",
    "output_format": "A float number representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= nums1.length <= 1000",
      "0 <= nums2.length <= 1000",
      "-10^6 <= nums1[i], nums2[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.0",
        "explanation": "The merged array is [1, 2, 3], and the median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.5",
        "explanation": "The merged array is [1, 2, 3, 4], and the median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to partition the two arrays to find the median.",
      "Using binary search can help narrow down the search space.",
      "Think about both odd and even length cases for the combined array."
    ],
    "company": "Akamai"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array",
    "description": "Given a sorted array of integers, remove the duplicates in-place such that each element appears only once and return the new length of the array. Do not allocate extra space for another array, you must do this by modifying the input array in-place.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An array of integers nums sorted in non-decreasing order.",
    "output_format": "An integer representing the new length of the array after removing duplicates.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "2",
        "explanation": "After removing duplicates, the array is [1, 2]. The new length is 2."
      },
      {
        "input": "nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]",
        "output": "5",
        "explanation": "After removing duplicates, the array is [0, 1, 2, 3, 4]. The new length is 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to track unique elements."
    ],
    "company": "Akamai"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers II",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contains a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.",
    "topic": "Linked List",
    "subtopic": "Addition",
    "tags": [
      "Linked List",
      "Math",
      "Addition"
    ],
    "input_format": "Two non-empty linked lists representing two non-negative integers.",
    "output_format": "A linked list representing the sum of the two integers.",
    "constraints": [
      "The number of nodes in each linked list is at most 100.",
      "Each node's value is an integer between 0 and 9.",
      "The input lists represent numbers in reverse order."
    ],
    "examples": [
      {
        "input": "l1 = [7, 2, 4, 3], l2 = [5, 6, 4]",
        "output": "[7, 8, 0, 7]",
        "explanation": "The numbers are 342 and 465, their sum is 807 which represented in reverse order is [7, 8, 0]."
      },
      {
        "input": "l1 = [2, 4, 3], l2 = [5, 6, 4]",
        "output": "[8, 0, 7]",
        "explanation": "The numbers are 342 and 465, their sum is 807 which represented in reverse order is [7, 0, 8]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dummy head to simplify list manipulation.",
      "Iterate through both lists, handling carry as needed."
    ],
    "company": "Akamai"
  },
  {
    "question_id": "",
    "title": "Min Stack",
    "description": "Design a stack that supports the following operations: push, pop, top, and retrieving the minimum element in constant time. Implement a class `MinStack` that supports these operations. Your program should also handle the case when the stack is empty and should not throw any errors.",
    "topic": "Stack",
    "subtopic": "Design",
    "tags": [
      "Stack",
      "Design",
      "Data Structure"
    ],
    "input_format": "The methods available in MinStack are: `void push(int x)`, `void pop()`, `int top()`, and `int getMin()`",
    "output_format": "The output will be the value returned by the `top()` and `getMin()` methods.",
    "constraints": [
      "The number of operations will be less than or equal to 1000.",
      "Each push operation will be followed by either a pop or a top operation."
    ],
    "examples": [
      {
        "input": "MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();  // return -3\nminStack.pop();\nminStack.top();     // return 0\nminStack.getMin();  // return -2",
        "output": "[-3, 0, -2]",
        "explanation": "The minimum element after pushing -3 is -3. After popping -3, the top element becomes 0 and the minimum element updates to -2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using an auxiliary stack.",
      "Keep track of the minimum value at each level of the stack."
    ],
    "company": "Akamai"
  },
  {
    "question_id": "",
    "title": "Construct Binary Search Tree from Preorder Traversal",
    "description": "Given an array representing the preorder traversal of a binary search tree, construct the binary search tree and return its root node. A binary search tree is defined such that for any node, all values in the left subtree are less than the node's value, and all values in the right subtree are greater than the node's value.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search",
      "Construction"
    ],
    "input_format": "An array of integers representing the preorder traversal of the binary search tree.",
    "output_format": "The root node of the constructed binary search tree.",
    "constraints": [
      "1 <= preorder.length <= 100",
      "1 <= preorder[i] <= 10^9",
      "All values of preorder are unique."
    ],
    "examples": [
      {
        "input": "preorder = [8, 5, 1, 7, 10, 12]",
        "output": "Root node with val = 8",
        "explanation": "The constructed BST will have 8 as the root, with left child 5 and right child 10."
      },
      {
        "input": "preorder = [1, 3]",
        "output": "Root node with val = 1",
        "explanation": "1 is the root and 3 is the right child."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a recursive approach to build the tree.",
      "Use the properties of binary search trees to determine where to place each value."
    ],
    "company": "Akamai"
  },
  {
    "question_id": "",
    "title": "Longest Palindrome",
    "description": "Given a string s, return the length of the longest substring in s that is a palindrome. A palindrome is a string that reads the same backward as forward.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Palindrome",
      "Dynamic Programming"
    ],
    "input_format": "A single string s consisting of lowercase and uppercase letters.",
    "output_format": "An integer representing the length of the longest palindromic substring.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only printable ASCII characters."
    ],
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "3",
        "explanation": "The longest palindromic substring is \"bab\" or \"aba\", both of length 3."
      },
      {
        "input": "s = \"cbbd\"",
        "output": "2",
        "explanation": "The longest palindromic substring is \"bb\", which has length 2."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a two-pointer approach to expand around potential centers of palindromes."
    ],
    "company": "Akamai"
  },
  {
    "question_id": "",
    "title": "Pairs of Songs With Total Durations Divisible by 60",
    "description": "You are given an array of integers representing the durations of various songs in seconds. Your task is to find the number of pairs of songs such that the total duration of each pair is divisible by 60.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Mathematics"
    ],
    "input_format": "An array of integers, 'durations', where 1 <= durations.length <= 10000 and 0 <= durations[i] <= 5000.",
    "output_format": "An integer representing the number of pairs of songs whose total duration is divisible by 60.",
    "constraints": [
      "1 <= durations.length <= 10000",
      "0 <= durations[i] <= 5000"
    ],
    "examples": [
      {
        "input": "durations = [30, 20, 150, 100, 40]",
        "output": "3",
        "explanation": "The pairs (30, 150), (20, 100), and (30, 30) all have sums that are divisible by 60."
      },
      {
        "input": "durations = [60, 60, 60]",
        "output": "3",
        "explanation": "The pairs (60, 60) can be formed in 3 different ways with the given durations."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the remainders when each duration is divided by 60.",
      "A pair of remainders that sums to 60 means their corresponding durations will be divisible by 60."
    ],
    "company": "Akamai"
  }
]