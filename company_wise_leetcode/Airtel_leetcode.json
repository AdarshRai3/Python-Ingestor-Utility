[
  {
    "question_id": "",
    "title": "Find Polygon With the Largest Perimeter",
    "description": "Given an integer array 'nums' representing the lengths of the sides of a polygon, return the largest perimeter of a polygon that can be formed with three of these sides. If it is not possible to form any polygon, return 0.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Geometry"
    ],
    "input_format": "An array of integers nums, where 3 <= nums.length <= 100 and 1 <= nums[i] <= 10^6.",
    "output_format": "An integer representing the largest perimeter of a polygon that can be formed, or 0 if no polygon can be formed.",
    "constraints": [
      "3 <= nums.length <= 100",
      "1 <= nums[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [2, 1, 2]",
        "output": "5",
        "explanation": "The sides 2, 2, and 1 can form a polygon with a perimeter of 5."
      },
      {
        "input": "nums = [1, 2, 1]",
        "output": "0",
        "explanation": "No polygon can be formed with the given sides."
      },
      {
        "input": "nums = [3, 6, 2, 3]",
        "output": "8",
        "explanation": "The sides 3, 3, and 2 can form a polygon with a perimeter of 8."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the lengths and try to find three consecutive sides that satisfy the polygon inequality."
    ],
    "company": "Airtel"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters. Your solution should scan the string efficiently to determine the maximum possible length of a substring that contains only unique characters.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A string s of length n (0 <= n <= 5 * 10^4).",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 5 * 10^4",
      "s consists of English letters, digits, symbols and spaces."
    ],
    "examples": [
      {
        "input": "s = 'abcabcbb'",
        "output": "3",
        "explanation": "The answer is 'abc', with the length of 3."
      },
      {
        "input": "s = 'bbbbb'",
        "output": "1",
        "explanation": "The answer is 'b', with the length of 1."
      },
      {
        "input": "s = 'pwwkew'",
        "output": "3",
        "explanation": "The answer is 'wke', with the length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window approach.",
      "Utilize a hash map to keep track of characters' indices."
    ],
    "company": "Airtel"
  },
  {
    "question_id": "",
    "title": "Generate Parentheses",
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
    "topic": "Backtracking",
    "subtopic": "Combinatorial Generation",
    "tags": [
      "Backtracking",
      "String",
      "Recursion"
    ],
    "input_format": "An integer n representing the number of pairs of parentheses.",
    "output_format": "A list of strings representing all the combinations of well-formed parentheses.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]",
        "explanation": "There are five combinations of well-formed parentheses when n = 3."
      },
      {
        "input": "n = 1",
        "output": "[\"()\"]",
        "explanation": "Only one combination of well-formed parentheses exists when n = 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use backtracking to explore all possibilities.",
      "Keep track of the count of open and close parentheses."
    ],
    "company": "Airtel"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices, where 0 <= prices.length <= 10^5.",
    "output_format": "An integer representing the maximum profit achievable.",
    "constraints": [
      "0 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate profit by subtracting the minimum price from current price."
    ],
    "company": "Airtel"
  },
  {
    "question_id": "",
    "title": "Find First and Last Position of Element in Sorted Array",
    "description": "Given an array of integers 'nums' sorted in non-decreasing order, find the starting and ending position of a given target value. If the target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity. If there are multiple occurrences of the target, return the indices of the first and last position.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Searching"
    ],
    "input_format": "An array of integers 'nums' and an integer 'target'.",
    "output_format": "An array of two integers representing the first and last position of target.",
    "constraints": [
      "0 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9",
      "nums is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 8",
        "output": "[3, 4]",
        "explanation": "The target 8 appears at indices 3 and 4."
      },
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 6",
        "output": "[-1, -1]",
        "explanation": "The target 6 does not exist in the array."
      },
      {
        "input": "nums = [], target = 0",
        "output": "[-1, -1]",
        "explanation": "The array is empty, so the target cannot be found."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to achieve O(log n) time complexity.",
      "You may need to adjust the binary search to find both the first and last occurrence."
    ],
    "company": "Airtel"
  }
]