[
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two indices where the numbers at those indices sum to the target.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash table to store the differences between the target and the current elements."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Movie Rating",
    "description": "You are given an array of movie ratings, where each rating is an integer between 1 and 10 (inclusive). Your task is to compute the average rating of the movies and round the result to the nearest integer. If the average rating has a fractional part of .5 or greater, round up to the next integer; otherwise, round down.",
    "topic": "Math",
    "subtopic": "Averaging",
    "tags": [
      "Math",
      "Average",
      "Rounding"
    ],
    "input_format": "An array of integers ratings representing movie ratings.",
    "output_format": "An integer representing the rounded average rating.",
    "constraints": [
      "1 <= ratings.length <= 10^4",
      "1 <= ratings[i] <= 10"
    ],
    "examples": [
      {
        "input": "ratings = [7, 6, 5, 8, 9]",
        "output": "7",
        "explanation": "The average is (7 + 6 + 5 + 8 + 9) / 5 = 7. The average rating is 7."
      },
      {
        "input": "ratings = [3, 4, 4, 7]",
        "output": "4",
        "explanation": "The average is (3 + 4 + 4 + 7) / 4 = 4.5. Rounded down, it becomes 4."
      },
      {
        "input": "ratings = [10, 9, 10, 8]",
        "output": "9",
        "explanation": "The average is (10 + 9 + 10 + 8) / 4 = 9.25. Rounded up, it becomes 9."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use the sum of the array to get the total rating.",
      "Don't forget to handle rounding correctly."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Count Increasing Quadruplets",
    "description": "Given an array of integers, count the number of quadruplets (i, j, k, l) such that 0 <= i < j < k < l < n and nums[i] < nums[j] < nums[k] < nums[l]. Return the number of such quadruplets modulo 10^9 + 7.",
    "topic": "Array",
    "subtopic": "Combination Count",
    "tags": [
      "Array",
      "Counting",
      "Combinatorics"
    ],
    "input_format": "An array of integers nums, where 1 <= nums.length <= 1000.",
    "output_format": "An integer representing the number of increasing quadruplets modulo 10^9 + 7.",
    "constraints": [
      "1 <= nums.length <= 1000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 2, 4, 5]",
        "output": "2",
        "explanation": "The increasing quadruplets are (1, 2, 3, 4) and (1, 2, 3, 5)."
      },
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "1",
        "explanation": "The only increasing quadruplet is (1, 2, 3, 4)."
      },
      {
        "input": "nums = [5, 4, 3, 2, 1]",
        "output": "0",
        "explanation": "There are no increasing quadruplets in a decreasing sequence."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using nested loops to find valid indices.",
      "Think about how to efficiently track the counts of possible pairs."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "Given n non-negative integers a1, a2, ..., an where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis, form a container, such that the container contains the most water. Note that you may not slant the container.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "input_format": "An array of integers heights where heights[i] represents the height of the i-th vertical line.",
    "output_format": "An integer representing the maximum area of water that can be contained.",
    "constraints": [
      "2 <= heights.length <= 3 * 10^4",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The maximum area is between the vertical lines at index 1 and 8, which gives an area of (8-1) * min(8, 7) = 49."
      },
      {
        "input": "heights = [1,1]",
        "output": "1",
        "explanation": "The area is 1 because the only two vertical lines are both of height 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using two pointers to find the maximum area.",
      "Consider the height and width when calculating the area.",
      "Move the pointer pointing to the shorter line to potentially find a taller line."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Count the Number of Infection Sequences",
    "description": "You are tasked with analyzing an infected area represented by a grid. Each cell in the grid can either be infected (1) or healthy (0). An infection spreads to adjacent cells (up, down, left, right) in unit time. You need to determine the total number of distinct sequences of infections that can occur in the grid. A sequence is defined as the order of time steps in which infections spread to adjacent cells before a healthy cell is completely infected.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "Matrix",
      "Count"
    ],
    "input_format": "A 2D grid of integers where 0 represents a healthy cell and 1 represents an infected cell.",
    "output_format": "An integer representing the total number of distinct infection sequences.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 100",
      "grid[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "grid = [[1,0,0],[0,1,0],[0,0,1]]",
        "output": "6",
        "explanation": "The distinct sequences of infection spreading can be: (1,0) -> (1,1); (1,0) -> (2,0) -> (2,1) -> (2,2); and so on, resulting in 6 distinct infection sequences."
      },
      {
        "input": "grid = [[1,1,0],[0,0,0],[0,1,1]]",
        "output": "4",
        "explanation": "Distinct sequences can be formed by first infecting the healthy cells adjacent to the infected ones leading to 4 sequences."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a DFS approach to explore all possible infection paths.",
      "Keep track of visited cells to avoid counting the same sequence multiple times.",
      "Use recursion to explore each time step of the infection spread."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Maximum Path Quality of a Graph",
    "description": "You are given an undirected graph with nodes equipped with values. A path quality is defined as the sum of the values in the nodes traversed. Your task is to find the maximum path quality of the graph based on the following rules: 1) You can start from any node, 2) You can traverse through any connected nodes without visiting the same node twice. Return the maximum path quality that can be obtained in the graph.",
    "topic": "Graph",
    "subtopic": "Traversing Graphs",
    "tags": [
      "Graph",
      "DFS",
      "Maximum Path"
    ],
    "input_format": "An integer n representing the number of nodes, an array edges of pairs representing undirected edges, and an array values of integers representing the value at each node.",
    "output_format": "An integer representing the maximum path quality.",
    "constraints": [
      "1 <= n <= 1000",
      "0 <= edges.length <= 10000",
      "1 <= values[i] <= 100"
    ],
    "examples": [
      {
        "input": "n = 5, edges = [[0, 1], [1, 2], [2, 3], [3, 4]], values = [5, 3, 4, 7, 2]",
        "output": "19",
        "explanation": "The maximum path is from node 0 -> 1 -> 2 -> 3 -> 4 with a quality of 5 + 3 + 4 + 7 + 2 = 21."
      },
      {
        "input": "n = 3, edges = [[0, 1], [1, 2]], values = [1, 2, 3]",
        "output": "6",
        "explanation": "The maximum path is from node 0 -> 1 -> 2 with a quality of 1 + 2 + 3 = 6."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using Depth First Search (DFS) to explore paths.",
      "Track visited nodes to avoid cycles.",
      "Use backtracking to explore all potential paths."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Maximum Students Taking Exam",
    "description": "Given a classroom represented as a 2D grid where some cells are occupied by students and others are empty, count the maximum number of students that can take the exam under the condition that no two students can sit adjacent to each other (horizontally, vertically, or diagonally). Each student occupies one cell in the grid, and a cell is marked with 1 if it's occupied by a student and 0 if it's empty.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Backtracking"
    ],
    "input_format": "A 2D list of integers where 1 represents a student and 0 represents an empty space.",
    "output_format": "An integer representing the maximum number of students that can take the exam.",
    "constraints": [
      "1 <= grid.length <= 15",
      "1 <= grid[i].length <= 15",
      "grid[i][j] is either 0 or 1"
    ],
    "examples": [
      {
        "input": "grid = [[1, 0, 0, 1], [0, 1, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]]",
        "output": "4",
        "explanation": "Four students can be seated in such a way that no two students are adjacent to each other."
      },
      {
        "input": "grid = [[1, 1, 0], [0, 0, 0], [1, 0, 1]]",
        "output": "2",
        "explanation": "Only two students can be seated without any adjacency."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a backtracking approach to explore different seating arrangements.",
      "Keep track of the positions already occupied to avoid conflicts."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".",
    "topic": "Strings",
    "subtopic": "Prefix",
    "tags": [
      "Strings",
      "Prefix",
      "Array"
    ],
    "input_format": "An array of strings strs, where 1 <= strs.length <= 200 and 0 <= strs[i].length <= 200.",
    "output_format": "A string representing the longest common prefix.",
    "constraints": [
      "1 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "All strings consist of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The longest common prefix is \"fl\"."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix, so the output is an empty string."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "\"a\"",
        "explanation": "The only string is \"a\", hence it is the longest prefix."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider sorting the array.",
      "The common prefix can only be as long as the shortest string."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the corresponding closing brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A string s consisting of parentheses characters: '(', ')', '{', '}', '[' and ']'.",
    "output_format": "Return true if the input string is valid, otherwise return false.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses characters only."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "'()' is a valid pair of parentheses."
      },
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "'()[]{}' contains valid pairs of all types of brackets."
      },
      {
        "input": "s = '(]')",
        "output": "false",
        "explanation": "'(]' contains mismatched pair of brackets."
      },
      {
        "input": "s = '([)]'",
        "output": "false",
        "explanation": "'([)]' contains brackets that are closed in the wrong order."
      },
      {
        "input": "s = '{[]}'",
        "output": "true",
        "explanation": "'{[]}' contains correctly nested brackets."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of open brackets.",
      "Close brackets should match the most recent open bracket."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Depth-First Search",
    "subtopic": "Graph",
    "tags": [
      "DFS",
      "Graph",
      "Matrix"
    ],
    "input_format": "A 2D binary grid represented as an array of arrays, where 1 represents land and 0 represents water.",
    "output_format": "An integer representing the number of islands in the grid.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "grid = [[1,1,0,0,0],[1,1,0,0,1],[0,0,0,1,1]]",
        "output": "3",
        "explanation": "There are three islands in the grid: one on the top left, one on the top right, and one on the bottom right."
      },
      {
        "input": "grid = [[1,1,1,1,0],[1,1,0,1,0],[1,1,0,0,0],[0,0,0,0,0]]",
        "output": "1",
        "explanation": "There is one large island that takes up most of the grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth-First Search (DFS) to explore the grid.",
      "Mark visited land cells to avoid counting them multiple times.",
      "A complete traversal from one land cell will mark the whole island."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Valid Palindrome",
    "description": "Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. A palindrome reads the same backward as forward. For example, 'A man, a plan, a canal: Panama' is a palindrome.",
    "topic": "String",
    "subtopic": "Two-Pointer Technique",
    "tags": [
      "String",
      "Palindrome",
      "Two-Pointers"
    ],
    "input_format": "A single string s.",
    "output_format": "A boolean indicating whether s is a valid palindrome.",
    "constraints": [
      "1 <= s.length <= 2 * 10^5",
      "s consists of printable ASCII characters."
    ],
    "examples": [
      {
        "input": "A man, a plan, a canal: Panama",
        "output": "true",
        "explanation": "'A man, a plan, a canal: Panama' is valid after removing non-alphanumeric characters and ignoring case."
      },
      {
        "input": "race a car",
        "output": "false",
        "explanation": "'race a car' is not a palindrome due to the presence of characters that do not form a symmetric sequence."
      },
      {
        "input": " ",
        "output": "true",
        "explanation": "The string contains only a space, which is considered a palindrome."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers, one starting from the beginning and the other from the end of the string.",
      "Skip non-alphanumeric characters while comparing the characters."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of bars, compute how much water it can trap after raining. The width of each bar is 1.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers heights representing the height of each bar.",
    "output_format": "An integer representing the total units of trapped rainwater.",
    "constraints": [
      "0 <= heights.length <= 2 * 10^4",
      "0 <= heights[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "heights = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The traps can hold 6 units of water: 1 unit between heights 2 and 3, 2 units between heights 1 and 2, and 3 units between heights 2 and 1."
      },
      {
        "input": "heights = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The maximum water trapped is 9 units: 2 units between heights 4 and 3, 3 units between heights 3 and 2, and 4 units between heights 2 and 5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the highest bars on both ends to calculate the trapped water.",
      "Use two pointers to represent the left and right boundaries and track the maximum heights."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Kadane's Algorithm"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the largest sum of the contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum = 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The subarray [1] has the largest sum = 1."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The entire array has the largest sum = 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "You can solve this problem using a dynamic programming approach.",
      "Keep track of the maximum sum and the current subarray sum."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List",
    "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    "topic": "Linked List",
    "subtopic": "Reversing a Linked List",
    "tags": [
      "Linked List",
      "Reversal",
      "Node Manipulation"
    ],
    "input_format": "A head node of a singly linked list.",
    "output_format": "The head node of the reversed linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 5000].",
      "-5000 <= Node.val <= 5000"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5]",
        "output": "[5, 4, 3, 2, 1]",
        "explanation": "The original list is 1 -> 2 -> 3 -> 4 -> 5. After reversing, it becomes 5 -> 4 -> 3 -> 2 -> 1."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "An empty list remains empty when reversed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Try using pointers to keep track of the previous and current nodes.",
      "Iterate through the list, adjusting the next pointers to reverse the links."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Maximal Square",
    "description": "Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "2D Matrix",
    "tags": [
      "Dynamic Programming",
      "Matrix",
      "Square"
    ],
    "input_format": "A 2D binary matrix represented as a list of lists of integers, where each integer is either 0 or 1.",
    "output_format": "An integer representing the area of the largest square containing only 1's.",
    "constraints": [
      "1 <= matrix.length <= 300",
      "1 <= matrix[0].length <= 300",
      "matrix[i][j] is '0' or '1'"
    ],
    "examples": [
      {
        "input": "[['1', '0', '1', '0', '0'], ['1', '0', '1', '1', '1'], ['1', '1', '1', '1', '1'], ['1', '0', '0', '1', '0']]",
        "output": "4",
        "explanation": "The largest square has a side length of 2 and thus an area of 2 * 2 = 4."
      },
      {
        "input": "[['0', '1'], ['1', '1']]",
        "output": "1",
        "explanation": "The largest square has a side length of 1 and thus an area of 1 * 1 = 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store the size of squares at each cell.",
      "A square's size can be determined by its top, left, and top-left neighbors."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A substring is a contiguous sequence of characters within a string. A palindrome is a string that reads the same forward and backward.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A single string s, where 1 <= s.length <= 1000.",
    "output_format": "A string representing the longest palindromic substring.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\"",
        "explanation": "Both \"bab\" and \"aba\" are valid longest palindromic substrings."
      },
      {
        "input": "s = \"cbbd\"",
        "output": "\"bb\"",
        "explanation": "\"bb\" is the longest palindromic substring."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding around possible centers.",
      "A palindrome mirrors around its center.",
      "Check for both odd and even length palindromes."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Leftmost Column with at Least a One",
    "description": "Given a 2D binary matrix where each row is sorted in ascending order, find the index of the leftmost column that contains at least one '1'. If no such column exists, return -1.",
    "topic": "Matrix",
    "subtopic": "Binary Search",
    "tags": [
      "Matrix",
      "Binary Search",
      "Two Pointer"
    ],
    "input_format": "A 2D binary matrix of size m x n (1 <= m, n <= 1000).",
    "output_format": "An integer representing the index of the leftmost column that contains at least one '1', or -1 if none exists.",
    "constraints": [
      "Each element of the matrix is either 0 or 1.",
      "The binary matrix has at least one row and one column."
    ],
    "examples": [
      {
        "input": "matrix = [[0,0,0],[0,1,1],[0,0,1]]",
        "output": "1",
        "explanation": "The matrix has '1's in column index 1 and 2, but column index 1 is the leftmost."
      },
      {
        "input": "matrix = [[0,0,0],[0,0,0]]",
        "output": "-1",
        "explanation": "There are no '1's in the matrix, so we return -1."
      },
      {
        "input": "matrix = [[1,0,0],[1,1,1],[0,0,0]]",
        "output": "0",
        "explanation": "The '1's appear in column index 0 in the first two rows."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use binary search to optimize the search for the leftmost column.",
      "Start from the top-right corner of the matrix."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Daily Temperatures",
    "description": "Given a list of daily temperatures, return a list such that, for each day in the input list, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.",
    "topic": "Array",
    "subtopic": "Stack",
    "tags": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "input_format": "An array of integers temperatures where 1 <= temperatures.length <= 30000 and 0 <= temperatures[i] <= 100.",
    "output_format": "An array of integers representing the number of days until a warmer temperature for each day.",
    "constraints": [
      "1 <= temperatures.length <= 30000",
      "0 <= temperatures[i] <= 100"
    ],
    "examples": [
      {
        "input": "temperatures = [73, 74, 75, 71, 69, 72, 76, 73]",
        "output": "[1, 1, 4, 2, 1, 1, 0, 0]",
        "explanation": "The output array is constructed as follows: day 0 (73) sees warmer temperature on day 1 (74), day 1 (74) sees warmer temperature on day 2 (75), and so on. Day 6 and day 7 do not see a warmer temperature."
      },
      {
        "input": "temperatures = [30, 40, 50, 60]",
        "output": "[1, 1, 1, 0]",
        "explanation": "Each day sees a warmer temperature the next day."
      },
      {
        "input": "temperatures = [30, 60, 90]",
        "output": "[1, 1, 0]",
        "explanation": "Day 0 sees a warmer temperature on day 1, day 1 sees a warmer temperature on day 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to use a stack to track the indices of the temperatures.",
      "You can pop the indices from the stack when you find a warmer temperature.",
      "The stack will help you maintain the order of days for which you haven't found a warmer temperature yet."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Kth Largest Element in an Array",
    "description": "Given an integer array `nums` and an integer `k`, return the k-th largest element in the array. Note that it is the k-th largest element in the sorted order, not the k-th distinct element. You must solve it in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Sorting & Selection",
    "tags": [
      "Array",
      "Sorting",
      "Selection",
      "Heap"
    ],
    "input_format": "An integer array `nums` followed by an integer `k`.",
    "output_format": "An integer representing the k-th largest element in the array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 1, 5, 6, 4], k = 2",
        "output": "5",
        "explanation": "When sorted in descending order, the array is [6, 5, 4, 3, 2, 1]. The 2nd largest element is 5."
      },
      {
        "input": "nums = [3, 2, 3, 1, 2, 4, 5, 5, 6], k = 4",
        "output": "4",
        "explanation": "When sorted in descending order, the array is [6, 5, 5, 4, 3, 3, 2, 2, 1]. The 4th largest element is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a min-heap to keep track of the k largest elements.",
      "You can also use Quickselect for optimal average-case time complexity."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Longest Consecutive Sequence",
    "description": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Set"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the length of the longest consecutive elements sequence.",
    "constraints": [
      "0 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [100, 4, 200, 1, 3, 2]",
        "output": "4",
        "explanation": "The longest consecutive sequence is [1, 2, 3, 4] which has a length of 4."
      },
      {
        "input": "nums = [0, -1]",
        "output": "2",
        "explanation": "The longest consecutive sequence is [-1, 0] which has a length of 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a set to store the numbers for O(1) lookups.",
      "For each number, check if it's the start of a sequence.",
      "Count the length of the sequence starting from that number."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices where 0 <= prices.length <= 10^4.",
    "output_format": "An integer representing the maximum profit achievable.",
    "constraints": [
      "0 <= prices.length <= 10^4",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate the potential profit at each price and update the maximum profit."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array",
    "description": "Given a sorted array, remove the duplicates in-place such that each element appears only once and return the new length of the array. Do not allocate extra space for another array. You must do this by modifying the input array in-place.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "A sorted array of integers nums.",
    "output_format": "An integer representing the new length of the array after duplicates have been removed.",
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-100 <= nums[i] <= 100",
      "nums are sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "2",
        "explanation": "After removing duplicates, the array becomes [1, 2], and the new length is 2."
      },
      {
        "input": "nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]",
        "output": "5",
        "explanation": "After removing duplicates, the array becomes [0, 1, 2, 3, 4], and the new length is 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to track unique elements.",
      "Iterate through the array, comparing adjacent elements."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Maximum Number of Weeks for Which You Can Work",
    "description": "You are given an array of integers representing the number of hours you can work each week. Your goal is to determine the maximum number of consecutive weeks you can work without exceeding a specified number of hours. You can choose to work any number of hours in a week but must stay within the total limit provided at the beginning.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An integer array hours and an integer limit.",
    "output_format": "An integer representing the maximum number of consecutive weeks you can work.",
    "constraints": [
      "1 <= hours.length <= 10^5",
      "0 <= hours[i] <= 168",
      "0 <= limit <= 10^6"
    ],
    "examples": [
      {
        "input": "hours = [40, 30, 50, 20, 60], limit = 100",
        "output": "3",
        "explanation": "You can work the first three weeks (40 + 30 + 50 = 120 exceeds limit) or the last three weeks (30 + 50 + 20 = 100 equals limit). So, the answer is 3."
      },
      {
        "input": "hours = [10, 20, 30, 40], limit = 100",
        "output": "4",
        "explanation": "You can work all four weeks since the total (10 + 20 + 30 + 40 = 100) equals the limit."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window to sum the hours.",
      "Shrink the window when the sum exceeds the limit."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Linked List Cycle",
    "description": "Given a linked list, determine if it has a cycle in it. A cycle is a situation where a node's next pointer points to one of the previous nodes in the list. Your task is to implement a function that returns true if there is a cycle in the linked list and false otherwise.",
    "topic": "Linked List",
    "subtopic": "Cycle Detection",
    "tags": [
      "Linked List",
      "Cycle Detection",
      "Two Pointers"
    ],
    "input_format": "The input consists of a linked list node.",
    "output_format": "Return a boolean value: true if there is a cycle, false otherwise.",
    "constraints": [
      "The number of nodes in the linked list will not exceed 10^4.",
      "Each node's value will be unique."
    ],
    "examples": [
      {
        "input": "head = [3,2,0,-4], pos = 1",
        "output": "true",
        "explanation": "The linked list contains a cycle because the tail connects to the second node."
      },
      {
        "input": "head = [1,2], pos = 0",
        "output": "true",
        "explanation": "The linked list contains a cycle because the tail connects to the first node."
      },
      {
        "input": "head = [1], pos = -1",
        "output": "false",
        "explanation": "The linked list does not contain a cycle since a single node points to null."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use the Floyd's Tortoise and Hare algorithm for cycle detection."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Max Consecutive Ones III",
    "description": "Given a binary array nums and an integer k, you can flip at most k 0's to 1's. Return the maximum number of consecutive 1's in the array after flipping.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Two Pointers"
    ],
    "input_format": "A binary array nums and an integer k.",
    "output_format": "An integer representing the maximum number of consecutive 1's.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "nums[i] is either 0 or 1",
      "0 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [1,1,0,0,1,1,1,0,1], k = 1",
        "output": "5",
        "explanation": "By flipping the first 0, the array becomes [1,1,1,0,1,1,1,0,1], yielding 5 consecutive 1's."
      },
      {
        "input": "nums = [0,0,0,0,0], k = 2",
        "output": "2",
        "explanation": "By flipping any two 0's, we can have a maximum of 2 consecutive 1's."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window approach to keep track of the count of 0's flipped.",
      "Adjust the left pointer of the window when the number of flipped 0's exceeds k."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Coin Change",
    "description": "You are given an integer array 'coins' representing coins of different denominations and an integer 'amount' representing a total amount of money. You want to determine the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.",
    "topic": "Dynamic Programming",
    "subtopic": "Coin Change Problem",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Optimization"
    ],
    "input_format": "An array of integers 'coins' representing the denominations and an integer 'amount' representing the total amount.",
    "output_format": "An integer representing the fewest number of coins needed to make up the amount or -1 if it is not possible.",
    "constraints": [
      "1 <= coins.length <= 12",
      "1 <= coins[i] <= 2^31 - 1",
      "0 <= amount <= 10^4"
    ],
    "examples": [
      {
        "input": "coins = [1, 2, 5], amount = 11",
        "output": "3",
        "explanation": "11 can be made up by using 2 coins of 5 and 1 coin of 1: 5 + 5 + 1 = 11."
      },
      {
        "input": "coins = [2], amount = 3",
        "output": "-1",
        "explanation": "It is not possible to make amount 3 using only the coin of denomination 2."
      },
      {
        "input": "coins = [1], amount = 0",
        "output": "0",
        "explanation": "No coins are needed to make amount 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about using a dynamic programming approach to build up the solution.",
      "You may want to use a table to store the minimum coins needed for each amount up to the target."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Binary Search Tree to Greater Sum Tree",
    "description": "Given a Binary Search Tree (BST), convert it to a Greater Sum Tree (GST) where each node's value is replaced by the sum of all values greater than or equal to the node's value in the original BST. This transformation should be done in place. The left and right subtree values should not be changed during the conversion.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "BST",
      "Recursion"
    ],
    "input_format": "The input is the root node of a binary search tree.",
    "output_format": "Return the root node of the transformed greater sum tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root = [4,1,6,0,2,5,7,3]",
        "output": "[30,36,21,36,35,26,15,0]",
        "explanation": "For each node, calculate the sum of node values greater than or equal to its value in the original BST."
      },
      {
        "input": "root = [0]",
        "output": "[0]",
        "explanation": "Since there is only one node, the value remains the same."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a reverse in-order traversal to accumulate sums.",
      "Keep track of the running total as you traverse the tree."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "LRU Cache",
    "description": "Design and implement a data structure for a Least Recently Used (LRU) Cache. It should support the following operations: get and put. The get method should retrieve the value of the key if the key exists in the cache. If the key does not exist, return -1. The put method should add the key-value pair to the cache. If the number of keys exceeds the capacity, it should invalidate the least recently used key.",
    "topic": "Data Structure",
    "subtopic": "Cache Implementation",
    "tags": [
      "Data Structure",
      "Cache",
      "LRU"
    ],
    "input_format": "The cache is initialized with a positive capacity.",
    "output_format": "Return the value associated with a key or -1 if the key does not exist.",
    "constraints": [
      "1 <= capacity <= 3000",
      "0 <= key, value <= 104"
    ],
    "examples": [
      {
        "input": "cache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\ncache.get(1)",
        "output": "1",
        "explanation": "The value for key 1 is 1."
      },
      {
        "input": "cache.put(3, 3)\ncache.get(2)",
        "output": "-1",
        "explanation": "Key 2 was evicted, so the output is -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a combination of a hash map and a doubly linked list.",
      "The head of the linked list can represent the most recently used item.",
      "Maintain the order of nodes to efficiently track the least recently used item."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Word Break",
    "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.",
    "topic": "Dynamic Programming",
    "subtopic": "String Segmentation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Backtracking"
    ],
    "input_format": "A string s representing the input string and a list of strings wordDict representing the dictionary.",
    "output_format": "A boolean value indicating whether the string can be segmented into words from the dictionary.",
    "constraints": [
      "1 <= s.length <= 300",
      "0 <= wordDict.length <= 1000",
      "1 <= wordDict[i].length <= 20",
      "s and all the strings in wordDict consist of lowercase English letters.",
      "All the strings in wordDict are unique."
    ],
    "examples": [
      {
        "input": "s = 'leetcode', wordDict = ['leet', 'code']",
        "output": "true",
        "explanation": "The string 'leetcode' can be segmented as 'leet code'."
      },
      {
        "input": "s = 'applepenapple', wordDict = ['apple', 'pen']",
        "output": "true",
        "explanation": "The string 'applepenapple' can be segmented as 'apple pen apple'."
      },
      {
        "input": "s = 'catsandog', wordDict = ['cats', 'dog', 'sand', 'and', 'cat']",
        "output": "false",
        "explanation": "The string 'catsandog' cannot be segmented into words from the given dictionary."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to keep track of segmentation results.",
      "Use a boolean array to represent the valid segmentations."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Sqrt(x)",
    "description": "Implement a function that computes the square root of a non-negative integer x, without using any built-in square root functions. The result should be the largest integer y such that y * y <= x.",
    "topic": "Math",
    "subtopic": "Binary Search",
    "tags": [
      "Math",
      "Binary Search",
      "Integer"
    ],
    "input_format": "A non-negative integer x.",
    "output_format": "An integer representing the largest integer y such that y * y <= x.",
    "constraints": [
      "0 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 4",
        "output": "2",
        "explanation": "The square root of 4 is 2 since 2 * 2 = 4."
      },
      {
        "input": "x = 8",
        "output": "2",
        "explanation": "The largest integer y such that y * y <= 8 is 2 because 2 * 2 = 4 and 3 * 3 = 9 which is greater than 8."
      },
      {
        "input": "x = 0",
        "output": "0",
        "explanation": "The square root of 0 is 0."
      },
      {
        "input": "x = 1",
        "output": "1",
        "explanation": "The square root of 1 is 1 since 1 * 1 = 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using binary search to find the integer square root."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Maximum Employees to Be Invited to a Meeting",
    "description": "You are given a list of employees with their availability to attend a meeting, represented as pairs of start and end times. Your task is to determine the maximum number of employees that can be invited to the meeting at any given time, ensuring that no two employees have overlapping schedules. Each employee's availability is defined by a tuple (start_time, end_time). You must find the optimal time slot to maximize attendance.",
    "topic": "Interval Scheduling",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Greedy",
      "Interval Scheduling",
      "Sorting"
    ],
    "input_format": "A list of tuples where each tuple contains two integers representing the start and end time of an employee's availability.",
    "output_format": "An integer representing the maximum number of employees that can attend the meeting at the same time.",
    "constraints": [
      "1 <= availability.length <= 10^5",
      "0 <= availability[i][0] < availability[i][1] <= 10^9"
    ],
    "examples": [
      {
        "input": "availability = [(1, 5), (2, 3), (4, 6), (7, 8)]",
        "output": "2",
        "explanation": "The optimal time to invite employees is between 2 and 3 where only the first two employees overlap."
      },
      {
        "input": "availability = [(10, 20), (15, 25), (20, 30), (30, 40)]",
        "output": "3",
        "explanation": "The maximum overlap happens between 10 to 20 where the first three employees are available."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider sorting the availability intervals by their start times.",
      "Use a greedy approach to keep track of overlapping intervals."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Valid Perfect Square",
    "description": "Given a positive integer num, determine if it is a perfect square. A perfect square is an integer that is the square of an integer. For example, 1, 4, 9, 16, 25 are perfect squares. You must implement a function that determines if num is a perfect square without using built-in square root functions.",
    "topic": "Math",
    "subtopic": "Binary Search",
    "tags": [
      "Math",
      "Binary Search",
      "Number Theory"
    ],
    "input_format": "A single positive integer num.",
    "output_format": "A boolean value indicating whether num is a perfect square.",
    "constraints": [
      "1 <= num <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "num = 16",
        "output": "true",
        "explanation": "16 is a perfect square because 4 * 4 = 16."
      },
      {
        "input": "num = 14",
        "output": "false",
        "explanation": "14 is not a perfect square since there is no integer that when multiplied by itself equals 14."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Try using binary search to find the square root."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Fibonacci Number",
    "description": "Given an integer n, return the nth Fibonacci number. The Fibonacci sequence is defined as follows: F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n >= 2. Your task is to implement a function that efficiently computes the nth Fibonacci number.",
    "topic": "Dynamic Programming",
    "subtopic": "Recursion",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Math"
    ],
    "input_format": "An integer n (0 <= n <= 30).",
    "output_format": "An integer representing the nth Fibonacci number.",
    "constraints": [
      "0 <= n <= 30"
    ],
    "examples": [
      {
        "input": "n = 5",
        "output": "5",
        "explanation": "The Fibonacci sequence is 0, 1, 1, 2, 3, 5. Therefore, F(5) = 5."
      },
      {
        "input": "n = 10",
        "output": "55",
        "explanation": "The Fibonacci sequence up to 10 is 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55. Therefore, F(10) = 55."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using recursion to express the Fibonacci definition.",
      "You can improve performance with memoization.",
      "Iterative methods can also be used for better space efficiency."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Monotone Increasing Digits",
    "description": "Given a non-negative integer N, find the largest number that is less than or equal to N and is monotone increasing. A number is said to be monotone increasing if each digit is not greater than the digit to its right. For example, 123 and 1357 are monotone increasing, but 321 is not.",
    "topic": "Math",
    "subtopic": "Number Manipulation",
    "tags": [
      "Math",
      "Greedy",
      "String"
    ],
    "input_format": "A single integer N (0 <= N <= 10^9)",
    "output_format": "An integer representing the largest monotone increasing number less than or equal to N.",
    "constraints": [
      "0 <= N <= 10^9"
    ],
    "examples": [
      {
        "input": "N = 10",
        "output": "9",
        "explanation": "The largest monotone increasing number less than or equal to 10 is 9."
      },
      {
        "input": "N = 1234",
        "output": "1234",
        "explanation": "1234 is already a monotone increasing number."
      },
      {
        "input": "N = 332",
        "output": "299",
        "explanation": "The largest monotone increasing number less than 332 is 299."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Check digit by digit from the left to the right.",
      "When a digit is greater than the next, decrement it and set the following digits to 9."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Maximum Depth of Binary Tree",
    "description": "Given a binary tree, return its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Depth",
      "Binary Tree"
    ],
    "input_format": "The input to the function is the root node of the binary tree.",
    "output_format": "An integer representing the maximum depth of the binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4]",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "3",
        "explanation": "The longest path from the root node '3' to the leaf nodes '15' or '7' comprises 3 nodes: 3 -> 20 -> 15 or 3 -> 20 -> 7."
      },
      {
        "input": "root = [1,null,2]",
        "output": "2",
        "explanation": "The longest path is from the root node '1' to the leaf node '2', which comprises 2 nodes."
      },
      {
        "input": "root = []",
        "output": "0",
        "explanation": "An empty tree has a maximum depth of 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use recursion to explore each branch of the tree.",
      "The maximum depth can be found by comparing depths of each subtree."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Sort Array by Increasing Frequency",
    "description": "Given an array of integers, sort the elements by their frequency in increasing order. If two elements have the same frequency, sort them by their value in ascending order.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Frequency"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An array of integers sorted by increasing frequency.",
    "constraints": [
      "1 <= nums.length <= 100",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2, 2, 3]",
        "output": "[3, 1, 1, 2, 2]",
        "explanation": "The frequency of numbers is {1: 2, 2: 2, 3: 1}. 3 appears once, 1 and 2 appear twice."
      },
      {
        "input": "nums = [2, 3, 1, 2, 3, 3]",
        "output": "[1, 2, 2, 3, 3, 3]",
        "explanation": "The frequency of numbers is {2: 2, 3: 3, 1: 1}. 1 appears once, 2 appears twice, 3 appears thrice."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hashmap to count the frequency of each number.",
      "Sort the array based on frequency and value."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Rotate String",
    "description": "Given two strings s and goal, you need to determine if you can obtain the string goal by rotating the string s. A rotation means moving characters from the beginning of the string to the end. For example, the rotations of 'abc' are: 'abc', 'bca', and 'cab'.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Rotation",
      "Two Pointers"
    ],
    "input_format": "Two strings s and goal, each with length n.",
    "output_format": "A boolean value: true if goal can be obtained from s by rotation, otherwise false.",
    "constraints": [
      "1 <= s.length, goal.length <= 100",
      "s and goal consist of lowercase English letters only."
    ],
    "examples": [
      {
        "input": "s = 'abc', goal = 'bca'",
        "output": "true",
        "explanation": "'bca' is a rotation of 'abc'."
      },
      {
        "input": "s = 'abc', goal = 'cab'",
        "output": "true",
        "explanation": "'cab' is a rotation of 'abc'."
      },
      {
        "input": "s = 'abc', goal = 'acb'",
        "output": "false",
        "explanation": "'acb' cannot be obtained by rotating 'abc'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Concatenate the string s to itself and check if goal is a substring.",
      "Consider using the substring method to simplify the checks."
    ],
    "company": "SAP"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase. Return the grouped anagrams as a list of lists, where each inner list contains all the anagrams that can be formed from the letters in the words provided.",
    "topic": "String",
    "subtopic": "Hashing",
    "tags": [
      "String",
      "Hashing",
      "Anagram"
    ],
    "input_format": "An array of strings `strs` where 1 <= strs.length <= 10^4 and 0 <= strs[i].length <= 100.",
    "output_format": "A list of lists, where each inner list contains strings that are anagrams of each other.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "All input strings are lowercase alphabets."
    ],
    "examples": [
      {
        "input": "strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
        "output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
        "explanation": "The first group contains the anagrams \"eat\", \"tea\", and \"ate\". The second group includes \"tan\" and \"nat\", and finally, \"bat\" forms its own group."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "Only one string which is an empty string, thus forms a single group."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "Only one single-character string, hence forms its own group."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting each string to compare them.",
      "Use a hashmap to group sorted strings together."
    ],
    "company": "SAP"
  }
]