[
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "Matrix"
    ],
    "input_format": "A 2D grid represented as a list of lists of characters, where each element is '1' or '0'.",
    "output_format": "An integer representing the number of islands in the grid.",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[i].length <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "[['1','1','1','1','0'], ['1','1','0','1','0'], ['1','1','0','0','0'], ['0','0','0','0','0']]",
        "output": "1",
        "explanation": "There is one island formed by the land in the first three rows."
      },
      {
        "input": "[['1','1','0','0','0'], ['1','1','0','0','0'], ['0','0','1','0','0'], ['0','0','0','1','1']]",
        "output": "3",
        "explanation": "Three separate islands are formed by the clusters of '1's."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth-First Search (DFS) to explore each island.",
      "You can mark visited '1's as '0' to avoid counting them again."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Video Stitching",
    "description": "You are given an array of video clips, where each clip is represented by a start and an end time. Your goal is to determine the minimum number of clips required to stitch together a continuous video from time 0 to time T. Each clip can be used only once. If it is not possible to create such a video, return -1.",
    "topic": "Greedy",
    "subtopic": "Interval Scheduling",
    "tags": [
      "Greedy",
      "Dynamic Programming",
      "Interval"
    ],
    "input_format": "An array clips of length n, where each clip is represented by an array of two integers [start, end], followed by an integer T.",
    "output_format": "An integer representing the minimum number of clips needed, or -1 if it is not possible.",
    "constraints": [
      "1 <= clips.length <= 100",
      "0 <= clips[i][0] < clips[i][1] <= 100",
      "0 <= T <= 100"
    ],
    "examples": [
      {
        "input": "clips = [[0, 2], [2, 3], [1, 5], [5, 7]], T = 5",
        "output": "2",
        "explanation": "We can use clips [0, 2] and [2, 3] to cover the range from 0 to 5, thus 2 clips are required."
      },
      {
        "input": "clips = [[0, 1], [1, 2]], T = 5",
        "output": "-1",
        "explanation": "It's not possible to cover the range from 0 to 5 using the given clips."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the farthest point you can reach with the current clips.",
      "Sort the clips based on the start time."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Maximum Number of Visible Points",
    "description": "You are given a set of points on a 2D plane and an angle in degrees. The goal is to determine the maximum number of points that can be observed from the origin (0, 0) within the given angle. Points can be transformed to their polar angles, and the observation is limited to a cone defined by the given angle.",
    "topic": "Geometry",
    "subtopic": "Polar Coordinates",
    "tags": [
      "Geometry",
      "Sorting",
      "Two Pointers"
    ],
    "input_format": "A list of points represented as pairs of integers [x, y] and a single integer angle.",
    "output_format": "An integer representing the maximum number of visible points.",
    "constraints": [
      "1 <= points.length <= 10^5",
      "-10^4 <= points[i][0], points[i][1] <= 10^4",
      "0 <= angle <= 360"
    ],
    "examples": [
      {
        "input": "points = [[2,1],[2,2],[3,3]], angle = 90",
        "output": "3",
        "explanation": "All three points can be seen within an angle of 90 degrees from the x-axis."
      },
      {
        "input": "points = [[1,0],[2,1],[2,2],[3,3]], angle = 45",
        "output": "2",
        "explanation": "Only the points [1,0] and [2,1] can be observed within the 45-degree angle."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider converting Cartesian coordinates to polar coordinates.",
      "Use sorting based on angles for efficient visibility checking.",
      "Utilize the two-pointer technique to maintain the valid range of visible points."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "topic": "String",
    "subtopic": "Sorting",
    "tags": [
      "String",
      "Hash Table",
      "Sorting"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A list of groups, where each group is a list of anagrams.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase English letters"
    ],
    "examples": [
      {
        "input": "strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "explanation": "The output groups the anagrams together; 'bat' does not have any anagrams in the input."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "A single empty string is an anagram of itself."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "A single character string is an anagram of itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash table to group the strings.",
      "Sorting the characters in each string could help in identifying anagrams."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Shortest Word Distance",
    "description": "Given a list of strings words and two strings word1 and word2, return the shortest distance between the indices of word1 and word2 in the list. If either word does not exist in the list, return -1. Note that word1 and word2 may be the same and you need to consider the same indices for calculating the distance.",
    "topic": "Hash Table",
    "subtopic": "Indexing",
    "tags": [
      "String",
      "Hash Table",
      "Searching"
    ],
    "input_format": "A list of strings words, and two strings word1 and word2.",
    "output_format": "An integer representing the shortest distance between word1 and word2 in the list.",
    "constraints": [
      "1 <= words.length <= 3 * 10^4",
      "1 <= words[i].length <= 20",
      "words[i] consists of lowercase English letters.",
      "word1 and word2 are both non-empty strings."
    ],
    "examples": [
      {
        "input": "words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"coding\", word2 = \"practice\"",
        "output": "3",
        "explanation": "The shortest distance between 'coding' and 'practice' is 3."
      },
      {
        "input": "words = [\"a\", \"b\", \"a\"], word1 = \"a\", word2 = \"b\"",
        "output": "1",
        "explanation": "The shortest distance between 'a' and 'b' is 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a single pass to track the indices of both words.",
      "Calculate the distance every time you find one of the words."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Heaters",
    "description": "You are given an array of houses as positions on a line, and an integer array representing the positions of heaters. Each house can be warmed by a heater if the distance between the house and the heater is less than or equal to a given radius. Your task is to determine the minimum radius required to ensure that all houses are warmed. If multiple heaters are within the radius of a house, the house will be warmed by the nearest heater.",
    "topic": "Binary Search",
    "subtopic": "Searching",
    "tags": [
      "Binary Search",
      "Array",
      "Greedy"
    ],
    "input_format": "An array of integers houses and an array of integers heaters representing the positions of the houses and heaters respectively.",
    "output_format": "An integer representing the minimum radius required to warm all houses.",
    "constraints": [
      "1 <= houses.length, heaters.length <= 10^4",
      "0 <= houses[i], heaters[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "houses = [1, 2, 3, 4, 5], heaters = [1, 4]",
        "output": "1",
        "explanation": "Heater at position 1 can warm houses at positions 1 and 2, while heater at position 4 can warm houses at positions 4 and 5. The maximum radius needed is 1."
      },
      {
        "input": "houses = [1, 2, 3, 5, 15], heaters = [2, 30]",
        "output": "13",
        "explanation": "Heater at position 2 can warm houses at positions 1, 2, and 3. Heater at position 30 can warm house at position 15. The maximum radius needed is (15 - 2) = 13."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the heaters array.",
      "Binary search can be useful to find the closest heater for each house."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Course Schedule",
    "description": "You have a list of courses you want to take, and for each course, there are prerequisites that need to be completed before enrolling in that course. Your task is to determine if it is possible to finish all courses given the list of prerequisites. Represent the courses as a graph and use topological sorting to check for cycles in the graph.",
    "topic": "Graph",
    "subtopic": "Topological Sorting",
    "tags": [
      "Graph",
      "Topological Sorting",
      "DFS",
      "BFS"
    ],
    "input_format": "An integer numCourses representing the total number of courses, followed by a list of prerequisite pairs where each pair [a, b] indicates that course b must be completed before course a.",
    "output_format": "A boolean value indicating whether all courses can be finished.",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= prerequisites[i][0], prerequisites[i][1] < numCourses"
    ],
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = [[1, 0]]",
        "output": "true",
        "explanation": "You can take course 0 before course 1, so it's possible to finish all courses."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1, 0], [0, 1]]",
        "output": "false",
        "explanation": "There is a cycle between courses 0 and 1, meaning not all courses can be finished."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a graph representation.",
      "Check for cycles in the directed graph."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Daily Temperatures",
    "description": "Given an array of integers representing daily temperatures, return an array such that each element at index i represents the number of days you have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.",
    "topic": "Array",
    "subtopic": "Stack",
    "tags": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "input_format": "An array of integers temperatures where 1 <= temperatures.length <= 30000 and 30 <= temperatures[i] <= 100.",
    "output_format": "An array of integers representing the number of days to wait for a warmer temperature.",
    "constraints": [
      "1 <= temperatures.length <= 30000",
      "30 <= temperatures[i] <= 100"
    ],
    "examples": [
      {
        "input": "temperatures = [73, 74, 75, 71, 69, 72, 76, 73]",
        "output": "[1, 1, 4, 2, 1, 1, 0, 0]",
        "explanation": "For each day, we compute the number of days until a warmer temperature. E.g., the first day (73) has to wait 1 day for a warmer temperature (74)."
      },
      {
        "input": "temperatures = [30, 40, 50, 60]",
        "output": "[1, 1, 1, 0]",
        "explanation": "Each day has a warmer temperature on the next day."
      },
      {
        "input": "temperatures = [80, 70, 60, 50]",
        "output": "[0, 0, 0, 0]",
        "explanation": "There are no days with a warmer temperature."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to keep track of indices of temperatures.",
      "Iterate through the temperatures array from the end to the beginning.",
      "If the current temperature is higher than the temperature at the index at the top of the stack, it's a candidate for a warmer day."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Find Median from Data Stream",
    "description": "Design a data structure that supports the following two operations: adding a number to the data stream and retrieving the median of all elements in the data stream. The median is the middle value in an ordered list of numbers. If the list contains an even number of elements, the median is the average of the two middle values.",
    "topic": "Design",
    "subtopic": "Data Structure",
    "tags": [
      "Heap",
      "Data Structure",
      "Median"
    ],
    "input_format": "A series of integers that represent the numbers added to a data stream, and a call to the median function.",
    "output_format": "A floating-point number representing the median of all added numbers.",
    "constraints": [
      "1 <= numbers.length <= 10^5",
      "-10^5 <= numbers[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "addNum(1), addNum(2), findMedian()",
        "output": "1.5",
        "explanation": "The numbers added are 1 and 2. The median is (1 + 2) / 2 = 1.5."
      },
      {
        "input": "addNum(3), findMedian()",
        "output": "2",
        "explanation": "The numbers are 1, 2, and 3. The median is 2."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using two heaps to maintain the lower and upper halves of the numbers.",
      "The median can be found easily if you maintain both heaps correctly."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Course Schedule II",
    "description": "A university is planning to build a course schedule for its students. Some courses have prerequisites, and a student can only take a course if they have completed all their prerequisites. Your task is to determine a valid order in which the courses can be completed. If it is not possible to finish all courses, return an empty array. You must represent the courses and their prerequisites as a directed graph.",
    "topic": "Graph",
    "subtopic": "Topological Sorting",
    "tags": [
      "Graph",
      "Topological Sort",
      "DFS"
    ],
    "input_format": "An integer numCourses representing the total number of courses, and an array of pairs prerequisites where each pair [a, b] indicates that course a is a prerequisite for course b.",
    "output_format": "An array of integers representing the order of courses to complete or an empty array if it is not possible.",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2"
    ],
    "examples": [
      {
        "input": "numCourses = 4, prerequisites = [[2,0],[1,0],[3,1],[3,2]]",
        "output": "[0,1,2,3]",
        "explanation": "The order [0,1,2,3] indicates that course 0 must be taken before course 1 and 2, and course 1 and 2 must be taken before course 3."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
        "output": "[]",
        "explanation": "The courses are in a cycle and cannot be completed. Hence, return an empty array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a graph structure to represent courses and prerequisites.",
      "Consider using Kahn's algorithm for topological sorting.",
      "Track the in-degree of each node to help identify the order."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Search Suggestions System",
    "description": "You are tasked with implementing a search suggestions system for a given set of products. Given a list of product names and a search query, return a list of suggested products based on the characters typed so far in the query. Each time a new character is added, the suggestions should be refreshed with lexicographically sorted suggestions that begin with the current input string. If no suggestions exist for a particular query, return an empty list.",
    "topic": "String",
    "subtopic": "Searching and Sorting",
    "tags": [
      "String",
      "Search",
      "Sorting",
      "Autocomplete"
    ],
    "input_format": "A list of product names and a string query.",
    "output_format": "A list of lists of suggested products for each character in the query.",
    "constraints": [
      "1 <= products.length <= 1000",
      "1 <= products[i].length <= 100",
      "All characters in products are lowercase English letters.",
      "1 <= query.length <= 100"
    ],
    "examples": [
      {
        "input": {
          "products": [
            "mobile",
            "mouse",
            "moneypot",
            "monitor",
            "mousepad"
          ],
          "query": "mouse"
        },
        "output": [
          [
            "mobile",
            "moneypot",
            "monitor",
            "mouse",
            "mousepad"
          ],
          [
            "mobile",
            "moneypot",
            "monitor",
            "mouse",
            "mousepad"
          ],
          [
            "mobile",
            "moneypot",
            "monitor",
            "mouse",
            "mousepad"
          ],
          [
            "mouse",
            "mousepad"
          ],
          [
            "mouse",
            "mousepad"
          ]
        ],
        "explanation": "Suggestions update with each character typed in the query, providing matching product names."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sorted data structure for efficient searching.",
      "Keep track of suggestions dynamically as the query is typed."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Making A Large Island",
    "description": "You are given a 2D grid representing a map where 0s represent water and 1s represent land. Your task is to find the size of the largest island that can be formed by connecting neighboring land cells (1s) through four possible directions: up, down, left, and right. An island is considered large if it can be expanded with adjacent water cells (0s) by flipping them to land (1s). Return the size of the largest possible island after performing this operation.",
    "topic": "Depth-First Search",
    "subtopic": "Grid Traversal",
    "tags": [
      "Depth-First Search",
      "Grid",
      "Island"
    ],
    "input_format": "A 2D integer grid where grid[i][j] is either 0 or 1.",
    "output_format": "An integer representing the size of the largest island after making the allowed conversions.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 50",
      "grid[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "grid = [[1, 0], [0, 1]]",
        "output": "3",
        "explanation": "By flipping the water cell (0, 0) or (1, 1) to land, we can form an island of size 3."
      },
      {
        "input": "grid = [[1, 1], [1, 0]]",
        "output": "4",
        "explanation": "By flipping the water cell (1, 1) to land, the entire grid becomes land, resulting in a size of 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use DFS or BFS to explore the connected components of land.",
      "Keep track of the size of each island as you explore.",
      "Consider the water cells that can be flipped to maximize the island size."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals and return an array of the non-overlapping intervals that cover all the intervals in the input.",
    "topic": "Array",
    "subtopic": "Sorting and Merging",
    "tags": [
      "Array",
      "Sorting",
      "Intervals",
      "Merge"
    ],
    "input_format": "An array of intervals, where each interval is represented as a pair of integers [start, end].",
    "output_format": "An array of merged intervals.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= start_i <= end_i <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "The intervals [1,3] and [2,6] overlap, so they can be merged into [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "The intervals [1,4] and [4,5] touch and can be merged into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals by their start times.",
      "Use a list to keep track of the merged intervals."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of k linked-lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. The resulting linked-list should also be sorted.",
    "topic": "Linked List",
    "subtopic": "Merge Techniques",
    "tags": [
      "Linked List",
      "Merge",
      "Sorting"
    ],
    "input_format": "An array of k linked-lists represented as arrays, where each nested array is the values of the linked-list elements.",
    "output_format": "The head of the merged sorted linked-list represented as a linked-list.",
    "constraints": [
      "0 <= k <= 10^4",
      "0 <= List[i].length <= 500",
      "-10^4 <= List[i][j] <= 10^4",
      "Lists are sorted in ascending order."
    ],
    "examples": [
      {
        "input": "[[1, 4, 5], [1, 3, 4], [2, 6]]",
        "output": "[1, 1, 2, 3, 4, 4, 5, 6]",
        "explanation": "Merging the three linked lists results in a single sorted linked list: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6."
      },
      {
        "input": "[]",
        "output": "[]",
        "explanation": "An empty list of linked-lists should return an empty linked-list."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a priority queue to manage the heads of the k lists.",
      "Consider handling the edge cases when one or more lists are empty."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Shortest Word Distance II",
    "description": "Design a data structure that supports the following two operations: adding a new word and finding the shortest distance between any two words in the data structure. Implement the methods to achieve efficient performance.",
    "topic": "Data Structure",
    "subtopic": "Design",
    "tags": [
      "Dictionary",
      "Design",
      "String"
    ],
    "input_format": "A series of operations: addWord(word: string), and shortest(word1: string, word2: string): integer.",
    "output_format": "An integer representing the shortest distance between the two specified words.",
    "constraints": [
      "The number of calls to addWord will be at most 10000.",
      "The number of calls to shortest will be at most 5000.",
      "Each word consists of lowercase English letters.",
      "Each word is unique."
    ],
    "examples": [
      {
        "input": "addWord(\"practice\"); addWord(\"makes\"); addWord(\"perfect\"); shortest(\"practice\", \"perfect\");",
        "output": "2",
        "explanation": "The shortest distance between \"practice\" and \"perfect\" is 2 (i.e., the distance to \"makes\")."
      },
      {
        "input": "addWord(\"hello\"); addWord(\"world\"); shortest(\"hello\", \"world\");",
        "output": "1",
        "explanation": "The distance between \"hello\" and \"world\" is 1 since they are added consecutively."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to store the words and their indices.",
      "Using a list or a dictionary could be helpful.",
      "Think about how to compute the distances efficiently."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Flip Equivalent Binary Trees",
    "description": "Given two binary trees, determine if they are flip equivalent. Two trees are considered flip equivalent if they can be made the same by performing a series of flips, where a flip means swapping the left and right children of any node in either tree. The trees do not need to be identical; rather, they should have the same structure after any number of flips.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Recursion"
    ],
    "input_format": "Two binary trees represented as root nodes.",
    "output_format": "A boolean value indicating whether the two binary trees are flip equivalent.",
    "constraints": [
      "The number of nodes in each tree will not exceed 100.",
      "Node values are distinct integers."
    ],
    "examples": [
      {
        "input": "tree1 = [1, 2, 3], tree2 = [1, 3, 2]",
        "output": "true",
        "explanation": "The second tree can be obtained from the first tree by flipping the children of the root node."
      },
      {
        "input": "tree1 = [1, 2], tree2 = [1, null, 2]",
        "output": "false",
        "explanation": "The structure of both trees cannot match through any series of flips."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider recursively checking the left and right children after potential flips.",
      "Use a helper function to handle the recursion and check structure."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Basic Calculator II",
    "description": "Implement a basic calculator to evaluate a simple expression string containing non-negative integers, '+', '-', '*', and '/' operators. The expression must be evaluated following the order of operations (multiplication and division before addition and subtraction). Return the result as an integer. The input expression is guaranteed to be valid.",
    "topic": "Mathematics",
    "subtopic": "Expression Evaluation",
    "tags": [
      "Math",
      "String",
      "Evaluation"
    ],
    "input_format": "A string expression containing non-negative integers and operators (+, -, *, /).",
    "output_format": "An integer representing the evaluated result of the expression.",
    "constraints": [
      "The expression contains only non-negative integers and operators.",
      "The length of the expression will not exceed 10^5."
    ],
    "examples": [
      {
        "input": "s = '3+2*2'",
        "output": "7",
        "explanation": "First, we multiply 2 * 2 = 4, then add 3 + 4 = 7."
      },
      {
        "input": "s = ' 3/2 '",
        "output": "1",
        "explanation": "3 divided by 2 is 1.5, but since we return an integer, the result is 1."
      },
      {
        "input": "s = '3+5 / 2 '",
        "output": "5",
        "explanation": "First, we divide 5 by 2 to get 2, then add 3 to get 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to help with the operations.",
      "Make sure to handle integer division properly."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order. Starting from the top-left corner of the matrix, you will traverse the matrix in a spiral pattern moving right, down, left, and up continually until all elements have been visited.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral",
      "Algorithm"
    ],
    "input_format": "A 2D list of integers representing the matrix.",
    "output_format": "A list of integers representing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "m * n <= 10^6",
      "-10^5 <= matrix[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The spiral order traversal is: 1 \u2192 2 \u2192 3 \u2192 6 \u2192 9 \u2192 8 \u2192 7 \u2192 4 \u2192 5."
      },
      {
        "input": "matrix = [[1]]",
        "output": "[1]",
        "explanation": "There's only one element to return."
      },
      {
        "input": "matrix = [[1, 2], [3, 4]]",
        "output": "[1, 2, 4, 3]",
        "explanation": "The spiral order traversal is: 1 \u2192 2 \u2192 4 \u2192 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about the boundaries of the matrix and how they change as you traverse.",
      "Use four variables to keep track of the current boundaries: top, bottom, left, right.",
      "Continue the process until the boundaries cross."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Number of Distinct Islands",
    "description": "You are given a 2D grid of '1's (land) and '0's (water). An island is a group of '1's connected horizontally or vertically. Two islands are considered distinct if they can\u2019t be transformed into one another by any number of rotations or reflections. Your task is to count the number of distinct islands in the grid.",
    "topic": "Graph",
    "subtopic": "DFS/BFS",
    "tags": [
      "Grid",
      "DFS",
      "Island Count"
    ],
    "input_format": "A 2D grid represented as a list of lists, where each sublist contains '0's and '1's.",
    "output_format": "An integer representing the number of distinct islands.",
    "constraints": [
      "1 <= grid.length <= 50",
      "1 <= grid[i].length <= 50",
      "grid[i][j] is either '0' or '1'."
    ],
    "examples": [
      {
        "input": "grid = [[1,0,0,0],[0,1,0,1],[0,0,0,0],[0,1,0,1]]",
        "output": "2",
        "explanation": "There are two distinct islands formed by '1's."
      },
      {
        "input": "grid = [[1,1,0,0],[1,0,0,1],[0,0,1,1],[0,1,1,0]]",
        "output": "3",
        "explanation": "Three distinct islands are present."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using DFS or BFS to traverse the islands.",
      "Normalize the shape of each island to facilitate comparison.",
      "Use a set to store unique island shapes."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string s consisting of just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if the brackets are closed in the correct order. Every opening bracket must have a corresponding closing bracket of the same type.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A single string s containing characters '(', ')', '{', '}', '[' and '].",
    "output_format": "A boolean value indicating whether the brackets in the string are valid.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses only."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The string has one pair of parentheses, which are valid."
      },
      {
        "input": "s = '([{}])'",
        "output": "true",
        "explanation": "The string has valid nested parentheses."
      },
      {
        "input": "s = '(]'",
        "output": "false",
        "explanation": "The first opening bracket does not have a matching closing bracket."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Try using a stack to keep track of the opening brackets.",
      "For every closing bracket, check if it matches the top of the stack."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Minesweeper",
    "description": "You are given a 2D grid of 'M' mines (represented by 'M') and 'E' empty squares (represented by 'E'). You need to update the grid by calculating the number of mines adjacent to each empty square. An empty square can be adjacent to 8 squares (horizontally, vertically, and diagonally). After updating the grid, return the modified grid. The original grid will remain unchanged except for the updates at empty squares.",
    "topic": "Matrix",
    "subtopic": "Counting",
    "tags": [
      "Matrix",
      "Counting",
      "Grid"
    ],
    "input_format": "A 2D grid of characters where each character is either 'M' or 'E'.",
    "output_format": "A 2D grid with the same dimensions, where each 'E' is replaced with a number representing the count of adjacent mines.",
    "constraints": [
      "1 <= grid.length <= 50",
      "1 <= grid[0].length <= 50",
      "grid[i][j] is 'M' or 'E'."
    ],
    "examples": [
      {
        "input": "[['E', 'E', 'E'], ['E', 'M', 'E'], ['E', 'E', 'E']]",
        "output": "[['1', '1', '1'], ['1', 'M', '1'], ['E', 'E', 'E']]",
        "explanation": "The first square has one adjacent mine, the second square is a mine, and the other squares are empty."
      },
      {
        "input": "[['E', 'E', 'E'], ['E', 'E', 'E'], ['E', 'E', 'E']]",
        "output": "[['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0']]",
        "explanation": "There are no mines in the grid, hence all empty squares are represented with '0'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using delta arrays to represent the relative positions of adjacent squares.",
      "Iterate through each cell in the grid to effectively count the mines."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Rotting Oranges",
    "description": "You are given a grid of integers where each cell can have one of three values: 0 (empty cell), 1 (fresh orange), or 2 (rotten orange). Every minute, any fresh orange that is adjacent (horizontally or vertically) to a rotten orange will become rotten. Your task is to determine the minimum number of minutes that must elapse until no fresh oranges remain. If it is impossible to have all oranges rotten, return -1.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "Matrix"
    ],
    "input_format": "A 2D integer grid representing the cells of the grid.",
    "output_format": "An integer representing the minimum number of minutes until all oranges are rotten, or -1 if not possible.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 300",
      "grid[i][j] is 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "[[2,1,1],[1,1,0],[0,1,1]]",
        "output": "4",
        "explanation": "Initially, the rotten orange at (0,0) causes the oranges at (0,1), (1,0) to rot after 1 min, further causing (1,1) and (2,1) to rot after the second minute until all are rotten."
      },
      {
        "input": "[[2,1,1],[0,1,1],[1,0,2]]",
        "output": "-1",
        "explanation": "The orange at (2,2) cannot spread its rot to any fresh oranges, thus not all oranges can rot."
      },
      {
        "input": "[[0,2]]",
        "output": "0",
        "explanation": "No fresh oranges are present; hence, the result is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to simulate the rotting process.",
      "BFS is suitable for exploring levels (minutes) of rotting."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Move Zeroes",
    "description": "Given an array of integers, you need to move all the zeroes in the array to the end while maintaining the relative order of the non-zero elements. You must do this in-place without making a copy of the array.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "The modified array with all zeroes moved to the end.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [0, 1, 0, 3, 12]",
        "output": "[1, 3, 12, 0, 0]",
        "explanation": "Move the non-zero elements to the front and fill the rest with zeroes."
      },
      {
        "input": "nums = [0, 0, 1]",
        "output": "[1, 0, 0]",
        "explanation": "The only non-zero is 1, which should be moved to the front."
      },
      {
        "input": "nums = [1, 2, 3, 0, 0, 4, 0]",
        "output": "[1, 2, 3, 4, 0, 0, 0]",
        "explanation": "Move the non-zero elements (1, 2, 3, 4) to the front maintaining their order."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to track the position of non-zero elements.",
      "Iterate through the array, swapping zeroes with non-zero elements when found."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Time Based Key-Value Store",
    "description": "Design a time-based key-value data structure that can store multiple values for the same key at different timestamps. Implement the TimeMap class with the following methods: \n\n1. `set(key: str, value: str, timestamp: int)`: Stores the key with the value at the given timestamp. \n2. `get(key: str, timestamp: int) -> str`: Returns the value associated with the key at the given timestamp. If there is no value at that timestamp, the method should return the value associated with the key at the closest timestamp less than the given timestamp. If there is no such value, return an empty string.",
    "topic": "Data Structure",
    "subtopic": "Hash Map",
    "tags": [
      "Hash Map",
      "Design",
      "Data Structure"
    ],
    "input_format": "The input to the methods is a string key, a string value, and an integer timestamp for the set method, and a string key and an integer timestamp for the get method.",
    "output_format": "For the get method, return a string representing the value or an empty string.",
    "constraints": [
      "The number of calls to `set` and `get` will not exceed 1000.",
      "All timestamps are positive integers.",
      "The length of the key and value strings will not exceed 100."
    ],
    "examples": [
      {
        "input": "timeMap = TimeMap(); timeMap.set('foo', 'bar', 1); timeMap.get('foo', 1);",
        "output": "'bar'",
        "explanation": "At timestamp 1, the value for key 'foo' is 'bar'."
      },
      {
        "input": "timeMap.set('foo', 'bar', 2); timeMap.get('foo', 3);",
        "output": "'bar'",
        "explanation": "At timestamp 3, the latest value for key 'foo' before timestamp 3 is 'bar' at timestamp 2."
      },
      {
        "input": "timeMap.get('foo', 0);",
        "output": "''",
        "explanation": "There is no value for key 'foo' at or before timestamp 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map for storage.",
      "You may need to maintain a list of timestamps for each key."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Insert into a Sorted Circular Linked List",
    "description": "You are given a sorted circular linked list and a target value. Your task is to insert the target value into the list while maintaining its sorted order. The circular linked list can be imagined as a connected loop where the tail connects back to the head. You need to return the head of the modified list.",
    "topic": "Linked List",
    "subtopic": "Insertion Techniques",
    "tags": [
      "Linked List",
      "Insertion",
      "Circular List"
    ],
    "input_format": "The input consists of two parts: the head of the sorted circular linked list and an integer target representing the value to be inserted.",
    "output_format": "The function should return the head of the updated circular linked list.",
    "constraints": [
      "The linked list has at least one node.",
      "The value of each node in the linked list is unique.",
      "-10^5 <= target <= 10^5"
    ],
    "examples": [
      {
        "input": "head = [1, 3, 5], target = 2",
        "output": "[1, 2, 3, 5]",
        "explanation": "Inserting 2 in the correct position results in the list becoming [1, 2, 3, 5]."
      },
      {
        "input": "head = [3, 4, 5], target = 2",
        "output": "[2, 3, 4, 5]",
        "explanation": "Inserting 2 at the beginning maintains the sorted order resulting in [2, 3, 4, 5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the cases for inserting at the end or beginning.",
      "A circular linked list means you can traverse from any node to check conditions."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Find the Duplicate Number",
    "description": "Given an array of integers nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. You must not modify the input array and should use only constant extra space. Find the duplicate number by utilizing the given properties of the array.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Duplicate"
    ],
    "input_format": "An array of integers nums where nums.length == n + 1 and 1 <= nums[i] <= n.",
    "output_format": "An integer indicating the duplicate number in the array.",
    "constraints": [
      "1 <= n <= 10^5",
      "nums.length == n + 1",
      "1 <= nums[i] <= n"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 4, 2, 2]",
        "output": "2",
        "explanation": "The number 2 appears twice in the array."
      },
      {
        "input": "nums = [3, 1, 3, 4, 2]",
        "output": "3",
        "explanation": "The number 3 is duplicated in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a cycle detection algorithm.",
      "Think about the properties of the input constraints."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Snakes and Ladders",
    "description": "You are given a board that is represented as a 1D array of integers, where the value at each index denotes the position you can jump to when landing on that index. A value of -1 means there is no snake or ladder on that square. The board is made up of squares from 1 to n*n (where n is the length of the array). You start at square 1 and want to reach the last square in the minimum number of moves. Write a function to determine the minimum number of moves required to reach the last square. If it is not possible to reach the last square, return -1.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "Pathfinding"
    ],
    "input_format": "An integer array board of size n, representing the game board.",
    "output_format": "An integer representing the minimum number of moves to reach the last square, or -1 if it is not possible.",
    "constraints": [
      "1 <= board.length <= 100",
      "-1 <= board[i] <= board.length"
    ],
    "examples": [
      {
        "input": "board = [1, 2, -1, 3, -1, 4, -1, -1, -1, 5]",
        "output": "3",
        "explanation": "You can move from 1 to 2, then from 2 to 3, and finally land on square 5."
      },
      {
        "input": "board = [1, -1, 3, -1, 5, -1]",
        "output": "-1",
        "explanation": "There are no paths that lead to the last square."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using BFS to explore moves.",
      "Represent the board as a graph for easier traversal.",
      "Track visited nodes to prevent cycles."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. You are to search for a target value in this array. If found, return its index; otherwise, return -1. You may assume no duplicate exists in the array. Your solution should be optimized to run in O(log n) time complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An integer array, nums, that is rotated at some pivot and an integer target.",
    "output_format": "An integer representing the index of the target in the array, or -1 if the target is not found.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "nums is guaranteed to be rotated at some pivot.",
      "-10^4 <= nums[i] <= 10^4",
      "No duplicate elements exist in nums."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "The target value 0 is found at index 4."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "The target value 3 does not exist in the array."
      },
      {
        "input": "nums = [1], target = 0",
        "output": "-1",
        "explanation": "The target value 0 does not exist in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of the rotated array to apply binary search.",
      "Check which part of the array is sorted, and decide where to search next."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Game of Life",
    "description": "The Game of Life is a cellular automaton devised by the British mathematician John Horton Conway. It consists of a grid of cells that can be 'alive' or 'dead'. Each cell interacts with its eight neighbors using the following four rules (taken from the above diagram):\n\n1. Any live cell with fewer than two live neighbors dies as if caused by under-population.\n2. Any live cell with two or three live neighbors lives on to the next generation.\n3. Any live cell with more than three live neighbors dies, as if by over-population.\n4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nGiven a board representing the current state of the Game of Life, you need to update it in place to represent the next state of the Game of Life. The board is a 2D array where 0 represents a dead cell and 1 represents a live cell. You must not return a new board; it should be updated in place instead.\n\nImplement a function that modifies the board according to the rules of the Game of Life.",
    "topic": "Array",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "input_format": "A 2D array representing the board of the Game of Life.",
    "output_format": "The same board after applying the rules of the Game of Life.",
    "constraints": [
      "1 <= board.length, board[0].length <= 25",
      "board[i][j] is 0 or 1."
    ],
    "examples": [
      {
        "input": "[[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
        "output": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]",
        "explanation": "The state after one update following Game of Life rules."
      },
      {
        "input": "[[1,1],[1,0]]",
        "output": "[[1,1],[1,1]]",
        "explanation": "The state after one update applies the over-population rule."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a temporary state to avoid mutating the board while processing.",
      "Count neighbors efficiently by checking all surrounding cells."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Flatten Binary Tree to Linked List",
    "description": "Given the root of a binary tree, flatten the tree to a linked list in-place. The linked list should use the same tree nodes, and the values should follow the preorder traversal of the tree. After flattening, the left child of all nodes should be null and the right child should point to the next node in the list.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "DFS",
      "In-place"
    ],
    "input_format": "The root of a binary tree.",
    "output_format": "Nothing is returned. The tree is modified in place.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1, 2, 5, 3, 4, null, 6]",
        "output": "1 -> 2 -> 3 -> 4 -> 5 -> 6",
        "explanation": "The preorder traversal of the tree is [1, 2, 3, 4, 5, 6], which represents the flattened linked list."
      },
      {
        "input": "root = []",
        "output": "",
        "explanation": "An empty tree results in an empty linked list."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to help with the traversal.",
      "You can recursively process the left and right children."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Basic Calculator",
    "description": "Implement a basic calculator that can evaluate a string expression containing non-negative integers, '+', '-', '(', and ')'. The expression should be evaluated according to the order of operations. You must consider both precedence and parentheses in your calculations. The expression will always be valid and will never include division or multiplication operators.",
    "topic": "Mathematics",
    "subtopic": "Parsing and Evaluating Expressions",
    "tags": [
      "Math",
      "Stack",
      "Parsing"
    ],
    "input_format": "A string expression containing non-negative integers and the operators '+', '-', '(', and ')'.",
    "output_format": "An integer result of the evaluated expression.",
    "constraints": [
      "The input string is not empty and contains only the characters: '0' - '9', '+', '-', '(', and ')'.",
      "The number of tokens in the expression is at most 10^5."
    ],
    "examples": [
      {
        "input": "s = \"1 + 1\"",
        "output": "2",
        "explanation": "The expression '1 + 1' evaluates to 2."
      },
      {
        "input": "s = \" 2-1 + 2 \"",
        "output": "3",
        "explanation": "The expression '2 - 1 + 2' evaluates to 3."
      },
      {
        "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
        "output": "23",
        "explanation": "The expression evaluates to 23 after following the order of operations."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to handle parentheses.",
      "Pay attention to the order of operations when evaluating expressions."
    ],
    "company": "Anduril"
  },
  {
    "question_id": "",
    "title": "Race Car",
    "description": "A race car can move forward by a certain distance or reverse back to the beginning. You are tasked with determining the minimum number of steps needed for the race car to reach position `target` on a straight track, where the forward movement doubles the current speed of the car and the reverse movement resets the car to the starting point. The race car can move according to the rules: at `position x` with `speed s`, you can either: 1. Move forward to `position x + s` with doubled speed `s`, or 2. Move backward to `position x` with speed `-1`.",
    "topic": "Dynamic Programming",
    "subtopic": "State Transition",
    "tags": [
      "BFS",
      "Dynamic Programming",
      "Graph"
    ],
    "input_format": "An integer target representing the target position the race car needs to reach.",
    "output_format": "An integer representing the minimum number of steps required to reach the target position.",
    "constraints": [
      "-10^4 <= target <= 10^4"
    ],
    "examples": [
      {
        "input": "target = 3",
        "output": "2",
        "explanation": "The race car can move forward -> (0 + 1) -> (1) and then forward again -> (1 + 2) -> (3). Total steps = 2."
      },
      {
        "input": "target = 2",
        "output": "3",
        "explanation": "The race car can move forward from (0 + 1) to (1), then move forward to (1 + 1) to (2), with a total of 3 steps."
      },
      {
        "input": "target = 5",
        "output": "5",
        "explanation": "The optimal path will take 5 steps: Forward to 1 -> Forward to 2 -> Forward to 4 -> Back to 0 -> Forward to 5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using BFS to explore each position and speed.",
      "Think about the relationship between position and speed for backward movement.",
      "Track visited states to avoid unnecessary computations."
    ],
    "company": "Anduril"
  }
]