[
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "An integer array nums.",
    "output_format": "A list of unique triplets that sum up to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that sum to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no numbers, so no triplets can be formed."
      },
      {
        "input": "nums = [0, 1, 1]",
        "output": "[]",
        "explanation": "No triplet can sum to zero since all numbers are positive except for zero."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try sorting the array first.",
      "Use two pointers to find the triplets efficiently.",
      "Skip duplicate values to avoid duplicate triplets."
    ],
    "company": "Works Applications"
  },
  {
    "question_id": "",
    "title": "Course Schedule III",
    "description": "You are given an array of tasks, where each task is represented by a pair of integers [startTime, endTime]. Each task must be completed before the next task can begin. You can schedule the tasks in any order, but you want to maximize the number of tasks you can complete within a given time frame. Write an algorithm to find the maximum number of tasks that can be completed without overlapping time intervals.",
    "topic": "Greedy",
    "subtopic": "Interval Scheduling",
    "tags": [
      "Greedy",
      "Intervals",
      "Scheduling"
    ],
    "input_format": "An integer n followed by an array of n pairs of integers representing the start and end times of the tasks.",
    "output_format": "An integer representing the maximum number of tasks that can be completed.",
    "constraints": [
      "1 <= n <= 10^5",
      "0 <= startTime < endTime <= 10^9"
    ],
    "examples": [
      {
        "input": "4\n[[1, 3], [2, 4], [3, 5], [6, 8]]",
        "output": "3",
        "explanation": "You can complete the tasks [1, 3], [3, 5], and [6, 8]."
      },
      {
        "input": "3\n[[1, 2], [2, 3], [3, 4]]",
        "output": "3",
        "explanation": "You can complete all three tasks as they do not overlap."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider sorting the tasks based on their end times.",
      "Use a greedy approach to select the next task that starts after the last selected task ends."
    ],
    "company": "Works Applications"
  },
  {
    "question_id": "",
    "title": "K Inverse Pairs Array",
    "description": "Given two integers n and k, return the number of different arrays that consist of numbers from 0 to n - 1 such that there are exactly k inverse pairs. An inverse pair is a pair of indices (i, j) such that i < j and arr[i] > arr[j]. Since the answer may be large, return it modulo 10^9 + 7.",
    "topic": "Dynamic Programming",
    "subtopic": "Combinatorial",
    "tags": [
      "Dynamic Programming",
      "Combinatorial",
      "Counting"
    ],
    "input_format": "Two integers n (1 <= n <= 1000) and k (0 <= k <= 1000).",
    "output_format": "An integer representing the number of different arrays with exactly k inverse pairs, modulo 10^9 + 7.",
    "constraints": [
      "1 <= n <= 1000",
      "0 <= k <= 1000"
    ],
    "examples": [
      {
        "input": "n = 3, k = 1",
        "output": "2",
        "explanation": "The arrays [0, 2, 1] and [1, 2, 0] have exactly one inverse pair."
      },
      {
        "input": "n = 5, k = 10",
        "output": "89",
        "explanation": "There are 89 different arrays of size 5 with exactly 10 inverse pairs."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to keep track of counts of inverse pairs.",
      "Start with base cases where you only have one number and build from there.",
      "Think about how the number of inverse pairs changes as you add a new element to the array."
    ],
    "company": "Works Applications"
  },
  {
    "question_id": "",
    "title": "Largest Number",
    "description": "Given a list of non-negative integers, you are to arrange them such that they form the largest number possible. The result should be a string representing the largest number.",
    "topic": "Greedy",
    "subtopic": "Sorting",
    "tags": [
      "Greedy",
      "Sorting",
      "String Manipulation"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "A string representing the largest number that can be formed.",
    "constraints": [
      "0 <= nums.length <= 100",
      "0 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [10, 2]",
        "output": "210",
        "explanation": "By arranging '2' before '10', the largest number formed is '210'."
      },
      {
        "input": "nums = [3, 30, 34, 5, 9]",
        "output": "9534330",
        "explanation": "By arranging in the order of '9', '5', '34', '3', '30', the largest number formed is '9534330'."
      },
      {
        "input": "nums = [0, 0]",
        "output": "0",
        "explanation": "All numbers are '0', so the largest number formed is '0'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to compare the concatenated results of two numbers.",
      "Using a custom sorting function might be necessary."
    ],
    "company": "Works Applications"
  }
]