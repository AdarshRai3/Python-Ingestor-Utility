[
  {
    "question_id": "",
    "title": "Simple Bank System",
    "description": "Design a simple bank system that allows customers to create accounts and perform basic operations such as depositing and withdrawing money. The system should support multiple accounts, each with its own balance. It should also allow customers to check their balance and perform transfers between accounts. Implement the functionality and return relevant information as needed.",
    "topic": "Design",
    "subtopic": "System Design",
    "tags": [
      "Design",
      "Banking",
      "OOP"
    ],
    "input_format": "The commands to interact with the bank system, including creating accounts, depositing, withdrawing, checking balance, and transferring.",
    "output_format": "Returns information about the success or failure of each operation, along with balances when queried.",
    "constraints": [
      "The number of operations will not exceed 1000.",
      "Account IDs are positive integers and unique."
    ],
    "examples": [
      {
        "input": "create_account(1)\ndeposit(1, 100)\ncheck_balance(1)\nwithdraw(1, 50)\ntransfer(1, 2, 25)",
        "output": "[\"Account created.\", \"Deposit successful.\", \"Balance: 100\", \"Withdrawal successful.\", \"Transfer successful.\"]",
        "explanation": "An account is created, money is deposited, balance checked, money is withdrawn, and transferred successfully."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider encapsulation for account details.",
      "Use a data structure to store account information."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order. The spiral order starts from the top-left corner and proceeds to the right, then downwards, left, and finally upwards, returning back to the start until all elements are traversed.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral Order"
    ],
    "input_format": "A 2D list (matrix) of integers where each list is a row of the matrix.",
    "output_format": "A list containing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "1 <= matrix[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The elements in spiral order are 1 -> 2 -> 3 -> 6 -> 9 -> 8 -> 7 -> 4 -> 5."
      },
      {
        "input": "matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]",
        "output": "[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]",
        "explanation": "The elements in spiral order are 1 -> 2 -> 3 -> 4 -> 8 -> 12 -> 11 -> 10 -> 9 -> 5 -> 6 -> 7."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use four pointers to keep track of the current bounds (top, bottom, left, right).",
      "Iterate while the bounds do not overlap."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Block Placement Queries",
    "description": "You are given a grid of size n x m initialized with zeros. You need to process q block placement queries of the form (x1, y1, x2, y2), where you place a block covering the rectangular area from (x1, y1) to (x2, y2) (inclusive) and increment the values in that area by 1. After processing all queries, return the final grid. The grid and queries can have dimensions up to 1000 x 1000 and 100,000 queries.",
    "topic": "Grid",
    "subtopic": "Range Updates",
    "tags": [
      "Grid",
      "2D Array",
      "Range Update"
    ],
    "input_format": "Two integers n and m followed by an array of queries, where each query is represented as a tuple of four integers (x1, y1, x2, y2).",
    "output_format": "A 2D list representing the final state of the grid after all block placement queries have been applied.",
    "constraints": [
      "1 <= n, m <= 1000",
      "1 <= q <= 100000",
      "1 <= x1 <= x2 <= n",
      "1 <= y1 <= y2 <= m"
    ],
    "examples": [
      {
        "input": "n = 3, m = 3, queries = [(1, 1, 2, 2), (2, 2, 3, 3)]",
        "output": "[[1, 1, 0], [1, 2, 1], [0, 1, 1]]",
        "explanation": "The first query places a block in the top-left 2x2 area, and the second query places a block in the bottom-right 2x2 area."
      },
      {
        "input": "n = 4, m = 4, queries = [(1, 1, 4, 4), (3, 3, 4, 4)]",
        "output": "[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 2, 2], [1, 1, 2, 2]]",
        "explanation": "The first query covers the entire grid, and the second query adds an additional block to the bottom-right corner."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a 2D difference array for efficient range updates.",
      "Iterate through each query and mark the boundaries of the updates efficiently."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Minimum Operations to Write the Letter Y on a Grid",
    "description": "Given a grid of lowercase letters, find the minimum number of operations required to change the letters on the grid to form the letter 'Y'. An operation consists of changing any letter to any other letter. The 'Y' should take the shape of a 'Y' and can be placed anywhere on the grid. The shape of 'Y' is defined as: in the center, there should be a vertical line of 3 letters, and from the second letter downwards, there should be two diagonal lines made of letters that form the arms of the 'Y'.",
    "topic": "Grid",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Grid",
      "Dynamic Programming",
      "String Manipulation"
    ],
    "input_format": "A 2D grid represented as a list of lists containing lowercase letters.",
    "output_format": "An integer representing the minimum number of operations required.",
    "constraints": [
      "1 <= grid.length <= 100",
      "1 <= grid[i].length <= 100",
      "grid[i][j] is a lowercase letter"
    ],
    "examples": [
      {
        "input": [
          [
            "a",
            "b",
            "c"
          ],
          [
            "d",
            "e",
            "f"
          ],
          [
            "g",
            "h",
            "i"
          ]
        ],
        "output": 3,
        "explanation": "To transform this grid into the shape of Y, the center should be at (1, 1) -> 'e', and the arms can be changed as follows: (0,1) -> 'y', (2,0) -> 'y', (2,2) -> 'y'. A total of 3 changes."
      },
      {
        "input": [
          [
            "y",
            "y",
            "y"
          ],
          [
            "y",
            "y",
            "y"
          ],
          [
            "y",
            "y",
            "y"
          ]
        ],
        "output": 0,
        "explanation": "The grid already forms a perfect Y shape, so no changes are needed."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider where to position the center of the 'Y'.",
      "Check the possible combinations of letters for forming the 'Y'.",
      "Try using a brute-force approach for small grids."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Text Justification",
    "description": "Given an array of words and a length maxWidth, format the text so that each line has exactly maxWidth characters and is fully justified. You should pack the words in a greedy approach; that is, add as many words as you can to a single line until the line would exceed maxWidth. The exception is when you reach the last line, which should be left-justified. Each line should contain at least one word. Additional spaces on the right end of the line are not allowed. The formatted output should return all lines as a list of strings.",
    "topic": "String",
    "subtopic": "Text Formatting",
    "tags": [
      "String",
      "Greedy",
      "Text Justification"
    ],
    "input_format": "A list of strings words and an integer maxWidth.",
    "output_format": "A list of strings representing the justified text.",
    "constraints": [
      "1 <= words.length <= 3000",
      "1 <= words[i].length <= 100",
      "1 <= maxWidth <= 100"
    ],
    "examples": [
      {
        "input": {
          "words": [
            "This",
            "is",
            "an",
            "example",
            "of",
            "text",
            "justification."
          ],
          "maxWidth": 16
        },
        "output": [
          "This    is    an",
          "example  of text",
          "justification.  "
        ],
        "explanation": "The first line has 4 words ('This', 'is', 'an') fitting best. The spaces are distributed evenly around to achieve the maxWidth of 16."
      },
      {
        "input": {
          "words": [
            "What",
            "must",
            "be",
            "acknowledgment",
            "shall",
            "be"
          ],
          "maxWidth": 16
        },
        "output": [
          "What   must   be",
          "acknowledgment  ",
          "shall be        "
        ],
        "explanation": "The first line has 3 words with extra spaces distributed to align with the maxWidth, while the last line is left-justified."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to distribute spaces between words evenly.",
      "Handle the last line separately for left justification.",
      "Use a greedy approach to add words until maxWidth is reached."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Candy Crush",
    "description": "You are given a 2D grid representing candies of different colors. Each cell in the grid contains a candy, where candies with the same color that are adjacent to each other (either horizontally or vertically) will crush. Write a function to simulate the crushing process, where all candies that are crushed change to zero. After each crush, the candies above will fall down to fill the empty spaces. Continue the process until no more candies can be crushed.",
    "topic": "Array",
    "subtopic": "2D Grid Manipulation",
    "tags": [
      "Array",
      "Grid",
      "Simulation"
    ],
    "input_format": "A 2D grid of integers where grid[i][j] represents the color of the candy in that cell (0 means empty).",
    "output_format": "Return the updated grid after all crushes have been processed.",
    "constraints": [
      "1 <= grid.length <= 50",
      "1 <= grid[0].length <= 50",
      "0 <= grid[i][j] <= 99"
    ],
    "examples": [
      {
        "input": "[[1,1,1,0],[0,1,0,2],[3,2,2,2],[0,0,0,0]]",
        "output": "[[3,0,0,0],[0,2,0,0],[0,1,0,0],[0,0,0,0]]",
        "explanation": "The first three candies (1) in the first row crush. The second row, candy 1 crushes with itself, and candies above are filled in."
      },
      {
        "input": "[[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[1,2,3],[4,5,6],[7,8,9]]",
        "explanation": "No candies can crush and the grid remains unchanged."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a visited matrix to track the candies to be crushed.",
      "Implement a function to collapse the grid after crushing.",
      "Consider using DFS or BFS to find connected components."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Rotate Image",
    "description": "You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). You have to rotate the matrix in-place, which means you have to do this using only constant space. Do not return anything; modify the input matrix directly.",
    "topic": "Matrix",
    "subtopic": "In-place Manipulation",
    "tags": [
      "Matrix",
      "In-place",
      "Rotation"
    ],
    "input_format": "A square matrix of integers, represented as a 2D array.",
    "output_format": "The same 2D array, rotated 90 degrees clockwise.",
    "constraints": [
      "1 <= n <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]",
        "explanation": "The matrix is rotated 90 degrees clockwise, transforming row 1 into column 1, row 2 into column 2, and so on."
      },
      {
        "input": "matrix = [[5]]",
        "output": "[[5]]",
        "explanation": "A single-element matrix remains unchanged after rotation."
      },
      {
        "input": "matrix = [[1,2],[3,4]]",
        "output": "[[3,1],[4,2]]",
        "explanation": "When the 2x2 matrix is rotated, row 1 becomes column 1 and row 2 becomes column 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider swapping elements in layers.",
      "Use a temporary variable to assist with swapping."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Count Alternating Subarrays",
    "description": "Given an integer array nums, count the number of contiguous subarrays where the elements alternate between even and odd integers. The subarrays must have at least two elements. A subarray is considered valid if it alternates starting from an even number followed by an odd number or vice versa.",
    "topic": "Array",
    "subtopic": "Subarray Count",
    "tags": [
      "Array",
      "Subarray",
      "Counting"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the count of valid alternating subarrays.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5]",
        "output": "4",
        "explanation": "The valid alternating subarrays are [1, 2], [2, 3], [3, 4], and [4, 5]."
      },
      {
        "input": "nums = [2, 3, 4, 5, 6]",
        "output": "6",
        "explanation": "The valid alternating subarrays are [2, 3], [3, 4], [4, 5], [5, 6], [2, 3, 4], and [3, 4, 5]."
      },
      {
        "input": "nums = [1, 1, 1, 1, 1]",
        "output": "0",
        "explanation": "There are no alternating subarrays with only odd numbers."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Keep track of the previous parity (even or odd) while iterating through the array.",
      "Use a counter to count valid pairs."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Four Divisors",
    "description": "Given an integer array nums, return the number of integers in the array that have exactly four divisors. An integer has exactly four divisors if it can be expressed as p^3 or p*q where p and q are distinct prime numbers.",
    "topic": "Mathematics",
    "subtopic": "Number Theory",
    "tags": [
      "Mathematics",
      "Prime Numbers",
      "Divisors"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the count of numbers with exactly four divisors.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "1 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [21, 22, 24]",
        "output": "2",
        "explanation": "21 has divisors 1, 3, 7, 21; 22 has divisors 1, 2, 11, 22; 24 has divisors 1, 2, 3, 4, 6, 8, 12, 24. Thus, 21 and 22 have exactly four divisors."
      },
      {
        "input": "nums = [15, 85, 33]",
        "output": "0",
        "explanation": "None of these numbers has exactly four divisors."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Check if a number is prime to use it in the divisor calculation.",
      "Consider the forms p^3 and p*q carefully to determine the divisors."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Count Operations to Obtain Zero",
    "description": "You are given two integers, `A` and `B`. You can perform the following operation on the values of `A` and `B`: If `A` is greater than `B`, subtract `B` from `A`. If `B` is greater than `A`, subtract `A` from `B`. Your task is to count the number of operations required to make `A` equal to `B`, or until one of them becomes zero.",
    "topic": "Math",
    "subtopic": "Greedy Algorithms",
    "tags": [
      "Math",
      "Greedy",
      "Counting"
    ],
    "input_format": "Two integers A and B, where 0 <= A, B <= 10^5.",
    "output_format": "An integer representing the number of operations needed to make A equal to B or one of them zero.",
    "constraints": [
      "0 <= A, B <= 10^5"
    ],
    "examples": [
      {
        "input": "A = 5, B = 10",
        "output": "2",
        "explanation": "Operations: 10 - 5 = 5, then 5 - 5 = 0. Total operations = 2."
      },
      {
        "input": "A = 3, B = 3",
        "output": "0",
        "explanation": "A is already equal to B. No operations needed."
      },
      {
        "input": "A = 8, B = 4",
        "output": "2",
        "explanation": "Operations: 8 - 4 = 4, and then 4 - 4 = 0. Total operations = 2."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Think about how the difference between A and B changes with each operation.",
      "Consider the relationship between A and B when one is larger than the other."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit",
    "description": "Given an integer array nums and an integer limit, return the length of the longest contiguous subarray such that the absolute difference between the maximum and minimum elements in this subarray is less than or equal to the limit.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer limit.",
    "output_format": "An integer representing the length of the longest subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= nums[i] <= 10^9",
      "0 <= limit <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [8, 2, 4, 7], limit = 4",
        "output": "2",
        "explanation": "The longest subarray with absolute diff <= 4 is [8, 4] or [4, 7], both have length 2."
      },
      {
        "input": "nums = [10, 1, 2, 4, 7, 2], limit = 5",
        "output": "4",
        "explanation": "The longest subarray with absolute diff <= 5 is [10, 1, 2, 4], with max = 10 and min = 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window to find the subarrays.",
      "Maintain the maximum and minimum elements within the window."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Simplify Path",
    "description": "Given a string representing an absolute path for a file in a Unix-style file system, simplify it. The path may contain redundant components like '..' and '.' which represent parent directories and current directories respectively. You should return the simplified canonical path.",
    "topic": "String",
    "subtopic": "Path Manipulation",
    "tags": [
      "String",
      "Path",
      "Manipulation"
    ],
    "input_format": "A string path representing the absolute path in a Unix-style file system.",
    "output_format": "A string representing the simplified canonical path.",
    "constraints": [
      "1 <= path.length <= 3000",
      "path consists of English letters, digits, '/', '.', and '..'.",
      "The path is guaranteed to be a valid absolute path."
    ],
    "examples": [
      {
        "input": "/home/",
        "output": "/home",
        "explanation": "The path '/home/' is simplified to '/home'."
      },
      {
        "input": "/../",
        "output": "/",
        "explanation": "The path '/../' is simplified to '/' since it refers to the root directory."
      },
      {
        "input": "/a/./b/../../c/",
        "output": "/c",
        "explanation": "The path '/a/./b/../../c/' is simplified to '/c' after removing redundant components."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to help manage the directories.",
      "Ignore any parts that are '.' or are empty.",
      "Pop the top of the stack when you encounter '..'."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Split Message Based on Limit",
    "description": "You are given a message string and a limit integer. Your task is to split the message into multiple segments such that each segment contains at most 'limit' characters. If a word exceeds the limit, it should be split at that limit, and the remaining characters should overflow to the next segment. The segments should be returned as a list of strings.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Splitting"
    ],
    "input_format": "A string message followed by an integer limit.",
    "output_format": "A list of strings representing the split segments.",
    "constraints": [
      "1 <= limit <= 1000",
      "1 <= length of message <= 10^5"
    ],
    "examples": [
      {
        "input": "message = \"Hello World\", limit = 5",
        "output": "[\"Hello\", \" Worl\", \"d\"]",
        "explanation": "The message 'Hello World' is split into segments of 5 characters: 'Hello', ' Worl', 'd'."
      },
      {
        "input": "message = \"LeetCode is amazing!\", limit = 10",
        "output": "[\"LeetCode \", \"is amazin\", \"g!\"]",
        "explanation": "The message is split where 'LeetCode ' occupies the first segment and 'is amazin' occupies the second, and 'g!' goes to the third."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to handle word boundaries when splitting.",
      "Think about how you can utilize substring operations efficiently."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Number of Black Blocks",
    "description": "You are given a grid of size m x n where each cell can either be a black block or a white block. Your task is to count the number of black blocks in the grid. A black block is defined as a cell that contains a '1', while a white block is a cell that contains a '0'. You need to ensure that your solution is efficient, especially for larger grids.",
    "topic": "Matrix",
    "subtopic": "Count Elements",
    "tags": [
      "Matrix",
      "Count",
      "Binary"
    ],
    "input_format": "A 2D array grid of size m x n containing only '0's and '1's.",
    "output_format": "An integer representing the number of black blocks in the grid.",
    "constraints": [
      "1 <= m, n <= 1000",
      "grid[i][j] is either '0' or '1'."
    ],
    "examples": [
      {
        "input": "grid = [[1,0,0],[0,1,0],[1,1,1]]",
        "output": "5",
        "explanation": "The grid has 5 black blocks, represented by '1's."
      },
      {
        "input": "grid = [[0,0,0],[0,0,0],[0,0,0]]",
        "output": "0",
        "explanation": "There are no black blocks in the grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "You can iterate through the grid to count '1's.",
      "Consider using optimized data structures if efficiency is a concern."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Rotating the Box",
    "description": "You are given a 2D grid representing a box, filled with stones and empty spaces. The box is represented as a grid of 'X' for stones and '.' for empty spaces. Your task is to rotate the box 90 degrees clockwise. After rotating, you need to drop the stones down to the bottom of the box. Return the modified grid after rotation and dropping the stones.",
    "topic": "Array",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Matrix",
      "Array",
      "Simulation"
    ],
    "input_format": "A 2D grid of characters, where each character is either 'X' (stone) or '.' (empty space).",
    "output_format": "A 2D grid of characters after rotating the box and dropping the stones.",
    "constraints": [
      "1 <= grid.length <= 100",
      "1 <= grid[i].length <= 100",
      "grid[i][j] is either 'X' or '.'"
    ],
    "examples": [
      {
        "input": "grid = [['X', '.', 'X'], ['X', 'X', 'X'], ['.', 'X', 'X']]",
        "output": "[['.', 'X', 'X'], ['X', 'X', 'X'], ['X', '.', '.']]",
        "explanation": "After rotating the box 90 degrees clockwise, stones fall down to the bottom."
      },
      {
        "input": "grid = [['.', 'X', 'X'], ['X', 'X', '.'], ['X', '.', '.']]",
        "output": "[['.', 'X', 'X'], ['X', 'X', '.'], ['X', '.', '.']]",
        "explanation": "The box remains the same because stones are already in the bottom-most positions."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to manage the rotation of the grid.",
      "You might need to use a temporary structure to help with the dropping of stones."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices where 1 <= prices.length <= 10^5 and 0 <= prices[i] <= 10^4.",
    "output_format": "An integer representing the maximum profit you can achieve.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate the potential profit at each price and update the maximum profit."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Number of Flowers in Full Bloom",
    "description": "You are given an array of integers representing the time when flowers will start blooming and an array representing the time when they will stop blooming. Your task is to determine the maximum number of flowers in full bloom at any given time. A flower is considered in full bloom from the time it starts until the time it stops (inclusive).",
    "topic": "Interval",
    "subtopic": "Sweep Line Algorithm",
    "tags": [
      "Interval",
      "Sweep Line",
      "Greedy"
    ],
    "input_format": "Two arrays of integers start and end, where start[i] is the time when the i-th flower blooms and end[i] is the time when it wilts.",
    "output_format": "An integer representing the maximum number of flowers in full bloom at any point in time.",
    "constraints": [
      "1 <= start.length == end.length <= 10^5",
      "0 <= start[i] <= end[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "start = [1, 2, 3], end = [3, 2, 7]",
        "output": "3",
        "explanation": "All flowers bloom at times 1, 2, and 3, resulting in a maximum of 3 flowers blooming at time 3."
      },
      {
        "input": "start = [1, 4, 5], end = [2, 6, 8]",
        "output": "2",
        "explanation": "At time 2 the maximum number of flowers in full bloom is 2 (one blooming at time 1 and another from time 4 )."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to handle events of blooming and wilting.",
      "Sorting events might be useful to easily track flower states."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Find the Length of the Longest Common Prefix",
    "description": "Write a function to find the length of the longest common prefix among an array of strings. If there is no common prefix, return 0.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Prefix",
      "Common"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "An integer representing the length of the longest common prefix.",
    "constraints": [
      "0 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "All strings contain only lowercase letters."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "2",
        "explanation": "The longest common prefix is \"fl\", which has length 2."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "0",
        "explanation": "There is no common prefix among the strings."
      },
      {
        "input": "strs = [\"\"]",
        "output": "0",
        "explanation": "The only string is empty, so the longest common prefix is of length 0."
      },
      {
        "input": "strs = [\"c\", \"c\"]",
        "output": "1",
        "explanation": "Both strings are \"c\", so the longest common prefix is \"c\", which has length 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider comparing characters of the strings from the start.",
      "You can stop when characters do not match."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Count Prefix and Suffix Pairs II",
    "description": "Given a string array words, you need to count the number of pairs (i, j) such that the prefix of the word at index i matches the suffix of the word at index j. A prefix of a string is defined as a substring that occurs at the beginning of the string, and a suffix is defined as a substring that occurs at the end of the string. Note that you should not count pairs where i == j.",
    "topic": "String",
    "subtopic": "Substring",
    "tags": [
      "String",
      "Prefix",
      "Suffix",
      "Counting"
    ],
    "input_format": "An array of strings words.",
    "output_format": "An integer representing the count of valid (i, j) pairs.",
    "constraints": [
      "1 <= words.length <= 1000",
      "1 <= words[i].length <= 100"
    ],
    "examples": [
      {
        "input": "words = [\"abc\", \"ab\", \"bc\", \"c\"]",
        "output": "4",
        "explanation": "The valid pairs are (0, 1), (0, 2), (1, 0), (2, 0) since 'ab' is a prefix of 'abc' and 'c' is a suffix of 'abc'."
      },
      {
        "input": "words = [\"def\", \"ef\", \"f\", \"de\"]",
        "output": "2",
        "explanation": "The valid pairs are (0, 1) and (1, 0) since 'ef' is a suffix of 'def' and 'def' is a prefix of 'ef'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to efficiently compare prefixes and suffixes.",
      "Think about using a hash map or set for quick lookups."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Remove Boxes",
    "description": "You are given an array of integers 'boxes' where each integer represents a box with a specific color. The goal is to maximize the number of points you can obtain by removing boxes in the following way: for each box removed, you earn points equal to the square of the number of consecutive boxes of the same color you removed. When you remove a box, all boxes that are adjacent and of the same color will also be removed. You need to find the maximum points that can be obtained by removing all boxes.",
    "topic": "Dynamic Programming",
    "subtopic": "Optimization",
    "tags": [
      "Dynamic Programming",
      "Memoization",
      "Recursion"
    ],
    "input_format": "An array 'boxes' of integers where each element represents the color of a box.",
    "output_format": "An integer representing the maximum points achievable by removing all boxes.",
    "constraints": [
      "1 <= boxes.length <= 100",
      "1 <= boxes[i] <= 100"
    ],
    "examples": [
      {
        "input": "boxes = [1, 3, 2, 2, 2, 3, 4, 3, 1]",
        "output": "23",
        "explanation": "By removing boxes in an optimal order, we can maximize the score to 23."
      },
      {
        "input": "boxes = [1, 1, 1]",
        "output": "9",
        "explanation": "All boxes are of the same color, so removing them gives us 3*3 = 9 points."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to break down the problem.",
      "Think about the use of memoization to store results of subproblems.",
      "Try to analyze the potential points from different segments of boxes."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Coin Change",
    "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. You need to return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0. You may assume that you have an infinite number of each kind of coin.",
    "topic": "Dynamic Programming",
    "subtopic": "Combinatorial Problems",
    "tags": [
      "Dynamic Programming",
      "Combinatorics",
      "Array"
    ],
    "input_format": "An integer array coins followed by an integer amount.",
    "output_format": "An integer representing the number of combinations to make the amount.",
    "constraints": [
      "1 <= coins.length <= 300",
      "1 <= coins[i] <= 5000",
      "0 <= amount <= 5000"
    ],
    "examples": [
      {
        "input": "coins = [1, 2, 5], amount = 5",
        "output": "4",
        "explanation": "The 4 combinations are: 5, 2+2+1, 2+1+1+1, 1+1+1+1+1."
      },
      {
        "input": "coins = [2], amount = 3",
        "output": "0",
        "explanation": "It is not possible to make the amount 3 using coins of denomination 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using dynamic programming to solve this problem.",
      "Consider using a dp array where dp[i] represents the number of combinations to make amount i."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Design File System",
    "description": "You are tasked with designing a simplified file system that can keep track of directories and files. The file system should support the following operations: creating a file, creating a directory, and listing the contents of a directory. Each file has a path and a size, while directories can contain other files or directories. Each file's path must be unique within its directory. Your goal is to implement the FileSystem class that handles these operations effectively.",
    "topic": "Design",
    "subtopic": "Data Structures",
    "tags": [
      "File System",
      "Design",
      "Data Structures"
    ],
    "input_format": "The input will be given as operations to perform on the file system. These operations include creating files, creating directories, and listing directory contents.",
    "output_format": "Output of each operation will either be a success message for creation or a list of the contents of a directory.",
    "constraints": [
      "1 <= number of operations <= 1000",
      "Paths will comprise of lowercase letters and '/' as the separator.",
      "Files and directories should be valid and follow the unique path rule."
    ],
    "examples": [
      {
        "input": "FileSystem fs = new FileSystem(); fs.createDirectory('/a'); fs.createFile('/a/file1.txt', 100); fs.list('/a')",
        "output": "['file1.txt']",
        "explanation": "After creating directory '/a' and file 'file1.txt', listing '/a' shows 'file1.txt'."
      },
      {
        "input": "fs.createDirectory('/a/b'); fs.createFile('/a/b/file2.txt', 200); fs.list('/a/b')",
        "output": "['file2.txt']",
        "explanation": "After creating directory '/a/b' and file 'file2.txt', listing '/a/b' shows 'file2.txt'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a tree-like structure to represent directories and files.",
      "Consider using a HashMap for fast access to directories."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Palindrome Number",
    "description": "Given an integer, determine if it is a palindrome. An integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome, while 123 is not.",
    "topic": "Math",
    "subtopic": "Number Properties",
    "tags": [
      "Math",
      "Palindrome",
      "Integer"
    ],
    "input_format": "An integer x.",
    "output_format": "A boolean value: return true if x is a palindrome, otherwise return false.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 121",
        "output": "true",
        "explanation": "121 reads the same backward: 121."
      },
      {
        "input": "x = -121",
        "output": "false",
        "explanation": "-121 reads backward as 121-, which is not the same."
      },
      {
        "input": "x = 10",
        "output": "false",
        "explanation": "10 reads backward as 01, which is not the same."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider converting the integer to a string."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Word Search",
    "description": "Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where 'adjacent' cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "topic": "Backtracking",
    "subtopic": "Grid Search",
    "tags": [
      "Backtracking",
      "Grid",
      "Search"
    ],
    "input_format": "A 2D board represented as a list of lists of characters and a string word.",
    "output_format": "A boolean value indicating whether the word exists in the grid.",
    "constraints": [
      "m == board.length",
      "n == board[i].length",
      "1 <= m, n <= 6",
      "1 <= word.length <= 15",
      "All square of the board contains only lowercase English letters."
    ],
    "examples": [
      {
        "input": "board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], word = 'ABCCED'",
        "output": "true",
        "explanation": "The word 'ABCCED' can be constructed from the board by going down, right, right, down, down."
      },
      {
        "input": "board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], word = 'SEE'",
        "output": "true",
        "explanation": "The word 'SEE' can be constructed from the board by going down, down, right."
      },
      {
        "input": "board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], word = 'ABCB'",
        "output": "false",
        "explanation": "The word 'ABCB' cannot be constructed from the board."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to explore all possible paths.",
      "Use a visited matrix to keep track of the cells you have already used in the current path."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Number of Subarrays That Match a Pattern I",
    "description": "Given an array of integers and a target pattern, your task is to compute the number of contiguous subarrays that match the given pattern. A subarray matches the pattern if it contains the same set of elements, in the same order, as the specified pattern.",
    "topic": "Array",
    "subtopic": "Subarray Matching",
    "tags": [
      "Array",
      "Subarray",
      "Pattern Matching"
    ],
    "input_format": "An integer array `nums` and an integer array `pattern` representing the target pattern.",
    "output_format": "An integer representing the number of contiguous subarrays that match the given pattern.",
    "constraints": [
      "1 <= nums.length <= 2000",
      "1 <= pattern.length <= 100",
      "All integers in nums and pattern are within the range of -10^4 to 10^4."
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 1, 2, 1], pattern = [1, 2]",
        "output": "4",
        "explanation": "The matching subarrays are [1, 2], [2, 1, 2], [1, 2] (from indices 0 to 1, 1 to 3, and 2 to 3 respectively), and [1, 2] (from indices 3 to 4) for a total of 4."
      },
      {
        "input": "nums = [1, 2, 3, 4, 5], pattern = [2, 3]",
        "output": "1",
        "explanation": "The only matching subarray is [2, 3] (from indices 1 to 2), so the output is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sliding window approach to check for matching subarrays.",
      "Keep track of elements' counts in the current window."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Largest Rectangle in Histogram",
    "description": "Given an array of integers representing the heights of bars in a histogram, return the area of the largest rectangle that can be formed within the histogram. The width of each bar is 1.",
    "topic": "Stack",
    "subtopic": "Monotonic Stack",
    "tags": [
      "Stack",
      "Array",
      "Histogram"
    ],
    "input_format": "An array of integers heights representing the heights of the histogram bars.",
    "output_format": "An integer representing the area of the largest rectangle that can be formed.",
    "constraints": [
      "1 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [2,1,5,6,2,3]",
        "output": "10",
        "explanation": "The largest rectangle can be formed with height 5 and width 2, yielding an area of 10."
      },
      {
        "input": "heights = [2,4]",
        "output": "4",
        "explanation": "The largest rectangle can be formed using the bar with height 4, with an area of 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to keep track of the bar indices.",
      "For each bar, determine how far the rectangle can extend left and right."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Add Strings",
    "description": "Given two non-negative integers represented as string, return their sum represented as a string. You must not use any built-in BigInteger library or convert the inputs to integer directly.",
    "topic": "Strings",
    "subtopic": "String Manipulation",
    "tags": [
      "Strings",
      "Math",
      "Simulation"
    ],
    "input_format": "Two strings num1 and num2, representing the non-negative integers.",
    "output_format": "A string representing the sum of the two integers.",
    "constraints": [
      "1 <= num1.length, num2.length <= 10^4",
      "num1 and num2 consist of digits only and do not have leading zeros."
    ],
    "examples": [
      {
        "input": "num1 = \"123\", num2 = \"456\"",
        "output": "\"579\"",
        "explanation": "The sum of 123 and 456 is 579."
      },
      {
        "input": "num1 = \"11\", num2 = \"123\"",
        "output": "\"134\"",
        "explanation": "The sum of 11 and 123 is 134."
      },
      {
        "input": "num1 = \"0\", num2 = \"0\"",
        "output": "\"0\"",
        "explanation": "The sum of 0 and 0 is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a loop to simulate the addition of the numbers from the last digit to the first.",
      "Use a carry variable to handle sums greater than 9."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Depth-First Search",
    "subtopic": "Graph",
    "tags": [
      "Depth-First Search",
      "Graph",
      "Matrix"
    ],
    "input_format": "A 2D binary grid represented as a list of lists of integers.",
    "output_format": "An integer representing the number of islands in the grid.",
    "constraints": [
      "1 <= grid.length, grid[0].length <= 300",
      "grid[i][j] is either '0' or '1'."
    ],
    "examples": [
      {
        "input": "grid = [['1','1','1','1','0'], ['1','1','0','1','0'], ['1','1','0','0','0'], ['0','0','0','0','0']]",
        "output": "1",
        "explanation": "There is one island formed by the connected '1's."
      },
      {
        "input": "grid = [['1','1','0','0','0'], ['1','1','0','0','0'], ['0','0','1','0','0'], ['0','0','0','1','1']]",
        "output": "3",
        "explanation": "There are three islands: one on the top left, one in the middle, and another at the bottom right."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a DFS or BFS approach to traverse the entire grid.",
      "Keep track of visited cells to avoid counting the same island multiple times."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contains a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zeros, except the number 0 itself.",
    "topic": "Linked List",
    "subtopic": "Addition",
    "tags": [
      "Linked List",
      "Math",
      "Addition"
    ],
    "input_format": "Two linked lists representing two integers.",
    "output_format": "A linked list representing the sum of the two integers.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the input lists represent numbers that do not have leading zeros."
    ],
    "examples": [
      {
        "input": "l1 = [2, 4, 3], l2 = [5, 6, 4]",
        "output": "[7, 0, 8]",
        "explanation": "342 + 465 = 807. The result is stored in reverse order."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "0 + 0 = 0."
      },
      {
        "input": "l1 = [9, 9, 9, 9, 9, 9, 9], l2 = [9, 9, 9, 9]",
        "output": "[8, 9, 9, 9, 0, 0, 0, 1]",
        "explanation": "9999999 + 9999 = 10009998. The result is stored in reverse order."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dummy head to simplify the addition process.",
      "Keep track of the carry for cases where the sum exceeds 9."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Binary Tree Paths",
    "description": "Given a binary tree, return all root-to-leaf paths in any order. A root-to-leaf path is defined as a path from the root node down to a leaf node, where each node in the path is connected by edges, and leaf nodes are nodes that do not have any children.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "DFS",
      "Recursion"
    ],
    "input_format": "The input will be a binary tree represented with a node structure. Each node has a value, a left child, and a right child.",
    "output_format": "An array of strings representing all root-to-leaf paths.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "Each node's value is in the range [-1000, 1000]."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, null, 5]",
        "output": "[\"1->2->5\", \"1->3\"]",
        "explanation": "The root-to-leaf paths are 1->2->5 and 1->3."
      },
      {
        "input": "root = [1]",
        "output": "[\"1\"]",
        "explanation": "There is only one path, which is the root itself."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use depth-first search to explore each path.",
      "Keep track of the current path in a string."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Non-overlapping Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. For example, if the input is [[1,3],[2,6],[8,10],[15,18]], the merged intervals would be [[1,6],[8,10],[15,18]]. Your task is to implement the function merge_intervals that takes the collection of intervals and returns the merged intervals in ascending order.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Intervals"
    ],
    "input_format": "A list of intervals where each interval is represented as a pair of integers [start, end].",
    "output_format": "A list of merged intervals where each merged interval is represented as a pair of integers [start, end].",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^5"
    ],
    "examples": [
      {
        "input": "[[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "The intervals [1,3] and [2,6] overlap, and when merged they form [1,6]."
      },
      {
        "input": "[[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "The intervals [1,4] and [4,5] overlap at point 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals by their starting point.",
      "Use a new list to keep track of the merged intervals.",
      "Only add a new interval to the merged list if it doesn't overlap with the last added interval."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Word Search II",
    "description": "Given an m x n board of characters and a list of strings words, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. You may assume all inputs are consist of lowercase letters a-z.",
    "topic": "Backtracking",
    "subtopic": "Trie",
    "tags": [
      "Backtracking",
      "Trie",
      "Array",
      "String"
    ],
    "input_format": "A 2D board represented by a list of lists of characters and a list of strings representing the words.",
    "output_format": "A list of strings that contain all possible words found on the board.",
    "constraints": [
      "1 <= board.length <= 12",
      "1 <= board[i].length <= 12",
      "1 <= words.length <= 3 * 10^4",
      "1 <= words[i].length <= 10"
    ],
    "examples": [
      {
        "input": "board = [['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v']], words = ['oath','pea','eat','rain']",
        "output": "['eat', 'oath']",
        "explanation": "The words 'eat' and 'oath' can be found on the board."
      },
      {
        "input": "board = [['a','b'], ['c','d']], words = ['abcced', 'ad', 'cefb', 'ba', 'bcc', 'acd', 'cda']",
        "output": "['ad']",
        "explanation": "Only the word 'ad' can be formed in the board."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a Trie to optimize the search for words.",
      "Mark cells as visited to avoid reusing them in a single word.",
      "Use depth-first search (DFS) to explore every possible path."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Meeting Rooms II",
    "description": "Given an array of meeting time intervals where each interval is represented as a pair of integers [start, end], return the minimum number of conference rooms required to hold all the meetings. An interval [start, end) means that a meeting starts at 'start' and ends at 'end'. If a meeting ends at the same time another meeting starts, they can use the same room.",
    "topic": "Greedy",
    "subtopic": "Intervals",
    "tags": [
      "Greedy",
      "Intervals",
      "Sorting"
    ],
    "input_format": "A list of lists, where each inner list contains two integers [start_time, end_time].",
    "output_format": "An integer representing the minimum number of conference rooms required.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "0 <= start_time < end_time <= 10^6"
    ],
    "examples": [
      {
        "input": "intervals = [[0, 30], [5, 10], [15, 20]]",
        "output": "2",
        "explanation": "The meetings [0, 30] and [5, 10] overlap, needing two rooms."
      },
      {
        "input": "intervals = [[7, 10], [2, 4]]",
        "output": "1",
        "explanation": "The meetings do not overlap, only one room is needed."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a priority queue to manage room assignments.",
      "Sort the intervals based on their start times."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Merge Two Sorted Lists",
    "description": "You are given the heads of two sorted linked lists. Merge the two lists into a new sorted list. The new list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
    "topic": "Linked List",
    "subtopic": "Merging Lists",
    "tags": [
      "Linked List",
      "Merge",
      "Sorting"
    ],
    "input_format": "The input consists of two linked lists, each represented by the head node.",
    "output_format": "Return the head node of the merged sorted linked list.",
    "constraints": [
      "The number of nodes in the first list is in the range [0, 100].",
      "The number of nodes in the second list is in the range [0, 100].",
      "Node values are in the range [-100, 100]."
    ],
    "examples": [
      {
        "input": "l1 = [1, 2, 4], l2 = [1, 3, 4]",
        "output": "[1, 1, 2, 3, 4, 4]",
        "explanation": "The merged list is 1 -> 1 -> 2 -> 3 -> 4 -> 4."
      },
      {
        "input": "l1 = [], l2 = [0]",
        "output": "[0]",
        "explanation": "Since the first list is empty, the merged list is simply the second list: 0."
      },
      {
        "input": "l1 = [], l2 = []",
        "output": "[]",
        "explanation": "Both lists are empty, so the merged list is also empty."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a dummy node to simplify the merging process.",
      "You can iterate through both lists and compare the values of each node."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Find Servers That Handled Most Number of Requests",
    "description": "You are given a list of server requests, where each request is represented by a timestamp in seconds. Your task is to determine which server(s) have handled the maximum number of requests within a given time window. A time window is defined by a start and an end timestamp. Your output should be a list of server IDs that handled the most requests in that time window.",
    "topic": "Database",
    "subtopic": "Aggregation",
    "tags": [
      "Database",
      "Aggregation",
      "Counting"
    ],
    "input_format": "An integer array requests representing the timestamps of requests and an integer 'window' representing the duration of the time window in seconds.",
    "output_format": "A list of integers representing the server IDs that handled the most requests.",
    "constraints": [
      "1 <= requests.length <= 10^5",
      "0 <= requests[i] <= 10^6",
      "1 <= window <= 10^6"
    ],
    "examples": [
      {
        "input": {
          "requests": [
            1,
            2,
            2,
            3,
            4,
            5,
            6
          ],
          "window": 3
        },
        "output": "[2, 3, 4, 5, 6]",
        "explanation": "In the time window from 2 to 5, the servers processed requests at timestamps 2, 3, 4, and 5. Each server handled 1 request, so all listed servers are tied for the most requests."
      },
      {
        "input": {
          "requests": [
            1,
            1,
            2,
            3,
            5,
            2,
            2,
            2
          ],
          "window": 2
        },
        "output": "[2]",
        "explanation": "In the time window from 1 to 3, server ID 2 received 4 requests (timestamps 2, 2, 2), which is more than any other server."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a hashmap to count requests for each server ID.",
      "Think about how to efficiently check requests within the time window."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Roman to Integer",
    "description": "Given a string representing a Roman numeral, convert it to an integer. The Roman numerals are represented by the characters 'I', 'V', 'X', 'L', 'C', 'D', and 'M'. In this numeral system, the characters have the following values: I = 1, V = 5, X = 10, L = 50, C = 100, D = 500, M = 1000. A numeral is usually written largest to smallest from left to right, but there are exceptions for instance, 'IV' represents 4 because the 'I' is before the 'V'. You must convert the Roman numeral to its corresponding integer value without using any built-in string conversion functions.",
    "topic": "String",
    "subtopic": "Conversion",
    "tags": [
      "String",
      "Conversion",
      "Mathematics"
    ],
    "input_format": "A string `s` representing a Roman numeral.",
    "output_format": "An integer representing the integer value of the Roman numeral.",
    "constraints": [
      "1 <= s.length <= 15",
      "s consists of valid Roman numeral characters: 'I', 'V', 'X', 'L', 'C', 'D', 'M'."
    ],
    "examples": [
      {
        "input": "s = 'III'",
        "output": "3",
        "explanation": "'I' + 'I' + 'I' = 3."
      },
      {
        "input": "s = 'IV'",
        "output": "4",
        "explanation": "'IV' is 4 because 'I' is before 'V'."
      },
      {
        "input": "s = 'IX'",
        "output": "9",
        "explanation": "'IX' is 9 because 'I' is before 'X'."
      },
      {
        "input": "s = 'LVIII'",
        "output": "58",
        "explanation": "'L' + 'V' + 'III' = 50 + 5 + 3 = 58."
      },
      {
        "input": "s = 'MCMXCIV'",
        "output": "1994",
        "explanation": "'M' + 'CM' + 'XC' + 'IV' = 1000 + (1000 - 100) + (100 - 10) + (5 - 1) = 1994."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a mapping of Roman characters to their integer values.",
      "Look for cases where a smaller numeral precedes a larger numeral."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Get Biggest Three Rhombus Sums in a Grid",
    "description": "Given a 2D grid of integers, the task is to find the three largest unique rhombus sums that can be formed in the grid. A rhombus is defined by a center point in the grid and expands outward to form a diamond shape. The minimum size of a rhombus is 1, and it can grow as large as the grid permits. Return the largest three rhombus sums sorted in descending order. If there are less than three unique sums, return all available sums sorted in descending order.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Traversal"
    ],
    "input_format": "A 2D grid of integers of size n x m where n is the number of rows and m is the number of columns.",
    "output_format": "An array of integers representing the largest three unique rhombus sums sorted in descending order.",
    "constraints": [
      "1 <= n, m <= 100",
      "-10^5 <= grid[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[21, 16, 15]",
        "explanation": "Rhombus centered at (1,1) gives the sum 21, while the rhombus centered at (0,1) gives us 16 and the one centered at (1,0) gives 15."
      },
      {
        "input": "grid = [[1, -1, 2], [2, 3, -4], [-5, 6, 7]]",
        "output": "[8, 5, 2]",
        "explanation": "Rhombus centered at (1,1) gives a unique sum of 8, hence three largest are 8, 5 and 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the contribution of each element to potential rhombus sums.",
      "Use a set to track unique sums efficiently.",
      "Iterate through all possible centers in the grid."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Rotate Array",
    "description": "Given an array of integers 'nums' and an integer 'k', rotate the array to the right by 'k' steps, where 'k' is non-negative. The elements of the array should wrap around to the beginning after reaching the end of the array.",
    "topic": "Array",
    "subtopic": "Rotation",
    "tags": [
      "Array",
      "Rotation",
      "In-place"
    ],
    "input_format": "Two inputs: an array of integers nums and an integer k.",
    "output_format": "The rotated array after k steps.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= k <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5] and k = 2",
        "output": "[4, 5, 1, 2, 3]",
        "explanation": "Rotating the array to the right by 2 steps gives [4, 5, 1, 2, 3]."
      },
      {
        "input": "nums = [-1, -100, 3, 99] and k = 2",
        "output": "[3, 99, -1, -100]",
        "explanation": "Rotating the array to the right by 2 steps gives [3, 99, -1, -100]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using the modulo operation to handle cases where k is greater than the length of the array.",
      "Try to find a way to reverse parts of the array to achieve the rotation."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Count Prefix and Suffix Pairs I",
    "description": "Given a list of strings, you need to count the number of pairs of indices (i, j) such that the concatenation of the strings at these indices forms a string where the first part is a prefix and the second part is a suffix. A prefix is defined as a substring that occurs at the start of a string, and a suffix is a substring that occurs at the end of a string.",
    "topic": "String",
    "subtopic": "Prefix and Suffix",
    "tags": [
      "String",
      "Prefix",
      "Suffix",
      "Counting"
    ],
    "input_format": "A list of strings 'strs'.",
    "output_format": "An integer representing the count of valid prefix and suffix pairs.",
    "constraints": [
      "1 <= strs.length <= 1000",
      "1 <= strs[i].length <= 100"
    ],
    "examples": [
      {
        "input": "strs = [\"abc\", \"ab\", \"bc\", \"a\"]",
        "output": "2",
        "explanation": "The valid pairs are (0, 1) because \"abc\" starts with \"ab\" and (0, 3) because \"abc\" ends with \"a\"."
      },
      {
        "input": "strs = [\"hello\", \"world\", \"helloworld\"]",
        "output": "1",
        "explanation": "The valid pair is (0, 2) because \"hello\" is a prefix of \"helloworld\"."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider iterating through each string and checking for pairs.",
      "Use string methods to identify prefixes and suffixes."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if the brackets are closed in the correct order. Every open bracket must have a corresponding closing bracket of the same type.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Valid Parentheses"
    ],
    "input_format": "A string s consisting of parentheses characters.",
    "output_format": "A boolean value indicating whether the input string is valid.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses characters only."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The brackets are correctly closed."
      },
      {
        "input": "s = '([{}])'",
        "output": "true",
        "explanation": "All types of brackets are correctly closed."
      },
      {
        "input": "s = '((()))'",
        "output": "true",
        "explanation": "Nested parentheses, all are correctly closed."
      },
      {
        "input": "s = '({[)]}'",
        "output": "false",
        "explanation": "The brackets are closed in the wrong order."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "Every time you encounter a closing bracket, check if it matches the top of the stack."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "K-diff Pairs in an Array",
    "description": "Given an array of integers, find the number of unique k-diff pairs in the array. A k-diff pair is defined as an integer pair (nums[i], nums[j]) such that |nums[i] - nums[j]| = k, where the indices i and j are different. Note that the pairs must be unique, meaning that (1, 2) and (2, 1) are considered the same pair if k is non-zero.",
    "topic": "Array",
    "subtopic": "Hashmap",
    "tags": [
      "Array",
      "Hashmap",
      "Two Pointers"
    ],
    "input_format": "An integer array nums and an integer k.",
    "output_format": "An integer representing the number of unique k-diff pairs in the array.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= k <= 10^7",
      "-10^7 <= nums[i] <= 10^7"
    ],
    "examples": [
      {
        "input": "nums = [3, 1, 4, 1, 5], k = 2",
        "output": "2",
        "explanation": "There are two unique pairs: (1, 3) and (3, 5)."
      },
      {
        "input": "nums = [1, 2, 3, 4, 5], k = 1",
        "output": "4",
        "explanation": "There are four unique pairs: (1, 2), (2, 3), (3, 4), and (4, 5)."
      },
      {
        "input": "nums = [1, 3, 1, 5, 4], k = 0",
        "output": "1",
        "explanation": "There is one unique pair: (1, 1)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hashmap to count occurrences of each number.",
      "Consider k=0 as a special case for counting duplicates."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock II",
    "description": "You are given an array where the ith element is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. However, you may make as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note that you cannot buy a stock on the same day you sell it. Return the maximum profit you can achieve.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Stock",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers prices where 0 <= prices.length <= 3 * 10^4.",
    "output_format": "An integer representing the maximum profit.",
    "constraints": [
      "0 <= prices.length <= 3 * 10^4",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "7",
        "explanation": "Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5 - 1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6 - 3 = 3. Total profit = 4 + 3 = 7."
      },
      {
        "input": "prices = [1, 2, 3, 4, 5]",
        "output": "4",
        "explanation": "Buy on day 1 (price = 1) and sell on day 5 (price = 5). Total profit = 5 - 1 = 4."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "There is no way to make profit since prices are in decreasing order."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the situation when to buy and sell multiple stocks."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Number of Adjacent Elements With the Same Color",
    "description": "Given a list of colors represented by characters, return the count of pairs of adjacent elements that have the same color. The colors are specified as lowercase letters, and you need to check for adjacent pairs that match.",
    "topic": "String",
    "subtopic": "Character Manipulation",
    "tags": [
      "String",
      "Adjacent Elements",
      "Counting"
    ],
    "input_format": "A string `colors` of length n (1 <= n <= 10^5) consisting only of lowercase letters.",
    "output_format": "An integer representing the number of adjacent elements with the same color.",
    "constraints": [
      "1 <= colors.length <= 10^5",
      "colors consists only of lowercase English letters."
    ],
    "examples": [
      {
        "input": "colors = \"aabbccdde\"",
        "output": "4",
        "explanation": "The adjacent pairs are (a,a), (b,b), (c,c), (d,d) which makes a total of 4 pairs."
      },
      {
        "input": "colors = \"abcde\"",
        "output": "0",
        "explanation": "There are no adjacent elements with the same color."
      },
      {
        "input": "colors = \"aaabbbccc\"",
        "output": "6",
        "explanation": "The adjacent pairs are (a,a), (a,a), (b,b), (b,b), (c,c), (c,c) which sums to 6 pairs."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Iterate through the string and compare each character with the next one.",
      "Maintain a counter to count the pairs."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Reverse Nodes in k-Group",
    "description": "Given a linked list, you need to reverse the nodes of the list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as they are.",
    "topic": "Linked List",
    "subtopic": "Reversal",
    "tags": [
      "Linked List",
      "Reversal",
      "Two Pointers"
    ],
    "input_format": "The head of a linked list.",
    "output_format": "The head of the modified linked list after reversing nodes in k-group.",
    "constraints": [
      "The number of nodes in the linked list is in the range [0, 5000]",
      "0 <= Node.val <= 1000",
      "1 <= k <= length of the list"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5], k = 2",
        "output": "[2,1,4,3,5]",
        "explanation": "The first two nodes are reversed to become [2,1], and the next two nodes become [4,3]. Since there is one node left (5), it remains the same."
      },
      {
        "input": "head = [1,2,3,4,5], k = 3",
        "output": "[3,2,1,4,5]",
        "explanation": "The first three nodes are reversed to become [3,2,1]. The remaining two nodes (4 and 5) stay the same."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Think about the pointers involved when reversing the nodes.",
      "Consider how to handle the remaining nodes when the number is not a multiple of k.",
      "You may need to use a temporary node to help with the reversal."
    ],
    "company": "Capital One"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals and return an array of the non-overlapping intervals that cover all the intervals in the input.",
    "topic": "Array",
    "subtopic": "Sorting and Merging Intervals",
    "tags": [
      "Array",
      "Sorting",
      "Intervals",
      "Merging"
    ],
    "input_format": "A 2D array of integers intervals where intervals[i] = [start_i, end_i], representing the start and end of each interval.",
    "output_format": "A 2D array of merged intervals.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Intervals [1,3] and [2,6] overlap, so they are merged into [1,6]. The other intervals do not overlap."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "Intervals [1,4] and [4,5] touch at the edge, so they are merged into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on the starting times.",
      "Use a list to keep track of merged intervals."
    ],
    "company": "Capital One"
  }
]