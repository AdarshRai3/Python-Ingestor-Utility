[
  {
    "question_id": "",
    "title": "Frog Jump",
    "description": "A frog is positioned at the start of a number line at position 0. It wants to jump to a specific position x. The frog can make jumps of different lengths, but its jump lengths can increase as it progresses. Specifically, the frog can make a jump of 1 unit on its first jump, 2 units on its second jump, and so on. The question is whether the frog can reach exactly position x without exceeding it. Given an integer x, return true if the frog can reach position x, or false otherwise.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Mathematics"
    ],
    "input_format": "An integer x, representing the target position on the number line.",
    "output_format": "A boolean value indicating whether the frog can reach the target position x.",
    "constraints": [
      "0 <= x <= 1,000,000,000"
    ],
    "examples": [
      {
        "input": "x = 5",
        "output": "true",
        "explanation": "The frog can make the jumps: 1 + 2 + 2 = 5."
      },
      {
        "input": "x = 2",
        "output": "false",
        "explanation": "The frog can only reach 1 on the first jump and 3 on the second jump."
      },
      {
        "input": "x = 7",
        "output": "true",
        "explanation": "The frog can make the jumps: 1 + 2 + 4 = 7."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how the sum of the first n natural numbers can help.",
      "Keep track of how many jumps you can make."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Burst Balloons",
    "description": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array arr, where arr[i] is the number on the ith balloon. You can burst the balloons in any order, and when you burst the balloon i, you will gain arr[i] * arr[left] * arr[right] coins. Here, left and right are adjacent indices of i. If there is no left or right balloon, treat them as having a value of 1. Your goal is to maximize the number of coins you can obtain by bursting all the balloons.",
    "topic": "Dynamic Programming",
    "subtopic": "Memoization",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Recursion"
    ],
    "input_format": "An integer array arr where 1 <= arr.length <= 300 and 1 <= arr[i] <= 100.",
    "output_format": "An integer representing the maximum coins you can collect by bursting the balloons.",
    "constraints": [
      "1 <= arr.length <= 300",
      "1 <= arr[i] <= 100"
    ],
    "examples": [
      {
        "input": "arr = [3, 1, 5, 8]",
        "output": "167",
        "explanation": "Bursting balloons in the order [(1, 5, 8), (3)], gives us 3*1*5 + 1*5*8 + 3*1*8 = 167."
      },
      {
        "input": "arr = [1, 5]",
        "output": "10",
        "explanation": "Bursting in the order [(1, 5)], gives us 1*1*5 = 5 coins. Then bursting the last one gives 5*1*1 = 5 coins. Total = 10."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Try using dynamic programming for memoization.",
      "Consider how bursting one balloon affects the others around it."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Decoded String at Index",
    "description": "Given a coded string s generated from a string t using the following encoding scheme:\n- For example, 'leet2code3' corresponds to 'leetccodeeee'.\nYou need to decode the string and return the character present at a given index k.\n\nThe encoded string consists only of lowercase English letters and digits, where each number indicates the number of times the contiguous substring before it is repeated. The decoded string can be very large, and directly decoding it may not be feasible. Therefore, you should return the character at the specified index without fully decoding the string.",
    "topic": "String",
    "subtopic": "Decoding",
    "tags": [
      "String",
      "Decoding",
      "Indexing",
      "Simulation"
    ],
    "input_format": "A string s followed by an integer k (0-based index).",
    "output_format": "A single character present at index k in the decoded string.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of lowercase English letters and digits.",
      "0 <= k <= 10^9"
    ],
    "examples": [
      {
        "input": "s = 'leet2code3', k = 10",
        "output": "e",
        "explanation": "The decoded string is 'leetccodeeee'. The character at index 10 is 'e'."
      },
      {
        "input": "s = 'a2b3c4d5', k = 10",
        "output": "c",
        "explanation": "The decoded string is 'aabbbccccdddd'. The character at index 10 is 'c'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to calculate the length of the decoded string without fully expanding it.",
      "Use a stack-based approach to handle nested repetitions."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Maximum Tastiness of Candy Basket",
    "description": "You have a basket of candies, and each candy has a tastiness level associated with it. Given an integer array where each element represents the tastiness of a candy, your task is to determine the maximum tastiness you can achieve by selecting a subset of candies such that the difference between the maximum and minimum tastiness levels in the selected subset is at most a given threshold. Return the maximum total tastiness from the selected candies.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Greedy"
    ],
    "input_format": "An integer array candies representing the tastiness levels of the candies, and an integer threshold which represents the allowed difference between the maximum and minimum tastiness.",
    "output_format": "An integer representing the maximum total tastiness of the selected candies.",
    "constraints": [
      "1 <= candies.length <= 10^5",
      "1 <= candies[i] <= 10^9",
      "0 <= threshold <= 10^9"
    ],
    "examples": [
      {
        "input": "candies = [1, 3, 5, 7, 9], threshold = 2",
        "output": "15",
        "explanation": "By selecting candies with tastiness levels 5, 7, and 9, the max difference is 9 - 5 = 4, which is not acceptable. However, selecting 3, 5, and 7 gives a max difference of 7 - 3 = 4, while selecting 1, 3, and 5 gives 5 - 1 = 4. The maximum total tastiness in a full selection of candies is 1 + 3 + 5 + 7 = 16."
      },
      {
        "input": "candies = [10, 20, 30, 40], threshold = 15",
        "output": "60",
        "explanation": "All selected candies have tastiness levels within the threshold. The maximum total tastiness is 10 + 20 + 30 + 40 = 100."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the candie array first.",
      "Use a two-pointer technique to find the valid window.",
      "Keep track of the current total tastiness as you expand and contract the window."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Simple Bank System",
    "description": "You are tasked with designing a simple bank system that supports the following operations: creating an account, depositing money, withdrawing money, and checking the account balance. Each account is identified by a unique account number. Notably, the system should ensure that withdrawals do not exceed the available balance in the account. Implement a class `Bank` that allows you to perform these operations efficiently.",
    "topic": "Design",
    "subtopic": "OOP",
    "tags": [
      "Design",
      "OOP",
      "Banking"
    ],
    "input_format": "A list of operations, where each operation is a tuple containing a string representing the operation and the associated parameters.",
    "output_format": "A list of results for each operation which returns either a valid response or an error message.",
    "constraints": [
      "1 <= operations.length <= 10^4",
      "1 <= accountNumber <= 10^6",
      "-10^9 <= amount <= 10^9",
      "amount will be a valid integer"
    ],
    "examples": [
      {
        "input": "[('CreateAccount', 1), ('Deposit', 1, 100), ('Withdraw', 1, 50), ('GetBalance', 1)]",
        "output": "[None, None, None, 50]",
        "explanation": "First, we create a new account with account number 1. We then deposit 100 into the account, withdraw 50, and check the balance which is 50."
      },
      {
        "input": "[('CreateAccount', 2), ('Withdraw', 2, 100)]",
        "output": "['Account not found']",
        "explanation": "Attempting to withdraw from an account that has not been created results in an error."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dictionary to store account balances.",
      "Ensure that your operations handle edge cases like non-existent accounts."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Frequencies of Shortest Supersequences",
    "description": "Given two strings `s` and `t`, find all the distinct shortest supersequences of `t` in `s`. A supersequence is a string that can be derived from another string by deleting some characters without changing the order of the remaining characters. In this problem, you need to return the frequencies of the shortest supersequences found in `s`. If no supersequence is found, return an empty list.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Search"
    ],
    "input_format": "Two strings, s and t, where 1 <= s.length, t.length <= 1000.",
    "output_format": "A list of integers representing the frequencies of the distinct shortest supersequences of t found in s.",
    "constraints": [
      "1 <= s.length, t.length <= 1000",
      "s and t consist of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = \"abcde\", t = \"ace\"",
        "output": "[1]",
        "explanation": "The only shortest supersequence of 'ace' in 'abcde' is 'abcde' itself, which appears once."
      },
      {
        "input": "s = \"abcabc\", t = \"abc\"",
        "output": "[2]",
        "explanation": "The shortest supersequences of 'abc' in 'abcabc' are 'abc' and 'abc', both appearing two distinct times."
      },
      {
        "input": "s = \"xyz\", t = \"abc\"",
        "output": "[]",
        "explanation": "No supersequences of 'abc' can be formed from 'xyz'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to find the shortest supersequences.",
      "Keep track of positions of characters in the string."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Maximum Amount of Money Robot Can Earn",
    "description": "A robot is placed in a 1D street with houses located at non-negative integer positions. Each house has a certain amount of money it can give if robbed. The robot has a constraint: it cannot rob two adjacent houses. Given an array of non-negative integers representing the amount of money at each house, determine the maximum amount of money the robot can earn without robbing two adjacent houses.",
    "topic": "Dynamic Programming",
    "subtopic": "Robbery Problem",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Greedy"
    ],
    "input_format": "An array of non-negative integers nums, where nums[i] represents the amount of money at the ith house.",
    "output_format": "An integer representing the maximum amount of money the robot can earn.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 9, 3, 1]",
        "output": "12",
        "explanation": "Rob the 1st (2), 3rd (9), and 5th (1) houses for a total of 12. Robbing 2nd (7) and 3rd (9) would result in less."
      },
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "4",
        "explanation": "Rob the 1st (1) and 3rd (3) houses for a total of 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to use dynamic programming to store the maximum money that can be earned up to each house.",
      "Consider whether to rob the current house or not, based on the previous choices."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Check if Point Is Reachable",
    "description": "You are given a grid of size m x n, consisting of cells with integer values. You can start at the top-left cell and move either down or right to reach the bottom-right cell. Your task is to determine if a point x-coordinate, y-coordinate in the grid can be reached by only traversing cells that are less than or equal to a specified value k. Return true if the point is reachable, otherwise return false.",
    "topic": "Grid",
    "subtopic": "Pathfinding",
    "tags": [
      "Grid",
      "Pathfinding",
      "BFS",
      "DFS"
    ],
    "input_format": "An integer m (number of rows), an integer n (number of columns), a m x n integer grid and two integers x, y (coordinates of the target point) and an integer k (the threshold value).",
    "output_format": "A boolean indicating whether the point is reachable or not.",
    "constraints": [
      "1 <= m, n <= 100",
      "1 <= grid[i][j] <= 1000",
      "0 <= x < m",
      "0 <= y < n",
      "0 <= k <= 1000"
    ],
    "examples": [
      {
        "input": "m = 3, n = 3, grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], x = 2, y = 2, k = 5",
        "output": "true",
        "explanation": "You can traverse from (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2), all cells are <= 5."
      },
      {
        "input": "m = 2, n = 2, grid = [[1, 3], [5, 4]], x = 1, y = 1, k = 3",
        "output": "false",
        "explanation": "The cell (1,1) has a value of 4, which is > 3, so it cannot be reached."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using BFS or DFS for traversing the grid.",
      "Track visited cells to avoid infinite loops.",
      "Use a queue for BFS traversal."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Count the Number of Arrays with K Matching Adjacent Elements",
    "description": "Given an integer array nums and an integer K, count the number of contiguous subarrays where at least K adjacent elements are equal. Return this count as an integer.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Counting"
    ],
    "input_format": "An array of integers nums and an integer K.",
    "output_format": "An integer representing the count of contiguous subarrays with at least K matching adjacent elements.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= K <= nums.length",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2, 3, 3, 3], K = 2",
        "output": "7",
        "explanation": "The valid subarrays are [2, 2], [2, 2, 3], [3, 3], [2, 3, 3], [2, 2, 3, 3], [3, 3], [3, 3, 3]."
      },
      {
        "input": "nums = [1, 1, 1, 1], K = 3",
        "output": "4",
        "explanation": "The valid subarrays are [1, 1, 1], [1, 1, 1, 1], [1, 1, 1], [1, 1, 1, 1]."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Try using the sliding window technique to efficiently count the subarrays.",
      "Remember to keep track of the current length of matching elements."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Smallest String With Swaps",
    "description": "You are given a string s and an array of pairs of indices, where each pair (i, j) indicates that you can swap the characters at index i and index j. Your task is to return the lexicographically smallest string that can be obtained by performing any number of swaps of the characters in the string according to the given pairs of indices.",
    "topic": "String",
    "subtopic": "Union Find",
    "tags": [
      "String",
      "Union Find",
      "Graph"
    ],
    "input_format": "A string s of length n (1 <= n <= 10^5) followed by an array of pairs of indices (i, j) where 0 <= i, j < n.",
    "output_format": "A string representing the lexicographically smallest string after performing the swaps.",
    "constraints": [
      "1 <= s.length <= 100000",
      "0 <= pairs.length <= 100000",
      "0 <= pairs[i][0], pairs[i][1] < s.length"
    ],
    "examples": [
      {
        "input": "s = \"dcab\", pairs = [[0, 3], [1, 2]]",
        "output": "abcd",
        "explanation": "After swapping characters at indices 0 and 3, and then at indices 1 and 2, the smallest string obtained is 'abcd'."
      },
      {
        "input": "s = \"cba\", pairs = [[0, 1], [1, 2]]",
        "output": "abc",
        "explanation": "All characters can be swapped, resulting in the smallest string 'abc'."
      },
      {
        "input": "s = \"hggg\", pairs = [[0, 1], [1, 2]]",
        "output": "gggh",
        "explanation": "After reordering, the lexicographically smallest string is 'gggh'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a Union-Find data structure to group connected indices.",
      "Sort the characters within each group to form the smallest possible string."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Smallest Range Covering Elements from K Lists",
    "description": "You are given k lists of integers, where each list is sorted in ascending order. Your task is to find the smallest range that includes at least one number from each of the k lists. Return the range as a pair of integers [start, end]. If there are multiple smallest ranges, return the one with the smallest 'start'.",
    "topic": "Heap",
    "subtopic": "Sliding Window",
    "tags": [
      "Heap",
      "Sliding Window",
      "Sorting",
      "Interval"
    ],
    "input_format": "An array of k lists, where each list contains sorted integers.",
    "output_format": "An array of two integers representing the smallest range [start, end].",
    "constraints": [
      "1 <= k <= 100",
      "1 <= lists[i].length <= 100",
      "-10^5 <= lists[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "[[1, 2, 3], [4, 5], [7, 8, 9]]",
        "output": "[1, 4]",
        "explanation": "The smallest range is from 1 to 4, which includes elements from all three lists."
      },
      {
        "input": "[[10, 15], [2, 9], [5, 12]]",
        "output": "[9, 10]",
        "explanation": "The smallest range is from 9 to 10, which includes 9 from the second list and 10 from the first list."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a min-heap to store the current smallest elements from each list.",
      "You might need to track the maximum element in the current range to find the smallest range."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Find Beautiful Indices in the Given Array II",
    "description": "Given an array of integers, an index is considered 'beautiful' if the sum of the elements to the left of the index is equal to the sum of the elements to the right of the index. Your task is to find all 'beautiful' indices in the array and return them in a list. If no beautiful indices exist, return an empty list.",
    "topic": "Array",
    "subtopic": "Prefix Sum",
    "tags": [
      "Array",
      "Prefix Sum",
      "Index"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A list of integers representing the indices that are beautiful.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 0, 3, 2, 1]",
        "output": "[3]",
        "explanation": "At index 3, the sum of elements on the left (1 + 2 + 3 = 6) equals the sum on the right (3 + 2 + 1 = 6)."
      },
      {
        "input": "nums = [0, 0, 0, 0, 0]",
        "output": "[0, 1, 2, 3]",
        "explanation": "All indices are beautiful because the sum to the left and right of each index is always 0."
      },
      {
        "input": "nums = [1, 2, 3]",
        "output": "[]",
        "explanation": "There are no indices for which the left and right sums are equal."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using prefix sums to efficiently calculate left and right sums.",
      "Iterate through the array to check each index.",
      "Keep track of the total sum of the array to simplify calculations."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Viewers Turned Streamers",
    "description": "In a video streaming platform, viewers can become streamers by subscribing to certain channels. Each viewer starts with a specific number of subscriptions they can convert into streamers. Given an array where each element represents the number of subscriptions a viewer has, your task is to determine how many viewers can successfully turn into streamers. To be eligible, a viewer needs to convert at least 3 subscriptions into a streamer role. Additionally, a viewer can choose to turn only the maximum number of subscriptions available to them into streamers. Return the total number of viewers who successfully transitioned to streamers.",
    "topic": "Array",
    "subtopic": "Counting",
    "tags": [
      "Array",
      "Counting",
      "Greedy"
    ],
    "input_format": "An array of integers representing the number of subscriptions each viewer has.",
    "output_format": "An integer representing the total number of viewers who turned into streamers.",
    "constraints": [
      "1 <= subscribers.length <= 10^5",
      "0 <= subscribers[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "subscribers = [3, 5, 2, 1, 4]",
        "output": "3",
        "explanation": "Viewers with 3, 5, and 4 subscriptions can turn into streamers. Viewers with 2 and 1 subscriptions cannot."
      },
      {
        "input": "subscribers = [0, 1, 2, 3, 4, 5]",
        "output": "3",
        "explanation": "The viewers with 3, 4, and 5 can become streamers. The others cannot."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Focus on counting only those viewers with 3 or more subscriptions.",
      "Consider iterating through each element and checking the condition.",
      "Sorting may not be necessary; a simple count can suffice."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Remove K Digits",
    "description": "Given a non-negative integer num represented as a string and an integer k, remove k digits from num, such that the new number is the smallest possible. Note that the resulting number may not have leading zeros.",
    "topic": "String",
    "subtopic": "Greedy",
    "tags": [
      "String",
      "Greedy",
      "Stack"
    ],
    "input_format": "A string num representing a non-negative integer and an integer k.",
    "output_format": "A string representing the smallest number possible after removing k digits.",
    "constraints": [
      "1 <= num.length <= 10^5",
      "0 <= k < num.length"
    ],
    "examples": [
      {
        "input": "num = \"1432219\", k = 3",
        "output": "1219",
        "explanation": "Removing the digits '4', '3', and '2' will result in the smallest number '1219'."
      },
      {
        "input": "num = \"10200\", k = 1",
        "output": "200",
        "explanation": "Removing the digit '1' will give you '0200', which is '200' without leading zeros."
      },
      {
        "input": "num = \"10\", k = 2",
        "output": "0",
        "explanation": "Removing both digits results in an empty string which is interpreted as '0'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a greedy approach to ensure you are removing high value digits.",
      "Use a stack to keep track of the digits you want to keep."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Bus Routes",
    "description": "You are given a list of bus routes represented by arrays. Each bus route contains a set of stops that it serves. You need to determine the minimum number of buses required to travel from one stop to another. Given a source stop and a destination stop, return the minimum number of buses you must take to get from the source to the destination, or -1 if it is not possible.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "Shortest Path"
    ],
    "input_format": "A list of bus routes, where each route is represented by an array of integers indicating the stops it serves. Two integers, source and destination, represent the starting and ending stops.",
    "output_format": "An integer representing the minimum number of buses required to travel from source to destination, or -1 if not possible.",
    "constraints": [
      "1 <= busRoutes.length <= 1000",
      "1 <= busRoutes[i].length <= 100",
      "0 <= source, destination <= 10^6"
    ],
    "examples": [
      {
        "input": "[[1, 2, 7], [2, 3, 4], [4, 5, 6]], 1, 6",
        "output": "2",
        "explanation": "Take bus 1 from stop 1 to 2, then take bus 2 from 2 to 4, and finally take bus 3 from 4 to 6."
      },
      {
        "input": "[[1, 2, 7], [2, 3, 4], [4, 5, 6]], 1, 3",
        "output": "2",
        "explanation": "Take bus 1 from stop 1 to 2 and then take bus 2 from 2 to 3."
      },
      {
        "input": "[[1, 2, 7], [2, 3, 4], [4, 5, 6]], 5, 6",
        "output": "1",
        "explanation": "You can take bus 3 directly from stop 5 to stop 6."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a breadth-first search approach for finding the shortest path.",
      "Think about the relationships between stops and routes.",
      "Keep track of visited routes to avoid cycles."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Most Stones Removed with Same Row or Column",
    "description": "You are given a 2D grid representing stones placed on a board, where each stone has a specific position given by its coordinates (x, y). The goal is to remove the maximum number of stones such that no two stones share the same row or the same column after removal. You can remove a stone if and only if there are no other stones in the same row or column. Return the maximum number of stones that can be removed.",
    "topic": "Graph",
    "subtopic": "DFS/BFS",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Matrix"
    ],
    "input_format": "A 2D integer array stones where stones[i] = [xi, yi] represents the position of the ith stone.",
    "output_format": "An integer representing the maximum number of stones that can be removed.",
    "constraints": [
      "1 <= stones.length <= 2000",
      "-10^4 <= stones[i][j] <= 10^4"
    ],
    "examples": [
      {
        "input": "stones = [[0,0],[0,1],[1,0],[1,1]]",
        "output": "3",
        "explanation": "You can remove one stone from each row and one from each column, resulting in a maximum of 3 stones removed."
      },
      {
        "input": "stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]",
        "output": "5",
        "explanation": "You can keep the stone at (1, 1) and remove the others, resulting in a maximum of 5 stones removed."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a union-find data structure to track connected components.",
      "Count the number of unique rows and columns for maximum removals."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A palindromic substring is a substring that reads the same backward as forward.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A single string s, where 1 <= s.length <= 1000.",
    "output_format": "A string representing the longest palindromic substring in s.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consist of only digits and English letters."
    ],
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\"",
        "explanation": "Both \"bab\" and \"aba\" are valid longest palindromic substrings. The order doesn't matter."
      },
      {
        "input": "s = \"cbbd\"",
        "output": "\"bb\"",
        "explanation": "\"bb\" is the longest palindromic substring in this case."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding around center for potential palindromes.",
      "Use dynamic programming to store results of subproblems."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of bars in a histogram, compute how much water can be trapped after raining. The width of each bar is 1.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Water Trapping"
    ],
    "input_format": "An array of non-negative integers heights representing the heights of the bars.",
    "output_format": "An integer representing the total amount of rainwater trapped.",
    "constraints": [
      "0 <= heights.length <= 2 * 10^4",
      "0 <= heights[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "heights = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The water is trapped between the bars of heights, amounting to 6 units."
      },
      {
        "input": "heights = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The water is trapped between the bars, totaling to 9 units."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider two pointers to track left and right boundaries.",
      "Use a variable to store the maximum height seen from both left and right."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Maximum Profit in Job Scheduling",
    "description": "You have a list of jobs, where each job has a start time, end time, and a profit associated with it. Your goal is to maximize your total profit by scheduling jobs such that no two jobs overlap. You can take at most one job at a time. Write a function to determine the maximum profit you can achieve with the given jobs.",
    "topic": "Dynamic Programming",
    "subtopic": "Weighted Interval Scheduling",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Interval Scheduling"
    ],
    "input_format": "A list of jobs, where each job is represented as a tuple (start_time, end_time, profit).",
    "output_format": "An integer representing the maximum profit that can be achieved.",
    "constraints": [
      "1 <= jobs.length <= 10^5",
      "0 <= start_time < end_time <= 10^9",
      "0 <= profit <= 10^6"
    ],
    "examples": [
      {
        "input": "jobs = [(1, 2, 50), (3, 5, 20), (6, 19, 100), (2, 100, 200)]",
        "output": "250",
        "explanation": "Select the jobs (1, 2, 50) and (2, 100, 200) for a total profit of 250."
      },
      {
        "input": "jobs = [(1, 4, 100), (2, 6, 200), (5, 7, 150)]",
        "output": "300",
        "explanation": "Select the jobs (1, 4, 100) and (5, 7, 150) for a total profit of 300."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider sorting the jobs by their end times.",
      "You may want to utilize binary search to find the previous non-conflicting job."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "House Robber",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected, and it will automatically contact the police if two adjacent houses were broken into. Given a list of integers representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "topic": "Dynamic Programming",
    "subtopic": "Robbery Problem",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "A list of integers nums where nums[i] represents the amount of money at the i-th house.",
    "output_format": "An integer representing the maximum amount of money that can be robbed.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 400"
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 9, 3, 1]",
        "output": "12",
        "explanation": "Robbing house 1 (2), house 3 (9), and house 4 (1) results in 2 + 9 + 1 = 12."
      },
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "4",
        "explanation": "Robbing house 1 (1) and house 3 (3) results in a total of 1 + 3 = 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to keep track of maximum money robbed up to each house.",
      "You can either rob a house or skip it; consider the consequences of both choices."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Frequency of the Most Frequent Element",
    "description": "Given an integer array nums, return the maximum frequency of any element that appears in the array. If all elements are unique, then return 1. The frequency of an element is the number of times it appears in the array.",
    "topic": "Array",
    "subtopic": "Frequency Counting",
    "tags": [
      "Array",
      "Frequency",
      "HashMap"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum frequency of any element in the array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2, 3, 3, 3]",
        "output": "3",
        "explanation": "The number 3 appears 3 times, which is the highest frequency."
      },
      {
        "input": "nums = [5, 5, 5, 5, 1, 1, 1, 2]",
        "output": "4",
        "explanation": "The number 5 appears 4 times, which is the highest frequency."
      },
      {
        "input": "nums = [9, 8, 7, 6]",
        "output": "1",
        "explanation": "All elements are unique, thus the maximum frequency is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map to count the frequency of each element.",
      "Iterate through the hash map to find the maximum frequency."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Split Array Largest Sum",
    "description": "Given an array nums of n integers and an integer k, you need to split nums into k non-empty continuous subarrays. The largest sum among these subarrays should be minimized. Return the minimized largest sum of the split array.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An integer representing the minimized largest sum of the split array.",
    "constraints": [
      "1 <= n <= 10000",
      "0 <= nums[i] <= 10^6",
      "1 <= k <= n"
    ],
    "examples": [
      {
        "input": "nums = [7, 2, 5, 10, 8], k = 2",
        "output": "18",
        "explanation": "The optimal split is [7, 2, 5] and [10, 8]. The largest sum is max(14, 18) = 18."
      },
      {
        "input": "nums = [1, 2, 3, 4, 5], k = 2",
        "output": "9",
        "explanation": "The optimal split is [1, 2, 3] and [4, 5]. The largest sum is max(6, 9) = 9."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the range of the result from max(nums) to sum(nums).",
      "Use binary search to find the minimum largest sum."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "House Robber II",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected which will automatically contact the police if two adjacent houses were broken into on the same night. This time, all houses are arranged in a circle, meaning the first house is adjacent to the last house. Given an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "topic": "Dynamic Programming",
    "subtopic": "Robbery Problem",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Greedy"
    ],
    "input_format": "An integer array nums where 1 <= nums.length <= 100 and 0 <= nums[i] <= 1000.",
    "output_format": "An integer representing the maximum amount of money that can be robbed.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 2]",
        "output": "3",
        "explanation": "Robbing the second house yields the maximum amount of money."
      },
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "4",
        "explanation": "Robbing the first and third houses yields the maximum amount of money."
      },
      {
        "input": "nums = [0]",
        "output": "0",
        "explanation": "There are no houses to rob."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider breaking the problem into two cases: robbing from house 0 to house n-2 and from house 1 to house n-1.",
      "Use a dynamic programming approach to keep track of maximum amounts."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Queue Reconstruction by Height",
    "description": "You are given an array of people where people[i] = [h_i, k_i] represents the height and the number of people in front of this person who have a height greater than or equal to h_i. Your task is to reconstruct the queue by returning the reconstructed queue in any order. The queue should satisfy the conditions outlined by h_i and k_i for each individual.",
    "topic": "Greedy",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Greedy"
    ],
    "input_format": "A list of lists, where each list contains two integers representing height and the number of people in front.",
    "output_format": "A list of lists representing the reconstructed queue.",
    "constraints": [
      "1 <= people.length <= 2000",
      "0 <= h_i <= 1000",
      "0 <= k_i < people.length"
    ],
    "examples": [
      {
        "input": "[[7, 0], [4, 4], [7, 1], [5, 0], [6, 1]]",
        "output": "[[5, 0], [6, 1], [4, 4], [7, 0], [7, 1]]",
        "explanation": "The person with height 5 and k=0 goes to the front, followed by the person with height 6 who has 1 person in front, then the person with height 4 and k=4 is placed next, leaving the two people with height 7 at the end."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about sorting the array by height and then inserting each person in the correct position.",
      "Consider using a sorted data structure for efficient insertion."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Candy",
    "description": "There are n children standing in a line, and each child is assigned a rating value. You need to distribute candies to these children such that each child receives at least one candy and children with a higher rating get more candies than their neighbors. Determine the minimum number of candies you must distribute to satisfy these requirements.",
    "topic": "Greedy",
    "subtopic": "Distribution",
    "tags": [
      "Greedy",
      "Array",
      "Simulation"
    ],
    "input_format": "An integer array ratings where ratings[i] is the rating of the ith child.",
    "output_format": "An integer representing the minimum number of candies needed.",
    "constraints": [
      "1 <= ratings.length <= 2 * 10^4",
      "0 <= ratings[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "ratings = [1, 0, 2]",
        "output": "5",
        "explanation": "The distribution of candies can be [2, 1, 2] where child 1 (rating 1) gets more than child 2 (rating 0), and child 3 (rating 2) gets more than both of its neighbors."
      },
      {
        "input": "ratings = [1, 2, 2]",
        "output": "4",
        "explanation": "The distribution of candies can be [1, 2, 1] where child 1 (rating 1) gets 1, child 2 (rating 2) gets more candies than child 1 and same as child 3."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider traversing the array from left to right and then from right to left to ensure the conditions are met.",
      "Use two passes to determine the minimum candies required."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit",
    "description": "Given an integer array nums and an integer limit, find the length of the longest continuous subarray such that the absolute difference between the maximum and minimum elements in this subarray is less than or equal to the limit.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Two Pointers"
    ],
    "input_format": "An integer array nums and an integer limit.",
    "output_format": "An integer representing the length of the longest continuous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9",
      "0 <= limit <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [8, 2, 4, 7], limit = 4",
        "output": "4",
        "explanation": "The entire array satisfies the condition as max(8, 2, 4, 7) - min(8, 2, 4, 7) = 6 <= 4. Therefore, the length of the longest subarray is 4."
      },
      {
        "input": "nums = [10, 1, 2, 3, 4, 5], limit = 2",
        "output": "4",
        "explanation": "The longest subarray is [1, 2, 3, 4] with max = 4 and min = 1, which gives max - min = 3 > 2. The best is [2, 3] with length 2."
      },
      {
        "input": "nums = [4, 2, 2, 2, 4, 4, 2, 2], limit = 0",
        "output": "5",
        "explanation": "The longest subarray with absolute difference of maximum and minimum equal to 0 is [2, 2, 2, 2, 2], which has a length of 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window technique to maintain the range of the current subarray.",
      "Utilize a data structure to efficiently retrieve the max and min values within the sliding window."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Amount of Time for Binary Tree to Be Infected",
    "description": "Given a binary tree and an integer representing the starting node at which a virus starts to spread, calculate the amount of time it takes for the virus to infect all nodes in the binary tree. The virus spreads to all connected nodes (children) each second.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "DFS",
      "BFS"
    ],
    "input_format": "The input consists of a binary tree represented by its root node and an integer indicating the starting infection node.",
    "output_format": "An integer representing the amount of time (in seconds) for the virus to infect all nodes.",
    "constraints": [
      "1 <= number of nodes <= 10^4",
      "Node values are unique and will be within the range [1, number of nodes]."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, 4, 5, 6, 7], startNode = 3",
        "output": "4",
        "explanation": "Starting from node 3, the virus spreads to nodes 2 and 6 after 1 second. After 2 seconds, it spreads to nodes 1 and 5. After 3 seconds, the virus spreads to nodes 4 and 7, ultimately infecting all nodes in 4 seconds."
      },
      {
        "input": "root = [1], startNode = 1",
        "output": "0",
        "explanation": "The virus starts at the only node which is already infected, thus it takes 0 seconds."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using DFS or BFS to traverse the tree.",
      "Track the time taken for the virus to spread to neighboring nodes."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Reachable Nodes In Subdivided Graph",
    "description": "You are given a graph that is represented as a list of edges along with a list of nodes. Each edge connects two nodes and may be subdivided into multiple segments. Your task is to determine the maximum number of nodes that can be reached from a starting node within a specified number of moves. You must consider subdivisions as separate segments for the purpose of reaching nodes.",
    "topic": "Graph",
    "subtopic": "Graph Traversal",
    "tags": [
      "Graph",
      "Traversal",
      "BFS",
      "DFS"
    ],
    "input_format": "An integer n representing the number of nodes, a list of edges represented as pairs of integers, and an integer maxMoves indicating the number of allowable moves.",
    "output_format": "An integer representing the maximum number of reachable nodes from the starting node.",
    "constraints": [
      "1 <= n <= 10^4",
      "1 <= edges.length <= 2 * 10^4",
      "0 <= maxMoves <= 10^4"
    ],
    "examples": [
      {
        "input": {
          "n": 5,
          "edges": [
            [
              0,
              1
            ],
            [
              0,
              2
            ],
            [
              1,
              3
            ],
            [
              1,
              4
            ]
          ],
          "maxMoves": 2
        },
        "output": "4",
        "explanation": "Starting from node 0, you can reach nodes 1 and 2. From node 1, you can further reach nodes 3 and 4, making a total of 4 reachable nodes."
      },
      {
        "input": {
          "n": 6,
          "edges": [
            [
              0,
              1
            ],
            [
              0,
              2
            ],
            [
              2,
              3
            ],
            [
              3,
              4
            ],
            [
              4,
              5
            ]
          ],
          "maxMoves": 3
        },
        "output": "5",
        "explanation": "Starting from node 0, you can reach nodes 1, 2, and then further move to nodes 3 and 4 using 3 moves, which allows accessing nodes up to 5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using BFS or DFS for exploring reachable nodes.",
      "Keep track of the number of moves used as you traverse the graph."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Sum of Distances in Tree",
    "description": "Given a tree rooted at node 0 with n nodes, where the nodes are numbered from 0 to n-1, you need to calculate the sum of distances from each node to all other nodes. The distances for a node are defined as the number of edges in the simple path that connects the two nodes. You should return an array where the i-th element is the sum of distances from node i to all other nodes in the tree.",
    "topic": "Graph",
    "subtopic": "Tree",
    "tags": [
      "Tree",
      "Graph",
      "DFS",
      "BFS"
    ],
    "input_format": "An integer n representing the number of nodes followed by a list of edges, where each edge is represented as a pair of integers [u, v] indicating an edge between nodes u and v.",
    "output_format": "An array of integers, where the i-th integer represents the sum of distances from node i to all other nodes.",
    "constraints": [
      "1 <= n <= 10000",
      "0 <= edges.length <= 2 * n - 2",
      "edges[i] contains two distinct integers between 0 and n-1."
    ],
    "examples": [
      {
        "input": "n = 6, edges = [[0, 1], [0, 2], [0, 3], [3, 4], [3, 5]]",
        "output": "[8, 12, 12, 12, 16, 16]",
        "explanation": "The distances from each node can be represented, and the sum of distances calculated gives the required output."
      },
      {
        "input": "n = 1, edges = []",
        "output": "[0]",
        "explanation": "For a single node, the sum of distances to itself is zero."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using DFS or BFS to calculate distances efficiently.",
      "Use memoization to avoid redundant calculations.",
      "Think about the contributions of each node to the distances of its children and parent."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Kth Smallest Element in a Sorted Matrix",
    "description": "Given a n x n matrix where each of the rows and columns is sorted in ascending order, write a program to find the kth smallest element in the matrix. Note that it is guaranteed that k is always valid, 1 \u2264 k \u2264 n * n.",
    "topic": "Binary Search",
    "subtopic": "Matrix",
    "tags": [
      "Binary Search",
      "Matrix",
      "Sorting"
    ],
    "input_format": "A 2D array of integers matrix and an integer k.",
    "output_format": "An integer representing the kth smallest element in the matrix.",
    "constraints": [
      "n == matrix.length",
      "n == matrix[i].length",
      "1 <= n <= 300",
      "-10^9 <= matrix[i][j] <= 10^9",
      "All the integers in the matrix are unique.",
      "1 <= k <= n * n"
    ],
    "examples": [
      {
        "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
        "output": "13",
        "explanation": "The 8th smallest element in the sorted order is 13."
      },
      {
        "input": "matrix = [[-5]], k = 1",
        "output": "-5",
        "explanation": "The only element in the matrix is -5, which is the 1st smallest."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search on the value range.",
      "Count how many numbers are less than or equal to a mid value."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Make Lexicographically Smallest Array by Swapping Elements",
    "description": "Given an array of distinct integers, you are allowed to perform at most one swap of any two elements in the array. Your task is to determine the lexicographically smallest array that can be formed by making at most one swap. If no swap is needed, return the original array.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Sorting"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "An array of integers representing the lexicographically smallest arrangement.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 1]",
        "output": "[1, 2, 3]",
        "explanation": "By swapping the first and last elements, we get the smallest possible arrangement."
      },
      {
        "input": "nums = [1, 3, 2]",
        "output": "[1, 2, 3]",
        "explanation": "Swapping 3 and 2 gives the lexicographically smallest array."
      },
      {
        "input": "nums = [1, 2, 3]",
        "output": "[1, 2, 3]",
        "explanation": "No swaps are needed as the array is already in the smallest arrangement."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the position of the smallest element that can be swapped.",
      "Use a greedy approach to determine the best swap."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Koko Eating Bananas",
    "description": "Koko loves to eat bananas, and she wants to finish eating all bananas in a given number of piles. Each pile contains a certain amount of bananas represented by an array. Koko can eat at a speed of k bananas per hour, and she can choose any k value for each hour. However, Koko wants to finish eating all the bananas in the least number of hours. What is the minimum speed k Koko should eat the bananas per hour to finish all of them in H hours?",
    "topic": "Binary Search",
    "subtopic": "Searching",
    "tags": [
      "Binary Search",
      "Greedy",
      "Array"
    ],
    "input_format": "An integer array piles, where piles[i] represents the number of bananas in the i-th pile, and an integer H representing the maximum number of hours.",
    "output_format": "An integer representing the minimum speed k to eat all bananas in H hours.",
    "constraints": [
      "1 <= piles.length <= 10^4",
      "1 <= piles[i] <= 10^9",
      "H >= piles.length"
    ],
    "examples": [
      {
        "input": "piles = [3, 6, 7, 11], H = 8",
        "output": "4",
        "explanation": "If Koko eats at speed 4, she can finish all piles in 8 hours: 3/4 + 6/4 + 7/4 + 11/4 = 0.75 + 1.5 + 1.75 + 2.75 = 6.75 hours."
      },
      {
        "input": "piles = [30, 11, 23, 4, 20], H = 5",
        "output": "30",
        "explanation": "If Koko eats at speed 30, she can finish all piles in 5 hours: 30/30 + 11/30 + 23/30 + 4/30 + 20/30 = 1 + 0.3667 + 0.7667 + 0.1333 + 0.6667 = 2.9334 hours."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to find the optimal speed.",
      "Start with the lowest possible speed and the maximum piles of bananas."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Initial Public Offering (IPO)",
    "description": "You are given a list of companies, each represented by a tuple containing the company's estimated profits and their respective losses. Your task is to find the maximum total profit you can achieve by conducting IPOs. However, you have a limitation on the maximum number of IPOs you can conduct. Determine the maximum profit you can earn while adhering to this restriction.",
    "topic": "Dynamic Programming",
    "subtopic": "Maximizing Profit",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Profit Maximization"
    ],
    "input_format": "A list of tuples where each tuple contains two integers: (profits, losses), and an integer max_Ipo to represent the maximum number of IPOs you can conduct.",
    "output_format": "An integer representing the maximum total profit.",
    "constraints": [
      "1 <= len(companies) <= 1000",
      "0 <= profits <= 10^6",
      "0 <= losses <= 10^6",
      "1 <= max_Ipo <= 100"
    ],
    "examples": [
      {
        "input": "companies = [(500, 200), (1000, 300), (1500, 500)], max_Ipo = 2",
        "output": "2000",
        "explanation": "Conducting the IPOs of the first two companies yields a profit of 500 + 1000 = 1500. We cannot conduct the third IPO since we have already conducted 2 IPOs."
      },
      {
        "input": "companies = [(250, 50), (300, 100), (200, 200)], max_Ipo = 1",
        "output": "250",
        "explanation": "The best option is to conduct the IPO of the first company, giving a profit of 250."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a greedy approach to select companies with the highest profit-to-loss ratio.",
      "Order the companies by potential profit and check how many IPOs you can afford."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. For example, if intervals = [[1,3],[2,6],[8,10],[15,18]], the output should be [[1,6],[8,10],[15,18]].",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Intervals",
      "Merge"
    ],
    "input_format": "A 2D array of integers, where each inner array represents an interval.",
    "output_format": "A 2D array of merged intervals.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "The intervals [1,3] and [2,6] overlap, so they are merged into [1,6]. The other intervals do not overlap."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "The intervals [1,4] and [4,5] overlap, so they are merged into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on the start time.",
      "Use a result list to keep track of merged intervals."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Jump Game II",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to find the minimum number of jumps needed to reach the last index, starting from the first index. If you cannot reach the last index, return -1.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of non-negative integers nums representing jump lengths.",
    "output_format": "An integer representing the minimum number of jumps to reach the last index, or -1 if not possible.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "2",
        "explanation": "Jump 1 step from index 0 to 1, then 1 jump from index 1 to 4 to reach the last index."
      },
      {
        "input": "nums = [2, 1, 0, 3]",
        "output": "-1",
        "explanation": "It is not possible to reach the last index."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the maximum reachable index at each position.",
      "Use a greedy approach to minimize the number of jumps."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices representing the stock prices on different days.",
    "output_format": "An integer representing the maximum profit possible.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). Maximum profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate the profit by subtracting the minimum price from the current price."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock III",
    "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. However, you are allowed to make at most two transactions (i.e., buy and sell up to two times). Return the maximum profit you can achieve with at most two transactions. If you cannot achieve any profit, return 0.",
    "topic": "Dynamic Programming",
    "subtopic": "Stock Buy and Sell",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers prices where 0 <= prices.length <= 10^5 and 0 <= prices[i] <= 10^4.",
    "output_format": "An integer representing the maximum profit that can be achieved.",
    "constraints": [
      "0 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [3,2,6,5,0,3]",
        "output": "7",
        "explanation": "Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6 - 2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3 - 0 = 3. Total profit = 4 + 3 = 7."
      },
      {
        "input": "prices = [1,2,3,4,5]",
        "output": "4",
        "explanation": "Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5 - 1 = 4. This is the maximum profit that can be achieved."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "No transactions are done since the prices never rise."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider breaking down the problem into simpler transactions.",
      "Think about tracking the minimum buy price and maximum profit iteratively.",
      "Use dynamic programming to maintain the state for the maximum profits with one or two transactions."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Split Array into Consecutive Subsequences",
    "description": "Given an integer array nums, you need to check if it is possible to split the array into one or more consecutive subsequences such that each consecutive subsequence is of length at least 3. Return true if you can do it, and false otherwise.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Sorting"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A boolean indicating whether the array can be split into consecutive subsequences.",
    "constraints": [
      "1 <= nums.length <= 10000",
      "0 <= nums[i] <= 10000"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 3, 4, 5]",
        "output": "true",
        "explanation": "We can split it into [1, 2, 3] and [3, 4, 5]."
      },
      {
        "input": "nums = [1, 2, 3, 3, 4, 4, 5, 5]",
        "output": "true",
        "explanation": "We can split it into [1, 2, 3], [3, 4, 5], and [4, 5]."
      },
      {
        "input": "nums = [1, 2, 3, 4, 5]",
        "output": "false",
        "explanation": "We cannot split it into consecutive subsequences of length at least 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hashmap to count the frequency of each number.",
      "Try to build subsequences by starting from the smallest number.",
      "Make sure to track the length of consecutive subsequences."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Distribute Coins in Binary Tree",
    "description": "In a binary tree, each node contains a number of coins. The goal is to distribute these coins among the nodes such that each node ends up with exactly one coin. To achieve this, you can move coins between nodes following the edges of the tree. You need to return the minimum number of moves required to achieve the distribution.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "DFS",
      "BFS"
    ],
    "input_format": "The input is a root of a binary tree represented as a TreeNode.",
    "output_format": "An integer representing the minimum number of moves required.",
    "constraints": [
      "1 <= number of nodes <= 100",
      "0 <= coins in each node <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,0,0]",
        "output": "2",
        "explanation": "There are 3 coins in the root and no coins in the children. We can move 1 coin to each child. Thus, it takes 2 moves."
      },
      {
        "input": "root = [0,3,0]",
        "output": "3",
        "explanation": "There are 3 coins in the left child and none in the root and right child. Moving 1 coin to the root takes 1 move and then moving 1 coin to the right child takes 2 moves."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you can balance the coins without moving them unnecessarily.",
      "Use DFS to calculate needed moves for balancing."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Rotting Oranges",
    "description": "In a grid of m x n cells, each cell can be either fresh (1), rotten (2), or empty (0). Every minute, any fresh orange that is adjacent (horizontally or vertically) to a rotten orange will become rotten. Your goal is to determine how many minutes will pass until no fresh oranges remain. If it is impossible for some fresh oranges to become rotten, return -1.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "Breadth First Search",
      "Matrix"
    ],
    "input_format": "A 2D grid of integers where each integer represents the state of the cell: 0 (empty), 1 (fresh orange), 2 (rotten orange).",
    "output_format": "An integer representing the minimum number of minutes until no fresh oranges remain, or -1 if it is impossible.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 10",
      "grid[i][j] is 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "[[2,1,1],[1,1,0],[0,1,1]]",
        "output": "4",
        "explanation": "Initially, the rotten orange at (0,0) will infect its neighbors in the following sequence: (0,1) -> (1,0) -> (1,1) -> (2,1) with a total of 4 minutes."
      },
      {
        "input": "[[2,1,1],[0,1,1],[1,0,2]]",
        "output": "-1",
        "explanation": "Fresh oranges at (1,1) and (2,0) cannot be reached by a rotten orange, so some fresh oranges will remain forever."
      },
      {
        "input": "[[0,2]]",
        "output": "0",
        "explanation": "There are no fresh oranges to begin with, so it takes 0 minutes."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to facilitate the processing of the rotten oranges.",
      "Keep track of time using a counter variable.",
      "Check for adjacent cells to determine if fresh oranges can rot."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Word Ladder",
    "description": "Given two words, beginWord and endWord, and a dictionary's word list, find the length of the shortest transformation sequence from beginWord to endWord, such that only one letter can be changed at a time and each transformed word must exist in the word list. Note that beginWord is not a part of the word list. If there is no such transformation sequence, return 0.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "Graph",
      "BFS",
      "String"
    ],
    "input_format": "A string beginWord, a string endWord, and a list of strings wordList.",
    "output_format": "An integer representing the number of words in the transformation sequence. Returns 0 if no such sequence exists.",
    "constraints": [
      "1 <= beginWord.length <= 10",
      "1 <= endWord.length <= 10",
      "1 <= wordList.length <= 5000",
      "beginWord != endWord",
      "All words consist of lowercase alphabetic characters."
    ],
    "examples": [
      {
        "input": {
          "beginWord": "hit",
          "endWord": "cog",
          "wordList": [
            "hot",
            "dot",
            "dog",
            "lot",
            "log",
            "cog"
          ]
        },
        "output": "5",
        "explanation": "The shortest transformation sequence is 'hit' -> 'hot' -> 'dot' -> 'dog' -> 'cog', which is 5 words long."
      },
      {
        "input": {
          "beginWord": "hit",
          "endWord": "cog",
          "wordList": [
            "hot",
            "dot",
            "dog",
            "lot",
            "log"
          ]
        },
        "output": "0",
        "explanation": "There is no such transformation sequence because 'cog' is not in the word list."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use BFS to explore all possible transformations.",
      "Keep track of visited words to avoid cycles.",
      "Consider creating an adjacency list based on one-letter differences."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "House Robber III",
    "description": "In this problem, you are a famous robber, and you want to rob houses along a street. Each house has a certain amount of money stashed, while adjacent houses have security systems connected; if two adjacent houses are robbed, the security system will automatically contact the police. You need to decide where to rob without alerting the police. In this case, the houses are arranged in a binary tree structure. Your task is to maximize the amount of money you can rob tonight without triggering any alarms. Assume each house has a value associated with it, which is given as a binary tree node. You need to return the maximum amount of money you can rob tonight without alerting the police.",
    "topic": "Dynamic Programming",
    "subtopic": "Tree",
    "tags": [
      "Dynamic Programming",
      "Tree",
      "Binary Tree"
    ],
    "input_format": "The input is the root node of a binary tree, where each node contains an integer representing the amount of money stashed in that house.",
    "output_format": "An integer representing the maximum amount of money you can rob tonight.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root = [3,2,3,null,3,null,1]",
        "output": "7",
        "explanation": "Robbing houses with values 3, 3, and 1 will give us 3 + 3 + 1 = 7."
      },
      {
        "input": "root = [3,4,5,1,3,null,1]",
        "output": "9",
        "explanation": "Robbing houses with values 4, 5, and 1 will give us 4 + 5 = 9."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a recursive approach with memoization.",
      "Think about the decision to rob a house or not to rob it."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Accounts Merge",
    "description": "You are given a list of accounts where each account is represented as a list of strings. The first element of each list is the name of the account, and the rest are emails associated with that account. Two accounts are considered the same if they have the same name and share at least one email. They should be merged into one account containing all unique emails. Return a list of unique accounts after merging.",
    "topic": "Graph",
    "subtopic": "Union Find",
    "tags": [
      "Graph",
      "Union Find",
      "String"
    ],
    "input_format": "A list of lists representing accounts, where each account is a list of strings.",
    "output_format": "A list of lists representing the merged accounts.",
    "constraints": [
      "1 <= accounts.length <= 100",
      "1 <= accounts[i].length <= 100",
      "accounts[i][0] is a non-empty string",
      "accounts[i][j] is a valid email address"
    ],
    "examples": [
      {
        "input": "[['John', 'johnsmith@mail.com', 'john00@mail.com'], ['John', 'johnnybravo@mail.com'], ['John', 'johnsmith@mail.com', 'john_newyork@mail.com']]",
        "output": "[['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], ['John', 'johnnybravo@mail.com']]",
        "explanation": "The first and third accounts are merged because they share 'johnsmith@mail.com'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a Union-Find data structure for efficiently merging accounts.",
      "Use a map to associate emails with a representative account."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Sort Colors",
    "description": "Given an array nums consisting of n objects colored red, white, or blue, sort them in place so that objects of the same color are adjacent, with the colors in the order red (0), white (1), and blue (2). You must solve this problem without using the language's built-in sort function and you must do it in a single-pass algorithm.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Sorting",
      "Two Pointers"
    ],
    "input_format": "An integer array nums, where each element is 0, 1, or 2.",
    "output_format": "The same array nums sorted in place.",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 300",
      "nums[i] is either 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "nums = [2, 0, 2, 1, 1, 0]",
        "output": "[0, 0, 1, 1, 2, 2]",
        "explanation": "The colors are sorted to become [0, 0, 1, 1, 2, 2]."
      },
      {
        "input": "nums = [2, 0, 1]",
        "output": "[0, 1, 2]",
        "explanation": "The colors are sorted to become [0, 1, 2]."
      },
      {
        "input": "nums = [1]",
        "output": "[1]",
        "explanation": "Single color array remains the same."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use three pointers to track the positions for red, white, and blue.",
      "The first pointer can denote the position of red, the second for white, and the third for blue."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Maximal Square",
    "description": "Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "Matrix",
    "tags": [
      "Dynamic Programming",
      "Matrix",
      "2D Array",
      "Square"
    ],
    "input_format": "A 2D binary matrix represented by a list of lists containing 0's and 1's.",
    "output_format": "An integer representing the area of the largest square containing only 1's.",
    "constraints": [
      "1 <= m, n <= 300",
      "matrix[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "matrix = [[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]",
        "output": "4",
        "explanation": "The largest square has a side length of 2, and thus its area is 2 * 2 = 4."
      },
      {
        "input": "matrix = [[0,0,0,0],[0,1,1,1],[0,1,1,1],[0,0,0,0]]",
        "output": "9",
        "explanation": "The largest square has a side length of 3, so its area is 3 * 3 = 9."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to use an array to keep track of the maximum size of the square ending at each position.",
      "Dynamic programming can help in building solutions from subproblems."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Sliding Window Maximum",
    "description": "Given an integer array nums and an integer k, return the maximum sliding window of size k over the array. You must solve it in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Queue"
    ],
    "input_format": "An array of integers nums followed by an integer k.",
    "output_format": "An array of integers representing the maximum values in each sliding window.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
        "output": "[3,3,5,5,6,7]",
        "explanation": "The maximum sliding windows are: [3, 3], [3, 5], [5, 5], [6, 7] respectively."
      },
      {
        "input": "nums = [1, -1], k = 1",
        "output": "[1,-1]",
        "explanation": "Each element is its own window of size 1."
      },
      {
        "input": "nums = [9, 7, 8, 6, 5], k = 2",
        "output": "[9, 8, 7, 6]",
        "explanation": "The maximums of the two-element windows are 9, 8, 7, and 6."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a deque to store indices of useful elements.",
      "Make sure to remove elements not in the current window.",
      "Maintain the order of elements in the deque."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Swim in Rising Water",
    "description": "You are swimming in a pool whose water level is rising continuously. The pool has dimensions of length L, width W, and a maximum depth H. You start at the bottom of the pool at position (0, 0, 0). Each second, the water rises by R meters. You want to determine the minimum amount of time it takes for you to reach the surface of the water given that you can swim straight up at a speed of S meters per second. If the water level rises above your position, you will be submerged. If you cannot reach the surface before the water level rises above where you are, return -1. Otherwise, return the time taken in seconds, rounded up to the nearest integer.",
    "topic": "Simulation",
    "subtopic": "Water Flow",
    "tags": [
      "Simulation",
      "Geometry",
      "Math"
    ],
    "input_format": "Four integers L, W, H, R, and S.",
    "output_format": "An integer representing the minimum amount of time to reach the surface, or -1 if it is impossible.",
    "constraints": [
      "1 <= L, W <= 1000",
      "1 <= H <= 100",
      "1 <= R, S <= 100"
    ],
    "examples": [
      {
        "input": "L = 10, W = 10, H = 10, R = 2, S = 5",
        "output": "2",
        "explanation": "After 2 seconds, the water level will be at 4 meters and the swimmer can swim to the surface in 2 seconds."
      },
      {
        "input": "L = 10, W = 10, H = 10, R = 5, S = 2",
        "output": "-1",
        "explanation": "The water level rises faster than you can swim, so you will be submerged."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the relationship between swimming speed and rising speed.",
      "Use ceiling functions to ensure time is rounded up."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Minimum Cost to Cut a Stick",
    "description": "You are given a stick of length n meters and a list of positions where you can cut the stick. Your task is to determine the minimum cost required to cut the stick into segments such that all cuts are made. The cost of making a cut at position x is equal to the length of the stick that that cut is made on. For example, if you cut a stick of length 10 at position 4, the cost incurred is 10. You need to output the minimum cost required to make all the cuts.",
    "topic": "Dynamic Programming",
    "subtopic": "Minimization",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Cost Minimization"
    ],
    "input_format": "An integer n representing the length of the stick, and a list of integers cuts representing the positions of cuts.",
    "output_format": "An integer representing the minimum cost to cut the stick.",
    "constraints": [
      "2 <= n <= 1000",
      "1 <= cuts.length <= 1000",
      "1 <= cuts[i] < n",
      "All cuts[i] are distinct"
    ],
    "examples": [
      {
        "input": "n = 7, cuts = [1, 3, 4, 5]",
        "output": "16",
        "explanation": "The minimum cost occurs when making the cuts in the order 3, 4, and then 1 followed by 5. The costs are: cut at 3 (length 7), cut at 4 (length 4), cut at 5 (length 3), cut at 1 (length 3). Total = 7 + 4 + 3 + 3 = 16."
      },
      {
        "input": "n = 9, cuts = [5, 6, 1, 4]",
        "output": "20",
        "explanation": "The minimum cost occurs when making the cuts in the order 4, 5, 6, and then 1. The costs are: cut at 4 (length 9), cut at 5 (length 5), cut at 6 (length 4), cut at 1 (length 5). Total 9 + 5 + 4 + 5 = 20."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Think about using dynamic programming to store the minimum costs.",
      "Consider the cost of each cut depending on the segments it creates."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Find Duplicate Subtrees",
    "description": "Given a binary tree, find all subtrees that have duplicate structures in the tree. A subtree is considered to be duplicate if it has the same structure and node values as another subtree in the tree. Return a list of these duplicate subtrees. Each subtree should be represented by the root node of its corresponding subtree.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Recursion"
    ],
    "input_format": "The input will be the root node of a binary tree.",
    "output_format": "A list of root nodes of the duplicate subtrees.",
    "constraints": [
      "The number of nodes in the tree is between 1 and 1000.",
      "-200 <= Node.val <= 200"
    ],
    "examples": [
      {
        "input": "root = [1,2,3,4,null,2,4,null,null,4]",
        "output": "[2,4]",
        "explanation": "The tree contains two duplicate subtrees: one rooted at the node with value 2 and another rooted at the node with value 4."
      },
      {
        "input": "root = [2,1,1]",
        "output": "[1]",
        "explanation": "The tree contains one duplicate subtree, which is the subtree rooted at the node with value 1."
      },
      {
        "input": "root = [1,2,3,4]",
        "output": "[]",
        "explanation": "This tree does not have any duplicate subtrees."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hashmap to track the serialized forms of the subtrees.",
      "Consider using a depth-first search (DFS) for traversal.",
      "A duplicate subtree has the same serialization string as another subtree."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Binary Tree Level Order Traversal",
    "description": "Given a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "BFS",
      "Traversal"
    ],
    "input_format": "The root node of a binary tree.",
    "output_format": "A list of lists of integers, where each inner list represents the values of nodes at a particular level.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [3, 9, 20, null, null, 15, 7]",
        "output": "[[3], [9, 20], [15, 7]]",
        "explanation": "The tree has the following structure: \n    3\n   / \\\n  9  20\n     /  \\\n    15   7\nThe level order traversal is [[3], [9, 20], [15, 7]]."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree results in an empty level order traversal."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to facilitate the level order traversal.",
      "Consider using a list to keep track of the values at each level."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Binary Tree Cameras",
    "description": "You are given the root of a binary tree. Each node in the tree can be covered by a camera placed either in the node itself or in its parent node. The goal is to place the minimum number of cameras necessary to monitor all nodes in the tree. A camera covers its node and all its descendants. Return the minimum number of cameras needed to monitor the entire tree.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "A binary tree represented by its root node.",
    "output_format": "An integer representing the minimum number of cameras needed to cover the entire tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 1000].",
      "Node values are unique and in the range [0, 10^4]."
    ],
    "examples": [
      {
        "input": "root = [0,0,null,0,0]",
        "output": "1",
        "explanation": "Place one camera at the root node to cover all nodes."
      },
      {
        "input": "root = [0,0,0,null,null,0,null,null,0]",
        "output": "2",
        "explanation": "Two cameras are needed: one at the root and another at one of its children."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider placing cameras at each node and observe the coverage.",
      "Use a DFS approach to decide where to place cameras optimally."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Asteroid Collision",
    "description": "You are given an array of integers representing asteroids in a row. For each asteroid, a positive integer represents its size, and a negative integer represents its size and direction (toward the left). When two asteroids collide, the smaller one is destroyed. If they are the same size, both are destroyed. Return the final configuration of the asteroids after all collisions have been processed.",
    "topic": "Stack",
    "subtopic": "Collision Detection",
    "tags": [
      "Stack",
      "Simulation",
      "Array"
    ],
    "input_format": "An array of integers representing the asteroids.",
    "output_format": "An array of integers representing the final state of the asteroids after all collisions.",
    "constraints": [
      "1 <= asteroids.length <= 10^4",
      "-1000 <= asteroids[i] <= 1000",
      "Asteroids are non-zero integers."
    ],
    "examples": [
      {
        "input": "asteroids = [5, 10, -5]",
        "output": "[5, 10]",
        "explanation": "The asteroid 5 and 10 move to the right, while -5 collides with 10 and is destroyed."
      },
      {
        "input": "asteroids = [8, -8]",
        "output": "[]",
        "explanation": "Both asteroids collide and destroy each other."
      },
      {
        "input": "asteroids = [10, 2, -5]",
        "output": "[10]",
        "explanation": "Asteroids 10 and 2 collide with -5 and -5 gets destroyed."
      },
      {
        "input": "asteroids = [-2, -1, 1, 2]",
        "output": "[-2, -1, 1, 2]",
        "explanation": "No asteroids collide; they all remain."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about using a stack to simulate the collisions.",
      "Only consider pairs of asteroids moving towards each other."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Matchsticks to Square",
    "description": "You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any matchstick, but you can use them in any order. Your goal is to determine whether you can make this square or not.",
    "topic": "Backtracking",
    "subtopic": "Partitioning",
    "tags": [
      "Backtracking",
      "Dynamic Programming",
      "Recursion"
    ],
    "input_format": "An array of integers matchsticks representing the lengths of the matchsticks.",
    "output_format": "A boolean indicating whether it is possible to form a square with the given matchsticks.",
    "constraints": [
      "1 <= matchsticks.length <= 15",
      "0 < matchsticks[i] <= 10^8"
    ],
    "examples": [
      {
        "input": "matchsticks = [1,1,2,2,2]",
        "output": "true",
        "explanation": "You can make a square with side length 2, using 1,1, and 2 for side 1, and another 1, 2, and 2 for side 2."
      },
      {
        "input": "matchsticks = [3,3,3,3,4]",
        "output": "false",
        "explanation": "It's impossible to form a square with one side longer than the others."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about the geometric properties of a square.",
      "Consider using backtracking to explore all combinations of matchstick lengths."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Maximum Total Damage With Spell Casting",
    "description": "You are a magician casting spells on enemies. Each spell has a power value and a cooldown period. You can cast one spell at a time, and after casting a spell, you cannot cast another spell until the cooldown period has passed. Given a list of spells where each spell is represented by a pair of integers (power, cooldown), calculate the maximum total damage you can inflict when spells are cast in an optimal order.",
    "topic": "Dynamic Programming",
    "subtopic": "Optimal Substructure",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Optimization"
    ],
    "input_format": "An array of tuples where each tuple consists of two integers (power, cooldown).",
    "output_format": "An integer representing the maximum total damage.",
    "constraints": [
      "1 <= spells.length <= 1000",
      "1 <= power <= 1000",
      "1 <= cooldown <= 100"
    ],
    "examples": [
      {
        "input": "spells = [(100, 2), (200, 3), (300, 2)]",
        "output": "500",
        "explanation": "Cast the 200 power spell first, wait for 3 turns, then cast the 100 and 300 power spells respectively. Total damage = 200 + 100 + 300 = 600."
      },
      {
        "input": "spells = [(50, 1), (150, 2), (200, 1)]",
        "output": "200",
        "explanation": "Cast the 200 power spell, then the 150 power spell after its cooldown. Total damage = 200 + 150 = 350."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider a greedy approach for selecting the next spell to cast.",
      "Use dynamic programming to store and reuse the maximum damage you've calculated."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Generate Parentheses",
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. A valid combination of parentheses is one where every opening bracket has a corresponding closing bracket in the correct order.",
    "topic": "Backtracking",
    "subtopic": "Generating Combinations",
    "tags": [
      "Backtracking",
      "Recursion",
      "String"
    ],
    "input_format": "An integer n representing the number of pairs of parentheses.",
    "output_format": "A list of strings containing all combinations of well-formed parentheses.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]",
        "explanation": "The valid combinations for n = 3 are generated by arranging three pairs of parentheses."
      },
      {
        "input": "n = 1",
        "output": "[\"()\"]",
        "explanation": "The only valid combination for n = 1 is a single pair of parentheses."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion to build the combinations.",
      "Keep track of the number of open and close parentheses used."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Insert Interval",
    "description": "Given a collection of intervals, merge all overlapping intervals and insert a new interval into the collection. The intervals should be represented as a list of lists, where each sub-list contains two integers representing the start and end of an interval. Your task is to return the updated collection of intervals after inserting the new interval and merging if necessary.",
    "topic": "Array",
    "subtopic": "Interval Management",
    "tags": [
      "Array",
      "Interval",
      "Merge"
    ],
    "input_format": "A list of lists representing the intervals, and a list representing the new interval.",
    "output_format": "A list of lists representing the updated collection of intervals.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "intervals are sorted by their start value",
      "newInterval.length == 2",
      "0 <= newInterval[0] <= newInterval[1] <= 10^5"
    ],
    "examples": [
      {
        "input": "[[1,3],[6,9]], [2,5]",
        "output": "[[1,5],[6,9]]",
        "explanation": "The new interval [2,5] overlaps with [1,3], so they merge to form [1,5]. The interval [6,9] remains unchanged."
      },
      {
        "input": "[[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]",
        "output": "[[1,2],[3,10],[12,16]]",
        "explanation": "The new interval [4,8] overlaps with [3,5] and [6,7], merging them into [3,10]. The interval [1,2] and [12,16] remain unchanged."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to merge intervals when they overlap.",
      "Focus on comparing the start and end of intervals."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Jump Game",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to determine if you can reach the last index starting from the first index. You can assume that you can always reach the last index if you are at index n-1 (where n is the length of the array).",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers nums representing the maximum jump lengths.",
    "output_format": "A boolean value indicating whether you can reach the last index (true) or not (false).",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "true",
        "explanation": "You can jump from index 0 to 1, and then jump to the last index."
      },
      {
        "input": "nums = [3, 2, 1, 0, 4]",
        "output": "false",
        "explanation": "You will reach index 3 but cannot make any further jumps to reach the last index."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how far you can jump from each index and track the farthest index you can reach.",
      "Try to use a greedy approach to determine if you can reach the end."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Maximum Performance of a Team",
    "description": "In a company, there are N engineers with different speeds and costs. You need to form a team of engineers such that the team has a maximum performance score. The performance score of a team is defined as the product of the sum of the speeds of the engineers and the minimum cost among the engineers in the team. Given the speeds and costs of the engineers, return the maximum performance score modulo 10^9 + 7.",
    "topic": "Greedy",
    "subtopic": "Sorting",
    "tags": [
      "Greedy",
      "Sorting",
      "Array"
    ],
    "input_format": "An integer N, followed by two arrays of integers speed and cost, each of size N.",
    "output_format": "An integer representing the maximum performance score modulo 10^9 + 7.",
    "constraints": [
      "1 <= N <= 10^5",
      "1 <= speed[i], cost[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "N = 3, speed = [2, 8, 5], cost = [3, 2, 4]",
        "output": "60",
        "explanation": "The optimal team includes engineers with speeds 5 and 8 leading to a performance score of (5 + 8) * min(4, 2) = 13 * 4 = 52."
      },
      {
        "input": "N = 4, speed = [1, 2, 3, 4], cost = [10, 20, 30, 40]",
        "output": "112",
        "explanation": "The optimal team includes the engineers with speeds 2 and 4, which results in (2 + 4) * min(20, 40) = 6 * 20 = 120."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a priority queue to maintain the minimum cost while calculating the performance.",
      "Sort the engineers by their speed to assess combinations effectively.",
      "Keep track of the total speed and adjust it as necessary when forming teams."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock IV",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer k representing the maximum number of transactions. You want to maximize your profit by choosing a single buy transaction and a single sell transaction. However, you can perform at most k transactions. Return the maximum profit you can achieve. Note that you cannot engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).",
    "topic": "Dynamic Programming",
    "subtopic": "Stock Market Problem",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Stock Market"
    ],
    "input_format": "An array of integers prices representing stock prices on different days, and an integer k for the maximum transactions.",
    "output_format": "An integer representing the maximum profit achievable.",
    "constraints": [
      "0 <= prices.length <= 100",
      "0 <= prices[i] <= 1000",
      "0 <= k <= 100"
    ],
    "examples": [
      {
        "input": "prices = [2,4,1], k = 2",
        "output": "2",
        "explanation": "Buy on day 0 (price = 2) and sell on day 1 (price = 4) for a profit of 2."
      },
      {
        "input": "prices = [3,2,6,5,0,3], k = 2",
        "output": "7",
        "explanation": "Buy on day 1 (price = 2) and sell on day 2 (price = 6). Then buy on day 4 (price = 0) and sell on day 5 (price = 3) for a total profit of 7."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use dynamic programming to keep track of profits.",
      "Consider the profits for 0 to k transactions."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array, find the smallest missing positive integer. Your algorithm should run in O(n) time and use constant space.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Positive Numbers"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the first missing positive integer.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "The smallest missing positive integer is 3."
      },
      {
        "input": "nums = [3, 4, -1, 1]",
        "output": "2",
        "explanation": "The smallest missing positive integer is 2."
      },
      {
        "input": "nums = [7, 8, 9, 11, 12]",
        "output": "1",
        "explanation": "The smallest missing positive integer is 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use the input array to store the numbers at their correct indices.",
      "Ignore non-positive numbers and numbers larger than the length of the array.",
      "Consider that the missing number must be within 1 to n+1 where n is the size of the array."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Sum of Subarray Minimums",
    "description": "Given an array of integers, return the sum of the minimums of all contiguous subarrays. Since the result can be very large, return it modulo 10^9 + 7.",
    "topic": "Array",
    "subtopic": "Subarray",
    "tags": [
      "Array",
      "Subarray",
      "Sum",
      "Stack"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the sum of the minimums of all contiguous subarrays, modulo 10^9 + 7.",
    "constraints": [
      "1 <= nums.length <= 3000",
      "1 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [3, 1, 2, 4]",
        "output": "17",
        "explanation": "The subarrays are: [3], [1], [2], [4], [3, 1], [1, 2], [2, 4], [3, 1, 2], [1, 2, 4], [3, 1, 2, 4]. Their minimums are: 3, 1, 2, 4, 1, 1, 2, 1, 1, and 1. The sum is 3 + 1 + 2 + 4 + 1 + 1 + 2 + 1 + 1 + 1 = 17."
      },
      {
        "input": "nums = [11, 81, 94, 43, 3]",
        "output": "444",
        "explanation": "The minimums of all contiguous subarrays sum up to 444."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how many subarrays a number is the minimum for.",
      "Use a stack to efficiently find the range for which each element is the minimum."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Snakes and Ladders",
    "description": "You are given a square board of size n x n, where each cell contains a number that represents either a ladder, a snake, or a regular cell. The player starts at the cell 1 and aims to reach the cell n^2. A ladder moves the player up to a higher-numbered cell while a snake moves the player down to a lower-numbered cell. The player can roll a die to move forward between 1 and 6 cells. Your task is to determine the minimum number of moves required to reach the end of the board.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "Queue"
    ],
    "input_format": "An integer n representing the size of the board, and a list of pairs representing the positions of ladders and snakes.",
    "output_format": "An integer representing the minimum number of moves to reach the last cell, or -1 if it is not possible.",
    "constraints": [
      "1 <= n <= 30",
      "The number of ladders and snakes combined will not exceed n^2."
    ],
    "examples": [
      {
        "input": "n = 3, snakes_and_ladders = [[2, 1], [3, 2]]",
        "output": "2",
        "explanation": "The player can move from 1 -> 2 using a die roll of 1, then slide down to 1 again, finally rolling 2 to reach 3 in total 2 moves."
      },
      {
        "input": "n = 2, snakes_and_ladders = [[1, 2]]",
        "output": "-1",
        "explanation": "It's impossible to reach the last cell due to the snake on cell 1 that moves back to cell 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think of each cell as a node in a graph.",
      "Use BFS to explore the positions from the start to the end.",
      "Remember to account for ladders and snakes when moving."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Heaters",
    "description": "You are given an array of integers, heaters, where each element represents the position of a heater on a number line. You are also given an array of integers, houses, where each element represents the position of a house on the same number line. Your task is to determine the minimum distance required to heat all houses with the available heaters. A house is heated by a heater if the distance between them is less than or equal to the distance from the house to the closest heater. Return an array of integers, where each element at index i represents the minimum distance from the house at houses[i] to the nearest heater.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Greedy"
    ],
    "input_format": "Two arrays of integers, heaters and houses, representing the positions of heaters and houses respectively.",
    "output_format": "An array of integers where each integer represents the minimum distance from the corresponding house to the nearest heater.",
    "constraints": [
      "1 <= heaters.length, houses.length <= 10^4",
      "-10^9 <= heaters[i], houses[j] <= 10^9"
    ],
    "examples": [
      {
        "input": "heaters = [1, 2, 3], houses = [2, 3, 4]",
        "output": "[0, 0, 1]",
        "explanation": "House 2 is at position 2 and has a heater at position 2 (distance 0). House 3 is at position 3 and has a heater at position 3 (distance 0). House 4 is at position 4 and is closest to the heater at position 3 (distance 1)."
      },
      {
        "input": "heaters = [1, 4], houses = [2, 3, 6]",
        "output": "[1, 1, 2]",
        "explanation": "House 2 is closest to heater 1 (distance 1), house 3 is also closest to heater 1 (distance 1), and house 6 is closest to heater 4 (distance 2)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting both arrays to facilitate searching.",
      "Use binary search to efficiently find the nearest heater."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Ways to Make a Fair Array",
    "description": "You are given an array of integers. You can remove any number of elements from the array to make it fair. An array is considered fair if the sum of the elements at even indices is equal to the sum of the elements at odd indices. Your task is to determine the number of ways you can achieve this by removing elements from the array.",
    "topic": "Array",
    "subtopic": "Prefix Sums",
    "tags": [
      "Array",
      "Prefix Sums",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers nums representing the original array.",
    "output_format": "An integer representing the number of ways to make the array fair.",
    "constraints": [
      "1 <= nums.length <= 1000",
      "-10^6 <= nums[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 1, 2]",
        "output": "2",
        "explanation": "You can remove the elements at indices 1 and 3 to result in the array [1, 3, 2] or remove the element at index 2 to get [1, 2, 1] which are fair."
      },
      {
        "input": "nums = [0, 1, 2, 3]",
        "output": "1",
        "explanation": "The only way to make this array fair is to remove either 1 or 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider maintaining cumulative sums for even and odd indices.",
      "Utilize a hash map to store the counts of even-odd sum pairs."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "LRU Cache",
    "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class with the following methods:  \n- LRUCache(int capacity): Initializes the LRU cache with positive size capacity.  \n- int get(int key): Returns the value of the key if the key exists, otherwise returns -1.  \n- void put(int key, int value): Updates the value of the key if the key exists. Otherwise, adds the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evicts the least recently used key.\nThe functions should run in O(1) time complexity.",
    "topic": "Design",
    "subtopic": "Data Structures",
    "tags": [
      "Cache",
      "Design",
      "LRU"
    ],
    "input_format": "The constructor takes a single integer argument, which is the capacity of the cache. The get and put methods are called with appropriate integer parameters.",
    "output_format": "The get method returns an integer value, and the put method does not return anything.",
    "constraints": [
      "1 <= capacity <= 3000",
      "0 <= key <= 10^4",
      "0 <= value <= 10^5",
      "The operations get and put are called at most 10^4 times."
    ],
    "examples": [
      {
        "input": "LRUCache cache = new LRUCache(2); cache.put(1, 1); cache.put(2, 2); cache.get(1); cache.put(3, 3); cache.get(2); cache.put(4, 4); cache.get(1); cache.get(3); cache.get(4);",
        "output": "[1,-1,3,4]",
        "explanation": "The cache allows 2 items. After adding (1,1) and (2,2), (1) is accessed, making it recent. When (3,3) is added, (2) is removed as it is the least recently used. Then (4,4) adds to cache, evicting (1) in the process."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a combination of a hash map and a doubly linked list.",
      "The most recently used items should be moved to the front of the list."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Longest Consecutive Sequence",
    "description": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Set"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the length of the longest consecutive elements sequence.",
    "constraints": [
      "0 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [100, 4, 200, 1, 3, 2]",
        "output": "4",
        "explanation": "The longest consecutive sequence is [1, 2, 3, 4], which has a length of 4."
      },
      {
        "input": "nums = [0, 1, 2, 2, 3, 4, 5]",
        "output": "6",
        "explanation": "The longest consecutive sequence is [0, 1, 2, 3, 4, 5], which has a length of 6."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a set to store the elements for O(1) lookups.",
      "Iterate through the array and check if the current number is the start of a consecutive sequence."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Largest Rectangle in Histogram",
    "description": "Given an array of integers representing the heights of bars in a histogram, find the area of the largest rectangle that can be formed by these bars. A rectangle is formed by choosing two or more contiguous bars and extending down to the x-axis. Your task is to calculate the maximum area of any such rectangle.",
    "topic": "Stack",
    "subtopic": "Monotonic Stack",
    "tags": [
      "Stack",
      "Array",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers heights representing the heights of bars in the histogram.",
    "output_format": "An integer representing the area of the largest rectangle that can be formed.",
    "constraints": [
      "1 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [2,1,5,6,2,3]",
        "output": "10",
        "explanation": "The largest rectangle can be formed with heights [5,6] which has an area of 5 * 2 = 10."
      },
      {
        "input": "heights = [2,4]",
        "output": "4",
        "explanation": "The largest rectangle can be formed using the height 4, resulting in an area of 4 * 1 = 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to keep track of the indices of the bars.",
      "Ensure to calculate area when popping the stack."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Make Sum Divisible by P",
    "description": "You are given an integer array nums and an integer p. You need to find the minimum number of elements that you can remove from nums to make the sum of the remaining elements divisible by p. If you cannot achieve such a sum, return -1.",
    "topic": "Array",
    "subtopic": "Mathematical Operations",
    "tags": [
      "Array",
      "Mathematics",
      "Greedy"
    ],
    "input_format": "An integer array nums and an integer p.",
    "output_format": "An integer representing the minimum number of elements to remove, or -1 if not possible.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 < p <= 10^6",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3, 1, 4, 2], p = 6",
        "output": "1",
        "explanation": "Removing the number 2 gives the sum 3 + 1 + 4 = 8, which is not divisible by 6. Removing 1 however results in 3 + 4 = 7, which is still not divisible by 6. But removing 3 gives 1 + 4 = 5, that\u2019s 5 % 6 = 5. Hence we can remove one of the two numbers 3 or 2."
      },
      {
        "input": "nums = [1, 2, 3], p = 3",
        "output": "-1",
        "explanation": "The total sum of the array is 6, which is already divisible by 3, so no need to remove any elements. However, finding a means to maintain divisibility isn't possible through removals."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Calculate the total sum of the array.",
      "Check the remainder when the sum is divided by p.",
      "Use a greedy approach to find removable elements that can help achieve divisibility."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix substring amongst an array of strings. If there is no common prefix, return an empty string \"\".",
    "topic": "Strings",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Prefix",
      "Substring"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A string representing the longest common prefix.",
    "constraints": [
      "0 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "All strings consist of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The longest common prefix is 'fl'."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among the strings."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider vertical scanning of the characters in the strings.",
      "If a mismatch is found, return the prefix found so far."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Find the Celebrity",
    "description": "In a party of n people, there is one celebrity who is known by everyone but does not know anyone. You need to identify the celebrity if they exist. A celebrity is defined as someone who: 1) knows no one, and 2) is known by everyone. You are given a function 'knows(a, b)' that returns true if person 'a' knows person 'b', and false otherwise. You need to determine the celebrity's index, or return -1 if no celebrity exists.",
    "topic": "Graph",
    "subtopic": "Graph Traversal",
    "tags": [
      "Graph",
      "Traversal",
      "Celebrity"
    ],
    "input_format": "An integer n representing the number of people and a 2D array knows[][] where knows[i][j] is true if person i knows person j.",
    "output_format": "An integer representing the index of the celebrity or -1 if there is no celebrity.",
    "constraints": [
      "2 <= n <= 1000",
      "knows is a function that runs in O(1) time and can be called at most n*n times."
    ],
    "examples": [
      {
        "input": "n = 4, knows = [[0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 0, 0], [0, 1, 1, 0]]",
        "output": "2",
        "explanation": "Person 2 knows no one, and everyone knows person 2, so they are the celebrity."
      },
      {
        "input": "n = 3, knows = [[0, 1, 0], [0, 0, 0], [0, 1, 0]]",
        "output": "-1",
        "explanation": "There is no person who is a celebrity in this case."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to keep track of potential celebrities.",
      "Check the conditions of knowing and being known for the candidate."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Find Minimum Time to Finish All Jobs",
    "description": "You are given an array of jobs, where each job has a certain duration. There are multiple workers available to perform these jobs. Each worker can take on multiple jobs, but can only work on one job at a time. Your task is to find the minimum time required for all workers to finish all jobs, considering they can work in parallel. The goal is to distribute the jobs among the workers such that the maximum time any worker spends working is minimized.",
    "topic": "Dynamic Programming",
    "subtopic": "Job Scheduling",
    "tags": [
      "Dynamic Programming",
      "Job Scheduling",
      "Greedy"
    ],
    "input_format": "An array of integers jobs representing the durations of each job and an integer k for the number of workers.",
    "output_format": "An integer representing the minimum time required for all workers to finish all jobs.",
    "constraints": [
      "1 <= jobs.length <= 16",
      "1 <= jobs[i] <= 10^4",
      "1 <= k <= 16"
    ],
    "examples": [
      {
        "input": "jobs = [3, 2, 3], k = 3",
        "output": "3",
        "explanation": "Each worker can take a job of duration 3, 2, or 3 respectively. Thus, the maximum time taken by any worker is 3."
      },
      {
        "input": "jobs = [1, 2, 4, 8, 2], k = 2",
        "output": "8",
        "explanation": "The optimal distribution is two workers taking jobs [8] and [1, 2, 4, 2]. The maximum time of the workers is 8."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a backtracking approach to explore all job distributions.",
      "Optimize by pruning paths that exceed the current minimum time."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Alien Dictionary",
    "description": "Given a list of words from an alien language sorted lexicographically according to the rules of that language, return the order of the letters in the alien language. The words are guaranteed to be sorted based on some unknown ordering of the letters. You must derive the order from the pairs of adjacent words.",
    "topic": "Graph",
    "subtopic": "Topological Sorting",
    "tags": [
      "Graph",
      "Topological Sort",
      "String"
    ],
    "input_format": "A list of strings words, where each string represents a word in the alien language.",
    "output_format": "A string representing the order of characters in the alien language. If there is no valid order, return an empty string.",
    "constraints": [
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 100"
    ],
    "examples": [
      {
        "input": "words = [\"za\",\"fb\",\"za\"]",
        "output": "zaf",
        "explanation": "The order is derived from comparing the words. 'z' comes before 'f'."
      },
      {
        "input": "words = [\"abc\",\"ab\"]",
        "output": "",
        "explanation": "The second word is a prefix of the first, which is not valid."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a graph to represent the letters and their order.",
      "Perform a topological sort on the constructed graph."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Daily Temperatures",
    "description": "Given an array of integers representing daily temperatures, return an array such that for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, keep the value 0 instead.",
    "topic": "Array",
    "subtopic": "Stack",
    "tags": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "input_format": "An array of integers temperatures where 1 <= temperatures.length <= 30000 and 30 <= temperatures[i] <= 100.",
    "output_format": "An array of integers representing the number of days until a warmer temperature for each day.",
    "constraints": [
      "1 <= temperatures.length <= 30000",
      "30 <= temperatures[i] <= 100"
    ],
    "examples": [
      {
        "input": "temperatures = [73, 74, 75, 71, 69, 72, 76, 73]",
        "output": "[1, 1, 4, 2, 1, 1, 0, 0]",
        "explanation": "In this example, we can see that:\n- 73\u00b0 -> Next warmer day is 74\u00b0 (1 day)\n- 74\u00b0 -> Next warmer day is 75\u00b0 (1 day)\n- 75\u00b0 -> Next warmer day is 76\u00b0 (4 days)\n- 71\u00b0 -> Next warmer day is 72\u00b0 (2 days)\n- 69\u00b0 -> Next warmer day is 72\u00b0 (1 day)\n- 72\u00b0 -> Next warmer day is 76\u00b0 (1 day)\n- 76\u00b0 -> No warmer day (0 days)\n- 73\u00b0 -> No warmer day (0 days)"
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to keep track of the indices of the temperatures.",
      "Keep updating the result array as you find warmer temperature while popping from the stack."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Course Schedule II",
    "description": "You are given an integer numCourses representing the total number of courses you have to take, labeled from 0 to numCourses - 1. You are also given an array prerequisites where prerequisites[i] = [a, b] indicates that you must take course b before course a. Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.",
    "topic": "Graph",
    "subtopic": "Topological Sort",
    "tags": [
      "Graph",
      "Topological Sort",
      "DFS",
      "BFS"
    ],
    "input_format": "An integer numCourses and a list of pairs prerequisites.",
    "output_format": "A list of integers representing the order to take the courses or an empty list if it's not possible.",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= numCourses * (numCourses - 1) / 2",
      "prerequisites[i].length == 2",
      "0 <= prerequisites[i][0], prerequisites[i][1] < numCourses",
      "All prerequisite pairs are unique."
    ],
    "examples": [
      {
        "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
        "output": "[0,1,2,3]",
        "explanation": "One possible order is 0 -> 1 -> 2 -> 3."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
        "output": "[]",
        "explanation": "It is impossible to finish all courses because of the cycle."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a graph to represent the courses and prerequisites.",
      "A cycle in the graph indicates that it's impossible to complete all courses."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Longest Repeating Character Replacement",
    "description": "You are given a string s and an integer k. You can replace any character in the string with any other character (including itself) up to k times. Your goal is to find the length of the longest substring that contains the same letter after performing at most k replacements.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Two Pointers"
    ],
    "input_format": "A string s and an integer k.",
    "output_format": "An integer representing the length of the longest substring with the same letter after at most k replacements.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of only uppercase English letters.",
      "0 <= k <= s.length"
    ],
    "examples": [
      {
        "input": "s = 'AABABBA', k = 1",
        "output": "4",
        "explanation": "Replace one 'B' with 'A' to form 'AAABBA', which has a length of 4."
      },
      {
        "input": "s = 'ABAB', k = 2",
        "output": "4",
        "explanation": "Replace both 'A' and 'B' to form 'AAAA' or 'BBBB', which has lengths of 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sliding window to keep track of the counts of characters.",
      "Use a hashmap to count the frequency of characters in the current window."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "Grid",
      "Depth-First Search"
    ],
    "input_format": "A 2D grid represented as a list of lists of characters, where each character is either '1' or '0'.",
    "output_format": "An integer representing the number of islands in the grid.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "grid = [[1,1,0,0,0],[1,1,0,0,0],[0,0,1,0,0],[0,0,0,1,1]]",
        "output": "3",
        "explanation": "The three islands are formed by the two '1's in rows 0 and 1, the single '1' in row 2, and the two '1's in row 3."
      },
      {
        "input": "grid = [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]",
        "output": "0",
        "explanation": "There are no islands in the grid as it is completely surrounded by water."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth-First Search (DFS) to traverse the islands.",
      "You can mark the visited land cells to avoid counting them again."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Complete Binary Tree Inserter",
    "description": "Design an algorithm to insert a new node into a complete binary tree while maintaining its completeness. The new node should be added as the leftmost available child node in the last level of the tree.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Insertion"
    ],
    "input_format": "The input consists of a reference to the root node of a complete binary tree and a value to be inserted.",
    "output_format": "Return the root node of the complete binary tree after the insertion.",
    "constraints": [
      "The complete binary tree will have at most 10^4 nodes.",
      "The value to be inserted will not exceed 10^6 in absolute value."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, 4], val = 5",
        "output": "[1, 2, 3, 4, 5]",
        "explanation": "The tree before insertion looks like this: 1\n    / \\\n   2   3\n  /\n 4. After inserting 5, we place it as the right child of node 2."
      },
      {
        "input": "root = [1, 2, 3], val = 4",
        "output": "[1, 2, 3, 4]",
        "explanation": "The tree before insertion: 1\n    / \\\n   2   3. We insert 4 as the left child of node 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to keep track of the nodes in level-order.",
      "The next available position to insert is always at the end of the queue."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "String Compression",
    "description": "Given an array of characters, compress it such that consecutive identical characters are stored as a single character followed by the count of repetitions. The compression should be done in-place, using O(1) extra space, and return the new length of the array after compression. If the compressed string is longer than the original, leave it as it is.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Compression",
      "In-place"
    ],
    "input_format": "An array of characters, representing the string to be compressed.",
    "output_format": "An integer representing the new length of the array after compression.",
    "constraints": [
      "1 <= chars.length <= 2000",
      "chars[i] is a printable ASCII character."
    ],
    "examples": [
      {
        "input": "chars = ['a', 'a', 'b', 'b', 'c', 'c', 'c']",
        "output": "6",
        "explanation": "The compressed version is ['a', '2', 'b', '2', 'c', '3']. The length of the compressed array becomes 6."
      },
      {
        "input": "chars = ['a']",
        "output": "1",
        "explanation": "No compression is needed, the output remains the same with length 1."
      },
      {
        "input": "chars = ['a', 'b', 'c']",
        "output": "3",
        "explanation": "No consecutive characters to compress, so the length remains 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Keep track of the current character and its count.",
      "Use two pointers to manage the writing position in the array."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Magnetic Force Between Two Balls",
    "description": "You are given two integer arrays, position and force, each of length n, where position[i] is the position of the i-th ball and force[i] is the magnetic force exerted on that ball. The balls are aligned on a straight line, and the force is either positive or negative, representing an attraction or repulsion. Calculate the maximum magnetic force between any two balls. The magnetic force between two balls at positions x1 and x2 is defined as the minimum of force exerted on either ball when they are placed at their positions. If a ball is pulled towards another ball against its force, the force is considered to be zero in that case. Return the maximum magnetic force possible between any two balls in the array.",
    "topic": "Array",
    "subtopic": "Sorting & Searching",
    "tags": [
      "Array",
      "Sorting",
      "Binary Search"
    ],
    "input_format": "Two arrays position and force of equal length n (1 <= n <= 10^5).",
    "output_format": "An integer representing the maximum magnetic force between any two balls.",
    "constraints": [
      "1 <= position.length <= 10^5",
      "-10^6 <= position[i] <= 10^6",
      "-10^6 <= force[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "position = [1, 2, 3, 4, 5], force = [5, 4, 3, 2, 1]",
        "output": "2",
        "explanation": "The maximum magnetic force occurs between balls at positions 2 and 3 where the forces are 4 and 3 respectively. Hence, the min(4, 3) = 3."
      },
      {
        "input": "position = [1, 3, 5, 7], force = [10, 2, 10, 2]",
        "output": "2",
        "explanation": "The maximum magnetic force occurs between balls at positions 1 and 3, where the forces are 10 and 2. The min(10, 2) = 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the position array to maximize efficiency.",
      "Think about the distance between balls when calculating force.",
      "Utilize binary search to speed up finding optimal force conditions."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Copy List with Random Pointer",
    "description": "You are given a special linked list with nodes that have two pointers: one pointing to the next node in the list and another pointer pointing to any node in the list. The task is to create a deep copy of the list while maintaining the connections as they were in the original list. Implement a function that receives the head of the original list and returns the head of the new, copied list.",
    "topic": "Linked List",
    "subtopic": "Deep Copying",
    "tags": [
      "Linked List",
      "Copying",
      "Deep Copy"
    ],
    "input_format": "The head of a linked list where each node has an additional random pointer.",
    "output_format": "The head of the deep copied linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 100].",
      "Each node has a random pointer that may point to any node in the list or null.",
      "The input linked list is well-formed."
    ],
    "examples": [
      {
        "input": "head = [[1,2],[2,1]]",
        "output": "[[1,2],[2,1]]",
        "explanation": "The original list has two nodes, where the first node points to the second, and the second points back to the first. The copied list should maintain the same structure."
      },
      {
        "input": "head = [[1,null],[2,1]]",
        "output": "[[1,null],[2,1]]",
        "explanation": "The first node points to null, and the second node points to the first node. The copied list reflects this structure."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map to keep track of copied nodes.",
      "You might need to iterate through the list multiple times."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Number of Islands II",
    "description": "You are given a 2D grid representing a map of '1's (land) and '0's (water). Each cell in the grid can be flipped, converting a '0' to a '1'. After each flip, you need to determine the number of distinct islands present in the grid. Two cells are considered part of the same island if they are adjacent (horizontally or vertically). You are to report the number of islands after each flip operation.",
    "topic": "Graph",
    "subtopic": "Union Find",
    "tags": [
      "Graph",
      "Union Find",
      "Matrix",
      "Counting"
    ],
    "input_format": "A 2D grid of integers, where each integer is either 0 or 1, followed by a list of flip operations represented by their coordinates.",
    "output_format": "An array of integers representing the number of islands after each flip operation.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 50",
      "0 <= flip operations <= 10^4",
      "flips[i][0] < grid.length and flips[i][1] < grid[i].length"
    ],
    "examples": [
      {
        "input": "grid = [[0,0,0],[0,1,1],[0,0,0]], flips = [[0,0],[0,1],[1,0],[1,1]]",
        "output": "[1, 1, 1, 2]",
        "explanation": "After the first flip (0,0), there is one island. After the second (0,1), there is still one island. After the third (1,0), the island exists as one single island. Flipping (1,1) creates a new island."
      },
      {
        "input": "grid = [[1,0,0],[0,1,0],[0,0,1]], flips = [[0,0],[0,1],[1,1]]",
        "output": "[3, 2, 1]",
        "explanation": "Initially, there are three islands. The first flip reduces it to two, and the second flip further reduces it to one."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a Union-Find data structure to connect land cells.",
      "Keep track of the number of islands dynamically with each flip."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Decode Ways II",
    "description": "A message containing letters from A-Z can be encoded into numbers using the following mapping: 'A' -> '1', 'B' -> '2', ..., 'Z' -> '26'. Now, given a string s that may contain '0's, you need to decode it into the number of possible ways to decode the message. However, note that the string can have the wildcard character '*' which can represent any digit from '1' to '9' or could also represent '10' or '20'. For example, '*' could be interpreted as '1', '2', ..., '9', '10', or '20'. You need to return the total number of ways to decode the message modulo 10^9 + 7.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Decoding"
    ],
    "input_format": "A string s consisting of digits and the '*' character.",
    "output_format": "An integer representing the number of ways to decode the message.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s[i] is either a digit ('0'-'9') or '*'"
    ],
    "examples": [
      {
        "input": "s = \"*1\"",
        "output": "18",
        "explanation": "The '*' could represent '1' to '9' (total 9) and '10' (total 1) or '11' to '19' (total 9), resulting in 9 + 1 + 9 = 18."
      },
      {
        "input": "s = \"1*\"",
        "output": "9",
        "explanation": "'1*' can be decoded into '11', '12', ..., '19', so there are 9 ways."
      },
      {
        "input": "s = \"**\"",
        "output": "96",
        "explanation": "Each '*' can be '1' to '9', and also could be part of '10' or '20', leading to multiple combinations."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how '*' can be expanded.",
      "Use dynamic programming to count the possible decodings.",
      "Think about how the previous characters affect the current character's decoding."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Gas Station",
    "description": "You are given two integer arrays, gas and cost, both of size n. The gas[i] represents the amount of gas available at the i-th gas station, while cost[i] represents the amount of gas required to travel from the i-th gas station to the next (i+1)-th gas station. You can start at any gas station and must travel in a circular route. Return the starting gas station's index if you can travel around the circuit once without running out of gas. If there is no such starting index, return -1.",
    "topic": "Greedy",
    "subtopic": "Circular Array",
    "tags": [
      "Greedy",
      "Array",
      "Simulation"
    ],
    "input_format": "Two integer arrays gas and cost, where 1 <= gas.length, cost.length <= 10^4.",
    "output_format": "An integer representing the starting gas station index or -1 if no such index exists.",
    "constraints": [
      "gas.length == cost.length",
      "1 <= gas[i], cost[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "gas = [1, 2, 3, 4, 5], cost = [3, 4, 5, 1, 2]",
        "output": "3",
        "explanation": "Starting at index 3, the total gas available is 4, enough to travel to index 4 and back to 0, completing the circuit."
      },
      {
        "input": "gas = [2, 3, 4], cost = [3, 4, 3]",
        "output": "-1",
        "explanation": "There is no starting gas station that allows a complete circuit."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider total gas vs total cost.",
      "If at any point you run out of gas, you can't start from any station between your last failed index and the current index."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "Given an integer array nums sorted in ascending order, then rotated at some pivot unknown to you beforehand, you should search for a target value in nums. If the target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Binary Search",
    "subtopic": "Searching in Rotated Array",
    "tags": [
      "Binary Search",
      "Array",
      "Search"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An integer representing the index of target in nums or -1 if not found.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "nums is guaranteed to be rotated at some pivot."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "Target 0 is at index 4."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "Target 3 does not exist in the array."
      },
      {
        "input": "nums = [1], target = 0",
        "output": "-1",
        "explanation": "Target 0 does not exist in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of the rotated sorted array.",
      "Use binary search but adjust the mid calculation based on the pivot."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Find All Possible Recipes from Given Supplies",
    "description": "You are given a list of recipes, where each recipe consists of a list of ingredients and a deliciousness score. You are also given a list of supplies. Your task is to find all the recipes that can be made with the available supplies. A recipe can be made if all of its ingredients are part of the supplies provided. Return a list of all the recipes that can be prepared, sorted in ascending order of their deliciousness scores.",
    "topic": "Backtracking",
    "subtopic": "Combination Generation",
    "tags": [
      "backtracking",
      "combinations",
      "sorting"
    ],
    "input_format": "A list of recipes, where each recipe is represented as a pair of a list of strings (ingredients) and an integer (deliciousness score), and a list of strings (supplies).",
    "output_format": "A list of strings representing the names of the recipes that can be prepared, sorted by their deliciousness scores.",
    "constraints": [
      "1 <= recipes.length <= 100",
      "1 <= recipe[i].length <= 15",
      "1 <= supplies.length <= 100",
      "1 <= deliciousness score <= 10^6"
    ],
    "examples": [
      {
        "input": "recipes = [['soup', 5], ['salad', 10]]; supplies = ['soup', 'salad']",
        "output": "['soup', 'salad']",
        "explanation": "Both recipes can be made since all ingredients are available in supplies."
      },
      {
        "input": "recipes = [['bread', 3], ['butter', 4], ['jam', 5]]; supplies = ['bread', 'butter']",
        "output": "['bread', 'butter']",
        "explanation": "Only 'bread' and 'butter' can be made since 'jam' is not in supplies."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Check if each ingredient of a recipe is present in the supplies.",
      "Use a set for supplies to allow O(1) average look-up time."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Walking Robot Simulation",
    "description": "A robot is located at the origin (0, 0) of a 2D grid. The robot can receive a sequence of commands, each of which is one of the following: 'G' (go straight), 'L' (turn left), 'R' (turn right). The robot initially faces North. The commands are executed in the order they are given to the robot. The robot will then move straight in the direction it is facing. The challenge is to determine if the robot will end up in a circle after executing the given commands. A circle is defined as the robot returning to the origin after each cycle of commands, or facing a direction that can lead to a path which returns to the origin over time. You need to implement a function that checks if the robot's path is circular or not.",
    "topic": "Simulation",
    "subtopic": "Robot Movement",
    "tags": [
      "Simulation",
      "Robot",
      "Geometry"
    ],
    "input_format": "A string commands representing a sequence of commands for the robot.",
    "output_format": "Return a boolean value: 'true' if the robot's movement forms a circle; otherwise, 'false'.",
    "constraints": [
      "1 <= commands.length <= 100",
      "commands[i] is one of 'G', 'L', 'R'."
    ],
    "examples": [
      {
        "input": "commands = 'GGLLGG'",
        "output": "true",
        "explanation": "The robot moves two steps forward and turns left twice, resulting in a circle."
      },
      {
        "input": "commands = 'GLGLG'",
        "output": "true",
        "explanation": "The robot moves forward and turns left repeatedly, which will also return it to the origin."
      },
      {
        "input": "commands = 'GGRR'",
        "output": "false",
        "explanation": "The robot moves forward twice and makes two right turns, ending up at (2, 0)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about the robot's orientation and how the turning affects its direction.",
      "Consider using a coordinate system to track the robot's position.",
      "Check the robot's final position and direction after executing all the commands."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Minimum Cost Tree From Leaf Values",
    "description": "Given an array of integers representing leaf values, you need to construct a binary tree such that the leaf nodes of the tree are the values from the array. The cost of a binary tree is the sum of all the products of each internal node and its two child nodes. Your task is to find the minimum cost possible for a tree constructed from these leaf values.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers leaves where each element represents the value of a leaf node.",
    "output_format": "An integer representing the minimum cost to construct the binary tree.",
    "constraints": [
      "1 <= leaves.length <= 40",
      "1 <= leaves[i] <= 15"
    ],
    "examples": [
      {
        "input": "leaves = [6, 2, 4]",
        "output": "32",
        "explanation": "The optimal tree structure is to combine the leaves 2 and 4 first at a cost of 8, resulting into a new node with value 8 and then combine with 6 at a cost of 48. Thus, total cost is 32."
      },
      {
        "input": "leaves = [4, 1, 3, 7]",
        "output": "42",
        "explanation": "Combine 1 and 3 to form 4 at cost 3, then combine resulting 4 with 4 at cost 16, finally combine resulting 8 with 7 at cost 56, total cost is 42."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a priority queue to help minimize the cost as you build the tree.",
      "You can think of this problem as an optimization problem where you want to combine the smallest values first."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock II",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. However, you can buy and sell the stock multiple times. In other words, you can make as many transactions as you like, but you must sell the stock before you buy again. Return the maximum profit you can achieve.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers prices, where 0 <= prices.length <= 10^4.",
    "output_format": "An integer representing the maximum profit you can achieve.",
    "constraints": [
      "0 <= prices.length <= 10^4",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "7",
        "explanation": "Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5 - 1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6 - 3 = 3. Total profit = 4 + 3 = 7."
      },
      {
        "input": "prices = [1, 2, 3, 4, 5]",
        "output": "4",
        "explanation": "Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5 - 1 = 4."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done, as prices never increase."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider when to buy and when to sell to take advantage of the price differences.",
      "You can iterate through the prices and sum up the positive differences."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Minimum Height Trees",
    "description": "A tree is an undirected graph in which any two vertices are connected by exactly one path. A minimum height tree (MHT) is a tree that minimizes the height when rooted at a specific node. Given an integer n, which represents the number of nodes in the tree, and an array edges, where edges[i] = [u, v] indicates that there is an undirected edge between nodes u and v, return all the nodes that could be the root of the minimum height trees. If there are multiple results, return them in any order.",
    "topic": "Graph",
    "subtopic": "Graph Traversal",
    "tags": [
      "Graph",
      "Tree",
      "Minimum Height Tree"
    ],
    "input_format": "An integer n representing the number of nodes and a list of edges where each edge is represented by a list of two integers.",
    "output_format": "A list of integers representing the nodes that could be the root of minimum height trees.",
    "constraints": [
      "1 <= n <= 2 * 10^4",
      "0 <= edges.length <= 10^4",
      "edges[i].length == 2",
      "0 <= edges[i][0], edges[i][1] < n",
      "edges[i][0] != edges[i][1]"
    ],
    "examples": [
      {
        "input": "n = 4, edges = [[1, 0], [1, 2], [1, 3]]",
        "output": "[1]",
        "explanation": "Rooted at node 1, the height is minimized for all paths."
      },
      {
        "input": "n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]",
        "output": "[3, 4]",
        "explanation": "Nodes 3 and 4 are the best candidates, creating a balanced tree."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use BFS or DFS to find the bottom nodes.",
      "The process of finding the center of a tree is key."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Partition Array Into Two Arrays to Minimize Sum Difference",
    "description": "You are given an integer array nums of even length n. You need to partition the array into two arrays of length n/2, such that the absolute difference between the sums of the two arrays is minimized. Your task is to return the minimum absolute sum difference possible.",
    "topic": "Dynamic Programming",
    "subtopic": "Subset Sum",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the minimum absolute sum difference.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "1 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5, 6]",
        "output": "1",
        "explanation": "Partitioning into [1, 6] and [2, 3, 4, 5] gives sums 7 and 14 respectively, leading to an absolute difference of |7 - 14| = 7. The optimal partition is [3, 4] and [1, 2, 5, 6], leading to absolute difference |7 - 14| = 1."
      },
      {
        "input": "nums = [10, 20, 30, 40]",
        "output": "0",
        "explanation": "Partitioning into [10, 20] and [30, 40] gives equal sums of 30, resulting in an absolute difference of |30 - 30| = 0."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using combinations to generate possible partitions.",
      "Think about dynamic programming approaches to store computed sums.",
      "You may need to optimize the generation of subsets."
    ],
    "company": "PhonePe"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. An Anagram is defined as two strings having the same character count, thus they can be rearranged to form each other.",
    "topic": "Hash Table",
    "subtopic": "String Manipulation",
    "tags": [
      "Anagrams",
      "Hash Table",
      "Strings"
    ],
    "input_format": "An array of strings, strs, where 1 <= strs.length <= 10^4 and 0 <= strs[i].length <= 100.",
    "output_format": "A list of lists of strings, where each inner list contains all the anagrams from the input array.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "All input strings are in lowercase."
    ],
    "examples": [
      {
        "input": "strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
        "output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
        "explanation": "The anagrams are grouped together. 'eat', 'tea', and 'ate' are anagrams, while 'tan' and 'nat' are also grouped together, and 'bat' does not have any anagrams."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "There is only one string which is empty, so it forms a group by itself."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "Similar to above, a single letter forms a group by itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using a hash map to store the sorted version of the strings as keys.",
      "Consider how to handle strings with different lengths."
    ],
    "company": "PhonePe"
  }
]