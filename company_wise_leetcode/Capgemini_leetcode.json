[
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers 'nums' and an integer 'target', return the indices of the two numbers such that they add up to 'target'. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers that add up to target.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 2 + 7 = 9."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "nums[1] + nums[2] = 2 + 4 = 6."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 3 + 3 = 6."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a hash map to store the numbers and their indices.",
      "Check if the complement (target - current number) exists in the hash map."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Number of Unique Subjects Taught by Each Teacher",
    "description": "You are given a list of subjects taught by different teachers in a school. Your task is to determine the number of unique subjects taught by each teacher. Each teacher may teach multiple subjects, and subjects are represented as strings. Return a list where each element corresponds to the number of unique subjects taught by each teacher, in the same order as they appear in the input list.",
    "topic": "Array",
    "subtopic": "Counting Unique Elements",
    "tags": [
      "Array",
      "Hash Set",
      "Counting"
    ],
    "input_format": "A list of lists, where each inner list contains subjects taught by a teacher represented as strings.",
    "output_format": "A list of integers where each integer represents the number of unique subjects taught by each teacher.",
    "constraints": [
      "1 <= teachers.length <= 1000",
      "1 <= subjects[i].length <= 100",
      "1 <= subjects[i][j].length <= 100"
    ],
    "examples": [
      {
        "input": "[['Math', 'Science', 'Math'], ['History', 'Science'], ['Math', 'History', 'Math']]",
        "output": "[2, 2, 2]",
        "explanation": "The first teacher teaches 'Math' and 'Science', which are 2 unique subjects. The second teacher teaches 'History' and 'Science', which are also 2 unique subjects, and the third teacher teaches 'Math' and 'History', which are again 2 unique subjects."
      },
      {
        "input": "[['Art', 'Drama'], ['Art', 'Art'], ['Drama']]",
        "output": "[2, 1, 1]",
        "explanation": "The first teacher teaches 'Art' and 'Drama', which are 2 unique subjects. The second teacher teaches 'Art' only, which is 1 unique subject, and the third teacher teaches 'Drama', also 1 unique subject."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a set to track unique subjects for each teacher."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Reverse Degree of a String",
    "description": "Given a string, you need to reverse the order of words in it while maintaining the original order of characters within each word. A word is defined as any sequence of characters separated by spaces. The reversed string should not have any leading or trailing spaces and only a single space between words.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Reverse"
    ],
    "input_format": "A single string s, which may contain leading or trailing spaces and multiple spaces between words.",
    "output_format": "A single string representing the words of the original string in reverse order with correct spacing.",
    "constraints": [
      "0 <= s.length <= 10^4"
    ],
    "examples": [
      {
        "input": "  Hello World  ",
        "output": "World Hello",
        "explanation": "Trailing and leading spaces are removed, and the words are reversed."
      },
      {
        "input": "a good   example",
        "output": "example good a",
        "explanation": "Multiple spaces between words are reduced to a single space in the output."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "You can split the string by spaces and use the reverse function.",
      "Consider trimming the string first to remove excessive spaces."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array",
    "description": "Given a sorted array of integers, remove the duplicates in-place such that each element appears only once and returns the new length of the array. You must do this without using extra space for another array.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "A sorted array of integers nums.",
    "output_format": "An integer representing the new length of the array after removing duplicates.",
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums is sorted in ascending order."
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "2",
        "explanation": "After removing duplicates, the array will be [1, 2] and the new length is 2."
      },
      {
        "input": "nums = [0, 0, 1, 1, 2, 2, 3, 3, 4]",
        "output": "5",
        "explanation": "After removing duplicates, the array will be [0, 1, 2, 3, 4] and the new length is 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to track the current position and the next unique element."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Count Elements With Maximum Frequency",
    "description": "Given an array of integers, count how many unique elements have the maximum frequency. The frequency of an element is defined as the number of times it appears in the array. Return the count of unique elements that are most frequent.",
    "topic": "Array",
    "subtopic": "Counting Frequency",
    "tags": [
      "Array",
      "Frequency",
      "Counting"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the count of unique elements that have the maximum frequency.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2, 3, 3, 3, 4, 4]",
        "output": "2",
        "explanation": "The maximum frequency is 3 (for the number 3), and there are 2 unique elements with this frequency: {3}."
      },
      {
        "input": "nums = [5, 5, 5, 1, 1, 2]",
        "output": "1",
        "explanation": "The maximum frequency is 3 (for the number 5), and there is 1 unique element with this frequency: {5}."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a frequency map to count occurrences of each element.",
      "Identify the maximum frequency by iterating through the frequency map."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Dynamic Programming",
    "subtopic": "Array Manipulation",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices representing the stock prices on different days.",
    "output_format": "An integer representing the maximum profit you can achieve.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far while iterating through the prices.",
      "Calculate the profit by subtracting the minimum price from the current price."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list. The addition should be done in the same way as you would do it on paper, starting from the least significant digit. If the sum of two digits exceeds 9, carry over the 1 to the next higher digit.",
    "topic": "Linked List",
    "subtopic": "Addition",
    "tags": [
      "Linked List",
      "Math",
      "Addition"
    ],
    "input_format": "Two linked lists representing two non-negative integers.",
    "output_format": "A linked list representing the sum of the two numbers.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the input numbers do not have leading zeros."
    ],
    "examples": [
      {
        "input": "[2 -> 4 -> 3] + [5 -> 6 -> 4]",
        "output": "[7 -> 0 -> 8]",
        "explanation": "342 + 465 = 807, hence the output linked list is 7 -> 0 -> 8."
      },
      {
        "input": "[0] + [0]",
        "output": "[0]",
        "explanation": "0 + 0 = 0, the output is simply 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how you would add two numbers on paper.",
      "Keep track of the carry for each addition."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".",
    "topic": "Strings",
    "subtopic": "Prefix",
    "tags": [
      "Strings",
      "Prefix",
      "Array"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A string representing the longest common prefix.",
    "constraints": [
      "0 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "strs[i] consists of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The longest common prefix is \"fl\"."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix, so the output is an empty string."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider sorting the array first.",
      "Compare characters of the first and last strings."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Reverse Words in a String",
    "description": "Given an input string s, reverse the order of the words in the string. A word is defined as a sequence of non-space characters. The words in the output string should be separated by a single space. Leading or trailing spaces in the input string should be ignored.",
    "topic": "Strings",
    "subtopic": "String Manipulation",
    "tags": [
      "Strings",
      "Manipulation",
      "Reverse"
    ],
    "input_format": "A single string s representing the input.",
    "output_format": "A single string representing the words in reverse order.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of English letters (upper and lower case), digits, and spaces.",
      "There are no two consecutive spaces in the input string."
    ],
    "examples": [
      {
        "input": "s = 'the sky is blue'",
        "output": "'blue is sky the'",
        "explanation": "The words in the input string are reversed."
      },
      {
        "input": "s = '  hello world  '",
        "output": "'world hello'",
        "explanation": "Leading and trailing spaces are omitted in the output."
      },
      {
        "input": "s = 'a good   example'",
        "output": "'example good a'",
        "explanation": "Multiple spaces between words are treated as a single space."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Trim the input string to remove leading and trailing spaces.",
      "Split the string into words based on spaces.",
      "Join the words in reverse order."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Palindrome Number",
    "description": "Given an integer x, determine whether it is a palindrome. An integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome while 123 is not.",
    "topic": "Math",
    "subtopic": "Number Theory",
    "tags": [
      "Math",
      "Palindrome",
      "Number Theory"
    ],
    "input_format": "An integer x.",
    "output_format": "Return true if x is a palindrome, and false otherwise.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 121",
        "output": "true",
        "explanation": "121 reads the same backward as forward."
      },
      {
        "input": "x = -121",
        "output": "false",
        "explanation": "-121 reads 121- backward, which is not the same."
      },
      {
        "input": "x = 10",
        "output": "false",
        "explanation": "10 reads 01 backward, which is not the same."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how to reverse an integer.",
      "A negative number can't be a palindrome."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Rotate Array",
    "description": "Given an array nums of n elements and a non-negative integer k, rotate the array to the right by k steps. Note that k can be greater than n.",
    "topic": "Array",
    "subtopic": "Manipulation",
    "tags": [
      "Array",
      "Rotation",
      "Manipulation"
    ],
    "input_format": "An integer array nums and a non-negative integer k.",
    "output_format": "The modified array after rotation.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= k <= 10^9",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5, 6, 7], k = 3",
        "output": "[5, 6, 7, 1, 2, 3, 4]",
        "explanation": "After rotating the array to the right by 3 steps, the last three elements [5, 6, 7] move to the front."
      },
      {
        "input": "nums = [-1, -100, 3, 99], k = 2",
        "output": "[3, 99, -1, -100]",
        "explanation": "After rotating the array to the right by 2 steps, [3, 99] move to the front."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the effective number of rotations.",
      "Utilize array slicing or reversing techniques."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Fibonacci Number",
    "description": "Given an integer n, return the nth number in the Fibonacci sequence. The Fibonacci sequence is defined as follows: F(0) = 0, F(1) = 1, and F(n) = F(n - 1) + F(n - 2) for n > 1. Implement a function to compute the nth Fibonacci number efficiently.",
    "topic": "Dynamic Programming",
    "subtopic": "Recursion and Memoization",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Fibonacci"
    ],
    "input_format": "An integer n (0 <= n <= 30), representing the position in the Fibonacci sequence.",
    "output_format": "An integer representing the nth Fibonacci number.",
    "constraints": [
      "0 <= n <= 30"
    ],
    "examples": [
      {
        "input": "n = 0",
        "output": "0",
        "explanation": "The 0th Fibonacci number is 0."
      },
      {
        "input": "n = 1",
        "output": "1",
        "explanation": "The 1st Fibonacci number is 1."
      },
      {
        "input": "n = 5",
        "output": "5",
        "explanation": "The Fibonacci numbers are 0, 1, 1, 2, 3, 5. Therefore, the 5th Fibonacci number is 5."
      },
      {
        "input": "n = 10",
        "output": "55",
        "explanation": "The Fibonacci numbers up to 10 are 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55. Thus, the 10th Fibonacci number is 55."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a recursive approach with memoization for better performance.",
      "You can also use an iterative approach to reduce space complexity."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Nth Highest Salary",
    "description": "Given a table 'Employee' with columns 'Id', 'Name', and 'Salary', write a SQL query to retrieve the Nth highest salary from the 'Employee' table. If there is no Nth highest salary, the query should return null.",
    "topic": "Database",
    "subtopic": "SQL Query",
    "tags": [
      "SQL",
      "Database",
      "Query"
    ],
    "input_format": "The input is a SQL query to be executed against the Employee table.",
    "output_format": "A single value representing the Nth highest salary or null.",
    "constraints": [
      "1 <= N <= 100",
      "The 'Salary' column could contain duplicate values."
    ],
    "examples": [
      {
        "input": "SELECT NthHighestSalary(2);",
        "output": "2000",
        "explanation": "The salaries in the table [1000, 2000, 2000, 3000]. The second highest salary is 2000."
      },
      {
        "input": "SELECT NthHighestSalary(5);",
        "output": "null",
        "explanation": "There are not enough unique salaries to return the 5th highest."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using the DISTINCT keyword to handle duplicates.",
      "You might want to use a subquery to find the Nth highest salary."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Valid Palindrome",
    "description": "Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. A palindrome is a word, phrase, number, or other sequence of characters which reads the same backward as forward.",
    "topic": "String",
    "subtopic": "Two Pointers",
    "tags": [
      "String",
      "Two Pointers",
      "Palindrome"
    ],
    "input_format": "A single string s.",
    "output_format": "Return true if s is a palindrome, and false otherwise.",
    "constraints": [
      "1 <= s.length <= 2 * 10^5",
      "s consist only of printable ASCII characters."
    ],
    "examples": [
      {
        "input": "s = \"A man, a plan, a canal: Panama\"",
        "output": "true",
        "explanation": "When we ignore non-alphanumeric characters and case, it reads 'amanaplanacanalpanama'."
      },
      {
        "input": "s = \"race a car\"",
        "output": "false",
        "explanation": "Ignoring non-alphanumeric characters, it reads 'raceacar' which is not the same backward."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to compare characters from both ends of the string.",
      "Consider using a function to filter only alphanumeric characters.",
      "Convert the characters to the same case for comparison."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Longest Happy String",
    "description": "A 'happy' string is a string that does not contain any of \u201caaa\u201d, \u201cbbb\u201d, or \u201cccc\u201d as a substring. Given two integers `a`, `b`, and `c`, representing the maximum number of occurrences for the characters 'a', 'b', and 'c' respectively, return the longest possible happy string that can be constructed. If there are multiple longest happy strings, return any of them. If there is no such string, return an empty string.",
    "topic": "String",
    "subtopic": "Construction",
    "tags": [
      "String",
      "Greedy",
      "Constructing",
      "Backtracking"
    ],
    "input_format": "Three integers a, b, c, where 0 <= a, b, c <= 100",
    "output_format": "A string representing the longest happy string that can be constructed.",
    "constraints": [
      "0 <= a, b, c <= 100",
      "a + b + c > 0"
    ],
    "examples": [
      {
        "input": "a = 1, b = 1, c = 7",
        "output": "ccaccbcc",
        "explanation": "The longest happy string is 'ccaccbcc' which has 1 'a', 1 'b', and 7 'c's without forming 'aaa', 'bbb', or 'ccc'."
      },
      {
        "input": "a = 2, b = 2, c = 1",
        "output": "aabbc",
        "explanation": "The longest happy string can be 'aabbc', which has 2 'a's, 2 'b's, and 1 'c' without any forbidden sequences."
      },
      {
        "input": "a = 7, b = 1, c = 0",
        "output": "aabaa",
        "explanation": "The longest happy string is 'aabaa' that avoids 'aaa' and uses the letters optimally."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider a greedy approach to construct the string.",
      "Keep track of the last added character to avoid three consecutive characters."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
    "topic": "Binary Search",
    "subtopic": "Finding Median",
    "tags": [
      "Array",
      "Binary Search",
      "Median"
    ],
    "input_format": "Two sorted arrays nums1 and nums2.",
    "output_format": "A floating point number representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= nums1.length <= 1000",
      "0 <= nums2.length <= 1000",
      "nums1 and nums2 are both sorted in ascending order."
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.00000",
        "explanation": "The combined sorted array is [1, 2, 3], and the median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.50000",
        "explanation": "The combined sorted array is [1, 2, 3, 4], and the median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how the median is positioned in relation to the two arrays.",
      "Use binary search to narrow down the potential median.",
      "Think about partitioning both arrays."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "topic": "String",
    "subtopic": "Hashing",
    "tags": [
      "String",
      "Hashing",
      "Anagrams"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A list of groups of anagrams, where each group is a list of strings.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
        "output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
        "explanation": "The output groups the anagrams together."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "The only string is an anagram of itself."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "The single character is an anagram of itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the characters of each string to identify anagrams.",
      "Use a dictionary to group strings by their sorted tuple."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Exchange Seats",
    "description": "You are given a classroom represented by a 2D array where each element is either 0 (empty seat) or 1 (occupied seat). Your task is to find the maximum number of students that can exchange their seats under the following condition: A student can exchange their seat with another student only if the seats are adjacent (horizontally or vertically) and not separated by any empty seat. The exchanged seats will still have to follow the occupied (1) and empty (0) rules. Return the maximum number of students that can exchange their seats simultaneously.",
    "topic": "Graph",
    "subtopic": "Graph Traversal",
    "tags": [
      "Graph",
      "DFS",
      "Breadth-First Search"
    ],
    "input_format": "A 2D array of integers representing the classroom layout.",
    "output_format": "An integer representing the maximum number of students that can exchange seats.",
    "constraints": [
      "1 <= rows <= 100",
      "1 <= cols <= 100",
      "0 <= classroom[i][j] <= 1"
    ],
    "examples": [
      {
        "input": "[[1, 0, 1], [1, 1, 0], [0, 1, 1]]",
        "output": "4",
        "explanation": "Students in (0,0) and (1,0) can swap with (1,1) and (2,1) respectively to maximize the exchanges."
      },
      {
        "input": "[[0, 0], [0, 0]]",
        "output": "0",
        "explanation": "There are no occupied seats to exchange."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about the connected components in the graph representation of the seats.",
      "Use BFS or DFS to explore all possible exchanges."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Valid Anagram",
    "description": "Given two strings s and t, return true if t is an anagram of s and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "topic": "String",
    "subtopic": "Hashing",
    "tags": [
      "String",
      "HashMap",
      "Sorting"
    ],
    "input_format": "Two strings s and t, both are lowercase alphabets.",
    "output_format": "A boolean value indicating whether t is an anagram of s.",
    "constraints": [
      "1 <= s.length, t.length <= 5 * 10^4",
      "s and t consist of lowercase alphabetical characters."
    ],
    "examples": [
      {
        "input": "s = \"anagram\", t = \"nagaram\"",
        "output": "true",
        "explanation": "Both strings contain the same characters: a, a, g, m, n, r."
      },
      {
        "input": "s = \"rat\", t = \"car\"",
        "output": "false",
        "explanation": "The characters in the string 'rat' cannot be rearranged to form the string 'car'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Count the frequency of each character in both strings and compare."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Move Zeroes",
    "description": "Given an array of integers, you are to move all the zeroes in the array to the end while maintaining the relative order of the non-zero elements. Write a function that modifies the original array in-place to achieve this goal.",
    "topic": "Array",
    "subtopic": "In-place Manipulation",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "The modified array with all zeroes moved to the end.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [0, 1, 0, 3, 12]",
        "output": "[1, 3, 12, 0, 0]",
        "explanation": "The non-zero elements 1, 3, and 12 maintain their order while all zeroes are moved to the end."
      },
      {
        "input": "nums = [0, 0, 1]",
        "output": "[1, 0, 0]",
        "explanation": "The only non-zero element 1 moves to the front."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to rearrange elements.",
      "Keep track of the position to insert non-zero elements."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given n non-negative integers representing the height of walls where the width between each wall is 1, calculate how much water it can trap after raining.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Water Trapping"
    ],
    "input_format": "An array of integers representing the heights of walls.",
    "output_format": "An integer representing the total amount of trapped rainwater.",
    "constraints": [
      "n == heights.length",
      "0 <= n <= 2 * 10^4",
      "0 <= heights[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "heights = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The trapped rain water is 6 units."
      },
      {
        "input": "heights = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The trapped rain water is 9 units."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Think about using a two-pointer technique to minimize space.",
      "Consider the water trapped at each index based on the height of walls."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A string s consisting of English letters, digits, symbols and spaces.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 10^5",
      "s consists of printable ASCII characters."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The answer is \"abc\", with the length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The answer is \"b\", with the length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The answer is \"wke\", with the length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sliding window approach.",
      "Use a hash set to track characters in the current substring."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Balanced Binary Tree",
    "description": "Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth"
    ],
    "input_format": "The input is the root node of a binary tree.",
    "output_format": "Return true if the binary tree is height-balanced, otherwise return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 5000].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "true",
        "explanation": "The tree is balanced, as the left subtree and right subtree of node 3 differ in height by 0."
      },
      {
        "input": "root = [1,2,2,3,3,null,null,4,4]",
        "output": "false",
        "explanation": "The tree is not balanced, as the left subtree of node 1 is deeper than the right subtree by 2."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using recursion to calculate the height of each subtree.",
      "Check the height difference at each node."
    ],
    "company": "Capgemini"
  },
  {
    "question_id": "",
    "title": "Subarray Sum Equals K",
    "description": "Given an array of integers and an integer K, find the total number of continuous subarrays whose sum equals to K.",
    "topic": "Array",
    "subtopic": "Prefix Sum",
    "tags": [
      "Array",
      "HashMap",
      "Prefix Sum"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An integer representing the number of continuous subarrays that sum up to k.",
    "constraints": [
      "1 <= nums.length <= 20000",
      "-1000 <= nums[i] <= 1000",
      "-10^7 <= k <= 10^7"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 1], k = 2",
        "output": "2",
        "explanation": "There are two subarrays [1, 1] that sum to 2."
      },
      {
        "input": "nums = [1, 2, 3], k = 3",
        "output": "2",
        "explanation": "The subarrays [3] and [1, 2] both sum to 3."
      },
      {
        "input": "nums = [4, 5, 0, -2, -3, 1], k = 0",
        "output": "5",
        "explanation": "The subarrays [0], [5, 0, -2, -3], [4, 5, 0, -2, -3, 1], [-2, -3], and [1] sum to 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a HashMap to store the cumulative sums.",
      "The key idea is to find a subarray that sums to K by checking the difference in cumulative sums."
    ],
    "company": "Capgemini"
  }
]