[
  {
    "question_id": "",
    "title": "Car Fleet",
    "description": "There are cars moving in a straight line on a one-lane road. Each car's position and speed are given. A car can catch another car if it is behind it and reaches the same position at the same time. You need to determine how many car fleets will arrive at the destination, given the positions and speeds of the cars. The destination is given as a target position.",
    "topic": "Greedy",
    "subtopic": "Car Fleet Problem",
    "tags": [
      "Greedy",
      "Simulation",
      "Math"
    ],
    "input_format": "An integer target representing the destination position, and arrays position and speed representing the initial positions and speeds of the cars respectively.",
    "output_format": "An integer representing the number of car fleets that reach the destination.",
    "constraints": [
      "1 <= position.length == speed.length <= 10^5",
      "0 <= position[i] < target",
      "1 <= speed[i] <= 10^6",
      "All elements in position are distinct."
    ],
    "examples": [
      {
        "input": "target = 12, position = [10, 8, 0, 5, 3], speed = [2, 4, 1, 1, 3]",
        "output": "3",
        "explanation": "The fleets formed are: 10 (speed 2), 8 (speed 4), and [0, 5, 3] (which combines into one fleet)."
      },
      {
        "input": "target = 10, position = [3], speed = [3]",
        "output": "1",
        "explanation": "There is only one car, hence only one fleet."
      },
      {
        "input": "target = 100, position = [0, 2, 4], speed = [4, 2, 1]",
        "output": "1",
        "explanation": "All cars will form a single fleet as they can catch up to each other."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about the time it takes for a car to reach the target.",
      "Use the concept of relative speed to determine if a car will catch another."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Check If Word Is Valid After Substitutions",
    "description": "Given a string 's', check if it can be constructed from the characters 'a', 'b', and 'c', by repeatedly substituting 'abc' with 'a' and 'ac', and 'b' and 'c' can be removed freely. Return true if the word is valid, otherwise return false.",
    "topic": "String",
    "subtopic": "Validation",
    "tags": [
      "String",
      "Validation",
      "Substitution"
    ],
    "input_format": "A single string s consisting of only lowercase letters.",
    "output_format": "A boolean value indicating whether the word is valid after substitutions.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of 'a', 'b', and 'c' only."
    ],
    "examples": [
      {
        "input": "s = 'aabcbc'",
        "output": "true",
        "explanation": "'aabcbc' can be reduced to 'abc' and then to 'a', so it is valid."
      },
      {
        "input": "s = 'abcabcababcc'",
        "output": "true",
        "explanation": "'abcabcababcc' can be reduced to 'abc' multiple times, so it is valid."
      },
      {
        "input": "s = 'abccba'",
        "output": "false",
        "explanation": "'abccba' cannot be reduced to 'a', so it is not valid."
      },
      {
        "input": "s = 'ac'",
        "output": "true",
        "explanation": "'ac' is already valid as it doesn't require any substitutions."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the sequence of characters and how they can be reduced.",
      "Think about using a stack to help with character matching.",
      "Check for patterns of 'abc' and determine what can be freely removed."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Delivering Boxes from Storage to Ports",
    "description": "You have a list of boxes where each box has a certain number of items and a specific port it should be delivered to. Your goal is to determine the minimum number of trips you need to make to deliver all the boxes to their respective ports. A trip can only carry a fixed number of boxes, and once you reach a port, you have to unload all boxes meant for that port. Each box takes one unit of space in the trip. If a box cannot fit in the current trip, it has to be taken in a new trip.",
    "topic": "Greedy",
    "subtopic": "Sorting",
    "tags": [
      "Greedy",
      "Sorting",
      "Boxes",
      "Trips"
    ],
    "input_format": "An array of integers boxes where each integer represents the number of items in a box, and an array of integers ports where each integer represents the port destination for the respective box.",
    "output_format": "An integer representing the minimum number of trips required to deliver all boxes.",
    "constraints": [
      "1 <= boxes.length <= 1000",
      "1 <= ports.length <= 1000",
      "1 <= boxes[i] <= 100",
      "1 <= ports[i] <= 100"
    ],
    "examples": [
      {
        "input": {
          "boxes": [
            2,
            3,
            4,
            2
          ],
          "ports": [
            1,
            2,
            1,
            2
          ]
        },
        "output": "3",
        "explanation": "First trip carries boxes 0 and 2 (2 and 4 items to port 1). Second trip carries boxes 1 and 3 (3 and 2 items to port 2). Third trip is empty since all boxes are delivered."
      },
      {
        "input": {
          "boxes": [
            5,
            1,
            3,
            4
          ],
          "ports": [
            3,
            3,
            2,
            2
          ]
        },
        "output": "4",
        "explanation": "Each box needs a separate trip due to the different ports and box sizes."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a sorting algorithm based on the destination ports and box sizes.",
      "Count how many boxes need to go to the same port and optimize the trips accordingly."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Minimum Processing Time",
    "description": "You are given a list of tasks, each represented by the time it takes to complete the task in milliseconds. Your goal is to find the minimum total processing time required to complete all the tasks if you can run at most two tasks in parallel. Return the minimum processing time required for all tasks to be completed.",
    "topic": "Optimization",
    "subtopic": "Parallel Processing",
    "tags": [
      "Optimization",
      "Parallel Processing",
      "Greedy"
    ],
    "input_format": "A list of integers tasks, where each integer represents the time taken to complete a task.",
    "output_format": "An integer representing the minimum processing time to complete all tasks.",
    "constraints": [
      "1 <= tasks.length <= 1000",
      "1 <= tasks[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "tasks = [2, 4, 1, 6, 5]",
        "output": "6",
        "explanation": "The tasks can be completed in pairs (2, 4), (1, 5), and (6) resulting in a total processing time of max(6, 6) = 6."
      },
      {
        "input": "tasks = [3, 2, 8, 1, 4}",
        "output": "8",
        "explanation": "Pair (3, 4) takes 4 ms, (2, 1) takes 2 ms, and (8) takes 8 ms, leading to total processing time of 8 ms."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a greedy approach to pair tasks effectively.",
      "Sort the tasks to minimize the processing time.",
      "Keep track of running times while processing pairs."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Swap For Longest Repeated Character Substring",
    "description": "Given a string consisting of lowercase English letters, you are allowed to swap any two characters in the string. Your goal is to determine the length of the longest substring that can be formed with repeating characters after making at most one swap.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Sliding Window"
    ],
    "input_format": "A single string s consisting of lowercase English letters.",
    "output_format": "An integer representing the length of the longest substring that can be formed with repeated characters after at most one swap.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "abccd",
        "output": "3",
        "explanation": "By swapping the first 'a' with 'c', we can form the substring 'ccc', which has a length of 3."
      },
      {
        "input": "abcde",
        "output": "2",
        "explanation": "By swapping any two characters, the best we can achieve is 'aa' or 'bb', leading to a maximum length of 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how many characters you can unify.",
      "Use a frequency count to determine potential swaps.",
      "Think about the properties of substrings and how swaps can affect them."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Maximum Sum of an Hourglass",
    "description": "You are given a 2D array of integers with dimensions 6x6. An hourglass is a subset of values with indices falling in this pattern in the array's grid: \n\n```\nA B C\n  D\nE F G\n```\n\nThat is, the elements of the hourglass are: \n- A, B, C  \n- D  \n- E, F, G  \n\nYour task is to find the maximum hourglass sum in the given 2D array.",
    "topic": "Array",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Array",
      "Matrix",
      "sum",
      "2D array"
    ],
    "input_format": "A 6x6 2D array of integers.",
    "output_format": "An integer representing the maximum hourglass sum.",
    "constraints": [
      "Each value of the array is a 32-bit integer.",
      "The dimensions of the array are fixed at 6x6."
    ],
    "examples": [
      {
        "input": "matrix = [[1, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0], [0, 0, 2, 4, 4, 0], [0, 0, 1, 2, 4, 0], [0, 0, 1, 2, 4, 0]]",
        "output": "19",
        "explanation": "The hourglass with the maximum sum is:\n```\n2 4 4\n  1\n1 2 4\n```\nIts sum is 2 + 4 + 4 + 1 + 1 + 2 + 4 = 19."
      },
      {
        "input": "matrix = [[-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1]]",
        "output": "-7",
        "explanation": "The maximum hourglass sum in this case is -7, as all values are -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Iterate through all possible hourglass positions in the grid.",
      "Keep track of the maximum sum found."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Partitioning Into Minimum Number Of Deci-Binary Numbers",
    "description": "Given a positive integer n, partition it into the minimum number of positive integers such that each integer can only contain the digits 0 and 1, while being represented in decimal notation. The output should be the minimum number of such integers needed to sum up to n.",
    "topic": "Mathematics",
    "subtopic": "Number Representation",
    "tags": [
      "Math",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "A single integer n (1 <= n <= 10^9).",
    "output_format": "An integer representing the minimum number of deci-binary numbers required to sum up to n.",
    "constraints": [
      "1 <= n <= 10^9"
    ],
    "examples": [
      {
        "input": "n = 32",
        "output": "3",
        "explanation": "We can partition 32 into 11 + 11 + 10 = 32, which uses 3 deci-binary numbers."
      },
      {
        "input": "n = 27",
        "output": "4",
        "explanation": "We can partition 27 into 11 + 11 + 5 = 27, which uses 4 deci-binary numbers."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the maximum digit in the number.",
      "Iterate through the digits of n to determine the upper limit."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Grumpy Bookstore Owner",
    "description": "A bookstore owner is feeling grumpy and decides to kick out customers who have been browsing too long. Given an array representing the time each customer spends in the store, your task is to determine how many customers will be allowed to stay. A customer who spends more than a specified amount of time will be asked to leave. Implement a function that returns the count of customers who can stay in the store.",
    "topic": "Array",
    "subtopic": "Filtering",
    "tags": [
      "Array",
      "Filtering",
      "Count"
    ],
    "input_format": "An array of integers `times` and an integer `threshold` where `times[i]` represents the time spent by the i-th customer.",
    "output_format": "An integer representing the number of customers who spent less than or equal to the threshold time.",
    "constraints": [
      "1 <= times.length <= 10^4",
      "0 <= times[i] <= 10^3",
      "0 <= threshold <= 10^3"
    ],
    "examples": [
      {
        "input": "times = [5, 3, 8, 1, 4], threshold = 4",
        "output": "3",
        "explanation": "Customers who spent <= 4 are: 3 (3), 1 (1), 4 (4). Total allowed to stay = 3."
      },
      {
        "input": "times = [10, 20, 30, 40], threshold = 25",
        "output": "2",
        "explanation": "Only the customers who spent 10 and 20 can stay. Total allowed to stay = 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a loop or a filtering function to count the number of customers."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Online Majority Element In Subarray",
    "description": "You are given an array of integers 'nums' and an integer 'k'. Your task is to find the majority element in all subarrays of length 'k'. A majority element is defined as an element that appears more than \u230ak / 2\u230b times in that subarray. If no majority element exists for a particular subarray, return -1 for that subarray. Implement a function that processes multiple subarrays and returns the majority elements for these subarrays.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Hash Map"
    ],
    "input_format": "An array of integers nums and an integer k, where 1 <= k <= nums.length.",
    "output_format": "An array of integers representing the majority elements for each subarray of length k.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^5 <= nums[i] <= 10^5",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2, 3, 2], k = 3",
        "output": "[2, 2]",
        "explanation": "For the first subarray [1, 2, 2], the majority element is 2. For the second subarray [2, 2, 3], the majority element is 2."
      },
      {
        "input": "nums = [1, 1, 2, 1, 3, 1], k = 2",
        "output": "[1, 1, 1, 1]",
        "explanation": "All subarrays have 1 appearing more than once, hence all return 1."
      },
      {
        "input": "nums = [1, 2, 3], k = 2",
        "output": "[-1, -1]",
        "explanation": "No majority element exists for any subarray of length 2."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a hash map to count occurrences of elements in the current window.",
      "Use a sliding window approach to efficiently manage subarray elements."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Broken Calculator",
    "description": "You are given a broken calculator that has two operations: double (x2) and subtract 1 (-1). Initially, the calculator displays the number X. Your goal is to transform the number X to the number Y using the minimum number of operations. You can only perform the operations in the order specified (double before subtract). Note that you can only use positive integers.",
    "topic": "Greedy",
    "subtopic": "Mathematical Operations",
    "tags": [
      "Greedy",
      "Mathematics",
      "Algorithm"
    ],
    "input_format": "Two integers X and Y (1 <= X, Y <= 10^9).",
    "output_format": "An integer representing the minimum number of operations required to transform X to Y.",
    "constraints": [
      "1 <= X, Y <= 10^9"
    ],
    "examples": [
      {
        "input": "X = 2, Y = 3",
        "output": "2",
        "explanation": "The operations are: double (2 -> 4) and then subtract (4 -> 3)."
      },
      {
        "input": "X = 5, Y = 8",
        "output": "2",
        "explanation": "The operations are: double (5 -> 10) and then subtract (10 -> 9, then 9 -> 8)."
      },
      {
        "input": "X = 10, Y = 1",
        "output": "9",
        "explanation": "You can only subtract 1 until you reach 1 (10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 4 -> 3 -> 2 -> 1)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about working backwards from Y to X.",
      "Consider when to use the subtract operation strategically."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Detect Cycles in 2D Grid",
    "description": "You are given a 2D grid of '1's (land) and '0's (water). An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You need to determine if there is a cycle in the island. A cycle occurs if you can start from any land cell and navigate through other land cells to return to the starting cell without traversing any water cells. Implement a function that detects whether such a cycle exists in the grid.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "Cycle Detection"
    ],
    "input_format": "A 2D grid of characters, where '1' represents land and '0' represents water.",
    "output_format": "Return true if a cycle exists, otherwise return false.",
    "constraints": [
      "1 <= grid.length <= 100",
      "1 <= grid[i].length <= 100",
      "grid[i][j] is '0' or '1'",
      "The grid is guaranteed to be non-empty."
    ],
    "examples": [
      {
        "input": [
          [
            "1",
            "1",
            "0"
          ],
          [
            "0",
            "1",
            "0"
          ],
          [
            "0",
            "0",
            "1"
          ]
        ],
        "output": "false",
        "explanation": "There is no closed cycle in the grid."
      },
      {
        "input": [
          [
            "1",
            "1",
            "0"
          ],
          [
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "1"
          ]
        ],
        "output": "true",
        "explanation": "There is a cycle formed by the land cells."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use DFS to explore the grid and keep track of visited nodes.",
      "Consider marking cells with a parent to help identify cycles."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "LRU Cache",
    "description": "Design and implement a data structure for Least Recently Used (LRU) Cache. It should support the following operations: get and put.\n\n- `get(key)` - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\n- `put(key, value)` - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item.\n\nThe cache should be initialized with a positive capacity.",
    "topic": "Data Structure",
    "subtopic": "Cache",
    "tags": [
      "Design",
      "Cache",
      "Data Structure"
    ],
    "input_format": "The input consists of a capacity for the LRU Cache, followed by a series of operations in the format: ['get', 'put'].",
    "output_format": "A list of the results of the get operations.",
    "constraints": [
      "The capacity of the cache is a positive integer.",
      "1 <= capacity <= 10^4",
      "All keys and values are positive integers.",
      "The operations may contain up to 10^4 calls."
    ],
    "examples": [
      {
        "input": "LRUCache(2); lruCache.put(1, 1); lruCache.put(2, 2); lruCache.get(1); lruCache.put(3, 3); lruCache.get(2); lruCache.put(4, 4); lruCache.get(1); lruCache.get(3); lruCache.get(4);",
        "output": "[1, -1, 3, 4]",
        "explanation": "1 was retrieved successfully, 2 was evicted when 3 was added, 1 is evicted when 4 is added."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map along with a doubly linked list.",
      "The least recently used item should always be at the tail of the list."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Pacific Atlantic Water Flow",
    "description": "Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the Pacific Ocean touches the left and top edges of the matrix and the Atlantic Ocean touches the right and bottom edges. Find the list of grid coordinates where water can flow to both the Pacific and Atlantic oceans.\n\nWater can flow from a cell to another cell directly up, down, left, or right if the height of the current cell is greater than or equal to the height of the adjacent cell. Return the coordinates of the cells where water can flow to both oceans.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "Matrix"
    ],
    "input_format": "A matrix heights where heights[i][j] represents the height of the cell at (i, j).",
    "output_format": "A list of coordinates (i, j) where water can flow to both oceans.",
    "constraints": [
      "1 <= m, n <= 200",
      "0 <= heights[i][j] <= 10^5"
    ],
    "examples": [
      {
        "input": "heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,5,4,2,2],[5,1,1,2,4]]",
        "output": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]",
        "explanation": "The coordinates where water can flow to both the Pacific and Atlantic oceans are listed."
      },
      {
        "input": "heights = [[2,1],[1,2]]",
        "output": "[[0,0],[0,1],[1,0],[1,1]]",
        "explanation": "All cells can flow to both oceans."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider depth-first search (DFS) for traversing water flow.",
      "Use visited arrays to track cells reachable by each ocean."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Rotting Oranges",
    "description": "In a given 2D grid of integers, each integer can be 0, 1, or 2, where: 0 represents an empty cell, 1 represents a fresh orange, and 2 represents a rotten orange. Every minute, any fresh orange that is adjacent (horizontally or vertically) to a rotten orange will rot. Your task is to determine how many minutes it will take for all the oranges to rot. If it is impossible for all oranges to rot, return -1.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "Matrix"
    ],
    "input_format": "A 2D grid represented as a list of lists of integers.",
    "output_format": "An integer representing the number of minutes until all oranges rot, or -1 if it's not possible.",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[i].length <= 300",
      "grid[i][j] is 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "[[2,1,1],[1,1,0],[0,1,1]]",
        "output": "4",
        "explanation": "Initially, the rotten orange (2) at (0,0) rots the oranges at (0,1) and (1,0) in the first minute. Then, at each subsequent minute, the fresh oranges continue to rot until they are all rotten."
      },
      {
        "input": "[[2,1,1],[0,1,1],[1,0,2]]",
        "output": "-1",
        "explanation": "The orange at (0,0) can rot all adjacent oranges except (1,1), which leaves the orange at (2,0) inaccessible, thus not all oranges can rot."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to perform BFS.",
      "Keep track of the number of minutes as you traverse."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Sliding Window Maximum",
    "description": "Given an integer array nums and an integer k, return the maximum sliding window of all elements in the window of size k. Better performance is expected with O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Queue"
    ],
    "input_format": "An integer array nums and an integer k.",
    "output_format": "An array of integers representing the maximum values for each sliding window of size k.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3",
        "output": "[3, 3, 5, 5, 6, 7]",
        "explanation": "The maximum values for windows are: [3] for the first window [1, 3, -1], [3] for [3, -1, -3], [5] for [-1, -3, 5], [5] for [-3, 5, 3], [6] for [5, 3, 6], [7] for [3, 6, 7]."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "Only one element in the window, so return it."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a deque to keep track of the indices of the elements.",
      "Maintain the order of elements while removing out-of-bound indices.",
      "Always push the current index and discard lesser elements."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "topic": "String",
    "subtopic": "Hashing",
    "tags": [
      "String",
      "Hashing",
      "Anagram",
      "Grouping"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A list of lists of strings, where each sublist contains the grouped anagrams.",
    "constraints": [
      "1 <= strs.length <= 1000",
      "0 <= strs[i].length <= 100",
      "The input strings consist of lowercase alphabets."
    ],
    "examples": [
      {
        "input": "strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
        "output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
        "explanation": "The anagrams are grouped together: 'eat', 'tea', 'ate' are anagrams of each other; 'tan', 'nat' as well; 'bat' is standalone."
      },
      {
        "input": "strs = [\"bat\", \"tab\", \"cat\"]",
        "output": "[[\"bat\",\"tab\"],[\"cat\"]]",
        "explanation": "The only anagrams are 'bat' and 'tab'. 'cat' is standalone."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the characters of each string as a way to identify anagrams.",
      "You can use a dictionary to group words by their sorted representations."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Search a 2D Matrix",
    "description": "You are given an m x n matrix, where each element is an integer, and its elements are sorted in ascending order both row-wise and column-wise. Write an efficient algorithm to determine if a given target value exists in the matrix.",
    "topic": "Binary Search",
    "subtopic": "2D Matrix Search",
    "tags": [
      "Binary Search",
      "Matrix",
      "Search"
    ],
    "input_format": "A 2D matrix of integers 'matrix' and an integer 'target'.",
    "output_format": "Return true if the target exists in the matrix, otherwise return false.",
    "constraints": [
      "1 <= m, n <= 100",
      "m == matrix.length",
      "n == matrix[i].length",
      "-10^9 <= matrix[i][j] <= 10^9",
      "All integers in the matrix are unique.",
      "-10^9 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [15, 17, 19]], target = 9",
        "output": "true",
        "explanation": "The target value 9 exists in the matrix."
      },
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [15, 17, 19]], target = 4",
        "output": "false",
        "explanation": "The target value 4 does not exist in the matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of the sorted matrix.",
      "You can start searching either from the top-right or bottom-left corner."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An array of integers `nums` and an integer `target`.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] = 2 + 7 = 9, we return [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "Because nums[1] + nums[2] = 2 + 4 = 6, we return [1, 2]."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] = 3 + 3 = 6, we return [0, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash map to store the difference between target and each number as you iterate."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Product of Array Except Self",
    "description": "Given an array of integers nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. You must solve it without using division and in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Product Calculation",
    "tags": [
      "Array",
      "Product",
      "Prefix Sum"
    ],
    "input_format": "An array of integers nums of length n.",
    "output_format": "An array of integers representing the product of elements except self.",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-30 <= nums[i] <= 30"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "[24, 12, 8, 6]",
        "explanation": "The output is obtained as follows: output[0] = 2*3*4, output[1] = 1*3*4, output[2] = 1*2*4, output[3] = 1*2*3."
      },
      {
        "input": "nums = [-1, 1, 0, -3, 3]",
        "output": "[0, 0, 9, 0, 0]",
        "explanation": "The output is obtained as follows: output[0] = 1*0*(-3)*3 = 0, output[1] = -1*0*(-3)*3 = 0, etc."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use two separate arrays to store the prefix and suffix products.",
      "Try to solve the problem in one pass after calculating prefix products."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Top K Frequent Elements",
    "description": "Given a non-empty array of integers, return the k most frequent elements. You may return the answer in any order. For example, given nums = [1,1,1,2,2,3] and k = 2, return [1,2].",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Frequency Count"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An array of the k most frequent elements.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= nums[i] <= 10^4",
      "k is guaranteed to be at least 1 and k is less than or equal to the number of unique elements in the array."
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3], k = 2",
        "output": "[1, 2]",
        "explanation": "The number 1 appears 3 times and the number 2 appears 2 times. Thus, the top 2 frequent elements are 1 and 2."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "Only one element exists in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash table to count the frequency of each element.",
      "Consider using a min-heap to keep track of the top k elements."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Increasing Triplet Subsequence",
    "description": "Given an integer array nums, return true if there exists a triplet of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.",
    "topic": "Array",
    "subtopic": "Subsequence",
    "tags": [
      "Array",
      "Subsequence",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A boolean value indicating whether an increasing triplet subsequence exists.",
    "constraints": [
      "1 <= nums.length <= 5 * 10^5",
      "-2^31 <= nums[i] <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5]",
        "output": "true",
        "explanation": "The triplet (1, 2, 3) satisfies the condition."
      },
      {
        "input": "nums = [5, 4, 3, 2, 1]",
        "output": "false",
        "explanation": "No triplet exists that can form an increasing sequence."
      },
      {
        "input": "nums = [2, 1, 5, 0, 4, 6]",
        "output": "true",
        "explanation": "The triplet (1, 5, 6) satisfies the condition."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to keep track of two smallest numbers you have found so far.",
      "If you find a number larger than the second smallest, you can return true."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Valid Number",
    "description": "Determine if a given string is a valid number. A valid number can be an integer or a decimal number, and it may have leading or trailing whitespace, an optional sign ('+' or '-'), and it can optionally contain a decimal point. Scientific notation is also considered valid if it follows the format with an 'e' or 'E' followed by an optional sign and digits.",
    "topic": "String",
    "subtopic": "Parsing",
    "tags": [
      "String",
      "Validation",
      "Parsing"
    ],
    "input_format": "A string s that represents the number to validate.",
    "output_format": "Return true if the string is a valid number, otherwise return false.",
    "constraints": [
      "1 <= s.length <= 20"
    ],
    "examples": [
      {
        "input": "s = \"42\"",
        "output": "true",
        "explanation": "The string '42' is a valid integer."
      },
      {
        "input": "s = \"-1.23e+10\"",
        "output": "true",
        "explanation": "The string '-1.23e+10' is a valid number in scientific notation."
      },
      {
        "input": "s = \"abc\"",
        "output": "false",
        "explanation": "The string 'abc' cannot be interpreted as a number."
      },
      {
        "input": "s = \"1.0.0\"",
        "output": "false",
        "explanation": "The string '1.0.0' has multiple decimal points, hence invalid."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using regular expressions for validation.",
      "Pay attention to the placement of the decimal point and exponent."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Maximum Frequency Stack",
    "description": "Design a stack-like data structure that supports the following operations:\n\n1. push(int x): Pushes an integer x onto the stack.\n2. pop(): Removes and returns the most frequent element in the stack. If there is a tie, the element with the highest value should be removed and returned.\n\nImplement the MaximumFrequencyStack class, the `push` method should take an integer x, while the `pop` method should return the most frequent element in the stack.",
    "topic": "Data Structure",
    "subtopic": "Stack",
    "tags": [
      "Stack",
      "Design",
      "Hash Map"
    ],
    "input_format": "Operations are given as commands to be executed in the MaximumFrequencyStack.",
    "output_format": "Returns the element popped from the stack for the pop() operation.",
    "constraints": [
      "1 <= x <= 10^5 (for push operations)",
      "The stack will have at most 2 * 10^4 operations.",
      "The pop operation will be called only if the stack is non-empty."
    ],
    "examples": [
      {
        "input": "fs = MaximumFrequencyStack()\nfs.push(5)\nfs.push(7)\nfs.push(5)\nfs.push(7)\nfs.push(4)\nfs.push(5)\nfs.pop()",
        "output": "5",
        "explanation": "5 is the most frequent element. It has frequency of 3."
      },
      {
        "input": "fs.push(1)\nfs.push(1)\nfs.push(2)\nfs.pop()",
        "output": "1",
        "explanation": "1 is the most frequent element with a frequency of 2."
      },
      {
        "input": "fs.pop()",
        "output": "2",
        "explanation": "After popping 1, 2 is the only element left."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a frequency map to keep track of the count of elements.",
      "Utilize a max-heap or a priority queue to help retrieve the most frequent items efficiently.",
      "Consider ties in frequency and ensure the max value is returned."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Decode String",
    "description": "Given an encoded string, return its decoded version. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. For example, the string '3[a2[c]]' is decoded as 'accaccacc'. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid and there are no extra spaces.",
    "topic": "String",
    "subtopic": "Decoding",
    "tags": [
      "String",
      "Stack",
      "Recursion"
    ],
    "input_format": "A string representing the encoded format.",
    "output_format": "A string representing the decoded version of the input.",
    "constraints": [
      "1 <= s.length <= 30",
      "s consists of digits, lowercase English letters, and square brackets '[]'.",
      "All the inputs are guaranteed to be valid."
    ],
    "examples": [
      {
        "input": "s = '3[a2[c]]'",
        "output": "accaccacc",
        "explanation": "The encoded string '3[a2[c]]' translates to 'a' repeated 2 times giving 'cc', and then 'acc' repeated 3 times gives 'accaccacc'."
      },
      {
        "input": "s = '2[abc]3[cd]ef'",
        "output": "abcabccdcdcdef",
        "explanation": "The string decodes to 'abc' repeated 2 times gives 'abcabc', 'cd' repeated 3 times gives 'cdcdcd', and together with 'ef' it becomes 'abcabccdcdcdef'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to manage the decoding process.",
      "Keep track of numbers and characters separately.",
      "Pop from the stack to concatenate strings in the correct order."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order. The traversal should start from the top-left corner of the matrix, and proceed rightwards, downwards, leftwards, and upwards, wrapping around until all elements have been visited.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral"
    ],
    "input_format": "A 2D array of integers representing the matrix.",
    "output_format": "A list of integers representing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "m * n <= 10^6",
      "-100 <= matrix[i][j] <= 100"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The spiral order for the given matrix is 1 -> 2 -> 3 -> 6 -> 9 -> 8 -> 7 -> 4 -> 5."
      },
      {
        "input": "matrix = [[1]]",
        "output": "[1]",
        "explanation": "The only element in the matrix is returned."
      },
      {
        "input": "matrix = [[1, 2], [3, 4]]",
        "output": "[1, 2, 4, 3]",
        "explanation": "The spiral order for the 2x2 matrix is 1 -> 2 -> 4 -> 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to keep track of the boundaries of the matrix as you traverse.",
      "Consider using four variables to represent the four edges of the current layer."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Boundary of Binary Tree",
    "description": "Given a binary tree, return the values of its boundary in anti-clockwise direction, starting from the root. The boundary includes the root, the left boundary (except for the leaf nodes), the leaf nodes, and the right boundary (except for the leaf nodes).",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Binary Tree",
      "Traversal"
    ],
    "input_format": "The root node of a binary tree.",
    "output_format": "A list of integers representing the boundary values of the binary tree.",
    "constraints": [
      "The number of nodes in the binary tree is in the range [0, 1000].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, 4, 5, null, 6]",
        "output": "[1, 2, 4, 5, 6, 3]",
        "explanation": "The boundary consists of the root (1), left boundary (2 -> 4), leaves (4 -> 5 -> 6), and right boundary (3)."
      },
      {
        "input": "root = [1]",
        "output": "[1]",
        "explanation": "The tree has only one node, which is the root and also the only boundary."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the different parts of the boundary separately: left boundary, leaf nodes, right boundary.",
      "Use Depth-First Search (DFS) to traverse the tree."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List II",
    "description": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the head of the modified list. Do this in one pass.",
    "topic": "Linked List",
    "subtopic": "Reversal",
    "tags": [
      "Linked List",
      "Reversal",
      "In-place"
    ],
    "input_format": "The first line contains an integer n, the number of nodes in the linked list. The second line contains n space-separated integers representing the linked list's elements. The third line contains two integers left and right.",
    "output_format": "Return the head of the modified linked list after the specified reversal.",
    "constraints": [
      "1 <= n <= 500",
      "1 <= left <= right <= n",
      "The nodes in the list are 1-indexed."
    ],
    "examples": [
      {
        "input": "5\n1 2 3 4 5\n2 4",
        "output": "1->4->3->2->5",
        "explanation": "Reversing nodes from position 2 to 4 will give us the modified list: 1->4->3->2->5."
      },
      {
        "input": "3\n1 2 3\n1 2",
        "output": "2->1->3",
        "explanation": "Reversing nodes from position 1 to 2 results in: 2->1->3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dummy node to simplify edge cases.",
      "Keep track of the previous, current, and next nodes during reversal."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array nums, find the smallest missing positive integer that is not in the array. You must implement an algorithm that runs in O(n) time and uses constant extra space.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Hashing",
      "Searching"
    ],
    "input_format": "An array of integers nums, where 1 <= nums.length <= 30000 and -2^31 <= nums[i] <= 2^31 - 1.",
    "output_format": "An integer representing the smallest missing positive integer.",
    "constraints": [
      "1 <= nums.length <= 30000",
      "-2^31 <= nums[i] <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "nums = [3, 4, -1, 1]",
        "output": "2",
        "explanation": "The integers in the array are 1, 3, and 4. The smallest missing positive integer is 2."
      },
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "The integers in the array are 0, 1, and 2. The smallest missing positive integer is 3."
      },
      {
        "input": "nums = [7, 8, 9, 11, 12]",
        "output": "1",
        "explanation": "None of the integers 1 through 6 are in the array. Hence, the smallest missing positive integer is 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Try to place each number in its right position.",
      "Consider using index as a way to track presence of numbers."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "You are given a rotated sorted array 'nums' and an integer 'target'. Write a function to search for 'target' in 'nums'. If target exists, return its index; otherwise, return -1. You must implement a solution with O(log n) runtime complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Searching"
    ],
    "input_format": "An array of integers 'nums' and an integer 'target'.",
    "output_format": "An integer representing the index of 'target' in 'nums', or -1 if it is not found.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "\u221210^4 <= nums[i] <= 10^4",
      "nums is guaranteed to be rotated at some pivot."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "The target 0 is located at index 4."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "The target 3 is not in the array, so we return -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you can apply binary search by identifying the rotated part of the array.",
      "The mid-point can help determine which half of the array to search next.",
      "Compare the target with 'nums[mid]' to decide the search direction."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Meeting Rooms II",
    "description": "Given an array of meeting time intervals where intervals[i] = [start_i, end_i], return the minimum number of conference rooms required to hold all meetings. Each meeting can only be held in one room at a time, and meetings in the same room must be scheduled based on their start and end times.",
    "topic": "Greedy",
    "subtopic": "Interval Scheduling",
    "tags": [
      "Greedy",
      "Interval",
      "Sorting"
    ],
    "input_format": "A list of intervals where each interval is represented as an array of two integers [start, end].",
    "output_format": "An integer representing the minimum number of conference rooms required.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "0 <= start_i < end_i <= 10^6"
    ],
    "examples": [
      {
        "input": "intervals = [[0, 30], [5, 10], [15, 20]]",
        "output": "2",
        "explanation": "We need two rooms: one for [0, 30] and another for [5, 10]."
      },
      {
        "input": "intervals = [[7, 10], [2, 4]]",
        "output": "1",
        "explanation": "Both meetings can be held in the same room."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the meetings by their start times.",
      "Use a min-heap to keep track of the end times of meetings."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Longest Common Subsequence",
    "description": "Given two strings text1 and text2, return the length of their longest common subsequence. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, 'ace' is a subsequence of 'abcde' while 'aec' is not. A common subsequence of two strings is a subsequence that is common to both strings. If there is no common subsequence, return 0.",
    "topic": "Dynamic Programming",
    "subtopic": "Longest Common Subsequence",
    "tags": [
      "Dynamic Programming",
      "String",
      "LCS"
    ],
    "input_format": "Two strings text1 and text2, where 1 <= text1.length, text2.length <= 1000.",
    "output_format": "An integer representing the length of the longest common subsequence.",
    "constraints": [
      "1 <= text1.length, text2.length <= 1000",
      "text1 and text2 consist of only English uppercase and lowercase letters."
    ],
    "examples": [
      {
        "input": "text1 = 'abcde', text2 = 'ace'",
        "output": "3",
        "explanation": "The longest common subsequence is 'ace' and its length is 3."
      },
      {
        "input": "text1 = 'abc', text2 = 'def'",
        "output": "0",
        "explanation": "There is no common subsequence between 'abc' and 'def'."
      },
      {
        "input": "text1 = 'abc', text2 = 'abc'",
        "output": "3",
        "explanation": "The longest common subsequence is 'abc' and its length is 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store results of subproblems.",
      "Define DP[i][j] as the length of LCS of text1[0..i-1] and text2[0..j-1].",
      "When characters match, increase the count by 1 and consider the previous indices."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Clone Graph",
    "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors. You must return the clone of the given node as the root of the cloned graph.",
    "topic": "Graph",
    "subtopic": "Depth First Search",
    "tags": [
      "Graph",
      "Depth-First Search",
      "Cloning"
    ],
    "input_format": "A reference to a node in the graph.",
    "output_format": "A reference to the root of the cloned graph.",
    "constraints": [
      "The number of nodes in the graph is in the range [0, 100].",
      "Each node's value is unique and in the range [-100, 100].",
      "The Graph is connected and undirected."
    ],
    "examples": [
      {
        "input": "Input: adjList = [[2,4],[1,3],[2],[1]] where node 1 connects to nodes 2 and 4, node 2 connects to nodes 1 and 3, etc.",
        "output": "Return a clone of the input graph.",
        "explanation": "The clone of the input graph will have the same structure as the original, with nodes having the same values and connections."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to keep track of copied nodes.",
      "Consider using DFS or BFS to traverse and clone nodes."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Surrounded Regions",
    "description": "Given a 2D board containing 'X' and 'O', capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. The 'O's that are on the border or connected to the border cannot be captured.",
    "topic": "Graph",
    "subtopic": "DFS/BFS",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Matrix"
    ],
    "input_format": "A 2D board represented as a list of lists containing 'X' and 'O'.",
    "output_format": "Modify the board in place with 'X' and 'O' updated as per the capturing rule.",
    "constraints": [
      "1 <= board.length <= 200",
      "1 <= board[i].length <= 200",
      "board[i][j] is 'X' or 'O'."
    ],
    "examples": [
      {
        "input": "board = [['X', 'X', 'X', 'X'], ['X', 'O', 'O', 'X'], ['X', 'X', 'O', 'X'], ['X', 'O', 'X', 'X']]",
        "output": "[['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'O', 'X', 'X']]",
        "explanation": "The surrounded region of 'O's is captured and turned into 'X's."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use DFS or BFS to find all 'O's connected to the border.",
      "You may need to mark the 'O's which cannot be captured temporarily."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Subsequence",
    "description": "Given a string s, return the length of the longest subsequence of s that is a palindrome. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Palindrome"
    ],
    "input_format": "A single string s of length n.",
    "output_format": "An integer representing the length of the longest palindromic subsequence.",
    "constraints": [
      "1 <= n <= 1000",
      "s consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = \"bbbab\"",
        "output": "4",
        "explanation": "The longest palindromic subsequence is \"bbbb\" which has a length of 4."
      },
      {
        "input": "s = \"cbbd\"",
        "output": "2",
        "explanation": "The longest palindromic subsequence is \"bb\" which has a length of 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to solve the problem.",
      "Think about how to compare characters from both ends of the string."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Set Matrix Zeroes",
    "description": "Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do this in place.",
    "topic": "Array",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Array",
      "Matrix",
      "In-Place"
    ],
    "input_format": "A 2D array of integers matrix of size m x n.",
    "output_format": "The modified matrix with specified rows and columns set to 0.",
    "constraints": [
      "1 <= m, n <= 200",
      "-10^7 <= matrix[i][j] <= 10^7"
    ],
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": "The element at (1,1) is 0, so we set the entire row 1 and column 1 to 0."
      },
      {
        "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
        "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
        "explanation": "The elements at (0,0) and (0,3) are 0, setting their respective rows and columns to 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a set to track which rows and columns need to be zeroed.",
      "Consider the first row and first column as special cases."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Swap Nodes in Pairs",
    "description": "Given a linked list, swap every two adjacent nodes and return its head. You must do this in place without modifying the values in the nodes. Only nodes themselves should be swapped.",
    "topic": "Linked List",
    "subtopic": "Basic Manipulation",
    "tags": [
      "Linked List",
      "Twopointers",
      "In-place"
    ],
    "input_format": "A singly linked list represented as a ListNode object.",
    "output_format": "The head of the modified linked list.",
    "constraints": [
      "The number of nodes in the linked list is in the range [0, 100].",
      "Value of each node is in the range [-100, 100]."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4]",
        "output": "[2, 1, 4, 3]",
        "explanation": "Swapping nodes 1 and 2 results in 2 -> 1. Swapping nodes 3 and 4 results in 4 -> 3. The final linked list looks like: 2 -> 1 -> 4 -> 3."
      },
      {
        "input": "head = [1]",
        "output": "[1]",
        "explanation": "There is only one node, so no swaps are needed, and the output remains the same."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "An empty list remains empty after attempting swaps."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dummy node to simplify edge cases.",
      "Consider using a loop to iterate through pairs of nodes."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of k linked lists, each linked list is sorted in ascending order. Merge all the linked lists into one sorted linked list and return it. Please note that the linked lists should remain in a valid linked list format.",
    "topic": "Linked List",
    "subtopic": "Merge Algorithms",
    "tags": [
      "Linked List",
      "Sorting",
      "Merge"
    ],
    "input_format": "An array of k linked lists, where 1 <= k <= 10^4, and each linked list contains nodes sorted in ascending order.",
    "output_format": "A single linked list that represents the merged sorted linked list.",
    "constraints": [
      "0 <= k <= 10^4",
      "0 <= n <= 500, where n is the number of nodes in a single linked list.",
      "-10^5 <= value <= 10^5"
    ],
    "examples": [
      {
        "input": "[1->4->5, 1->3->4, 2->6]",
        "output": "1->1->2->3->4->4->5->6",
        "explanation": "The merged linked list combines all values in ascending order."
      },
      {
        "input": "[]",
        "output": "",
        "explanation": "An empty input returns an empty linked list."
      },
      {
        "input": "[3->4->5, 1->2->3]",
        "output": "1->2->3->3->4->5",
        "explanation": "The two linked lists merged in order yield the result."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a priority queue to keep track of the smallest current node.",
      "You can also use divide and conquer to merge the lists in pairs."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Binary Tree Maximum Path Sum",
    "description": "Given a non-empty binary tree, find the maximum path sum. The path may start and end at any node in the tree. It is defined as the sum of the node values along the path. A path is defined as a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. Note that the path does not need to go through the root.",
    "topic": "Tree",
    "subtopic": "Binary Trees",
    "tags": [
      "Tree",
      "Depth-First Search",
      "Dynamic Programming"
    ],
    "input_format": "The input is the root node of the binary tree.",
    "output_format": "An integer representing the maximum path sum of the binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 3 * 10^4].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "[1, 2, 3]",
        "output": "6",
        "explanation": "The maximum path sum is 2 + 1 + 3 = 6."
      },
      {
        "input": "[-10, 9, 20, null, null, 15, 7]",
        "output": "42",
        "explanation": "The maximum path sum is 15 + 20 + 7 = 42."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider paths that may start from any node.",
      "You may need to perform a depth-first search.",
      "Keep track of the current path sum at each node."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Scramble String",
    "description": "Given two strings 's1' and 's2', write a function to determine if 's2' is a scramble string of 's1'. A string 's2' is a scramble string of 's1' if we can transform 's1' into 's2' by making a series of swaps, where each swap consists of swapping two non-empty substring of 's1'. For example, 'great' can be transformed to 'rgeat' by swapping 'gr' and 'eat'.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Recursion"
    ],
    "input_format": "Two strings s1 and s2, where 1 <= s1.length, s2.length <= 30.",
    "output_format": "Return true if s2 is a scramble string of s1, otherwise return false.",
    "constraints": [
      "1 <= s1.length, s2.length <= 30",
      "s1 and s2 must contain only lowercase English letters."
    ],
    "examples": [
      {
        "input": "s1 = 'great', s2 = 'rgeat'",
        "output": "true",
        "explanation": "String 's2' can be formed from 's1' by swapping the first two characters."
      },
      {
        "input": "s1 = 'abcde', s2 = 'caebd'",
        "output": "false",
        "explanation": "'s2' cannot be formed from 's1' with the scrambling rules."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a recursive approach to check for scramble substrings.",
      "Consider character frequency for early pruning."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Minimum Number of Swaps to Make the String Balanced",
    "description": "Given a string containing only the characters 'a' and 'b', your task is to find the minimum number of swaps required to make the string balanced. A balanced string is defined as one that contains an equal number of 'a's and 'b's. You can swap any two characters in the string. If it is not possible to balance the string, return -1.",
    "topic": "String Manipulation",
    "subtopic": "Swapping Characters",
    "tags": [
      "String",
      "Swapping",
      "Balanced"
    ],
    "input_format": "A string s which contains only the characters 'a' and 'b'.",
    "output_format": "An integer representing the minimum number of swaps required to make the string balanced, or -1 if it is impossible.",
    "constraints": [
      "1 <= s.length <= 10^6",
      "s consists of only 'a' and 'b'."
    ],
    "examples": [
      {
        "input": "s = 'aabbb'",
        "output": "1",
        "explanation": "One possible way to balance is to swap one 'b' with one 'a', resulting in 'ababb' which contains equal numbers of 'a's and 'b's."
      },
      {
        "input": "s = 'aaa'",
        "output": "-1",
        "explanation": "It's impossible to balance the string as it contains only 'a's."
      },
      {
        "input": "s = 'abab'",
        "output": "0",
        "explanation": "The string is already balanced, with equal numbers of 'a's and 'b's."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Count the number of 'a's and 'b's and check if they can be balanced.",
      "Swaps are needed when one character appears more than half the length of the string."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Amount of Time for Binary Tree to Be Infected",
    "description": "You are given a binary tree where each node contains a boolean value indicating whether it is infected or not. Initially, all nodes are uninfected, except for a certain node which is infected at time t = 0. Each infected node can infect its directly connected neighbors (left and right children) in one unit of time. Your task is to determine the amount of time it takes for the entire tree to become infected.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Graph Traversal"
    ],
    "input_format": "The input consists of the root node of a binary tree, where each node has a boolean value representing its infected status.",
    "output_format": "An integer representing the time (in units) it takes for the entire tree to become infected.",
    "constraints": [
      "1 <= number of nodes <= 1000",
      "The tree is a complete binary tree."
    ],
    "examples": [
      {
        "input": "root = [1, 0, 0, 0, 1, 0, 0]",
        "output": "2",
        "explanation": "Starting from the infected node at root, it takes 1 unit of time to infect its children, and then 1 more unit to infect their children. Thus, total time is 2."
      },
      {
        "input": "root = [0, 1, 0, 0, 0, 1, 0, 0, 0]",
        "output": "3",
        "explanation": "The infected nodes at depth 1 can infect their children in the next unit, leading to complete infection at depth 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use depth-first search or breadth-first search for traversal.",
      "Track the levels of infection using a queue or stack.",
      "Consider each step as a time unit."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Find Minimum in Rotated Sorted Array",
    "description": "Given a rotated sorted array, find the minimum element in it. You must assume that the array was originally sorted in ascending order before the rotation. Write a function that takes in the rotated array and returns the minimum element. The array may contain duplicates.",
    "topic": "Binary Search",
    "subtopic": "Search in Rotated Sorted Array",
    "tags": [
      "Array",
      "Binary Search",
      "Sorting"
    ],
    "input_format": "An integer array nums representing the rotated sorted array.",
    "output_format": "An integer representing the minimum element in the array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [3, 4, 5, 1, 2]",
        "output": "1",
        "explanation": "The minimum element in the rotated array [3, 4, 5, 1, 2] is 1."
      },
      {
        "input": "nums = [4, 5, 6, 7, 0, 1, 2]",
        "output": "0",
        "explanation": "The minimum element in the rotated array [4, 5, 6, 7, 0, 1, 2] is 0."
      },
      {
        "input": "nums = [1, 3, 5]",
        "output": "1",
        "explanation": "The minimum element in the rotated array [1, 3, 5] is 1."
      },
      {
        "input": "nums = [2, 2, 2, 0, 1, 2]",
        "output": "0",
        "explanation": "The minimum element in the rotated array [2, 2, 2, 0, 1, 2] is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use binary search to efficiently find the minimum.",
      "Consider the properties of a rotated sorted array."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A palindrome is a string that reads the same backward as forward.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Palindrome",
      "Dynamic Programming"
    ],
    "input_format": "A string s consisting of lowercase and uppercase letters.",
    "output_format": "A string representing the longest palindromic substring.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consist of only digits and English letters."
    ],
    "examples": [
      {
        "input": "s = 'babad'",
        "output": "'bab'",
        "explanation": "Both 'bab' and 'aba' are valid longest palindromic substrings."
      },
      {
        "input": "s = 'cbbd'",
        "output": "'bb'",
        "explanation": "'bb' is the longest palindromic substring."
      },
      {
        "input": "s = 'a'",
        "output": "'a'",
        "explanation": "The longest palindromic substring in a single character string is the string itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Expand around the center to find palindromes.",
      "Consider both odd and even length palindromes."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "Given an array of integers where each integer represents the height of a vertical line drawn on the x-axis, find two lines that together with the x-axis form a container that holds the most water. Return the maximum amount of water that can be contained.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Geometry"
    ],
    "input_format": "An array of integers heights representing the heights of the lines.",
    "output_format": "An integer representing the maximum amount of water that can be contained.",
    "constraints": [
      "2 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The container formed between lines at indices 1 and 8 (heights 8 and 7) can hold water. The width is 7, and the height is 7, giving area = 7 * 7 = 49."
      },
      {
        "input": "heights = [1,1]",
        "output": "1",
        "explanation": "The only lines available are both of height 1, forming a container of area 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a two-pointer technique to maximize efficiency.",
      "Calculate the area and move the pointer from the shorter line."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Jump Game II",
    "description": "You are given an array of non-negative integers nums, where each element represents the maximum jump length at that position. Your goal is to determine the minimum number of jumps needed to reach the last index. If you cannot reach the last index, return -1.",
    "topic": "Greedy",
    "subtopic": "Jump Game",
    "tags": [
      "Array",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "An integer representing the minimum number of jumps to reach the last index, or -1 if not possible.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "2",
        "explanation": "Jump 1 step from index 0 to 1, then jump 2 steps to reach the last index."
      },
      {
        "input": "nums = [2, 3, 0, 1, 4]",
        "output": "2",
        "explanation": "Jump 1 step from index 0 to 1, then jump 3 steps to reach the last index."
      },
      {
        "input": "nums = [0]",
        "output": "0",
        "explanation": "Already at the last index, no jumps needed."
      },
      {
        "input": "nums = [1, 0, 0, 0]",
        "output": "-1",
        "explanation": "Cannot reach the last index from the first index."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a greedy approach to minimize the number of jumps.",
      "Track the farthest position you can reach at each jump."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Word Ladder",
    "description": "Given two words, beginWord and endWord, and a dictionary's word list, find the length of the shortest transformation sequence from beginWord to endWord, such that only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not part of the word list. If there is no such transformation sequence, return 0.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "Word Ladder"
    ],
    "input_format": "A string beginWord, a string endWord, and an array of strings wordList.",
    "output_format": "An integer representing the length of the shortest transformation sequence.",
    "constraints": [
      "1 <= beginWord.length, endWord.length <= 10",
      "1 <= wordList.length <= 5000",
      "beginWord and endWord consist of lowercase English letters.",
      "All the strings in wordList are unique."
    ],
    "examples": [
      {
        "input": {
          "beginWord": "hit",
          "endWord": "cog",
          "wordList": [
            "hot",
            "dot",
            "dog",
            "lot",
            "log",
            "cog"
          ]
        },
        "output": "5",
        "explanation": "The shortest transformation sequence is 'hit' -> 'hot' -> 'dot' -> 'dog' -> 'cog', which has a length of 5."
      },
      {
        "input": {
          "beginWord": "hit",
          "endWord": "cog",
          "wordList": [
            "hot",
            "dot",
            "dog",
            "lot",
            "log"
          ]
        },
        "output": "0",
        "explanation": "There is no way to transform 'hit' to 'cog' because 'cog' is not in the word list."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a breadth-first search (BFS) approach.",
      "Consider each word as a node in a graph.",
      "Use a queue to explore possible transformations."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Course Schedule",
    "description": "You are given an array of prerequisites where each prerequisites[i] = [a, b] indicates that you must take course b before course a. Determine if you can finish all courses given the total number of courses and the prerequisite pairs.",
    "topic": "Graph",
    "subtopic": "Topological Sort",
    "tags": [
      "Graph",
      "Topological Sort",
      "DFS"
    ],
    "input_format": "An integer numCourses representing the total number of courses, and an array of prerequisite pairs representing the dependencies.",
    "output_format": "Return true if you can finish all courses, otherwise return false.",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2"
    ],
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = [[1, 0]]",
        "output": "true",
        "explanation": "There are a total of 2 courses, and taking course 0 allows you to take course 1."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1, 0], [0, 1]]",
        "output": "false",
        "explanation": "There is a cycle between course 0 and course 1, thus cannot take all courses."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using depth-first search to detect cycles.",
      "Use an adjacency list to represent the graph."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Heaters",
    "description": "You are given a list of houses and a list of heaters. Each heater has a position and can heat all houses located within a certain radius. Your task is to find the minimum radius of heaters such that all houses are heated. A house is considered heated if there is at least one heater within distance 'r' from the house. The distance between the house and the heater is defined as the absolute difference between their positions.",
    "topic": "Binary Search",
    "subtopic": "Greedy",
    "tags": [
      "Binary Search",
      "Greedy",
      "Array"
    ],
    "input_format": "Two arrays, houses and heaters, where houses[i] is the position of the i-th house and heaters[j] is the position of the j-th heater.",
    "output_format": "An integer representing the minimum heating radius required to heat all houses.",
    "constraints": [
      "1 <= houses.length, heaters.length <= 10^4",
      "0 <= houses[i], heaters[j] <= 10^9"
    ],
    "examples": [
      {
        "input": "houses = [1, 2, 3, 4, 5], heaters = [1, 4]",
        "output": "1",
        "explanation": "Heater at position 1 can heat house 1 and house 2, while the heater at position 4 can heat houses 4 and 5. Thus, a minimum radius of 1 is sufficient."
      },
      {
        "input": "houses = [1, 2, 3], heaters = [2]",
        "output": "1",
        "explanation": "Heater at position 2 can heat all houses within a radius of 1. House 1 is 1 unit away, and house 3 is also 1 unit away."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the heaters array for easier look-up.",
      "Use binary search to optimize finding the closest heater."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit",
    "description": "Given an integer array nums and an integer limit, return the length of the longest continuous subarray such that the absolute difference between any two elements in this subarray is less than or equal to limit.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Two Pointers"
    ],
    "input_format": "An integer array nums and an integer limit.",
    "output_format": "An integer denoting the length of the longest continuous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9",
      "0 <= limit <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [8, 2, 4, 7], limit = 4",
        "output": "2",
        "explanation": "The longest subarray with an absolute difference of at most 4 is [2, 4] or [4, 7], both of length 2."
      },
      {
        "input": "nums = [10, 1, 2, 4, 7, 2], limit = 5",
        "output": "4",
        "explanation": "The longest subarray with an absolute difference of at most 5 is [1, 2, 4, 2], length 4."
      },
      {
        "input": "nums = [4, 2, 2, 2, 4], limit = 0",
        "output": "3",
        "explanation": "The longest subarray with an absolute difference of at most 0 is [2, 2, 2], length 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sliding window approach to maintain the current range.",
      "Use a data structure to keep track of the minimum and maximum in the current window."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "All Nodes Distance K in Binary Tree",
    "description": "Given a binary tree, a target node, and an integer K, return a list of all nodes that are K distance from the target node. The distance between two nodes is defined as the number of edges in the shortest path between them. You may assume that the target node is always a valid node in the tree.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Graph",
      "DFS",
      "BFS"
    ],
    "input_format": "The root of the binary tree and the value of the target node, as well as integer K.",
    "output_format": "A list of integers representing the node values that are K distance away from the target node.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 10^4].",
      "-10^9 <= Node.val <= 10^9",
      "All Node.val are unique.",
      "Target node is guaranteed to be in the tree."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, 4, 5, 6, 7], target = 3, K = 2",
        "output": "[4, 5, 6, 7]",
        "explanation": "The nodes 4, 5, 6, and 7 are all at distance 2 from the target node 3."
      },
      {
        "input": "root = [1], target = 1, K = 0",
        "output": "[1]",
        "explanation": "The only node is 1, which is at distance 0 from itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using BFS to explore the tree from the target node.",
      "Keep track of the parent nodes to navigate back when necessary.",
      "Use a queue to manage the nodes to visit while keeping track of distances."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices where 0 <= prices.length <= 10^5.",
    "output_format": "An integer representing the maximum profit you can achieve.",
    "constraints": [
      "0 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate profit as the difference between the current price and the minimum price."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Maximum Product of Three Numbers",
    "description": "Given an integer array nums, find three numbers whose product is maximized, and return the maximum product.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Math",
      "Sorting"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum product of three numbers from the array.",
    "constraints": [
      "3 <= nums.length <= 10^4",
      "-1000 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "6",
        "explanation": "The product of the three numbers 1, 2, and 3 is 6."
      },
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "24",
        "explanation": "The maximum product is from the three numbers 2, 3, and 4, which is 6 * 4 = 24."
      },
      {
        "input": "nums = [-10, -10, 5, 2]",
        "output": "500",
        "explanation": "The product of the two negative numbers -10 and -10, and the positive number 5 gives the maximum product: -10 * -10 * 5 = 500."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider both positive and negative numbers.",
      "The maximum product can come from either three largest numbers or two smallest (negative) numbers with the largest positive number."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not have any leading zeroes, except the number 0 itself.",
    "topic": "Linked List",
    "subtopic": "Addition",
    "tags": [
      "Linked List",
      "Math",
      "Simulation"
    ],
    "input_format": "The input consists of two linked lists, l1 and l2.",
    "output_format": "Return the sum as a linked list.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= node.val <= 9",
      "It is guaranteed that the input lists represent a number that does not have leading zeros."
    ],
    "examples": [
      {
        "input": "l1 = [2, 4, 3], l2 = [5, 6, 4]",
        "output": "[7, 0, 8]",
        "explanation": "The numbers represented by the linked lists are 342 and 465. Their sum is 807, which is represented as [7, 0, 8]."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "Both linked lists represent the number 0. Their sum is also 0."
      },
      {
        "input": "l1 = [9, 9, 9, 9, 9, 9, 9], l2 = [9, 9, 9, 9]",
        "output": "[8, 9, 9, 9, 0, 0, 0, 1]",
        "explanation": "The numbers represented are 9999999 and 9999. Their sum is 10009998, which is represented as [8, 9, 9, 9, 0, 0, 0, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to handle carry when the sum of nodes exceeds 9.",
      "Use a dummy head node to simplify the linked list building process."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Reverse Nodes in k-Group",
    "description": "Given a linked list, reverse the nodes of the list k at a time and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k, then left-out nodes in the end should remain as they are. You need to do this in a single pass and without using extra memory for another data structure.",
    "topic": "Linked List",
    "subtopic": "Reversing Linked List",
    "tags": [
      "Linked List",
      "Reversal",
      "In-place"
    ],
    "input_format": "The head of the linked list as a ListNode.",
    "output_format": "The head of the modified linked list as a ListNode.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 5000].",
      "0 <= Node.val <= 1000",
      "1 <= k <= length of list"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], k = 2",
        "output": "[2, 1, 4, 3, 5]",
        "explanation": "The first two nodes (1 and 2) are reversed to become 2 and 1. The next two nodes (3 and 4) are also reversed. Node 5 remains as it is since there are less than k nodes left."
      },
      {
        "input": "head = [1, 2, 3, 4, 5], k = 3",
        "output": "[3, 2, 1, 4, 5]",
        "explanation": "The first three nodes (1, 2, and 3) are reversed, resulting in 3, 2, and 1. The remaining nodes (4 and 5) remain unchanged."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a pointer to track the current node.",
      "Consider using a dummy node to simplify edge cases.",
      "Handle the left-over nodes after the last k-group."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Min Cost to Connect All Points",
    "description": "There are n points in a 2D plane. The cost of connecting two points (x1, y1) and (x2, y2) is the Manhattan distance between them: |x1 - x2| + |y1 - y2|. Return the minimum cost to connect all n points.",
    "topic": "Graph",
    "subtopic": "Minimum Spanning Tree",
    "tags": [
      "Graph",
      "Minimum Spanning Tree",
      "Union Find"
    ],
    "input_format": "An array points where points[i] = [xi, yi] represents the coordinates of the i-th point.",
    "output_format": "An integer representing the minimum cost to connect all points.",
    "constraints": [
      "1 <= n <= 100",
      "-10^6 <= xi, yi <= 10^6"
    ],
    "examples": [
      {
        "input": "points = [[0,0],[2,2],[3,10],[5,2],[7,0]]",
        "output": "20",
        "explanation": "The minimum cost to connect all the points is 20."
      },
      {
        "input": "points = [[-1,-1],[1,1],[1,-1],[-1,1]]",
        "output": "4",
        "explanation": "The minimum cost to connect all the points is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Prim's or Kruskal's algorithm.",
      "The Manhattan distance is crucial in calculating costs."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Note that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "An integer array nums of length n.",
    "output_format": "A list of unique triplets that sum up to zero.",
    "constraints": [
      "0 <= n <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that sum up to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no triplets in an empty array."
      },
      {
        "input": "nums = [0, 0, 0]",
        "output": "[[0, 0, 0]]",
        "explanation": "The only triplet is [0, 0, 0] which sums up to zero."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the array first to facilitate finding triplets.",
      "Use two pointers to reduce the range after choosing one element."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Word Break",
    "description": "Given a string s and a list of strings wordDict, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Backtracking"
    ],
    "input_format": "A string s and an array of strings wordDict.",
    "output_format": "A boolean value indicating whether s can be segmented into dictionary words.",
    "constraints": [
      "1 <= s.length <= 300",
      "1 <= wordDict.length <= 1000",
      "1 <= wordDict[i].length <= 20",
      "The input string and words in the dictionary consist of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = 'leetcode', wordDict = ['leet', 'code']",
        "output": "true",
        "explanation": "The string 'leetcode' can be segmented as 'leet' + 'code'."
      },
      {
        "input": "s = 'applepenapple', wordDict = ['apple', 'pen']",
        "output": "true",
        "explanation": "The string can be segmented as 'apple' + 'pen' + 'apple'."
      },
      {
        "input": "s = 'catsandog', wordDict = ['cats', 'dog', 'sand', 'and', 'cat']",
        "output": "false",
        "explanation": "The string cannot be segmented into words from the dictionary."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to use dynamic programming to build up the solution.",
      "Use a DP array to track achievable segmentations.",
      "Consider starting from the beginning of s and check possible splits."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Binary Tree Zigzag Level Order Traversal",
    "description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search"
    ],
    "input_format": "A binary tree represented by its root node.",
    "output_format": "A list of lists, where each inner list represents the values at each level of the tree in zigzag order.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[20,9],[15,7]]",
        "explanation": "Level 0 has one node with value 3. Level 1 has nodes with values 9 and 20, but we traverse from right to left, yielding 20, 9. Level 2 has nodes 15 and 7, traversed from left to right."
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": "There is only one node with value 1, so the output is [[1]]."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree results in an empty output."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to perform level order traversal.",
      "Alternately reverse the order of lists for odd levels."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Graph",
    "subtopic": "DFS/BFS",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Matrix"
    ],
    "input_format": "A 2D grid (list of lists) where each element is either '1' or '0'.",
    "output_format": "An integer representing the number of islands.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "[['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1']]",
        "output": "3",
        "explanation": "There are three islands in the grid."
      },
      {
        "input": "[['1', '1', '1', '1', '0'], ['1', '1', '0', '1', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '0', '0', '0']]",
        "output": "1",
        "explanation": "There is one single island in the grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you can traverse the grid to find connected components.",
      "Use Depth First Search (DFS) or Breadth First Search (BFS) to explore each island."
    ],
    "company": "Nutanix"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of bars, compute how much water it can trap after raining. The width of each bar is uniform and equal to 1.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers height representing the height of each bar.",
    "output_format": "An integer representing the total units of trapped rain water.",
    "constraints": [
      "0 <= height.length <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The water can be trapped over bars 1, 2, 4, 5, 6 and 10. Hence, the total water trapped is 6."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The water can be trapped between heights resulting in a total of 9 units."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to determine the left and right max heights.",
      "Implement two pointers to traverse the array."
    ],
    "company": "Nutanix"
  }
]