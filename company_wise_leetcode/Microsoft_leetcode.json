[
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers, return the indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers that add up to target.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "The solution exists."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] == 2 + 7 == 9, so the indices are 0 and 1."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "nums[1] + nums[2] == 2 + 4 == 6, so the indices are 1 and 2."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a hash table to store the indices of the numbers.",
      "Think about the difference between the target and each number."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Merge Sorted Array",
    "description": "Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. The initial number of elements in nums1 is m, and nums2 has n elements. You must merge in-place, meaning you should not use extra space for a third array. The resulting array should be in non-decreasing order.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Sorting",
      "In-place"
    ],
    "input_format": "Two sorted arrays nums1 (of size m + n) and nums2 (of size n). The first m elements of nums1 are the elements to be merged, while the last n elements are set to 0 and should be ignored.",
    "output_format": "The merged array in nums1, which is sorted in non-decreasing order.",
    "constraints": [
      "0 <= m, n <= 200",
      "1 <= m + n <= 200",
      "nums1.length == m + n",
      "nums2.length == n",
      "0 <= nums1[i], nums2[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3",
        "output": "[1, 2, 2, 3, 5, 6]",
        "explanation": "After merging nums2 into nums1, the array is [1, 2, 2, 3, 5, 6]."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "Since nums2 is empty, nums1 remains the same."
      },
      {
        "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
        "output": "[1]",
        "explanation": "nums1 was empty, so we replace it with elements from nums2."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to traverse the two arrays from the end.",
      "Start placing elements in nums1 from the back to avoid overwriting."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters. A substring is defined as a contiguous sequence of characters within the string. You must ensure that no characters in the substring repeat.",
    "topic": "Strings",
    "subtopic": "Sliding Window",
    "tags": [
      "Strings",
      "Sliding Window",
      "Substrings"
    ],
    "input_format": "A string s consisting of English letters, digits, symbols, and spaces.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 5 * 10^4",
      "s consists of English letters, digits, symbols, and spaces."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The answer is \"abc\", with the length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The answer is \"b\", with the length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The answer is \"wke\", with the length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using a sliding window approach.",
      "Use a set to track characters in the current substring."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.",
    "topic": "Linked List",
    "subtopic": "Addition",
    "tags": [
      "Linked List",
      "Mathematics",
      "Two Pointers"
    ],
    "input_format": "Two linked lists l1 and l2, where each linked list represents a non-negative integer.",
    "output_format": "A linked list representing the sum of the two numbers.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the list represents a number that does not have leading zeros."
    ],
    "examples": [
      {
        "input": "l1 = [2, 4, 3], l2 = [5, 6, 4]",
        "output": "[7, 0, 8]",
        "explanation": "342 + 465 = 807, so the linked list representing 807 is [7, 0, 8]."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "0 + 0 = 0, so the linked list is [0]."
      },
      {
        "input": "l1 = [9, 9, 9], l2 = [1]",
        "output": "[0, 0, 0, 1]",
        "explanation": "999 + 1 = 1000, so the linked list is [0, 0, 0, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a carry variable to handle sums greater than 9.",
      "Iterate through both linked lists until both are fully processed."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of bars, calculate how much water can be trapped after raining. The water can only be trapped if there are bars on both sides of a bar.",
    "topic": "Dynamic Programming",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Two Pointers"
    ],
    "input_format": "An array of integers height, where each height[i] represents the bar's height at position i.",
    "output_format": "An integer representing the total units of trapped rain water.",
    "constraints": [
      "n == height.length",
      "1 <= n <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The trapped water units are between the bars, resulting in a total of 6 units."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The configuration allows for 9 units of water to be trapped."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to find the maximum height to the left and right of each bar.",
      "Use two pointers to traverse the array efficiently."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A palindromic substring is one that reads the same backward as forward. If there are multiple longest palindromic substrings, return any one of them.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A string s where 1 <= s.length <= 1000.",
    "output_format": "A string representing the longest palindromic substring in s.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only digits and English letters."
    ],
    "examples": [
      {
        "input": "babad",
        "output": "bab",
        "explanation": "Both 'bab' and 'aba' are valid outputs since they are palindromic substrings of maximum length 3."
      },
      {
        "input": "cbbd",
        "output": "bb",
        "explanation": "The longest palindromic substring is 'bb'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding around potential center points.",
      "Check both odd-length and even-length palindromes."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. For example, if the input intervals are [[1,3],[2,6],[8,10],[15,18]], the merged intervals would be [[1,6],[8,10],[15,18]]. There may be other intervals that overlap and should be merged accordingly.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Intervals"
    ],
    "input_format": "A collection of intervals, where each interval is represented as an array of two integers [start, end].",
    "output_format": "A collection of merged intervals, each represented as an array of two integers [start, end].",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Intervals [1,3] and [2,6] overlap, thus they are merged into [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "Intervals [1,4] and [4,5] touch and thus should be merged into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on the start time.",
      "Use a list to keep track of the merged intervals.",
      "Iterate and merge overlapping intervals accordingly."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if the brackets are closed in the correct order. Every opening bracket must have a corresponding closing bracket of the same type.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A string s consisting of parentheses.",
    "output_format": "A boolean indicating whether the parentheses are valid.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses only '()[]{}'"
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The parentheses are correctly closed."
      },
      {
        "input": "s = '([{}])'",
        "output": "true",
        "explanation": "All types of parentheses are correctly closed."
      },
      {
        "input": "s = '(}'",
        "output": "false",
        "explanation": "The closing bracket '}' does not match the opening bracket '('."
      },
      {
        "input": "s = '([)]'",
        "output": "false",
        "explanation": "The order of brackets is incorrect."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a stack to keep track of opening brackets.",
      "Check if the stack is empty at the end."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Kadane's Algorithm"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the largest sum of the contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The contiguous subarray [4,-1,2,1] has the largest sum = 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The only element is 1, so the maximum sum is 1."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The contiguous subarray [5,4,-1,7,8] has the largest sum = 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a variable to store the maximum sum found so far.",
      "Keep track of the current subarray sum while iterating through the array."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "An integer array nums where 0 <= nums.length <= 3000 and -10^5 <= nums[i] <= 10^5.",
    "output_format": "A list of lists of triplets where each triplet sums to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that sum to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no triplets in an empty array."
      },
      {
        "input": "nums = [0, 1, 1]",
        "output": "[]",
        "explanation": "There are no triplets that sum to zero."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array to make it easier to avoid duplicates.",
      "Use two pointers to find pairs that sum to the negative of the current element."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Median"
    ],
    "input_format": "Two sorted arrays nums1 and nums2 where 0 <= m <= 10^6 and 0 <= n <= 10^6.",
    "output_format": "A float representing the median of the two sorted arrays.",
    "constraints": [
      "Both arrays are 0-indexed.",
      "nums1 and nums2 can be of different lengths.",
      "The total number of elements is up to 2 * 10^6."
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.0",
        "explanation": "The combined sorted array is [1, 2, 3]. The median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.5",
        "explanation": "The combined sorted array is [1, 2, 3, 4]. The median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using binary search on the smaller array.",
      "Keep track of partition indices in both arrays to find the median."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. You should return a list of groups, where each group is represented as a list of words that are anagrams of each other.",
    "topic": "String",
    "subtopic": "Sorting",
    "tags": [
      "String",
      "Sorting",
      "Hashmap"
    ],
    "input_format": "An array of strings strs, where 1 <= strs.length <= 10^4 and 1 <= strs[i].length <= 100.",
    "output_format": "A list of lists, where each sublist contains strings that are anagrams of each other.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "1 <= strs[i].length <= 100",
      "All strings in strs are lowercase alphabetical characters."
    ],
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
        "explanation": "The strings 'eat', 'tea', and 'ate' are anagrams. The strings 'tan' and 'nat' are also anagrams."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "There is only one string which is an empty string."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "There is only one string which is 'a'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hashmap to group words by their sorted character sequence.",
      "You can sort each string to find anagrams."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Reverse Nodes in k-Group",
    "description": "Given a linked list, reverse the nodes of the list k at a time and return the modified list. If the number of nodes is not a multiple of k, then leave the last nodes as they are. You may not alter the values in the nodes, only nodes themselves may be changed.",
    "topic": "Linked List",
    "subtopic": "Reversal",
    "tags": [
      "Linked List",
      "Reversal",
      "Two Pointers"
    ],
    "input_format": "A linked list's head node and an integer k.",
    "output_format": "The head node of the modified linked list after reversing nodes in k-sized groups.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 5000].",
      "1 <= k <= 5000"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5], k = 2",
        "output": "[2,1,4,3,5]",
        "explanation": "The first two nodes (1 and 2) are reversed to become (2 and 1), and the next two nodes (3 and 4) become (4 and 3). The last node (5) remains as is."
      },
      {
        "input": "head = [1,2,3], k = 5",
        "output": "[1,2,3]",
        "explanation": "Since k is greater than the number of nodes, no reversal occurs."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider breaking the list into pieces of size k.",
      "Use a dummy node to simplify edge case handling."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Merge Two Sorted Lists",
    "description": "Given the heads of two sorted linked lists, merge them into a single sorted linked list. The new list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
    "topic": "Linked List",
    "subtopic": "Merging Linked Lists",
    "tags": [
      "Linked List",
      "Merge",
      "Sorting"
    ],
    "input_format": "The input consists of two linked lists represented by their heads.",
    "output_format": "A linked list that represents the merged sorted linked list.",
    "constraints": [
      "Both linked lists may contain between 0 and 1000 nodes.",
      "The values of nodes of the linked lists are between -10^4 and 10^4."
    ],
    "examples": [
      {
        "input": "l1 = [1, 2, 4], l2 = [1, 3, 4]",
        "output": "[1, 1, 2, 3, 4, 4]",
        "explanation": "Merging the two lists results in a single sorted list: 1 -> 1 -> 2 -> 3 -> 4 -> 4."
      },
      {
        "input": "l1 = [], l2 = [0]",
        "output": "[0]",
        "explanation": "Since the first list is empty, the merged list is just the elements of the second list."
      },
      {
        "input": "l1 = [], l2 = []",
        "output": "[]",
        "explanation": "Both lists are empty, so the merged list is also empty."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a dummy node to help with the merging process.",
      "Compare the heads of both lists to determine which node to append next."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "Given an integer array nums that is sorted in ascending order and then rotated at some pivot unknown to you beforehand, and an integer target, write a function to search for target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Binary Search",
    "subtopic": "Search in Rotated Array",
    "tags": [
      "Binary Search",
      "Array",
      "Search"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An integer representing the index of target in nums, or -1 if target is not found.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "nums is guaranteed to be rotated at some pivot."
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "The target 0 is found at index 4 in the rotated sorted array."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "The target 3 is not present in the array, so the output is -1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to optimize the search.",
      "Identify the sorted and unsorted halves of the array.",
      "Keep narrowing down the search space based on the target and mid value."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Roman to Integer",
    "description": "Given a string representing a Roman numeral, convert it to an integer. The input string is guaranteed to be within the range from 1 to 3999.",
    "topic": "String",
    "subtopic": "Conversion",
    "tags": [
      "String",
      "Conversion",
      "Roman Numerals"
    ],
    "input_format": "A string s representing the Roman numeral.",
    "output_format": "An integer representing the corresponding integer value of the Roman numeral.",
    "constraints": [
      "1 <= s.length <= 15",
      "s consists of the characters 'I', 'V', 'X', 'L', 'C', 'D', 'M'.",
      "The value of the Roman numeral is between 1 and 3999."
    ],
    "examples": [
      {
        "input": "s = 'III'",
        "output": "3",
        "explanation": "'I' is 1, 'I' is 1, and 'I' is 1. So 1 + 1 + 1 = 3."
      },
      {
        "input": "s = 'LVIII'",
        "output": "58",
        "explanation": "'L' is 50, 'V' is 5, and 'III' is 3. So 50 + 5 + 3 = 58."
      },
      {
        "input": "s = 'MCMXCIV'",
        "output": "1994",
        "explanation": "'M' is 1000, 'CM' is 900, 'XC' is 90, and 'IV' is 4. So 1000 + 900 + 90 + 4 = 1994."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider the rules for subtractive notation in Roman numerals."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order. The spiral order begins at the top-left corner of the matrix and proceeds to the right, then downwards, then to the left, and finally upwards until all elements are traversed.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral"
    ],
    "input_format": "An m x n matrix 'matrix' where 1 <= m, n <= 100.",
    "output_format": "A list of integers representing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= m, n <= 100",
      "-10^4 <= matrix[i][j] <= 10^4"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The elements are traversed in the following order: 1 -> 2 -> 3 -> 6 -> 9 -> 8 -> 7 -> 4 -> 5."
      },
      {
        "input": "matrix = [[1, 2], [3, 4]]",
        "output": "[1, 2, 4, 3]",
        "explanation": "The elements are traversed in the following order: 1 -> 2 -> 4 -> 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use four pointers to easily manage the boundaries of the spiral.",
      "Iterate until the pointers collapse.",
      "Remember to move in four directions: right, down, left, up."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "topic": "Dynamic Programming",
    "subtopic": "Fibonacci Sequence",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Mathematics"
    ],
    "input_format": "An integer n, where n is the number of steps in the staircase.",
    "output_format": "An integer representing the number of distinct ways to reach the top of the staircase.",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: 1 step + 1 step or 2 steps."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top: 1+1+1, 1+2, or 2+1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider breaking down the problem into smaller subproblems.",
      "You can use a recurrence relation to express how to reach the nth step."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Palindrome Number",
    "description": "Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. For example, the integer 121 is a palindrome while 123 is not.",
    "topic": "Mathematics",
    "subtopic": "Number Theory",
    "tags": [
      "Palindrome",
      "Mathematics",
      "Validation"
    ],
    "input_format": "An integer x.",
    "output_format": "Return true if x is a palindrome, otherwise return false.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "121",
        "output": "true",
        "explanation": "121 reads the same backward as forward."
      },
      {
        "input": "-121",
        "output": "false",
        "explanation": "-121 reads 121- which is not the same."
      },
      {
        "input": "10",
        "output": "false",
        "explanation": "10 reads the same as 01 which is not the same."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how to reverse an integer.",
      "Negative numbers are not palindromes.",
      "You may consider converting the integer to a string."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of k linked-lists, each linked-list is sorted in ascending order. Please merge all the linked-lists into one sorted linked-list and return it.",
    "topic": "Linked List",
    "subtopic": "Merging Lists",
    "tags": [
      "Linked List",
      "Sorting",
      "Heap"
    ],
    "input_format": "An array of k linked-lists where each linked-list is represented by its head node.",
    "output_format": "The head node of the merged sorted linked-list.",
    "constraints": [
      "0 <= k <= 10^4",
      "0 <= n <= 500",
      "The total number of nodes in all linked-lists should not exceed 10^4."
    ],
    "examples": [
      {
        "input": "[1->4->5, 1->3->4, 2->6]",
        "output": "1->1->2->3->4->4->5->6",
        "explanation": "Merging the lists yields a sorted order of 1, 1, 2, 3, 4, 4, 5, 6."
      },
      {
        "input": "[]",
        "output": "",
        "explanation": "An empty input results in an empty linked-list."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a min-heap to efficiently get the smallest element from the current lists."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "Given an integer array height where height[i] represents the height of a vertical line at index i, return the maximum amount of water a container can store between two lines. The width of the container is the distance between the two lines, and the amount of water it can hold is determined by the shorter of the two lines.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Geometry"
    ],
    "input_format": "An array of integers height of length n (1 <= n <= 10^5).",
    "output_format": "An integer representing the maximum amount of water that can be stored.",
    "constraints": [
      "2 <= height.length <= 10^5",
      "0 <= height[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The container with lines at index 1 and index 8 can hold 49 units of water."
      },
      {
        "input": "height = [1,1]",
        "output": "1",
        "explanation": "The only container formed between the two lines can hold 1 unit of water."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using two pointers to find the maximum area efficiently.",
      "The area is limited by the shorter line; try maximizing the width as you adjust pointers."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Rotate Image",
    "description": "You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, meaning you have to perform the rotation using only constant space.",
    "topic": "Array",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Array",
      "Matrix",
      "In-Place"
    ],
    "input_format": "An n x n 2D matrix, where 1 <= n <= 20.",
    "output_format": "The 2D matrix after rotating it by 90 degrees clockwise.",
    "constraints": [
      "1 <= matrix.length == matrix[i].length <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]",
        "explanation": "Rotating the matrix clockwise results in this new configuration."
      },
      {
        "input": "matrix = [[ 5, 1, 9,11],[ 2, 4, 8,10],[13, 3, 6, 7],[15,14,12,16]]",
        "output": "[[15,13, 2, 5],[14, 3, 4, 1],[12, 6, 8, 9],[16, 7,10,11]]",
        "explanation": "Rotating the matrix leads to the new arrangement."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider swapping elements in layers.",
      "Use the formulas for calculating corresponding positions in the rotated matrix."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".",
    "topic": "String",
    "subtopic": "Prefix",
    "tags": [
      "String",
      "Prefix",
      "Array"
    ],
    "input_format": "An array of strings, strs, where 1 <= strs.length <= 200 and 0 <= strs[i].length <= 200.",
    "output_format": "A string representing the longest common prefix among the input strings.",
    "constraints": [
      "1 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "All input strings are in lowercase letters a-z."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The longest common prefix is \"fl\"."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among the strings."
      },
      {
        "input": "strs = [\"abcd\", \"abc\", \"ab\"]",
        "output": "\"ab\"",
        "explanation": "The longest common prefix is \"ab\"."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a horizontal scanning approach.",
      "Start by assuming the first string is the common prefix.",
      "Iterate through the remaining strings and update the prefix."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Sort Colors",
    "description": "Given an array containing n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. You must solve this problem without using any library's sort function and in a single pass.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums where each integer represents the color: 0 for red, 1 for white, and 2 for blue.",
    "output_format": "The sorted array of integers in-place with colors ordered as red (0), white (1), and blue (2).",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 300",
      "nums[i] is either 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "nums = [2,0,2,1,1,0]",
        "output": "[0,0,1,1,2,2]",
        "explanation": "After sorting, the array will have all 0's followed by all 1's, and then all 2's."
      },
      {
        "input": "nums = [2,0,1]",
        "output": "[0,1,2]",
        "explanation": "The sorted array places the red (0) first, followed by white (1) and blue (2)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "You can use the Dutch national flag algorithm for this problem.",
      "Consider maintaining three pointers for 0s, 1s, and 2s."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array",
    "description": "Given a sorted array nums, remove the duplicates in-place such that each element appears only once and return the new length of the array. Do not allocate extra space for another array. You must do this by modifying the input array in-place.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-Place"
    ],
    "input_format": "A sorted integer array nums.",
    "output_format": "An integer representing the new length of the array after removing duplicates.",
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "2",
        "explanation": "After removing duplicates, the array will be [1, 2], and the length is 2."
      },
      {
        "input": "nums = [0, 0, 1, 1, 2, 2, 3, 3, 4]",
        "output": "5",
        "explanation": "After removing duplicates, the array will be [0, 1, 2, 3, 4], and the length is 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to track the unique elements.",
      "Consider modifying the array in-place for optimal space usage."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Reverse Integer",
    "description": "Given a 32-bit signed integer, reverse the digits of the integer. You need to handle overflow conditions when reversing the integer. If the reversed integer overflows, return 0.",
    "topic": "Mathematics",
    "subtopic": "Integer Manipulation",
    "tags": [
      "Integer",
      "Math",
      "String Manipulation"
    ],
    "input_format": "A single integer x, where -2^31 <= x <= 2^31 - 1.",
    "output_format": "An integer representing the reversed digits of the input integer.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 123",
        "output": "321",
        "explanation": "The integer 123 reversed is 321."
      },
      {
        "input": "x = -123",
        "output": "-321",
        "explanation": "The integer -123 reversed is -321."
      },
      {
        "input": "x = 120",
        "output": "21",
        "explanation": "The integer 120 reversed is 21 (leading zeros are dropped)."
      },
      {
        "input": "x = 1534236469",
        "output": "0",
        "explanation": "The reversed integer overflows the 32-bit signed integer range, so we return 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to handle negative numbers.",
      "Use modulo and division to extract digits.",
      "Watch out for overflow when reversing."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Letter Combinations of a Phone Number",
    "description": "Given a string containing digits from 2-9, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. For example, the digit 2 maps to 'abc', the digit 3 maps to 'def', and so on.",
    "topic": "Backtracking",
    "subtopic": "Combinatorial Generation",
    "tags": [
      "Backtracking",
      "String",
      "Combinations"
    ],
    "input_format": "A string digits representing the dialed numbers, where '2' to '9' are valid inputs.",
    "output_format": "A list of strings representing all the possible letter combinations.",
    "constraints": [
      "0 <= digits.length <= 4",
      "digits[i] is a digit from '2' to '9'."
    ],
    "examples": [
      {
        "input": "digits = \"23\"",
        "output": "[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]",
        "explanation": "The digit 2 maps to ['a', 'b', 'c'] and the digit 3 maps to ['d', 'e', 'f']. The combinations are all the pairs formed by picking one character from the first set and one from the second."
      },
      {
        "input": "digits = \"\"",
        "output": "[]",
        "explanation": "An empty input returns an empty list."
      },
      {
        "input": "digits = \"2\"",
        "output": "[\"a\", \"b\", \"c\"]",
        "explanation": "The digit 2 maps to ['a', 'b', 'c']. Thus, the output includes all three letters."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a backtracking approach to build combinations.",
      "Map each digit to its corresponding character set beforehand."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Set Matrix Zeroes",
    "description": "Given a m x n matrix, if an element is 0, set its entire row and column to 0. You must do it in place. Do not use extra space for another matrix.",
    "topic": "Array",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Array",
      "Matrix",
      "In-place"
    ],
    "input_format": "A 2D array of integers matrix.",
    "output_format": "The modified input matrix with rows and columns set to zero.",
    "constraints": [
      "1 <= m, n <= 200",
      "-10^9 <= matrix[i][j] <= 10^9"
    ],
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": "The element at matrix[1][1] is 0, so the entire second row and second column are set to 0."
      },
      {
        "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
        "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
        "explanation": "The first row and last column contain 0, which sets the entire first row and last column to 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use first row and first column as markers.",
      "Iterate from the end of the matrix to avoid overwriting values."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Word Search",
    "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where 'adjacent' cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "topic": "Backtracking",
    "subtopic": "Depth-First Search",
    "tags": [
      "Backtracking",
      "DFS",
      "Matrix"
    ],
    "input_format": "A 2D grid of characters and a string representing the word.",
    "output_format": "A boolean value indicating whether the word exists in the grid.",
    "constraints": [
      "1 <= board.length, board[i].length <= 6",
      "1 <= word.length <= 15",
      "board[i][j] is a lowercase English letter."
    ],
    "examples": [
      {
        "input": "board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'ABCCED'",
        "output": "true",
        "explanation": "'ABCCED' can be constructed from the grid."
      },
      {
        "input": "board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'SEE'",
        "output": "true",
        "explanation": "'SEE' can be constructed from the grid."
      },
      {
        "input": "board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'ABCB'",
        "output": "false",
        "explanation": "'ABCB' cannot be constructed as the 'B' cannot be reused."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using depth-first search (DFS) to explore all paths.",
      "Keep track of visited cells to avoid using them more than once."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Generate Parentheses",
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
    "topic": "Backtracking",
    "subtopic": "Combinations",
    "tags": [
      "Backtracking",
      "Recursion",
      "String"
    ],
    "input_format": "An integer n representing the number of pairs of parentheses.",
    "output_format": "A list of strings representing all combinations of well-formed parentheses.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]",
        "explanation": "These are the five valid combinations of 3 pairs of parentheses."
      },
      {
        "input": "n = 1",
        "output": "[\"()\"]",
        "explanation": "There is only one valid combination for a single pair of parentheses."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use backtracking to explore all possibilities.",
      "Maintain a count of open and close parentheses."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Jump Game",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to determine if you can reach the last index starting from the first index. You can assume that you can always reach the last index if you can jump beyond the last index.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "A boolean value indicating whether you can reach the last index.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "true",
        "explanation": "You can jump 2 steps from index 0 to index 2, then jump 2 more steps to reach the last index."
      },
      {
        "input": "nums = [3, 2, 1, 0, 4]",
        "output": "false",
        "explanation": "You will always be stuck at index 3 because you cannot make any further jumps."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the maximum reachable index at each point.",
      "Use a greedy approach to track the farthest you can reach."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Next Permutation",
    "description": "Implement the next permutation algorithm, which rearranges the numbers into the lexicographically next greater permutation of its numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order). The replacement must be in place and use only constant extra memory.",
    "topic": "Array",
    "subtopic": "Permutation",
    "tags": [
      "Array",
      "Permutation",
      "In-place"
    ],
    "input_format": "An array of integers nums representing the current permutation.",
    "output_format": "The array nums modified to represent the next permutation.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[1, 3, 2]",
        "explanation": "The next permutation of [1, 2, 3] is [1, 3, 2]."
      },
      {
        "input": "nums = [3, 2, 1]",
        "output": "[1, 2, 3]",
        "explanation": "There is no greater permutation for [3, 2, 1], so it is rearranged to the lowest possible order [1, 2, 3]."
      },
      {
        "input": "nums = [1, 1, 5]",
        "output": "[1, 5, 1]",
        "explanation": "The next permutation for [1, 1, 5] is [1, 5, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Find the first pair of two successive elements (from the end) where the earlier element is smaller than the later one.",
      "Find the smallest element on the right side of the found element which is larger than it.",
      "Swap the two elements and reverse the sequence after the original position of the smaller element."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Binary Tree Zigzag Level Order Traversal",
    "description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "BFS",
      "DFS"
    ],
    "input_format": "The input consists of the root node of a binary tree.",
    "output_format": "A list of lists of integers where each list contains the values of nodes at that level in zigzag order.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[20,9],[15,7]]",
        "explanation": "The first level is [3]. The second level is [20, 9] (right to left). The third level is [15, 7] (left to right)."
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": "The only level consists of [1]."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree results in an empty list."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to perform level order traversal.",
      "Keep track of the current level to determine the order of traversal.",
      "You may need to reverse the list of values at every alternate level."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Remove Element",
    "description": "Given an array nums and a value val, you need to remove all instances of that value in-place and return the new length of the array. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length.",
    "topic": "Array",
    "subtopic": "In-place Modification",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An array of integers nums followed by an integer val.",
    "output_format": "An integer representing the new length of the array after removing all instances of val.",
    "constraints": [
      "0 <= nums.length <= 100",
      "0 <= nums[i] <= 50",
      "0 <= val <= 50"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 2, 3], val = 3",
        "output": "2",
        "explanation": "After removing the elements equal to 3, the array becomes [2, 2] and its length is 2."
      },
      {
        "input": "nums = [0, 1, 2, 2, 3, 0, 4, 2], val = 2",
        "output": "5",
        "explanation": "After removing the elements equal to 2, the array becomes [0, 1, 3, 0, 4] with length 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers to solve the problem efficiently.",
      "You can overwrite elements in the array when you encounter the value to be removed."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Minimum Path Sum",
    "description": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of the numbers along the path. You can only move either down or right at any point in time.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Minimum Path"
    ],
    "input_format": "A 2D array of integers grid, where grid[i][j] represents the non-negative integer at the cell.",
    "output_format": "An integer representing the minimum path sum from the top left to the bottom right.",
    "constraints": [
      "1 <= m, n <= 200",
      "0 <= grid[i][j] <= 100"
    ],
    "examples": [
      {
        "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7",
        "explanation": "The path 1 \u2192 3 \u2192 1 \u2192 1 minimizes the sum: 1 + 3 + 1 + 2 = 7."
      },
      {
        "input": "grid = [[1,2,3],[4,5,6]]",
        "output": "12",
        "explanation": "The path 1 \u2192 2 \u2192 3 \u2192 6 minimizes the sum: 1 + 2 + 3 + 6 = 12."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store minimum path sums.",
      "Start from the bottom right cell and work your way to the top left."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Validate Binary Search Tree",
    "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: 1. The left subtree of a node contains only nodes with keys less than the node's key. 2. The right subtree of a node contains only nodes with keys greater than the node's key. 3. Both the left and right subtrees must also be binary search trees.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "BST",
      "Recursion"
    ],
    "input_format": "The input is the root of a binary tree.",
    "output_format": "Return true if the tree is a valid BST, or false otherwise.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "Each node's value is in the range [-10^4, 10^4]."
    ],
    "examples": [
      {
        "input": "[2, 1, 3]",
        "output": "true",
        "explanation": "The given tree is a valid binary search tree."
      },
      {
        "input": "[5, 1, 4, null, null, 3, 6]",
        "output": "false",
        "explanation": "The given tree is not a valid binary search tree because the node with value 3 is in the right subtree of the node with value 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use recursion to traverse the tree.",
      "Keep track of the valid range for each node."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Find the Index of the First Occurrence in a String",
    "description": "Given two strings 'haystack' and 'needle', return the index of the first occurrence of 'needle' in 'haystack', or -1 if 'needle' is not part of 'haystack'.",
    "topic": "String",
    "subtopic": "String Search",
    "tags": [
      "String",
      "Searching",
      "Two Pointers"
    ],
    "input_format": "Two strings, 'haystack' and 'needle'.",
    "output_format": "An integer representing the index of the first occurrence or -1.",
    "constraints": [
      "1 <= haystack.length <= 10^4",
      "0 <= needle.length <= 10^4"
    ],
    "examples": [
      {
        "input": "haystack = 'hello', needle = 'll'",
        "output": "2",
        "explanation": "'ll' first occurs at index 2 in 'hello'."
      },
      {
        "input": "haystack = 'aaaaa', needle = 'b'",
        "output": "-1",
        "explanation": "'b' is not part of 'aaaaa'."
      },
      {
        "input": "haystack = '', needle = ''",
        "output": "0",
        "explanation": "An empty needle is found at the start of an empty haystack."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using the built-in method for substring search.",
      "Think about edge cases involving empty strings."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array nums, return the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses constant extra space.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Positive Integers"
    ],
    "input_format": "An unsorted array of integers nums.",
    "output_format": "An integer representing the smallest missing positive integer.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^6 <= nums[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [3, 4, -1, 1]",
        "output": "2",
        "explanation": "The smallest missing positive integer is 2."
      },
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "The smallest missing positive integer is 3."
      },
      {
        "input": "nums = [7, 8, 9, 11, 12]",
        "output": "1",
        "explanation": "The smallest missing positive integer is 1."
      },
      {
        "input": "nums = [1, 2, 3]",
        "output": "4",
        "explanation": "The smallest missing positive integer is 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using the index of the array to track the missing positive.",
      "Swap elements to their correct positions if they are in the range.",
      "Remember that the answer must be a positive integer."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Jump Game II",
    "description": "You are given an array of non-negative integers `nums`. Each element in the array represents the maximum jump length at that position. Your goal is to reach the last index of the array using the minimum number of jumps. Write a function to determine the minimum number of jumps needed to reach the end of the array.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithms",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "An integer representing the minimum number of jumps to reach the last index.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "2",
        "explanation": "Jump 1 step from index 0 to 1, then jump 3 steps to the last index."
      },
      {
        "input": "nums = [2, 3, 0, 1, 4]",
        "output": "2",
        "explanation": "Jump 1 step from index 0 to 1, then jump 3 steps to the last index."
      },
      {
        "input": "nums = [0]",
        "output": "0",
        "explanation": "Already at the last index."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "You can reach index i by jumping from index j if j + nums[j] >= i.",
      "Consider the farthest reachable index at each step."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Permutations",
    "description": "Given an array of distinct integers, return all possible permutations of the array. You can return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Permutations",
      "Array"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "A list of lists, where each list is a permutation of the input array.",
    "constraints": [
      "1 <= nums.length <= 6",
      "-10 <= nums[i] <= 10",
      "All integers in nums are distinct."
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": "The permutations of the array [1, 2, 3] are all the possible arrangements of these three numbers."
      },
      {
        "input": "nums = [0, 1]",
        "output": "[[0,1],[1,0]]",
        "explanation": "The permutations of the array [0, 1] are [0, 1] and [1, 0]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a backtracking approach to generate all permutations.",
      "Consider using a helper function that takes the current state of permutations."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Combination Sum",
    "description": "Given an array of distinct integers candidates and a target integer target, return all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.",
    "topic": "Backtracking",
    "subtopic": "Combination Sum",
    "tags": [
      "Backtracking",
      "Recursion",
      "Combination"
    ],
    "input_format": "An array of distinct integers candidates and an integer target.",
    "output_format": "A list of lists of integers representing all unique combinations that sum to target.",
    "constraints": [
      "1 <= candidates.length <= 30",
      "1 <= candidates[i] <= 200",
      "All elements of candidates are distinct.",
      "1 <= target <= 500"
    ],
    "examples": [
      {
        "input": "candidates = [2, 3, 6, 7], target = 7",
        "output": "[[2, 2, 3], [7]]",
        "explanation": "The combinations that sum to 7 are [2, 2, 3] and [7]."
      },
      {
        "input": "candidates = [1], target = 2",
        "output": "[[1, 1]]",
        "explanation": "The only combination that sums to 2 is [1, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion to explore each candidate.",
      "You can reuse candidates in the same combination.",
      "Make sure to skip duplicates when necessary."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Largest Rectangle in Histogram",
    "description": "Given an array of integers representing the heights of bars in a histogram, return the area of the largest rectangle that can be formed in the histogram. Each bar's width is considered to be 1 unit. The area of a rectangle is calculated as width * height.",
    "topic": "Array",
    "subtopic": "Stack",
    "tags": [
      "Array",
      "Stack",
      "Geometry"
    ],
    "input_format": "An array of integers heights, where heights[i] represents the height of the ith bar.",
    "output_format": "An integer representing the area of the largest rectangle.",
    "constraints": [
      "1 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [2, 1, 5, 6, 2, 3]",
        "output": "10",
        "explanation": "The largest rectangle has a height of 5 and spans 2 units from index 2 to index 3, giving an area of 5 * 2 = 10."
      },
      {
        "input": "heights = [2, 4]",
        "output": "4",
        "explanation": "The largest rectangle has a height of 2 and spans 2 units from index 0 to index 1, giving an area of 2 * 2 = 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to keep track of bar indices.",
      "When a bar is shorter than the bar at the top of the stack, calculate areas for rectangles formed.",
      "Don't forget to process all remaining bars in the stack after iterating through the array."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Find First and Last Position of Element in Sorted Array",
    "description": "Given an array of integers sorted in non-decreasing order, find the starting and ending position of a given target value. If the target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Searching"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "A list of two integers representing the starting and ending position of the target in the array.",
    "constraints": [
      "0 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9",
      "The array is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 8",
        "output": "[3, 4]",
        "explanation": "The target 8 appears at indices 3 and 4."
      },
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 6",
        "output": "[-1, -1]",
        "explanation": "The target 6 is not found in the array."
      },
      {
        "input": "nums = [], target = 0",
        "output": "[-1, -1]",
        "explanation": "The array is empty, so the target cannot be found."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to find the first and last positions.",
      "You can modify the binary search to find the leftmost and rightmost indices."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Swap Nodes in Pairs",
    "description": "Given a linked list, swap every two adjacent nodes and return its head. You must do this in one pass without using any extra space. For example, given the linked list 1 -> 2 -> 3 -> 4, you should return the new head of the list, which would be 2 -> 1 -> 4 -> 3.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "Linked List",
      "Swap",
      "In-place"
    ],
    "input_format": "A linked list where each node contains an integer value.",
    "output_format": "The head of the modified linked list after swapping every two adjacent nodes.",
    "constraints": [
      "The number of nodes in the linked list is in the range [0, 100].",
      "0 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4]",
        "output": "[2, 1, 4, 3]",
        "explanation": "Swapping adjacent nodes gives us the linked list 2 -> 1 -> 4 -> 3."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "An empty list remains empty."
      },
      {
        "input": "head = [1]",
        "output": "[1]",
        "explanation": "A single node list remains unchanged."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dummy node to simplify edge cases.",
      "Think about how you can use pointers to keep track of pairs while swapping."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Regular Expression Matching",
    "description": "Implement a function that checks if a given string matches a specified pattern using regular expressions. You need to support the '.' and '*' special characters. The '.' character matches any single character, while the '*' character matches zero or more of the preceding element.",
    "topic": "Dynamic Programming",
    "subtopic": "String Matching",
    "tags": [
      "Dynamic Programming",
      "String",
      "Matching"
    ],
    "input_format": "Two strings: 's' (the input string) and 'p' (the pattern string).",
    "output_format": "A boolean value indicating whether the string 's' matches the pattern 'p'.",
    "constraints": [
      "1 <= s.length, p.length <= 20",
      "s consists of lowercase English letters.",
      "p consists of lowercase English letters, '.' and '*'"
    ],
    "examples": [
      {
        "input": "s = 'aa', p = 'a'",
        "output": "false",
        "explanation": "The pattern 'a' does not match the string 'aa'."
      },
      {
        "input": "s = 'aa', p = 'a*'",
        "output": "true",
        "explanation": "The pattern 'a*' matches 'aa' as '*' allows for zero or more occurrences of 'a'."
      },
      {
        "input": "s = 'ab', p = '.*'",
        "output": "true",
        "explanation": "The pattern '.*' can match any string, including 'ab'."
      },
      {
        "input": "s = 'aab', p = 'c*a*b'",
        "output": "true",
        "explanation": "The pattern 'c*a*b' matches 'aab' with 'c*' treating 'c' as 0 occurrences."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to keep track of the matches.",
      "Handle the '*' character carefully to consider both its presence and absence."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "4Sum",
    "description": "Given an array of integers nums and an integer target, return all unique quadruplets (a, b, c, d) such that a + b + c + d = target. You may return the answer in any order. Each quadruplet should be sorted in ascending order, and the final list should not contain duplicate quadruplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Backtracking"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "A list of unique quadruplets that sum to the target.",
    "constraints": [
      "0 <= nums.length <= 200",
      "-10^9 <= nums[i] <= 10^9",
      "The solution set must not contain duplicate quadruplets."
    ],
    "examples": [
      {
        "input": "nums = [1,0,-1,0,-2,2], target = 0",
        "output": "[[-2,-1,0,1],[-2,0,0,2],[-1,0,0,1]]",
        "explanation": "The unique quadruplets that sum to zero are [-2,-1,0,1], [-2,0,0,2], and [-1,0,0,1]."
      },
      {
        "input": "nums = [2,2,2,2,2], target = 8",
        "output": "[[2,2,2,2]]",
        "explanation": "The only unique quadruplet that sums to eight is [2,2,2,2]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using sorting to handle duplicates.",
      "Use two pointers approach for optimized searching."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Subsets",
    "description": "Given an integer array nums, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.",
    "topic": "Backtracking",
    "subtopic": "Generating Subsets",
    "tags": [
      "Backtracking",
      "Subset",
      "Recursion"
    ],
    "input_format": "An array of integers nums where each element is unique.",
    "output_format": "A list of lists containing all possible subsets.",
    "constraints": [
      "1 <= nums.length <= 10",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]",
        "explanation": "All possible subsets of [1, 2, 3] are generated."
      },
      {
        "input": "nums = [0]",
        "output": "[[], [0]]",
        "explanation": "The only subsets of [0] are the empty set and the set containing 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how you can build subsets by including or excluding each number.",
      "Use recursion to explore both including and not including each element."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Search Insert Position",
    "description": "Given a sorted array of distinct integers and a target value, determine the index at which the target should be inserted to maintain the sorted order. If the target exists in the array, return its index.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Searching"
    ],
    "input_format": "A sorted array of distinct integers nums and an integer target.",
    "output_format": "An integer representing the index where the target should be inserted.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "All elements of nums are distinct."
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 5, 6], target = 5",
        "output": "2",
        "explanation": "The target 5 is found at index 2."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 2",
        "output": "1",
        "explanation": "The target 2 should be inserted at index 1 to maintain sorted order."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 7",
        "output": "4",
        "explanation": "The target 7 is greater than all elements and should be inserted at the end (index 4)."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 0",
        "output": "0",
        "explanation": "The target 0 is less than all elements and should be inserted at index 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using binary search to find the target's position efficiently.",
      "If the target is not found, the insertion index is where the search ends."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Unique Paths",
    "description": "A robot is located at the top-left corner of a m x n grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. How many unique paths are there for the robot to reach the bottom-right corner?",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Paths",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Recursion"
    ],
    "input_format": "Two integers m and n representing the number of rows and columns in the grid.",
    "output_format": "An integer representing the number of unique paths to reach the bottom-right corner.",
    "constraints": [
      "1 <= m, n <= 100"
    ],
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": "There are 28 unique paths from the top-left corner to the bottom-right corner."
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "There are 3 unique paths to go from the top-left to the bottom-right."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store intermediate results.",
      "Use a 2D array to store the number of ways to reach each cell."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Integer to Roman",
    "description": "Given an integer, convert it to a Roman numeral. The Roman numeral system uses letters from the Latin alphabet: I, V, X, L, C, D, M to represent numbers. For example, 1 is represented as 'I', 2 as 'II', and 3 as 'III'. The number 4 is represented as 'IV', because the numeral for 1 is before the numeral for 5, which means you subtract it. The same principle applies to 9, which is represented as 'IX'. This makes the number 8 'VIII'. Numbers are formed by combining letters and adding the values, for example, 58 is 'LVIII', which is '50' (L) + '5' (V) + '3' (III). Input is guaranteed to be within the range from 1 to 3999.",
    "topic": "Math",
    "subtopic": "Conversion",
    "tags": [
      "Math",
      "Conversion",
      "Strings"
    ],
    "input_format": "An integer n representing the number to be converted (1 <= n <= 3999).",
    "output_format": "A string representing the Roman numeral equivalent of the integer.",
    "constraints": [
      "1 <= n <= 3999"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "III",
        "explanation": "The integer 3 is represented as 'III' in Roman numerals."
      },
      {
        "input": "n = 4",
        "output": "IV",
        "explanation": "The integer 4 is represented as 'IV' in Roman numerals."
      },
      {
        "input": "n = 58",
        "output": "LVIII",
        "explanation": "The integer 58 is represented as 'LVIII', which comprises '50' (L) + '5' (V) + '3' (III)."
      },
      {
        "input": "n = 1994",
        "output": "MCMXCIV",
        "explanation": "The integer 1994 is represented as 'MCMXCIV'. It is composed of '1000' (M) + '900' (CM) + '90' (XC) + '4' (IV)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a mapping of Roman numerals to integers.",
      "Iterate through the integer and build the Roman numeral based on the mappings."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Pow(x, n)",
    "description": "Implement a function that calculates x raised to the power n (x^n). This function must handle both positive and negative integers for n, and you should not use built-in power functions or libraries.",
    "topic": "Mathematics",
    "subtopic": "Exponentiation",
    "tags": [
      "Math",
      "Recursion",
      "Exponentiation"
    ],
    "input_format": "Two integers x and n where x is the base and n is the exponent.",
    "output_format": "A float representing the result of x raised to the power of n.",
    "constraints": [
      "-100.0 <= x <= 100.0",
      "-2^31 <= n <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 2, n = 10",
        "output": "1024.0",
        "explanation": "2 raised to the power of 10 is 1024."
      },
      {
        "input": "x = 2, n = -2",
        "output": "0.25",
        "explanation": "2 raised to the power of -2 is 1/(2^2) = 1/4 = 0.25."
      },
      {
        "input": "x = 0, n = 5",
        "output": "0.0",
        "explanation": "0 raised to any positive power is 0."
      },
      {
        "input": "x = 5, n = 0",
        "output": "1.0",
        "explanation": "Any number raised to the power of 0 is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the properties of powers when n is negative.",
      "You can use recursion to simplify the problem."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Search a 2D Matrix",
    "description": "Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the properties: Integers in each row are sorted in ascending from left to right, and integers in each column are sorted in ascending from top to bottom. Write a function that returns true if the value exists in the matrix and false otherwise.",
    "topic": "Matrix",
    "subtopic": "Binary Search",
    "tags": [
      "Matrix",
      "Binary Search",
      "Search"
    ],
    "input_format": "A 2D matrix represented as a list of lists and an integer target.",
    "output_format": "A boolean value indicating whether the target exists in the matrix.",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 100",
      "-10^4 <= matrix[i][j], target <= 10^4"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [12, 14, 16]], target = 9",
        "output": "true",
        "explanation": "9 is found at position (1, 1) in the matrix."
      },
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 10",
        "output": "false",
        "explanation": "10 is not present in the matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how you can leverage the properties of the matrix's ordering.",
      "Think about using binary search."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Simplify Path",
    "description": "Given a string representing an absolute path for a file or directory in a Unix-like file system, simplify it. The path may contain multiple slashes '//' which are to be treated as a single slash, and it may contain special elements like '.' to refer to the current directory and '..' to refer to the parent directory. Your task is to return the simplified path as a string.",
    "topic": "String",
    "subtopic": "Path Manipulation",
    "tags": [
      "String",
      "Path",
      "Manipulation"
    ],
    "input_format": "A single string path, which is a valid absolute path in the Unix file system.",
    "output_format": "A string representing the simplified canonical path.",
    "constraints": [
      "1 <= path.length <= 3000",
      "path consists of English letters, digits, '/', '.', and '..'.",
      "The input path is guaranteed to be a valid absolute path."
    ],
    "examples": [
      {
        "input": "/a/./b/../../c/",
        "output": "/c",
        "explanation": "The path goes to 'a', then to 'b', then back to the parent directory which leaves 'a', and then goes to 'c'."
      },
      {
        "input": "/../",
        "output": "/",
        "explanation": "Since we are at the root directory, moving to '.' or '..' will still keep us at root."
      },
      {
        "input": "/home//user/../docs/../uploads//./file.txt",
        "output": "/home/uploads/file.txt",
        "explanation": "The path simplifies by resolving '..' and removing extra slashes."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to keep track of the directories.",
      "Pop the stack when encountering '..' and push the current directory when encountering a valid directory name."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Valid Sudoku",
    "description": "Determine if a 9x9 Sudoku board is valid according to the rules of Sudoku. The Sudoku board can be partially filled, where empty cells are represented by the character '.' for convenience. A valid Sudoku board must satisfy the following conditions: Each row must contain the digits 1-9 without repetition, each column must contain the digits 1-9 without repetition, and each of the nine 3x3 sub-boxes of the grid must also contain the digits 1-9 without repetition.",
    "topic": "Game Theory",
    "subtopic": "Validation",
    "tags": [
      "Array",
      "Hash Table",
      "Matrix"
    ],
    "input_format": "A 2D array representing the Sudoku board, where each element is a character (1-9 or '.')",
    "output_format": "A boolean value, true if the Sudoku board is valid, false otherwise.",
    "constraints": [
      "The board is a 9x9 array.",
      "Each cell contains either a digit (1-9) or '.'."
    ],
    "examples": [
      {
        "input": [
          [
            "5",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            "2",
            "8",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": "true",
        "explanation": "All rows, columns, and 3x3 sub-boxes contain unique numbers between 1-9, thus the board is valid."
      },
      {
        "input": [
          [
            "8",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            "2",
            "8",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": "false",
        "explanation": "The number '8' appears twice in the first column, hence the board is invalid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use sets to track the numbers in each row, column, and sub-box.",
      "Check for duplicates while iterating through the board."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Binary Tree Inorder Traversal",
    "description": "Given a binary tree, return the nodes' values in inorder traversal. Inorder traversal means you visit the left subtree first, then the node, and finally the right subtree.",
    "topic": "Tree",
    "subtopic": "Traversal",
    "tags": [
      "Tree",
      "Traversal",
      "Binary Tree"
    ],
    "input_format": "The root of a binary tree.",
    "output_format": "An array of integers representing the values of nodes in inorder traversal.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100]",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[1,3,2]",
        "explanation": "The inorder traversal of the tree is 1, 3, 2."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree results in an empty inorder traversal."
      },
      {
        "input": "root = [1]",
        "output": "[1]",
        "explanation": "A single node tree's inorder traversal is the node itself."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a recursive function to traverse the left subtree, visit the node, then traverse the right subtree."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Binary Tree Level Order Traversal",
    "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "BFS",
      "Traversal"
    ],
    "input_format": "A binary tree node represented as a root node.",
    "output_format": "A list of lists, where each sublist contains the values of the nodes at that level.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [3, 9, 20, null, null, 15, 7]",
        "output": "[[3], [9, 20], [15, 7]]",
        "explanation": "Level 0 has 1 node with value 3. Level 1 has 2 nodes with values 9 and 20. Level 2 has 2 nodes with values 15 and 7."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "The tree is empty, hence the output is an empty list."
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": "There is only one node in the tree, which is level 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to help with level order traversal.",
      "Make sure to track the number of nodes at each level."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Edit Distance",
    "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 into word2. The allowed operations are insertion, deletion, or substitution of a single character.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "Strings",
      "Recursion"
    ],
    "input_format": "Two strings word1 and word2, where 0 <= word1.length, word2.length <= 500.",
    "output_format": "An integer representing the minimum number of operations required.",
    "constraints": [
      "0 <= word1.length, word2.length <= 500",
      "word1 and word2 consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "word1 = 'horse', word2 = 'ros'",
        "output": "3",
        "explanation": "The operations are: 'horse' -> 'ros' (horse -> rorse by removing 'h', rorse -> rose by replacing 'r' with 'e', and rose -> ros by removing 'e')."
      },
      {
        "input": "word1 = 'intention', word2 = 'execution'",
        "output": "5",
        "explanation": "The operations are: 'intention' -> 'invention' -> 'invenction' -> 'invections' -> 'executing' -> 'execution'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to keep track of the minimum edits.",
      "Use a 2D table to store intermediate results.",
      "Think about base cases where one of the strings is empty."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Remove Nth Node From End of List",
    "description": "Given the head of a singly linked list, remove the N-th node from the end of the list and return its head. The list can be assumed to be non-empty and N will always be valid.",
    "topic": "Linked List",
    "subtopic": "Two Pointers",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Removal"
    ],
    "input_format": "A singly linked list represented by the head node and an integer N.",
    "output_format": "The head of the linked list after removing the N-th node from the end.",
    "constraints": [
      "The number of nodes in the list is in the range [1, 30].",
      "1 <= N <= the number of nodes in the list."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], N = 2",
        "output": "[1, 2, 3, 5]",
        "explanation": "Removing the 2nd node from the end, which is '4', results in the list [1, 2, 3, 5]."
      },
      {
        "input": "head = [1], N = 1",
        "output": "[]",
        "explanation": "Removing the only node results in an empty list."
      },
      {
        "input": "head = [1, 2], N = 1",
        "output": "[1]",
        "explanation": "Removing the last node '2' from the end results in the list [1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use two pointers to find the node to remove.",
      "First pointer can be N steps ahead of the second pointer."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Divide Two Integers",
    "description": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator. The integer division should truncate toward zero, returning the quotient. Handle edge cases such as overflow conditions.",
    "topic": "Math",
    "subtopic": "Bit Manipulation",
    "tags": [
      "Math",
      "Bit Manipulation",
      "Division"
    ],
    "input_format": "Two integers, dividend and divisor (-2^31 <= dividend, divisor <= 2^31 - 1; divisor != 0).",
    "output_format": "An integer which is the result of the division, truncated toward zero.",
    "constraints": [
      "-2^31 <= dividend, divisor <= 2^31 - 1",
      "divisor != 0"
    ],
    "examples": [
      {
        "input": "dividend = 10, divisor = 3",
        "output": "3",
        "explanation": "10 divided by 3 is 3.333... but returns 3 when truncated."
      },
      {
        "input": "dividend = 7, divisor = -3",
        "output": "-2",
        "explanation": "7 divided by -3 is -2.333... which returns -2 when truncated."
      },
      {
        "input": "dividend = 0, divisor = 1",
        "output": "0",
        "explanation": "0 divided by any non-zero number is 0."
      },
      {
        "input": "dividend = 1, divisor = 1",
        "output": "1",
        "explanation": "1 divided by 1 is 1."
      },
      {
        "input": "dividend = -1, divisor = -1",
        "output": "1",
        "explanation": "-1 divided by -1 is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use bit manipulation for efficient division.",
      "Consider handling edge cases carefully."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Sudoku Solver",
    "description": "Implement a function that solves a partially filled 9x9 Sudoku board by filling in the empty cells. A Sudoku board is valid if the following conditions hold true: each row must contain the digits 1-9 without repetition, each column must also contain the digits 1-9 without repetition, and each of the nine 3x3 sub-boxes of the grid must also contain the digits 1-9 without repetition. An empty cell is represented by the character '.' and can be filled with any digit from '1' to '9'. The function should modify the board in-place and not return anything.",
    "topic": "Backtracking",
    "subtopic": "Grid Traversal",
    "tags": [
      "Backtracking",
      "Grid",
      "Sudoku"
    ],
    "input_format": "A 2D array of characters representing the Sudoku board.",
    "output_format": "The modified 2D array representing the solved Sudoku board.",
    "constraints": [
      "The board is guaranteed to be a valid Sudoku board.",
      "The input will contain only '.' for empty cells and '1' to '9' for filled cells."
    ],
    "examples": [
      {
        "input": "[['5','3','.','.','7','.','.','.','.'], ['6','.','.','1','9','5','.','.','.'], ['.','9','8','.','.','.','.','6','.'], ['8','.','.','.','6','.','.','.','3'], ['4','.','9','.','.','1','8','.','.'), ['7','.','.','8','.','4','.','.','2'], ['.','6','.','.','.','2','9','.','.'], ['.','.','.','4','1','9','.','.','5'], ['.','.','.','.','8','.','.','7','9']]",
        "output": "[['5','3','4','6','7','8','9','1','2'], ['6','7','2','1','9','5','3','4','8'], ['1','9','8','3','4','2','5','6','7'], ['8','5','9','7','6','1','4','2','3'], ['4','2','6','8','5','3','7','9','1'], ['7','1','3','9','2','4','8','5','6'], ['9','6','1','5','3','7','2','8','4'], ['2','8','7','4','1','9','6','3','5'], ['3','4','5','2','8','6','1','7','9']]",
        "explanation": "The empty cells are filled according to the Sudoku rules, resulting in a completely filled valid board."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using backtracking to try different numbers in empty cells.",
      "Make sure to check whether placing a number violates Sudoku rules."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Decode Ways",
    "description": "A message containing letters from A-Z can be encoded into numbers using a simple mapping: 'A' -> '1', 'B' -> '2', ..., 'Z' -> '26'. Given a string s consisting of digits, determine the total number of ways to decode it. For example, '12' can be decoded as 'AB' (1 2) or 'L' (12). Return the number of possible decodings of the input string.",
    "topic": "Dynamic Programming",
    "subtopic": "String Decoding",
    "tags": [
      "Dynamic Programming",
      "String",
      "Recursion"
    ],
    "input_format": "A string s representing the encoded message consisting of digits.",
    "output_format": "An integer representing the total number of ways to decode the input string.",
    "constraints": [
      "1 <= s.length <= 100",
      "s[i] is a digit."
    ],
    "examples": [
      {
        "input": "s = '12'",
        "output": "2",
        "explanation": "'12' can be decoded as 'AB' (1 2) or 'L' (12)."
      },
      {
        "input": "s = '226'",
        "output": "3",
        "explanation": "'226' can be decoded as 'BBF' (2 2 6), 'BZ' (2 26), or 'VF' (22 6)."
      },
      {
        "input": "s = '06'",
        "output": "0",
        "explanation": "'06' cannot be decoded as '6' not being a valid mapping."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how many ways you can decode based on the last digit.",
      "Use dynamic programming to keep track of previously calculated results."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Longest Valid Parentheses",
    "description": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Stack"
    ],
    "input_format": "A string s consisting of characters '(' and ')'.",
    "output_format": "An integer representing the length of the longest valid parentheses substring.",
    "constraints": [
      "0 <= s.length <= 3 * 10^4",
      "s[i] is either '(' or ')'."
    ],
    "examples": [
      {
        "input": "s = \"(()\"",
        "output": "2",
        "explanation": "The longest valid parentheses substring is \"()\", which has a length of 2."
      },
      {
        "input": "s = \")()())\"",
        "output": "4",
        "explanation": "The longest valid parentheses substring is \"()()\", which has a length of 4."
      },
      {
        "input": "s = \"\"",
        "output": "0",
        "explanation": "There are no parentheses in the string, so the length is 0."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to keep track of the indices of valid parentheses.",
      "You might want to maintain a variable to keep track of the last unmatched index."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Zigzag Conversion",
    "description": "The string 'PAYPALISHIRING' is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   C\n\nAnd then read line by line: 'PAHNAPLSIIGYI'.\n\nWrite a function to convert the given string to the specified zigzag pattern, given the number of rows. The conversion should be done row by row.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Zigzag"
    ],
    "input_format": "A string s and an integer numRows representing the number of rows.",
    "output_format": "A single string which is the zigzag conversion of the input string.",
    "constraints": [
      "1 <= s.length <= 1000",
      "1 <= numRows <= 1000"
    ],
    "examples": [
      {
        "input": {
          "s": "PAYPALISHIRING",
          "numRows": 3
        },
        "output": "PAHNAPLSIIGYI",
        "explanation": "With 3 rows, the zigzag would look like: P A H N A P L S I I G Y I, hence the result is PAHNAPLSIIGYI."
      },
      {
        "input": {
          "s": "AB",
          "numRows": 1
        },
        "output": "AB",
        "explanation": "With only 1 row, the zigzag is simply 'AB'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a list to keep track of characters for each row.",
      "Use a variable to track the current row and direction of traversal."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Sqrt(x)",
    "description": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The return type should be an integer. Do not use any built-in exponentiation or square root functions.",
    "topic": "Math",
    "subtopic": "Binary Search",
    "tags": [
      "Math",
      "Binary Search",
      "Square Root"
    ],
    "input_format": "A non-negative integer x (0 <= x <= 2^31 - 1).",
    "output_format": "An integer representing the square root of x rounded down.",
    "constraints": [
      "0 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 4",
        "output": "2",
        "explanation": "The square root of 4 is 2."
      },
      {
        "input": "x = 8",
        "output": "2",
        "explanation": "The square root of 8 is approximately 2.828, and when rounded down it becomes 2."
      },
      {
        "input": "x = 0",
        "output": "0",
        "explanation": "The square root of 0 is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using binary search to efficiently find the square root.",
      "The square root of x is between 0 and x."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Plus One",
    "description": "You are given a large integer represented as a non-empty array of digits, where each element is a single digit. The digits are stored such that the most significant digit is at the head of the list, and each digit is in the range 0-9. The integer does not contain leading zeros except for the number 0 itself. You need to implement a function that increments this large integer by one and returns the resulting array of digits.",
    "topic": "Array",
    "subtopic": "Manipulating Arrays",
    "tags": [
      "Array",
      "Math",
      "Simulation"
    ],
    "input_format": "An array of integers representing the digits of the number.",
    "output_format": "An array of integers representing the digits of the incremented number.",
    "constraints": [
      "1 <= digits.length <= 100",
      "0 <= digits[i] <= 9",
      "digits does not have leading zeros"
    ],
    "examples": [
      {
        "input": "digits = [1, 2, 3]",
        "output": "[1, 2, 4]",
        "explanation": "Adding one to 123 gives us 124, which is represented as [1, 2, 4]."
      },
      {
        "input": "digits = [9, 9, 9]",
        "output": "[1, 0, 0, 0]",
        "explanation": "Adding one to 999 gives us 1000, which is represented as [1, 0, 0, 0]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how to handle carrying over when the digit exceeds 9.",
      "You might need to add a new digit if the highest place value carries over."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Maximal Rectangle",
    "description": "Given a 2D binary matrix filled with 0's and 1's, find the area of the largest rectangle containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "Matrix",
    "tags": [
      "Dynamic Programming",
      "Matrix",
      "Binary Search"
    ],
    "input_format": "A 2D binary matrix represented as a list of lists.",
    "output_format": "An integer representing the area of the largest rectangle containing only 1's.",
    "constraints": [
      "1 <= matrix.length <= 200",
      "1 <= matrix[i].length <= 200",
      "matrix[i][j] is '0' or '1'"
    ],
    "examples": [
      {
        "input": "[['1', '0', '1', '0', '0'], ['1', '0', '1', '1', '1'], ['1', '1', '1', '1', '1'], ['1', '0', '0', '1', '0']]",
        "output": "6",
        "explanation": "The largest rectangle containing only 1's has an area of 6 units."
      },
      {
        "input": "[['0']]",
        "output": "0",
        "explanation": "The matrix does not contain any 1's, thus the area is 0."
      },
      {
        "input": "[['1', '1'], ['1', '1']]",
        "output": "4",
        "explanation": "The entire matrix is filled with 1's, hence the area is 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using heights to keep track of the number of consecutive 1's.",
      "You can find the maximal rectangle area by treating each row as a histogram.",
      "Implement a strategy to calculate maximal area using a stack."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Permutations II",
    "description": "Given a collection of numbers that might contain duplicates, return all possible unique permutations. The solution set must not contain duplicate permutations.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Recursion",
      "Permutations"
    ],
    "input_format": "An array of integers nums, which may contain duplicates.",
    "output_format": "A list of all unique permutations of the input array.",
    "constraints": [
      "1 <= nums.length <= 8",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "[[1, 1, 2], [1, 2, 1], [2, 1, 1]]",
        "explanation": "The unique permutations are generated from the given numbers, while avoiding duplicates."
      },
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]",
        "explanation": "All permutations of the distinct numbers 1, 2, and 3 are considered."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a backtracking approach to explore all potential permutations.",
      "Track counts of each number to handle duplicates effectively."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List II",
    "description": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the modified list. Constraints guarantee that the input list has at least left elements.",
    "topic": "Linked List",
    "subtopic": "Reversing a Sublist",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Reversal"
    ],
    "input_format": "A singly linked list and two integers left and right.",
    "output_format": "The head of the modified linked list.",
    "constraints": [
      "1 <= left <= right <= number of nodes in the linked list",
      "The number of nodes in the list is at most 10^5000"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], left = 2, right = 4",
        "output": "[1, 4, 3, 2, 5]",
        "explanation": "Reversing the nodes from position 2 to 4 results in the modified linked list: 1 -> 4 -> 3 -> 2 -> 5."
      },
      {
        "input": "head = [1, 2, 3, 4, 5], left = 1, right = 1",
        "output": "[1, 2, 3, 4, 5]",
        "explanation": "Since left and right are both 1, no changes are made to the list."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dummy node to simplify the edge cases.",
      "Keep track of the previous node to reconnect the reversed segment.",
      "Reverse the links in the specified range."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Symmetric Tree",
    "description": "Given a binary tree, determine if it is a mirror of itself (symmetric around its center). A tree is symmetric if the left and right subtrees are mirror images of each other. You can assume that the tree is represented in the following manner: each node has a value and potentially two children, a left child and a right child.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Recursion",
      "Binary Tree"
    ],
    "input_format": "The input is the root of the binary tree.",
    "output_format": "Return true if the tree is symmetric; otherwise, return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 1000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1,2,2,3,4,4,3]",
        "output": "true",
        "explanation": "The tree is symmetric because the left and right subtrees are mirror images of each other."
      },
      {
        "input": "root = [1,2,2,null,3,null,3]",
        "output": "false",
        "explanation": "The tree is not symmetric since the left subtree has a '3' and the right subtree has a 'null'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a recursive approach to compare the left and right subtrees.",
      "Ensure both nodes have the same value and compare their children in mirror order."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Add Binary",
    "description": "Given two binary strings a and b, return their sum as a binary string. The input strings are both non-empty and contain only characters '0' or '1'.",
    "topic": "String",
    "subtopic": "Binary Manipulation",
    "tags": [
      "Binary",
      "String",
      "Addition"
    ],
    "input_format": "Two non-empty binary strings a and b.",
    "output_format": "A binary string representing the sum of a and b.",
    "constraints": [
      "1 <= a.length, b.length <= 1000",
      "a and b consist only of '0' or '1'."
    ],
    "examples": [
      {
        "input": "a = '1010', b = '1011'",
        "output": "'10101'",
        "explanation": "The binary sum of '1010' and '1011' is '10101'."
      },
      {
        "input": "a = '0', b = '0'",
        "output": "'0'",
        "explanation": "The binary sum of '0' and '0' is '0'."
      },
      {
        "input": "a = '1', b = '111'",
        "output": "'1000'",
        "explanation": "The binary sum of '1' and '111' is '1000'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a carry to handle the binary addition.",
      "You can simulate the addition like in grade school from the rightmost bit to the left."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array II",
    "description": "Given a sorted array of integers, nums, you need to remove the duplicates in-place such that each element appears at most twice and returns the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place. The relative order of the elements should be kept the same.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "A sorted array of integers nums.",
    "output_format": "An integer representing the new length of the modified array.",
    "constraints": [
      "0 <= nums.length <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3]",
        "output": "5",
        "explanation": "The modified array is [1, 1, 2, 2, 3], and the new length is 5."
      },
      {
        "input": "nums = [0,0,1,1,1,1,2,3,3]",
        "output": "7",
        "explanation": "The modified array is [0, 0, 1, 1, 2, 3, 3], and the new length is 7."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use two pointers to manage the position for placing the next unique element.",
      "Keep track of the count for each number while iterating."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted List",
    "description": "Given a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "LinkedList",
      "Manipulation",
      "Two Pointers"
    ],
    "input_format": "The input is the head of a sorted linked list.",
    "output_format": "Return the head of the linked list after removing duplicates.",
    "constraints": [
      "The number of nodes in the linked list is in the range [0, 300].",
      "-100 <= Node.val <= 100",
      "The linked list is guaranteed to be sorted in ascending order."
    ],
    "examples": [
      {
        "input": "head = [1, 1, 2]",
        "output": "[1, 2]",
        "explanation": "The duplicates are removed, leaving the unique elements [1, 2]."
      },
      {
        "input": "head = [1, 1, 2, 3, 3]",
        "output": "[1, 2, 3]",
        "explanation": "The duplicates are removed, leaving the unique elements [1, 2, 3]."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "The input list is empty, so the output is also empty."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to iterate through the list.",
      "Compare the current node with the next node.",
      "Adjust the next pointers to skip duplicates."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Multiply Strings",
    "description": "Given two non-negative integers num1 and num2 represented as string, return the product of num1 and num2, also represented as a string. Note that the numbers can be very large since they are given in string format, and you must not convert them into integers directly.",
    "topic": "Math",
    "subtopic": "Strings",
    "tags": [
      "String",
      "Math",
      "Multiplication"
    ],
    "input_format": "Two strings num1 and num2 representing non-negative integers.",
    "output_format": "A string representing the product of num1 and num2.",
    "constraints": [
      "1 <= num1.length, num2.length <= 200",
      "num1 and num2 consist of digits only and do not contain leading zeros."
    ],
    "examples": [
      {
        "input": "num1 = '123', num2 = '456'",
        "output": "56088",
        "explanation": "Multiplying 123 and 456 gives 56088."
      },
      {
        "input": "num1 = '2', num2 = '3'",
        "output": "6",
        "explanation": "Multiplying 2 and 3 gives 6."
      },
      {
        "input": "num1 = '0', num2 = '987'",
        "output": "0",
        "explanation": "Multiplying 0 with any number results in 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to simulate the multiplication process digit by digit.",
      "You may want to use an array to store intermediate results."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Wildcard Matching",
    "description": "Implement a function that takes two strings: `s` and `p`. The string `p` contains wildcard characters, where '?' matches any single character and '*' matches any sequence of characters (including the empty sequence). Your task is to determine if the string `s` matches the pattern `p`.",
    "topic": "String",
    "subtopic": "Pattern Matching",
    "tags": [
      "String",
      "Dynamic Programming",
      "Pattern Matching"
    ],
    "input_format": "Two strings `s` and `p`, where 0 <= len(s), len(p) <= 100.",
    "output_format": "A boolean value indicating whether `s` matches the pattern `p`.",
    "constraints": [
      "0 <= len(s), len(p) <= 100"
    ],
    "examples": [
      {
        "input": "s = 'aa', p = 'a'",
        "output": "false",
        "explanation": "'a' cannot match 'aa' as '?' matches a single character."
      },
      {
        "input": "s = 'aa', p = '*'",
        "output": "true",
        "explanation": "The '*' can match any sequence of characters, including 'aa'."
      },
      {
        "input": "s = 'cb', p = '?a'",
        "output": "false",
        "explanation": "'?a' expects a character followed by 'a', which 'cb' does not satisfy."
      },
      {
        "input": "s = 'adceb', p = '*a*b'",
        "output": "true",
        "explanation": "'*a*b' matches 'adceb' with '*' matching 'dc', and '?' matching 'e'."
      },
      {
        "input": "s = 'acdcb', p = 'a*c?b'",
        "output": "false",
        "explanation": "'a*c?b' does not match 'acdcb' as it requires a character before 'b'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to track matches.",
      "How can you handle consecutive '*' characters efficiently?",
      "Think about the base case where `p` is empty."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix II",
    "description": "Given an integer n, generate a square matrix filled with elements from 1 to n^2 in spiral order. The matrix should be filled in a clockwise manner starting from the top-left corner. For example, if n = 3, the matrix should look like this: 1 2 3 8 9 4 7 6 5.",
    "topic": "Matrix",
    "subtopic": "Spiraling",
    "tags": [
      "Matrix",
      "Spiral",
      "Array"
    ],
    "input_format": "An integer n (1 <= n <= 20), representing the size of the square matrix.",
    "output_format": "A 2D array of integers representing the filled spiral matrix.",
    "constraints": [
      "1 <= n <= 20"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[[1, 2, 3], [8, 9, 4], [7, 6, 5]]",
        "explanation": "The numbers from 1 to 9 are filled in a spiral order in a 3x3 matrix."
      },
      {
        "input": "n = 1",
        "output": "[[1]]",
        "explanation": "There is only one element in the matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use direction vectors to control the movement through the matrix.",
      "Keep track of the boundaries to avoid overwriting elements."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Text Justification",
    "description": "Given an array of words and a length maxWidth, format the text such that each line has exactly maxWidth characters and is fully justified. Use spaces to fill the remaining space in the line. The last line should be left-justified. Words are separated by a single space, and extra spaces are distributed as evenly as possible, with the extra spaces going to the leftmost gaps. Return the fully justified text as an array of strings.",
    "topic": "String",
    "subtopic": "Text Justification",
    "tags": [
      "String",
      "Justification",
      "Formatting"
    ],
    "input_format": "An array of strings words and an integer maxWidth.",
    "output_format": "An array of strings representing the fully justified text.",
    "constraints": [
      "1 <= words.length <= 3000",
      "1 <= words[i].length <= 100",
      "1 <= maxWidth <= 100"
    ],
    "examples": [
      {
        "input": {
          "words": [
            "This",
            "is",
            "an",
            "example",
            "of",
            "text",
            "justification."
          ],
          "maxWidth": 16
        },
        "output": [
          "This    is    an",
          "example  of text",
          "justification.  "
        ],
        "explanation": "The first line is justified with 4 spaces after 'This' and 1 space after 'is'. The second line has 2 spaces after 'example' and 1 space after 'of'. The last line is left-justified."
      },
      {
        "input": {
          "words": [
            "What",
            "must",
            "be",
            "acknowledgment",
            "shall",
            "be"
          ],
          "maxWidth": 16
        },
        "output": [
          "What   must   be",
          "acknowledgment  ",
          "shall be        "
        ],
        "explanation": "The spaces are distributed to meet the length requirement without breaking words."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to distribute spaces between words.",
      "Use a greedy approach for spacing based on the remaining space.",
      "Remember to handle the last line differently."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Length of Last Word",
    "description": "Given a string s consists of upper/lowercase English letters and spaces, return the length of the last word in the string. If the last word does not exist, return 0.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Length"
    ],
    "input_format": "A single string s consisting of words separated by spaces.",
    "output_format": "An integer representing the length of the last word.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of upper/lowercase English letters and spaces.",
      "There are no leading or trailing spaces."
    ],
    "examples": [
      {
        "input": "Hello World",
        "output": "5",
        "explanation": "The last word is 'World', which has length 5."
      },
      {
        "input": "   fly me   to   the moon  ",
        "output": "4",
        "explanation": "The last word is 'moon', which has length 4."
      },
      {
        "input": "luffy is still joy",
        "output": "3",
        "explanation": "The last word is 'joy', which has length 3."
      },
      {
        "input": " a ",
        "output": "1",
        "explanation": "The last word is 'a', which has length 1."
      },
      {
        "input": "   ",
        "output": "0",
        "explanation": "No words exist in the input, hence the length is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "You can use string manipulation methods to find words in the input string.",
      "Trim any excess whitespace before processing."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Combination Sum II",
    "description": "Given an array of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the chosen numbers sum to target.\n\nEach number in candidates may only be used once in the combination. To ensure that the combinations are unique, you can not include the same number in the same combination again. The solution set must not contain duplicate combinations. \n\nYou may return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Combination Sum",
    "tags": [
      "Backtracking",
      "Array",
      "Combination"
    ],
    "input_format": "An array of integers 'candidates' and an integer 'target'.",
    "output_format": "A list of unique combinations where the chosen numbers sum to 'target'.",
    "constraints": [
      "1 <= candidates.length <= 100",
      "1 <= candidates[i] <= 50",
      "target <= 30",
      "All elements of candidates are unique."
    ],
    "examples": [
      {
        "input": "candidates = [10, 1, 2, 7, 6, 1, 5], target = 8",
        "output": "[[1, 1, 6], [1, 2, 5], [2, 6], [1, 7]]",
        "explanation": "The unique combinations that add up to 8 are [1, 1, 6], [1, 2, 5], [2, 6], and [1, 7]."
      },
      {
        "input": "candidates = [2, 5, 2, 1, 2], target = 5",
        "output": "[[1, 2, 2], [5]]",
        "explanation": "The unique combinations that add up to 5 are [1, 2, 2] and [5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use sorting to facilitate finding unique combinations.",
      "Consider a depth-first search (DFS) to explore combinations.",
      "Skip duplicates in the sorted array to avoid repetition."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Same Tree",
    "description": "Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Recursion"
    ],
    "input_format": "Two binary tree nodes, root1 and root2.",
    "output_format": "Return true if the two trees are the same, false otherwise.",
    "constraints": [
      "The number of nodes in both trees is in the range [0, 100].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root1 = [1, 2, 3], root2 = [1, 2, 3]",
        "output": "true",
        "explanation": "Both trees have the same structure and the same values."
      },
      {
        "input": "root1 = [1, 2], root2 = [1, null, 2]",
        "output": "false",
        "explanation": "Tree 1 has a left child while Tree 2 has a right child."
      },
      {
        "input": "root1 = [], root2 = []",
        "output": "true",
        "explanation": "Both trees are empty."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a recursive approach to compare each node.",
      "Base cases: both nodes are null or one of them is null."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array II",
    "description": "Given an array of integers that may include duplicates, which is sorted in ascending order and then rotated at an unknown pivot, determine if a target value exists within the array. You must implement a function that searches for the target and returns true if found, or false if not found. Your solution should be as efficient as possible, ideally with a time complexity of O(log n) if duplicates are not present.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "A boolean value indicating whether the target exists in the array.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums may contain duplicates."
    ],
    "examples": [
      {
        "input": "nums = [2,5,6,0,0,1,2], target = 0",
        "output": "true",
        "explanation": "The target 0 exists in the array."
      },
      {
        "input": "nums = [2,5,6,0,0,1,2], target = 3",
        "output": "false",
        "explanation": "The target 3 does not exist in the array."
      },
      {
        "input": "nums = [1,1,1,1,1,1], target = 1",
        "output": "true",
        "explanation": "All elements are 1; thus, the target 1 exists in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to handle duplicates when implementing binary search.",
      "You may need to adjust the mid index comparison for duplicates."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Insert Interval",
    "description": "Given a set of non-overlapping intervals sorted by their start time and a new interval, insert the new interval into the set and merge any overlapping intervals. Return the updated list of intervals.",
    "topic": "Array",
    "subtopic": "Intervals",
    "tags": [
      "Array",
      "Intervals",
      "Sorting"
    ],
    "input_format": "A list of non-overlapping intervals and a new interval. Intervals are represented as lists of two integers [start, end].",
    "output_format": "A list of merged intervals after inserting the new interval.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "intervals are sorted by their start time",
      "0 <= start <= end <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
        "output": "[[1,5],[6,9]]",
        "explanation": "The new interval [2,5] overlaps with [1,3], merging them gives [1,5] and [6,9]."
      },
      {
        "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
        "output": "[[1,2],[3,10],[12,16]]",
        "explanation": "The new interval [4,8] overlaps with [3,5], [6,7], and [8,10]. Merging them results in [3,10]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a loop to find the right position to insert the new interval.",
      "Consider cases of overlap carefully during the merging process."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Subsets II",
    "description": "Given a collection of integers that might contain duplicates, return all possible subsets (the power set). Note that the solution set must not contain duplicate subsets. The subsets should be returned in any order.",
    "topic": "Backtracking",
    "subtopic": "Subset Generation",
    "tags": [
      "Backtracking",
      "Subsets",
      "Array"
    ],
    "input_format": "An array of integers nums that may contain duplicates.",
    "output_format": "A list of lists containing all the unique subsets.",
    "constraints": [
      "1 <= nums.length <= 20",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2]",
        "output": "[[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]",
        "explanation": "The subsets are generated as follows: [], [1], [2], [1, 2], [2, 2], [1, 2, 2]."
      },
      {
        "input": "nums = [0]",
        "output": "[[], [0]]",
        "explanation": "For a single element array, the subsets are: [], [0]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a backtracking approach to explore all possible subsets.",
      "Sort the input array to handle duplicates efficiently.",
      "Skip the duplicates while generating subsets to avoid repeated subsets."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Rotate List",
    "description": "Given a linked list, rotate the list to the right by k places, where k is non-negative. You should modify the list in place and return the new head of the list.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Rotation"
    ],
    "input_format": "A linked list node representing the head of the list and an integer k representing the number of places to rotate.",
    "output_format": "A linked list node representing the new head of the rotated list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 500].",
      "0 <= Node.val <= 100.",
      "0 <= k <= 2 * 10^9."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], k = 2",
        "output": "[4, 5, 1, 2, 3]",
        "explanation": "Rotating the list by 2 places results in the new head as 4, followed by 5, 1, 2, 3."
      },
      {
        "input": "head = [0, 1, 2], k = 4",
        "output": "[2, 0, 1]",
        "explanation": "Rotating the list by 4 is effectively the same as rotating it by 1, resulting in 2, 0, 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the length of the list and how k might affect the rotation.",
      "Use a two-pointer approach to find the correct position to rotate."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Interleaving String",
    "description": "Given three strings s1, s2, and s3, determine if s3 is formed by the interleaving of s1 and s2. An interleaving of two strings essentially means that characters from s1 and s2 are taken in such a way that they maintain their relative order, and all characters of s3 are used exactly once.",
    "topic": "Dynamic Programming",
    "subtopic": "String Interleaving",
    "tags": [
      "Dynamic Programming",
      "String",
      "Interleaving"
    ],
    "input_format": "Three strings s1, s2, and s3.",
    "output_format": "A boolean value indicating if s3 is an interleaving of s1 and s2.",
    "constraints": [
      "0 <= s1.length, s2.length, s3.length <= 100",
      "The sum of s1.length and s2.length must be equal to s3.length."
    ],
    "examples": [
      {
        "input": "s1 = \"aab\", s2 = \"axy\", s3 = \"aaxyab\"",
        "output": "true",
        "explanation": "The sequence where 'a' from s1, then 'a' from s1, followed by 'a' from s2, 'x' from s2, then 'y' from s2, and finally 'b' from s1 forms s3."
      },
      {
        "input": "s1 = \"abc\", s2 = \"def\", s3 = \"abdecf\"",
        "output": "false",
        "explanation": "Characters cannot be interleaved to form s3 while preserving the order of s1 and s2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dynamic programming approach to track the interleaving."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted List II",
    "description": "Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.",
    "topic": "Linked List",
    "subtopic": "Deletion",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "The head of a sorted linked list.",
    "output_format": "The head of the modified linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 10^4].",
      "-100 <= Node.val <= 100",
      "The list is sorted in ascending order."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 3, 4, 4, 5]",
        "output": "[1, 2, 5]",
        "explanation": "The nodes with values 3 and 4 are duplicates, so we remove them, leaving nodes with values 1, 2, and 5."
      },
      {
        "input": "head = [1, 1, 1, 2, 3]",
        "output": "[2, 3]",
        "explanation": "The node with value 1 is a duplicate, thus removed. Only nodes with values 2 and 3 remain."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dummy node to handle edge cases easily.",
      "Keep track of the previous node to build the new list."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Count and Say",
    "description": "The 'Count and Say' sequence is a sequence of digit strings defined by the recursive formula:\n\n- countAndSay(1) = '1'\n- To generate the next number in the sequence, we count the number of digits in the current number, reading from left to right. For example, countAndSay(1) = '1', countAndSay(2) = '11' (one '1'). Then, countAndSay(3) = '21' (two '1's). Define the function countAndSay(n) that returns the nth term of the sequence as a string.\n\nNote that the sequence starts from n = 1.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Recursion",
      "Count and Say"
    ],
    "input_format": "An integer n (1 <= n <= 30).",
    "output_format": "A string representing the nth term of the 'Count and Say' sequence.",
    "constraints": [
      "1 <= n <= 30"
    ],
    "examples": [
      {
        "input": "1",
        "output": "'1'",
        "explanation": "The first term of the sequence is '1'."
      },
      {
        "input": "4",
        "output": "'1211'",
        "explanation": "'1211' represents one '1', one '2', and two '1's from the previous term '21'."
      },
      {
        "input": "5",
        "output": "'111221'",
        "explanation": "'111221' is derived from three '1's, two '2's, and one '1' from the previous term '1211'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to build the string iteratively by processing counts of digits.",
      "Consider using a loop to traverse through the string."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Recover Binary Search Tree",
    "description": "You are given the root of a binary search tree (BST) where two nodes might be swapped by mistake. Recover the tree without changing its structure. You should restore it so that the tree is a valid binary search tree, where the left subtree values are less than the root, and the right subtree values are greater than the root.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "A binary tree node represented as a reference to the root node.",
    "output_format": "You should not return anything, modify the tree in place.",
    "constraints": [
      "The number of nodes in the tree is in the range [2, 1000].",
      "Node values are distinct integers."
    ],
    "examples": [
      {
        "input": "root = [1, 3, null, null, 2]",
        "output": "root = [3, 1, null, null, 2]",
        "explanation": "The nodes with values 1 and 3 are swapped. After recovery, the values are in the correct order."
      },
      {
        "input": "root = [3, 1, 4, null, null, 2]",
        "output": "root = [2, 1, 4, null, null, 3]",
        "explanation": "The nodes with values 2 and 3 are swapped. After recovery, the values are in the correct order."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "In-order traversal can help identify the swapped nodes.",
      "Keep track of the previous node during traversal."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Combinations",
    "description": "Given a collection of distinct integers, return all possible subsets (the power set). The solution set must not contain duplicate subsets. You may return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Combinations",
    "tags": [
      "Backtracking",
      "Combinations",
      "Subsets"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "A list of lists containing all possible subsets.",
    "constraints": [
      "0 <= nums.length <= 10",
      "-10 <= nums[i] <= 10",
      "All elements of nums are unique."
    ],
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]",
        "explanation": "The subsets of the set {1, 2, 3} include the empty set, the individual elements, pairs of elements, and the full set."
      },
      {
        "input": "nums = [0]",
        "output": "[[],[0]]",
        "explanation": "The only subsets of the set {0} are the empty set and the set itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use backtracking to explore all possible subsets.",
      "For each element, you can choose to include it in the current subset or not."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Maximum Depth of Binary Tree",
    "description": "Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Depth",
      "Binary Tree"
    ],
    "input_format": "The input consists of a binary tree represented as a root node.",
    "output_format": "An integer representing the maximum depth of the binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4]",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "3",
        "explanation": "The maximum depth is 3 as the longest path is 3 -> 20 -> 15."
      },
      {
        "input": "root = [1,null,2]",
        "output": "2",
        "explanation": "The maximum depth is 2 as the longest path is 1 -> 2."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use recursion to explore each path in the tree.",
      "Keep track of the depth as you descend."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "3Sum Closest",
    "description": "Given an array of integers nums and an integer target, find the sum of three integers in nums such that their sum is closest to the target. Return the sum of the three integers. You may assume that each input would have exactly one solution.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sum"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An integer representing the sum of three integers that is closest to the target.",
    "constraints": [
      "1 <= nums.length <= 15",
      "-1000 <= nums[i] <= 1000",
      "-10^4 <= target <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-1, 2, 1, -4], target = 1",
        "output": "2",
        "explanation": "The sum of the triplet (-1, 2, 1) is 2, which is closest to the target 1."
      },
      {
        "input": "nums = [0, 0, 0], target = 1",
        "output": "0",
        "explanation": "The sum of the triplet (0, 0, 0) is 0, which is closest to the target 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array to enable two-pointer technique.",
      "Check adjacent sums to find the closest to the target.",
      "Use a variable to track the smallest difference."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Substring with Concatenation of All Words",
    "description": "You are given a string s and an array of strings words of the same length. Each string in words is of the same length. You need to find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. The order of concatenation should also be preserved.",
    "topic": "String",
    "subtopic": "Substring Search",
    "tags": [
      "String",
      "Substring",
      "Hashmap"
    ],
    "input_format": "A string s followed by an array of strings words.",
    "output_format": "A list of integers representing all starting indices of substring(s) in s.",
    "constraints": [
      "1 <= s.length <= 1000",
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 100",
      "The total length of all words combined will not exceed 1000."
    ],
    "examples": [
      {
        "input": "s = 'barfoothefoobarman', words = ['foo', 'bar']",
        "output": "[0, 9]",
        "explanation": "The substring 'barfoo' starts at index 0 and 'foobar' starts at index 9."
      },
      {
        "input": "s = 'wordgoodgoodgoodbestword', words = ['word', 'good', 'best', 'word']",
        "output": "[]",
        "explanation": "No combination of the words exists in the string."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the length of each word and the total length of all words together.",
      "Use a hashmap to count occurrences of each word."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Partition List",
    "description": "Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions.",
    "topic": "Linked List",
    "subtopic": "Partitioning",
    "tags": [
      "Linked List",
      "Partitioning",
      "Two Pointers"
    ],
    "input_format": "A linked list and an integer x.",
    "output_format": "The head of the new partitioned linked list.",
    "constraints": [
      "The number of nodes in the linked list is in the range [0, 200].",
      "-100 <= Node.val <= 100",
      "-200 <= x <= 200"
    ],
    "examples": [
      {
        "input": "head = [1, 4, 3, 2, 5, 2], x = 3",
        "output": "[1, 2, 2, 4, 3, 5]",
        "explanation": "The partitioning results in [1, 2, 2] < 3 and [4, 3, 5] >= 3."
      },
      {
        "input": "head = [2, 1], x = 2",
        "output": "[1, 2]",
        "explanation": "The partitioning results in [1] < 2 and [2] >= 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using two separate lists to store nodes less than and greater than or equal to x.",
      "You may need to connect the two lists at the end."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "N-Queens II",
    "description": "The N-Queens II problem is to place N queens on an N x N chessboard such that no two queens threaten each other. In this version, you are required to calculate the total number of distinct solutions to the N-Queens problem. A solution is distinct if the arrangement cannot be obtained from another by rotation or reflection.",
    "topic": "Backtracking",
    "subtopic": "Combinatorial Search",
    "tags": [
      "Backtracking",
      "Combinatorics",
      "DFS"
    ],
    "input_format": "An integer n representing the size of the chessboard and the number of queens to be placed.",
    "output_format": "An integer representing the total number of distinct solutions for placing N queens on an N x N chessboard.",
    "constraints": [
      "1 <= n <= 15"
    ],
    "examples": [
      {
        "input": "n = 4",
        "output": "2",
        "explanation": "The two distinct solutions for placing 4 queens are: 1. [[.Q..], [...Q], [Q...], [..Q.]] and 2. [[..Q.], [Q...], [...Q], [.Q..]]."
      },
      {
        "input": "n = 1",
        "output": "1",
        "explanation": "There is only one way to place a queen on a 1 x 1 board."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use backtracking to explore all possible placements.",
      "Consider a set for columns and two sets for diagonal tracking."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Unique Paths II",
    "description": "A robot is located at the top-left corner of a m x n grid (represented as grid[0][0]). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (represented as grid[m-1][n-1]). However, some cells in the grid are obstacles that block the robot's path. Design an algorithm to find the number of unique paths from the top-left corner to the bottom-right corner of the grid, while considering the obstacles.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Pathfinding"
    ],
    "input_format": "A 2D grid represented by a list of lists, where 0 represents an empty cell and 1 represents an obstacle.",
    "output_format": "An integer representing the number of unique paths to the bottom-right corner of the grid.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 100",
      "grid[i][j] is 0 or 1.",
      "The starting point (grid[0][0]) and the ending point (grid[m-1][n-1]) will always be 0."
    ],
    "examples": [
      {
        "input": "grid = [[0,0,0],[0,1,0],[0,0,0]]",
        "output": "2",
        "explanation": "There are two unique paths: the robot can either go down, down, right, right or right, down, down, right."
      },
      {
        "input": "grid = [[0,1],[0,0]]",
        "output": "1",
        "explanation": "There is only one unique path: down, then right."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use dynamic programming to store the number of paths to each cell.",
      "Consider the obstacles while calculating the number of paths.",
      "The number of paths to a cell is the sum of the paths from the cell above and the cell to the left."
    ],
    "company": "Microsoft"
  },
  {
    "question_id": "",
    "title": "Unique Binary Search Trees II",
    "description": "Given an integer n, you need to generate all the unique binary search trees (BST) that can be constructed with values from 1 to n. A binary search tree is defined as a binary tree in which the left subtree contains only nodes with keys less than the node\u2019s key, and the right subtree contains only nodes with keys greater than the node\u2019s key.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "An integer n representing the number of nodes.",
    "output_format": "A list containing all unique BSTs, where each BST is represented as a tree node.",
    "constraints": [
      "0 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
        "explanation": "The unique trees formed by values 1, 2, and 3 are shown as arrays of tree nodes."
      },
      {
        "input": "n = 1",
        "output": "[[1]]",
        "explanation": "There is only one BST that can be formed with a single node."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion to build subtrees.",
      "The root can be any value from 1 to n."
    ],
    "company": "Microsoft"
  }
]