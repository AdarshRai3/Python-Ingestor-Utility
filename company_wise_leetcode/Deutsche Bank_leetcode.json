[
  {
    "question_id": "",
    "title": "Smallest K-Length Subsequence With Occurrences of a Letter",
    "description": "Given a string s and an integer k, return the lexicographically smallest subsequence of length k that contains at least one occurrence of a specified letter 'letter'. You must pick characters from s in order. If there is no valid subsequence, return an empty string.",
    "topic": "String",
    "subtopic": "Subsequence",
    "tags": [
      "String",
      "Subsequence",
      "Lexicographical Order"
    ],
    "input_format": "A string s and an integer k, followed by a character letter.",
    "output_format": "A string representing the smallest k-length subsequence containing 'letter'.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "1 <= k <= s.length",
      "letter is a lowercase English letter"
    ],
    "examples": [
      {
        "input": "s = 'cbacdcbc', k = 4, letter = 'c'",
        "output": "acbc",
        "explanation": "The smallest subsequence of length 4 containing 'c' is 'acbc'."
      },
      {
        "input": "s = 'abcde', k = 3, letter = 'f'",
        "output": "",
        "explanation": "There is no valid subsequence of length 3 that contains 'f'."
      },
      {
        "input": "s = 'abacabad', k = 4, letter = 'a'",
        "output": "aaab",
        "explanation": "The smallest subsequence of length 4 containing 'a' is 'aaab'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to build the subsequence.",
      "Make sure to count occurrences of 'letter' and maintain their positions."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Find the Maximum Sum of Node Values",
    "description": "Given a binary tree, find the maximum sum of the values of nodes that can be collected along any path from the root node to any leaf node. Note that a path is defined as starting from the root and ending at any leaf node, and you can only move to child nodes. The path sum will be calculated as the sum of the node values along the path.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth-First Search",
      "Dynamic Programming"
    ],
    "input_format": "A binary tree represented by its root node.",
    "output_format": "An integer representing the maximum sum of values along any path from the root to a leaf node.",
    "constraints": [
      "The binary tree has at most 1000 nodes.",
      "-1000 <= node.val <= 1000"
    ],
    "examples": [
      {
        "input": "tree = [10, 5, 3, 1, null, 2, null]",
        "output": "18",
        "explanation": "The path with the maximum sum is 10 -> 5 -> 3, where the sum is 10 + 5 + 3 = 18."
      },
      {
        "input": "tree = [5, 4, 8, 11, null, 13, 4, 7, 2]",
        "output": "22",
        "explanation": "The path with the maximum sum is 5 -> 4 -> 11 -> 2, where the sum is 5 + 4 + 11 + 2 = 22."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a recursive depth-first search to explore all paths.",
      "Keep track of the current path sum at each node.",
      "Update the maximum sum whenever you reach a leaf node."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Maximum Running Time of N Computers",
    "description": "You are given N computers with different processing powers. Each computer can complete a task in a certain amount of time. Your goal is to determine the maximum running time for all the computers to finish a set of tasks.\n\nEach task requires a certain amount of time to be completed. A computer can take on multiple tasks as long as its total running time does not exceed the given maximum running time. If it cannot take on any task, it can remain idle.\n\nYou need to find the maximum time that the computers can run such that all tasks are completed optimally.",
    "topic": "Dynamic Programming",
    "subtopic": "Optimization",
    "tags": [
      "Dynamic Programming",
      "Optimization",
      "Greedy"
    ],
    "input_format": "An integer N representing the number of computers, an array of integers representing their processing times, and an array of integers representing the task times.",
    "output_format": "An integer that represents the maximum time that all computers can run to complete the tasks.",
    "constraints": [
      "1 <= N <= 100",
      "1 <= processing times[i] <= 10^5",
      "1 <= task times[j] <= 10^5"
    ],
    "examples": [
      {
        "input": "N = 3, processing_times = [1, 2, 3], task_times = [2, 4, 6]",
        "output": "12",
        "explanation": "Computer 1 can take tasks of time 2 (runs for 2), Computer 2 can take task of time 4 (runs for 4), Computer 3 can take task of time 6 (runs for 6). The running time sums up to 12."
      },
      {
        "input": "N = 2, processing_times = [3, 6], task_times = [1, 1, 1, 1, 1, 1]",
        "output": "6",
        "explanation": "All computers can take 3 tasks each, leading to the maximum running time of 6."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to distribute tasks among computers to maximize running time.",
      "Think about the total running time as a function of computer processing power.",
      "Try to sort both processing times and task times to optimize allocation."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Pour Water Between Buckets to Make Water Levels Equal",
    "description": "You have several buckets of different heights, each bucket initially contains a certain amount of water. You can pour water from one bucket to another such that the total amount of water remains the same. Your task is to determine the minimum number of pour operations required to make the water levels in all buckets equal. If it's not possible, return -1.",
    "topic": "Greedy",
    "subtopic": "Water Management",
    "tags": [
      "Greedy",
      "Simulation",
      "Math"
    ],
    "input_format": "An integer array 'heights' where heights[i] is the height of bucket i, and an integer array 'water' where water[i] is the amount of water in bucket i.",
    "output_format": "An integer representing the minimum number of pour operations required to make the water levels equal, or -1 if it's not possible.",
    "constraints": [
      "1 <= heights.length <= 100",
      "0 <= heights[i] <= 1000",
      "0 <= water[i] <= sum(water) (total amount of water cannot exceed total bucket capacity)"
    ],
    "examples": [
      {
        "input": "heights = [1, 2, 3], water = [1, 1, 1]",
        "output": "2",
        "explanation": "Transfer 1 unit from bucket 1 to 3, and 1 unit from bucket 2 to 3. Now all buckets can hold the same level."
      },
      {
        "input": "heights = [1, 1, 1], water = [1, 1, 1]",
        "output": "0",
        "explanation": "All buckets are already at the same level, hence no operation is needed."
      },
      {
        "input": "heights = [5, 5, 5], water = [2, 2, 2]",
        "output": "0",
        "explanation": "No operation is needed as the water levels are already equal."
      },
      {
        "input": "heights = [1, 5, 3], water = [2, 2, 3]",
        "output": "-1",
        "explanation": "It's not possible to equalize the water levels due to bucket capacity constraints."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how the total water can be distributed evenly based on the bucket heights.",
      "Pay attention to the maximum possible water level dictated by the bucket heights."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Maximum Coins Heroes Can Collect",
    "description": "In a grid-like world, heroes can collect coins by moving only right or down. You start at the top-left corner of a grid filled with coins, represented as a 2D array, and your goal is to reach the bottom-right corner while collecting the maximum number of coins possible. Each cell contains a non-negative integer indicating the number of coins available in that cell. Determine the maximum number of coins that can be collected on the way to the bottom-right corner.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Pathfinding"
    ],
    "input_format": "A 2D array of integers where each integer represents the number of coins in that cell.",
    "output_format": "An integer representing the maximum number of coins that can be collected.",
    "constraints": [
      "1 <= grid.length <= 100",
      "1 <= grid[i].length <= 100",
      "0 <= grid[i][j] <= 100"
    ],
    "examples": [
      {
        "input": "grid = [[0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1]]",
        "output": "12",
        "explanation": "Taking the path 0 -> 3 -> 0 -> 4 -> 1 collects a total of 12 coins."
      },
      {
        "input": "grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "21",
        "explanation": "Taking the path 1 -> 2 -> 3 -> 6 -> 9 collects a total of 21 coins."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a DP table to store maximum coins at each cell.",
      "You can only move down or right at each step."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "The Time When the Network Becomes Idle",
    "description": "You have a network of n tasks that need to be completed. Each task has a specific time it takes to complete and dependent tasks can only start once their prerequisite tasks have been completed. Your task is to determine the earliest time the entire network becomes idle, which is defined as the time at which all tasks have been completed and no tasks are remaining. The network is represented by a directed graph where nodes are tasks and edges represent dependencies between them. Given the completion times of each task and the list of dependencies, calculate the idle time.",
    "topic": "Graph",
    "subtopic": "Topological Sorting",
    "tags": [
      "Graph",
      "Topological Sort",
      "Task Scheduling"
    ],
    "input_format": "The input consists of an integer n (1 <= n <= 1000) representing the number of tasks, an array of integers times (length n), and a list of dependencies, where each dependency is represented as a pair of integers [u, v] indicating task u must be completed before task v.",
    "output_format": "An integer representing the earliest time when the network becomes idle.",
    "constraints": [
      "1 <= n <= 1000",
      "1 <= times[i] <= 1000",
      "The number of dependencies does not exceed 10^4."
    ],
    "examples": [
      {
        "input": {
          "n": 4,
          "times": [
            1,
            2,
            3,
            4
          ],
          "dependencies": [
            [
              0,
              1
            ],
            [
              1,
              2
            ],
            [
              2,
              3
            ]
          ]
        },
        "output": "10",
        "explanation": "Task 0 takes 1 time, completing it first takes 1 time. Then task 1 takes 2 time, completing it takes 3 time. Task 2 takes 3 time, completing it takes 6 time. Task 3 takes 4 time, completing it takes 10 time. Thus, the entire network becomes idle at time 10."
      },
      {
        "input": {
          "n": 3,
          "times": [
            5,
            1,
            2
          ],
          "dependencies": [
            [
              0,
              1
            ],
            [
              1,
              2
            ]
          ]
        },
        "output": "8",
        "explanation": "Task 0 takes 5 time, completing it takes 5 time. Task 1 takes 1 time, completing it takes 6 time. Task 2 takes 2 time, completing it takes 8 time. Thus, the entire network becomes idle at time 8."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how tasks can be completed in layers based on their dependencies.",
      "Consider using topological sorting to determine the order of task completion."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Minimum Operations to Collect Elements",
    "description": "You are given an array of integers representing the elements in various boxes. Each operation allows you to remove an arbitrary number of elements from any box, but you must collect them all into a single box. Your goal is to perform the minimum number of operations required to collect all the elements into one box. Return the minimum number of operations needed.",
    "topic": "Greedy",
    "subtopic": "Operations Counting",
    "tags": [
      "Greedy",
      "Array",
      "Counting"
    ],
    "input_format": "An array of integers nums where each integer represents the number of elements in that box.",
    "output_format": "An integer representing the minimum number of operations needed to collect all elements into one box.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "2",
        "explanation": "You can first collect all elements from box 2 (1 operation) into box 1, and then collect all elements from box 3 (1 operation) into box 1, resulting in a total of 2 operations."
      },
      {
        "input": "nums = [0, 0, 0]",
        "output": "0",
        "explanation": "No operations are needed since all boxes are empty."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Think about how you can minimize the number of operations needed to collect elements.",
      "If you have k boxes with elements, you will always need at least k-1 operations."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Apply Operations to Maximize Frequency Score",
    "description": "You are given an array of integers where each element represents an operation that can be applied to maximize a frequency score. The frequency score is defined as the frequency of the most common element in the array after applying some operations. You can perform either of the following operations on any element of the array: increment its value by 1 or decrement its value by 1. To maximize the frequency score, find out how many elements in the array can be transformed to have the same value after applying a limited number of operations. Return the maximum frequency score you can achieve.",
    "topic": "Array",
    "subtopic": "Frequency Count",
    "tags": [
      "Array",
      "Frequency",
      "Operations"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum frequency score after applying the operations.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2, 3]",
        "output": "3",
        "explanation": "By incrementing both 1 and 2, we can make the entire array [2, 2, 2, 3]. The maximum frequency is 3."
      },
      {
        "input": "nums = [1, 1, 4, 4, 4]",
        "output": "4",
        "explanation": "We can increase both 1s to 2 or decrease one 4 to 3 to achieve the maximum frequency of 4 with value 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider counting the frequency of each number.",
      "Think about using a sliding window or two-pointer technique to minimize operations."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Minimum Operations to Make the Array Increasing",
    "description": "You are given an integer array nums. In one operation, you can increment any element by 1. Your goal is to make the array strictly increasing, meaning that nums[i] < nums[i + 1] for all valid i. Return the minimum number of operations required to achieve this.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Increment"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the minimum number of operations to make the array strictly increasing.",
    "constraints": [
      "1 <= nums.length <= 2000",
      "0 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1, 5, 2, 4, 1]",
        "output": "14",
        "explanation": "Incrementing the elements in the following manner will result in a strictly increasing sequence: [1, 5, 6, 7, 8]. Total operations = (6-2) + (7-4) + (8-1) = 4 + 3 + 7 = 14."
      },
      {
        "input": "nums = [2, 2, 1, 2, 1]",
        "output": "6",
        "explanation": "To make the array strictly increasing, incrementing 2nd element to 3, 3rd element to 4, 4th element to 5, and 5th element to 6 results in [2, 3, 4, 5, 6]. Total operations = 1 + 3 + 3 + 5 = 6."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the previous number in the increasing sequence.",
      "If the current number is not greater than the previous, calculate how much to increment it."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Minimize the Difference Between Target and Chosen Elements",
    "description": "Given an array of integers and a target integer, find a subset of the array whose sum is closest to the target. Return the minimum difference between the sum of the chosen subset and the target. If there are no elements, return the absolute value of the target.",
    "topic": "Dynamic Programming",
    "subtopic": "Subset Sum Problem",
    "tags": [
      "Dynamic Programming",
      "Subset Sum",
      "Greedy"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An integer representing the minimum difference between the target and the sum of the chosen subset.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 1000",
      "0 <= target <= 10000"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5], target = 11",
        "output": "0",
        "explanation": "The subset [1, 2, 3, 5] gives a sum of 11, which is equal to the target."
      },
      {
        "input": "nums = [1, 3, 4, 7], target = 10",
        "output": "1",
        "explanation": "The subset [3, 4] gives a sum of 7, which is closest to the target 10 with a difference of 3."
      },
      {
        "input": "nums = [2, 3, 5, 7], target = 14",
        "output": "0",
        "explanation": "The subset [2, 3, 5, 4] sums exactly to 14."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about using dynamic programming to compute all possible subset sums.",
      "Consider using a boolean array to track achievable sums.",
      "The closest sum can be determined by finding the largest sum less than or equal to the target."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Boats to Save People",
    "description": "You are given an array `people` where `people[i]` is the weight of the i-th person. There are boats available, each boat can carry a maximum weight of `limit`. Each boat can carry at most two people at the same time, provided their total weight does not exceed `limit`. You need to calculate the minimum number of boats required to carry all the people. Note that a boat can only be used for one trip at a time and the weights of the people in the boat cannot exceed the weight `limit`.",
    "topic": "Greedy",
    "subtopic": "Two Pointers",
    "tags": [
      "Greedy",
      "Two Pointers",
      "Array"
    ],
    "input_format": "An integer array `people` and an integer `limit`.",
    "output_format": "An integer denoting the minimum number of boats required.",
    "constraints": [
      "1 <= people.length <= 5 * 10^4",
      "1 <= people[i] <= limit <= 3 * 10^4"
    ],
    "examples": [
      {
        "input": "people = [1, 2], limit = 3",
        "output": "1",
        "explanation": "Both can be in the same boat; thus only 1 boat is required."
      },
      {
        "input": "people = [3, 2, 2, 1], limit = 3",
        "output": "3",
        "explanation": "We can take 1 and 2 together in one boat, 2 alone in another, and 3 alone in a third one."
      },
      {
        "input": "people = [3, 5, 3, 4], limit = 5",
        "output": "4",
        "explanation": "Each person will need their own boat since no two people can fit in one without exceeding the limit."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the weights first.",
      "Use two pointers to evaluate pairs from both ends."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Koko Eating Bananas",
    "description": "Koko loves to eat bananas. There are n piles of bananas, and the i-th pile has piles[i] bananas. Koko can decide to eat bananas at a speed k bananas/hour. Each hour, she can choose to eat any number of bananas from any of the piles. Koko wants to eat all the bananas in the shortest amount of time possible. Given the integer array piles and an integer h, return the minimum integer k such that Koko can eat all the bananas within h hours.",
    "topic": "Binary Search",
    "subtopic": "Optimization",
    "tags": [
      "Binary Search",
      "Greedy",
      "Array"
    ],
    "input_format": "An integer array piles representing the number of bananas in each pile and an integer h representing the number of hours Koko has to eat all the bananas.",
    "output_format": "An integer representing the minimum speed k such that Koko can eat all bananas within h hours.",
    "constraints": [
      "1 <= piles.length <= 10^4",
      "1 <= piles[i] <= 10^9",
      "1 <= h <= 10^9"
    ],
    "examples": [
      {
        "input": "piles = [3,6,7,11], h = 8",
        "output": "4",
        "explanation": "If Koko eats at a speed of 4 bananas/hour, she can finish eating all the bananas in 8 hours."
      },
      {
        "input": "piles = [30,11,23,4,20], h = 5",
        "output": "30",
        "explanation": "Koko must eat at least 30 bananas/hour to finish within the time limit of 5 hours."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search on the possible speeds.",
      "You can calculate how many hours it takes at a given speed."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Robot Collisions",
    "description": "You are given a one-dimensional array representing a line of robots, where each robot is represented by an integer. A positive integer represents a robot facing right, while a negative integer represents a robot facing left. When two robots collide (i.e., they are adjacent to each other), the robot facing left will be destroyed if the robot facing right is a larger absolute value. If they are equal, both robots are destroyed. Your task is to determine the final state of the robots after all collisions have been resolved.",
    "topic": "Simulation",
    "subtopic": "Stack",
    "tags": [
      "Simulation",
      "Stack",
      "Collision"
    ],
    "input_format": "An integer array robots of size n (1 <= n <= 10^4). Each integer represents a robot's direction and strength.",
    "output_format": "An integer array representing the final state of robots after all collisions.",
    "constraints": [
      "1 <= robots.length <= 10^4",
      "-1000 <= robots[i] <= 1000"
    ],
    "examples": [
      {
        "input": "robots = [5, 10, -5]",
        "output": "[5, 10]",
        "explanation": "The robot '10' continues intact, while robot '5' and '-5' collide, resulting in '5' remaining as '5 > 5' destroys robot '-5'."
      },
      {
        "input": "robots = [8, -8]",
        "output": "[]",
        "explanation": "Both robots '8' and '-8' collide and destroy each other since they have equal strength."
      },
      {
        "input": "robots = [1, 2, 3, -1, -2, -3]",
        "output": "[1, 2, 3]",
        "explanation": "The negative robots destroy the matching positive robots in pairs, leaving '1, 2, 3' intact."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to maintain the current state of robots.",
      "Process each robot from left to right and resolve collisions using the stack."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Collecting Chocolates",
    "description": "You are given a list of integers representing the amounts of chocolates in various boxes. Your goal is to collect the maximum number of chocolates from the boxes, but you must follow these rules: You can only collect chocolates from a box if you have already collected from the previous box or if the next box contains fewer chocolates than the current box. The task is to return the maximum number of chocolates you can collect following these rules.",
    "topic": "Dynamic Programming",
    "subtopic": "Optimal Substructure",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers representing the number of chocolates in each box.",
    "output_format": "An integer representing the maximum number of chocolates that can be collected.",
    "constraints": [
      "1 <= boxes.length <= 10^5",
      "1 <= boxes[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "boxes = [5, 1, 3, 7, 4]",
        "output": "12",
        "explanation": "Collect from box 1 (5), skip box 2 (1), collect from box 3 (3), and box 4 (7), follow the rules to reach the maximum collection of 12."
      },
      {
        "input": "boxes = [2, 3, 1, 4, 5]",
        "output": "10",
        "explanation": "Collect from box 1 (2), box 2 (3), box 4 (4), and box 5 (5), leading to a total of 10 chocolates."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dynamic programming approach to store the results of past collections.",
      "Think of the problem in terms of states: the best choice at each box based on previous choices."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Asteroid Collision",
    "description": "We have an array of integers representing asteroids in a row. For each asteroid, the absolute value represents its size, and the sign represents its direction: positive for right and negative for left. When two asteroids collide, the smaller one will be destroyed. If they are of the same size, both will be destroyed. Return an array representing the state of the asteroids after all collisions have been processed.",
    "topic": "Stack",
    "subtopic": "Collision Handling",
    "tags": [
      "Stack",
      "Simulation",
      "Array"
    ],
    "input_format": "An array of integers asteroids where 1 <= asteroids.length <= 10^4 and -10^5 <= asteroids[i] <= 10^5.",
    "output_format": "An array of integers representing the remaining asteroids after all collisions.",
    "constraints": [
      "1 <= asteroids.length <= 10^4",
      "-10^5 <= asteroids[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "asteroids = [5, 10, -5]",
        "output": "[5, 10]",
        "explanation": "The first asteroid 5 and the second asteroid 10 are moving right. The third asteroid -5 collides with asteroid 10. Since they don't collide (they go in opposite directions), both remain. Final array is [5, 10]."
      },
      {
        "input": "asteroids = [8, -8]",
        "output": "[]",
        "explanation": "Asteroids 8 and -8 collide and destroy each other, leaving no asteroids."
      },
      {
        "input": "asteroids = [10, 2, -5]",
        "output": "[10]",
        "explanation": "Asteroid 10 collides with 2 (2 is destroyed), then 10 collides with -5 (5 is destroyed). Result is [10]."
      },
      {
        "input": "asteroids = [-2, -1, 1, 2]",
        "output": "[-2, -1, 1, 2]",
        "explanation": "No collisions occur as no positive and negative asteroids collide."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to keep track of the current asteroids.",
      "Process each asteroid and decide whether to push or handle a collision."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Profit"
    ],
    "input_format": "An array of integers prices where 1 <= prices.length <= 10^5 and 0 <= prices[i] <= 10^4.",
    "output_format": "An integer representing the maximum profit that can be achieved.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate profit by subtracting the minimum price from the current price."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An array of integers `nums` and an integer `target`.",
    "output_format": "An array of two integers representing the indices of the two numbers in `nums`.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Assume there's exactly one solution."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Try using a hash table to store the indices of the numbers you have seen."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function that finds the longest common prefix string among an array of strings. If there is no common prefix, return an empty string. A common prefix is defined as a substring that appears at the beginning of each string in the array.",
    "topic": "String",
    "subtopic": "Prefix Matching",
    "tags": [
      "String",
      "Prefix",
      "Array"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A string representing the longest common prefix.",
    "constraints": [
      "0 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "All strings consist of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The longest common prefix is 'fl' as it appears in all three strings."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among these strings."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider the first string as a reference for the prefix.",
      "Iterate through the characters of the reference string and compare with others."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Maximum Fruits Harvested After at Most K Steps",
    "description": "You are given an array of integers representing fruits available at each position along a path. You can harvest fruits by taking steps either to the left or to the right. Your task is to find the maximum number of fruits you can collect after taking at most K steps from your starting position (which is at the beginning of the array). Consider that you can step over occupied positions, and fruits do not reappear once collected.",
    "topic": "Dynamic Programming",
    "subtopic": "Sliding Window",
    "tags": [
      "Dynamic Programming",
      "Sliding Window",
      "Greedy"
    ],
    "input_format": "An array of integers fruits and an integer K representing the maximum steps.",
    "output_format": "An integer representing the maximum number of fruits that can be harvested.",
    "constraints": [
      "1 <= fruits.length <= 10^5",
      "0 <= fruits[i] <= 1000",
      "0 <= K <= fruits.length"
    ],
    "examples": [
      {
        "input": "fruits = [1, 2, 3, 4, 5], K = 2",
        "output": "9",
        "explanation": "From the starting position, we can go to index 2 and then to index 4, collecting fruits 3, 4, and 5. Total = 3 + 4 + 5 = 12."
      },
      {
        "input": "fruits = [0, 2, 0, 1, 2, 3], K = 3",
        "output": "6",
        "explanation": "From the starting position, we can collect fruit at index 1, then step to index 3 and collect fruit from index 5 to total 2 + 1 + 2 + 3 = 8."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Think about how you can approach the problem using a sliding window.",
      "Consider the impact of stepping left versus stepping right."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Frequency of the Most Frequent Element",
    "description": "Given an integer array nums, return the frequency of the most frequently occurring element in the array. If there are multiple elements with the same highest frequency, return the one that appears first in the array.",
    "topic": "Array",
    "subtopic": "Counting Frequencies",
    "tags": [
      "Array",
      "Frequency",
      "HashMap"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the frequency of the most frequent element.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2, 3, 1]",
        "output": "2",
        "explanation": "The most frequent element is 2, which occurs 2 times."
      },
      {
        "input": "nums = [1, 1, 2, 2, 3, 3]",
        "output": "2",
        "explanation": "Both 1 and 2 occur 2 times. The first one is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hashmap to keep track of the frequencies.",
      "Iterate through the array to update frequencies and find the maximum."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Minimize Manhattan Distances",
    "description": "Given a list of points in a 2D plane, your task is to return the smallest possible sum of Manhattan distances between the points after you optimally sort them along both axes. The Manhattan distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|. You can assume that you are allowed to permute both the x-coordinates and y-coordinates independently.",
    "topic": "Geometry",
    "subtopic": "Distance Calculation",
    "tags": [
      "Geometry",
      "Sorting",
      "Distance"
    ],
    "input_format": "A list of points where each point is represented as a pair of integers [x, y].",
    "output_format": "An integer representing the minimized sum of Manhattan distances.",
    "constraints": [
      "1 <= points.length <= 10^4",
      "-10^9 <= points[i][0], points[i][1] <= 10^9"
    ],
    "examples": [
      {
        "input": "points = [[1, 2], [3, 4], [5, 6]]",
        "output": "8",
        "explanation": "After sorting the points by both coordinates, the minimized sum of Manhattan distances can be calculated as follows: |1-3| + |2-4| + |3-5| + |4-6| = 2 + 2 + 2 + 2 = 8."
      },
      {
        "input": "points = [[1, 1], [2, 2], [3, 3]]",
        "output": "4",
        "explanation": "After sorting, the distances are |1-2| + |1-2| + |2-3| + |2-3| = 1 + 1 + 1 + 1 = 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Sort the points by their x-coordinates and y-coordinates independently.",
      "The optimal arrangement will result in minimized distances due to properties of absolute values."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Reverse String",
    "description": "Write a function that takes a string as input and returns the string reversed. You must solve it without using built-in reverse functions.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Manipulation"
    ],
    "input_format": "A single string s (1 <= s.length <= 10^5).",
    "output_format": "A single string representing the reversed input string.",
    "constraints": [
      "The input string consists of printable ASCII characters."
    ],
    "examples": [
      {
        "input": "hello",
        "output": "olleh",
        "explanation": "The string 'hello' reversed is 'olleh'."
      },
      {
        "input": "Reverse",
        "output": "esreveR",
        "explanation": "The string 'Reverse' reversed is 'esreveR'."
      },
      {
        "input": "12345",
        "output": "54321",
        "explanation": "The string '12345' reversed is '54321'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Think about how you can loop through the string backwards.",
      "You can use a new string to build the reversed result."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Kth Largest Element in an Array",
    "description": "Given an integer array `nums` and an integer `k`, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. You must solve it in O(n log n) time complexity or better.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Heap"
    ],
    "input_format": "An array of integers `nums` and an integer `k`.",
    "output_format": "An integer representing the kth largest element in the array.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 1, 5, 6, 4], k = 2",
        "output": "5",
        "explanation": "The second largest element in the sorted order is 5."
      },
      {
        "input": "nums = [3, 2, 3, 1, 2, 4, 5, 5, 6], k = 4",
        "output": "4",
        "explanation": "The fourth largest element in the sorted order is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a heap to keep track of the largest elements.",
      "Sorting the array might be an option, but can you do it in linear time?"
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock II",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. However, you can buy and sell the stock multiple times (i.e., you can complete as many transactions as you like). Note that you cannot own multiple copies of the same stock at the same time. For example, if you have a stock in hand, you must sell it before you buy again. Return the maximum profit you can achieve.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithm",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of integers prices.",
    "output_format": "An integer representing the maximum profit that can be achieved.",
    "constraints": [
      "1 <= prices.length <= 3 * 10^4",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "7",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5. Then buy on day 3 (price = 3) and sell on day 4 (price = 4), profit = 4 - 3 = 1. Total profit = 5 + 1 = 6."
      },
      {
        "input": "prices = [1, 2, 3, 4, 5]",
        "output": "4",
        "explanation": "Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5 - 1 = 4."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the effect of buying and selling on each day.",
      "Try to find where prices increase, and buy/sell at those points."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Fruit Into Baskets",
    "description": "You are given an integer array 'fruits' where 'fruits[i]' is the type of fruit in the ith basket. You want to have a maximum of two different types of fruits in your basket at any time. Return the maximum number of fruits you can pick up in one go.",
    "topic": "Sliding Window",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Sliding Window",
      "Two Pointers"
    ],
    "input_format": "An array of integers 'fruits' representing types of fruits.",
    "output_format": "An integer representing the maximum number of fruits that can be picked.",
    "constraints": [
      "1 <= fruits.length <= 10^5",
      "0 <= fruits[i] < 2^31"
    ],
    "examples": [
      {
        "input": "fruits = [1, 2, 1]",
        "output": "3",
        "explanation": "You can pick all 3 fruits since they only contain two types."
      },
      {
        "input": "fruits = [0, 1, 2, 2]",
        "output": "3",
        "explanation": "You can pick [1, 2, 2] or [0, 1, 2] which both have a maximum of 3 fruits."
      },
      {
        "input": "fruits = [1, 2, 3, 2, 2]",
        "output": "4",
        "explanation": "You can pick [2, 3, 2, 2] which has 4 fruits with two types."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window to maintain the types of fruits.",
      "Keep track of the counts of the fruits inside the window.",
      "When you exceed two types, shrink the window from the left."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Validate IP Address",
    "description": "Given a string s, determine if it is a valid IPv4 or IPv6 address. An IPv4 address is represented as four decimal numbers separated by dots, where each number is in the range of 0 to 255. Each number cannot contain leading zeros. An IPv6 address consists of eight groups of four hexadecimal digits, each group is separated by a colon. If the input string is a valid IP address, return 'IPv4' or 'IPv6' accordingly. Otherwise, return 'Neither'.",
    "topic": "String",
    "subtopic": "Validation",
    "tags": [
      "String",
      "Validation",
      "IP address"
    ],
    "input_format": "A string s representing the IP address to be validated.",
    "output_format": "A string indicating whether the IP address is 'IPv4', 'IPv6', or 'Neither'.",
    "constraints": [
      "1 <= s.length <= 40"
    ],
    "examples": [
      {
        "input": "s = \"192.168.1.1\"",
        "output": "IPv4",
        "explanation": "This is a valid IPv4 address with four octets."
      },
      {
        "input": "s = \"256.256.256.256\"",
        "output": "Neither",
        "explanation": "256 is out of the valid range for an IPv4 octet."
      },
      {
        "input": "s = \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"",
        "output": "IPv6",
        "explanation": "This is a valid IPv6 address with eight groups of four hexadecimal digits."
      },
      {
        "input": "s = \"123.045.67.89\"",
        "output": "Neither",
        "explanation": "045 has leading zeros, making this an invalid IPv4 address."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Check if the address contains dots or colons to determine its type.",
      "For IPv4, split by dots and validate the segments.",
      "For IPv6, split by colons and confirm each segment's length and characters."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Rotting Oranges",
    "description": "In a given grid, each cell can be either empty (0), contain a fresh orange (1), or contain a rotten orange (2). Every minute, any fresh orange adjacent (up, down, left, right) to a rotten orange will rot. Your task is to determine how many minutes will pass until no fresh oranges remain. If it is impossible for all fresh oranges to become rotten, return -1.",
    "topic": "Graph",
    "subtopic": "BFS/DFS",
    "tags": [
      "BFS",
      "DFS",
      "Graph",
      "Matrix"
    ],
    "input_format": "A 2D grid represented as a list of lists where each element represents the state of that cell.",
    "output_format": "An integer representing the minimum minutes until all oranges are rotten, or -1 if it is impossible.",
    "constraints": [
      "1 <= grid.length <= 10",
      "1 <= grid[0].length <= 10",
      "grid[i][j] is 0, 1, or 2"
    ],
    "examples": [
      {
        "input": "[[2,1,1],[1,1,0],[0,1,2]]",
        "output": "4",
        "explanation": "In this case, the fresh oranges will rot in 4 minutes."
      },
      {
        "input": "[[2,1,1],[0,1,1],[1,0,2]]",
        "output": "-1",
        "explanation": "It's impossible for all fresh oranges to rot."
      },
      {
        "input": "[[0,2]]",
        "output": "0",
        "explanation": "There are no fresh oranges, so the result is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using BFS to simulate the rotting process.",
      "Keep track of the number of fresh oranges and the time taken."
    ],
    "company": "Deutsche Bank"
  },
  {
    "question_id": "",
    "title": "Design HashMap",
    "description": "Implement a HashMap with basic functionalities such as put, get, and remove. The HashMap should handle collisions using separate chaining or open addressing. Ensure that the operations have average time complexity of O(1).",
    "topic": "Data Structure",
    "subtopic": "Hash Table",
    "tags": [
      "HashMap",
      "Data Structure",
      "Hash Table"
    ],
    "input_format": "A series of operations on the HashMap: 'put(key, value)', 'get(key)', or 'remove(key)'.",
    "output_format": "For 'get(key)', return the value associated with the key or -1 if the key does not exist.",
    "constraints": [
      "The number of operations will not exceed 10^6.",
      "Keys and values are integers in the range of [-10^9, 10^9]."
    ],
    "examples": [
      {
        "input": "put(1, 1), put(2, 2), get(1), get(3), put(2, 1), get(2), remove(2), get(2)",
        "output": "[1, -1, 1, -1]",
        "explanation": "After performing the operations, the output values for get(1), get(3), get(2), and get(2) after removal are 1, -1, 1, and -1 respectively."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how to handle hash collisions.",
      "Think about the underlying data structure to store the key-value pairs."
    ],
    "company": "Deutsche Bank"
  }
]