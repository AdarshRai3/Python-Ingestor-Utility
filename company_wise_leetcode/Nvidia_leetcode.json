[
  {
    "question_id": "",
    "title": "Last Stone Weight",
    "description": "In a row of stones, each stone has a positive integer weight. When two stones of the same weight collide, they both get destroyed. When two stones of different weights collide, the heavier stone will crush the lighter stone, and the new stone's weight will be the difference between the two. You need to find the weight of the last remaining stone. If no stones are left, return 0.",
    "topic": "Greedy",
    "subtopic": "Heap",
    "tags": [
      "Greedy",
      "Heap",
      "Simulation"
    ],
    "input_format": "An array of integers stones representing the weights of the stones.",
    "output_format": "An integer representing the weight of the last remaining stone or 0 if no stones are left.",
    "constraints": [
      "1 <= stones.length <= 30",
      "1 <= stones[i] <= 1000"
    ],
    "examples": [
      {
        "input": "[2,7,4,1,8,1]",
        "output": "1",
        "explanation": "The stones collide as follows: 7 and 8 collide to produce 1, then 4 and 1 collide resulting in 0, and finally, 2 and 1 collide leaving 1."
      },
      {
        "input": "[1,3]",
        "output": "2",
        "explanation": "The stones collide as 1 and 3 produce 2, leaving the last stone."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a max heap to efficiently simulate stone collisions.",
      "Think about how to handle cases when stones collide."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "LRU Cache",
    "description": "Design and implement a data structure for a Least Recently Used (LRU) cache. The cache should support the following operations: get and put.\n\n- get(key): Return the value of the key if the key exists, otherwise return -1.\n- put(key, value): Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe cache should be initialized with a positive capacity.",
    "topic": "Design",
    "subtopic": "Cache Implementation",
    "tags": [
      "Design",
      "Cache",
      "Data Structure"
    ],
    "input_format": "A sequence of operations on the LRU cache, where each operation is either 'get' or 'put'. Each 'get' operation has one integer key. Each 'put' operation has one integer key and one integer value.",
    "output_format": "For each 'get' operation, return the value associated with the key or -1 if the key does not exist.",
    "constraints": [
      "The capacity of the cache is a positive integer.",
      "0 <= key, value <= 10^4",
      "The number of calls to get and put will not exceed 10^4."
    ],
    "examples": [
      {
        "input": "cache = LRUCache(2);\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);  // returns 1\ncache.put(3, 3); // evicts key 2\ncache.get(2);  // returns -1 (not found)\ncache.put(4, 4); // evicts key 1\ncache.get(1);  // returns -1 (not found)\ncache.get(3);  // returns 3\ncache.get(4);  // returns 4",
        "output": "[1, -1, -1, 3, 4]",
        "explanation": "In this example, after inserting (1 -> 1) and (2 -> 2), we retrieve the value for key 1 which is found. Adding (3 -> 3) evicts the least recently used key 2. Then we try to retrieve the values for keys 2 and 1 which are not found anymore. Lastly, we retrieve values for keys 3 and 4 which are present."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a combination of a hash map and a doubly linked list.",
      "The linked list can help maintain the order of usage.",
      "Ensure the most recently used items are easily accessible."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "topic": "String",
    "subtopic": "Hashing",
    "tags": [
      "Strings",
      "Hashing",
      "Grouping"
    ],
    "input_format": "A list of strings `strs`.",
    "output_format": "A list of lists, where each sublist contains strings that are anagrams of each other.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
        "output": "[[\"bat\"],[\"tan\",\"nat\"],[\"eat\",\"tea\",\"ate\"]]",
        "explanation": "The anagrams are 'eat', 'tea', and 'ate' which can be combined into one group, while 'tan' and 'nat' can be grouped together, and 'bat' is separate."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "An empty string is an anagram of itself."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "A single character is an anagram of itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash map to group the strings.",
      "Sort each string and use the sorted string as a key.",
      "Don't forget to handle edge cases like empty strings."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Minimum Operations to Reduce an Integer to 0",
    "description": "You are given a positive integer n. In one operation, you can either subtract 1 from n or divide n by 2 if n is even. Your task is to find the minimum number of operations needed to reduce n to 0.",
    "topic": "Dynamic Programming",
    "subtopic": "Mathematical Operations",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Mathematics"
    ],
    "input_format": "A single integer n (1 <= n <= 10^6).",
    "output_format": "An integer representing the minimum number of operations to reduce n to 0.",
    "constraints": [
      "1 <= n <= 10^6"
    ],
    "examples": [
      {
        "input": "n = 14",
        "output": "6",
        "explanation": "Operations: 14 -> 7 (subtract 1), 7 -> 6 (subtract 1), 6 -> 3 (divide by 2), 3 -> 2 (subtract 1), 2 -> 1 (divide by 2), 1 -> 0 (subtract 1). Total operations = 6."
      },
      {
        "input": "n = 8",
        "output": "4",
        "explanation": "Operations: 8 -> 4 (divide by 2), 4 -> 2 (divide by 2), 2 -> 1 (divide by 2), 1 -> 0 (subtract 1). Total operations = 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a recursive approach to explore all operations.",
      "Memoization could help optimize your solution.",
      "Think about the structure of the problem: how can you break it down into subproblems?"
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Special Binary String",
    "description": "A binary string is special if it satisfies the following two conditions: 1. It consists of '0's and '1's. 2. It can be split into substrings of '0's and '1's such that each substring of '1's is surrounded by '0's. Given a binary string s, return the lexicographically largest special binary string that can be obtained from s after any number of splits and swaps.",
    "topic": "String",
    "subtopic": "Binary String Manipulation",
    "tags": [
      "String",
      "Binary",
      "Greedy"
    ],
    "input_format": "A binary string s consisting of '0's and '1's.",
    "output_format": "A binary string representing the lexicographically largest special binary string.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of '0's and '1's only.",
      "The input string is guaranteed to be a special binary string."
    ],
    "examples": [
      {
        "input": "s = \"1100\"",
        "output": "10",
        "explanation": "The special binary string can be split into '11' and '00'. The largest binary string is '10'."
      },
      {
        "input": "s = \"11011000\"",
        "output": "11100100",
        "explanation": "The largest special binary string that can be formed is '11100100'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to approach splitting between '0's and '1's.",
      "Focus on recursively processing each part of the string.",
      "Think about how to maintain the special structure of '1's surrounded by '0's."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return the indices [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return the indices [1, 2]."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 6, we return the indices [0, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash map to store the difference between the target and each element.",
      "Check if the current number exists in the hash map."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters. This problem requires you to identify the maximum length of a substring, which contains all unique characters without any repetitions.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Hash Map"
    ],
    "input_format": "A string s containing only printable ASCII characters.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 10^5",
      "s consists of English letters, digits, symbols and spaces."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"abc\", which has a length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The longest substring without repeating characters is \"b\", with a length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"wke\", which has a length of 3."
      },
      {
        "input": "s = \"\"",
        "output": "0",
        "explanation": "An empty string has a length of 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a sliding window technique to expand and contract the substring.",
      "Use a hash map to keep track of the characters and their indices."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "input_format": "An array of integers prices representing the stock prices on consecutive days.",
    "output_format": "An integer representing the maximum profit that can be achieved.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate potential profit at each step."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "DFS",
      "Graph",
      "Matrix"
    ],
    "input_format": "A 2D grid represented as a list of lists containing '1's and '0's.",
    "output_format": "An integer representing the total number of islands in the grid.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "grid = [[1,1,0,0,0],[1,1,0,0,0],[0,0,1,0,0],[0,0,0,1,1]]",
        "output": "3",
        "explanation": "There are three islands: one consisting of the top-left '1's, another consisting of the '1' in the lower-left, and the last consisting of the '1's in the bottom-right."
      },
      {
        "input": "grid = [[1,1,1,1,0],[0,1,0,0,0],[0,0,0,1,1]]",
        "output": "2",
        "explanation": "There are two islands: one consisting of the connected '1's in the first row, and another consisting of the '1's in the last row."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth-First Search (DFS) to explore each island.",
      "Mark the visited land as water to avoid counting it again.",
      "Iterate through each cell in the grid, counting an island when you encounter a '1'."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Maximum Number of Visible Points",
    "description": "You are given a set of points represented by their coordinates in a 2D plane. Some of these points might be obscured from view by others due to their relative angles. Your task is to determine the maximum number of points that can be viewed from a specific vantage point, considering that only distinct angles can be seen. Points that align with the same angle from the vantage point cannot be counted multiple times.",
    "topic": "Geometry",
    "subtopic": "Trigonometry",
    "tags": [
      "Geometry",
      "Trigonometry",
      "Points"
    ],
    "input_format": "An array of points, where each point is represented as a tuple of two integers (x, y) representing the coordinates on the 2D plane, and a tuple representing the vantage point (vx, vy).",
    "output_format": "An integer representing the maximum number of visible points.",
    "constraints": [
      "1 <= points.length <= 1000",
      "-10^4 <= points[i][0], points[i][1], vx, vy <= 10^4"
    ],
    "examples": [
      {
        "input": "points = [[1, 1], [2, 2], [3, 3]], vantage_point = [0, 0]",
        "output": "3",
        "explanation": "All points are visible from the vantage point (0, 0) since they are at distinct angles."
      },
      {
        "input": "points = [[1, 1], [1, -1], [-1, 1], [-1, -1]], vantage_point = [0, 0]",
        "output": "4",
        "explanation": "All four points are visible as they are positioned at 90-degree angles."
      },
      {
        "input": "points = [[1, 1], [2, 2], [2, 1], [1, 2]], vantage_point = [0, 0]",
        "output": "3",
        "explanation": "The points [2,2] and [2,1] align at the same angle from the vantage point, only one can be observed."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider calculating angles using trigonometric functions.",
      "Use a set to track distinct angles.",
      "Be cautious with points that lie on the same line from the vantage point."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "Given a rotated sorted array and a target value, search for the target in the array. If the target exists, return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Searching"
    ],
    "input_format": "An integer array nums, followed by an integer target.",
    "output_format": "An integer representing the index of target in nums, or -1 if not found.",
    "constraints": [
      "The array is rotated at some pivot and may contain duplicates.",
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [4, 5, 6, 7, 0, 1, 2], target = 0",
        "output": "4",
        "explanation": "The target 0 is at index 4 in the array."
      },
      {
        "input": "nums = [4, 5, 6, 7, 0, 1, 2], target = 3",
        "output": "-1",
        "explanation": "The target 3 is not present in the array."
      },
      {
        "input": "nums = [1], target = 0",
        "output": "-1",
        "explanation": "The target 0 is not present in the array."
      },
      {
        "input": "nums = [1, 3], target = 3",
        "output": "1",
        "explanation": "The target 3 is at index 1 in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how the array is divided into two sorted parts.",
      "Check if the target is in the left sorted part or the right sorted part."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a non-empty contiguous part of an array.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Prefix Sum"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum sum of the contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum = 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The only subarray is [1] which has the sum = 1."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The subarray [5,4,-1,7,8] has the largest sum = 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dynamic programming approach.",
      "Keep track of the maximum sum ending at each index."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Reverse Bits",
    "description": "Given a 32-bit unsigned integer, reverse its bits and return it as an unsigned integer.",
    "topic": "Bit Manipulation",
    "subtopic": "Bit Operations",
    "tags": [
      "Bit Manipulation",
      "Math",
      "Integer"
    ],
    "input_format": "A single integer n representing a 32-bit unsigned integer.",
    "output_format": "An integer representing the unsigned integer formed by reversing the bits of n.",
    "constraints": [
      "0 <= n <= 2^32 - 1"
    ],
    "examples": [
      {
        "input": "n = 43261596",
        "output": "964176192",
        "explanation": "The binary representation of 43261596 is 00000010100101000001111010011100. Reversing the bits gives 00111001011110000010101000000000, which equals 964176192."
      },
      {
        "input": "n = 4294967293",
        "output": "3221225471",
        "explanation": "The binary representation of 4294967293 is 11111111111111111111111111111101. Reversing the bits gives 10111111111111111111111111111111, which equals 3221225471."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "You can use bitwise operations to manipulate individual bits.",
      "Consider using a loop to build the reversed number bit by bit."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. Note that an empty string is also considered valid.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A string s consisting of characters '(', ')', '{', '}', '[' and '].",
    "output_format": "Return true if the input string is valid, otherwise return false.",
    "constraints": [
      "0 <= s.length <= 104",
      "s consists of parentheses only '()[]{}'."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The parentheses are properly closed and nested."
      },
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "Each type of bracket is closed properly."
      },
      {
        "input": "s = '(]'",
        "output": "false",
        "explanation": "The opening bracket '(' is not closed by the corresponding closing bracket ']'."
      },
      {
        "input": "s = '([)]'",
        "output": "false",
        "explanation": "The brackets are not closed in the correct order."
      },
      {
        "input": "s = '{[]}'",
        "output": "true",
        "explanation": "The brackets are properly closed and nested."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "Check for matching closing brackets when popping from the stack."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Dot Product of Two Sparse Vectors",
    "description": "Given two sparse vectors represented by two arrays, calculate and return their dot product. The dot product of two vectors is calculated as the sum of the product of their corresponding elements. You may assume the two vectors are of the same length.",
    "topic": "Array",
    "subtopic": "Sparse Data Structure",
    "tags": [
      "Array",
      "Math",
      "Dot Product"
    ],
    "input_format": "Two arrays of integers, nums1 and nums2, representing the sparse vectors.",
    "output_format": "An integer representing the dot product of the two sparse vectors.",
    "constraints": [
      "1 <= nums1.length, nums2.length <= 10^5",
      "0 <= nums1[i], nums2[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 0, 0, 2], nums2 = [0, 3, 0, 4]",
        "output": "8",
        "explanation": "The dot product is calculated as (1*0) + (0*3) + (0*0) + (2*4) = 0 + 0 + 0 + 8 = 8."
      },
      {
        "input": "nums1 = [0, 1, 0, 0], nums2 = [0, 2, 0, 3]",
        "output": "2",
        "explanation": "The dot product is calculated as (0*0) + (1*2) + (0*0) + (0*3) = 0 + 2 + 0 + 0 = 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider only non-zero values in the sparse vectors.",
      "Use a hash map to store and access non-zero elements efficiently."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list.",
    "topic": "Linked List",
    "subtopic": "Addition",
    "tags": [
      "Linked List",
      "Mathematics",
      "Addition"
    ],
    "input_format": "Two linked lists l1 and l2, where each linked list represents a non-negative integer.",
    "output_format": "A linked list representing the sum of the two numbers.",
    "constraints": [
      "The linked lists are non-empty.",
      "The numbers represented by the linked lists will not exceed 10^4 digits."
    ],
    "examples": [
      {
        "input": "l1 = [2, 4, 3], l2 = [5, 6, 4]",
        "output": "[7, 0, 8]",
        "explanation": "342 + 465 = 807, represented as [7, 0, 8] in reverse order."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "0 + 0 = 0, represented as [0]."
      },
      {
        "input": "l1 = [9, 9, 9], l2 = [1]",
        "output": "[0, 0, 0, 1]",
        "explanation": "999 + 1 = 1000, represented as [0, 0, 0, 1] in reverse order."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "You may need to manage carry during the addition.",
      "Iterate through both lists until both are null."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Missing Number",
    "description": "Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one number that is missing from the array.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Mathematics"
    ],
    "input_format": "An array of distinct integers nums where 0 <= nums.length <= n.",
    "output_format": "An integer representing the missing number.",
    "constraints": [
      "0 <= nums.length <= 10000",
      "0 <= nums[i] <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [3, 0, 1]",
        "output": "2",
        "explanation": "The numbers from 0 to 3 are 0, 1, 2, 3. The missing number is 2."
      },
      {
        "input": "nums = [0, 1]",
        "output": "2",
        "explanation": "The numbers from 0 to 2 are 0, 1, 2. The missing number is 2."
      },
      {
        "input": "nums = [9,6,4,2,3,5,7,0,1]",
        "output": "8",
        "explanation": "The numbers from 0 to 9 are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. The missing number is 8."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using the sum formula for the first n natural numbers.",
      "Iterate through the array to find the missing number."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Move Zeroes",
    "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array.",
    "topic": "Array",
    "subtopic": "In-place Manipulation",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "The modified array with all 0's moved to the end.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [0,1,0,3,12]",
        "output": "[1,3,12,0,0]",
        "explanation": "The non-zero elements are 1, 3, and 12. They maintain their relative order after moving all 0's to the end."
      },
      {
        "input": "nums = [0]",
        "output": "[0]",
        "explanation": "There are no non-zero elements, so the array remains unchanged."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to track the position of non-zero elements.",
      "Swap elements to move non-zero values forward."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Task Scheduler II",
    "description": "You are given a list of tasks that need to be scheduled. Each task is represented by a single uppercase letter. Tasks are executed in order and you are required to insert 'n' units of time (cooldown) between executing the same task. Your goal is to determine the minimum time required to complete all tasks, including cooling time between identical tasks. If it's not possible to complete the tasks within the required cooldown, return -1.",
    "topic": "Greedy",
    "subtopic": "Task Scheduling",
    "tags": [
      "Greedy",
      "Scheduling",
      "Array"
    ],
    "input_format": "An array of strings `tasks` representing the tasks and an integer `n` representing the cooldown period.",
    "output_format": "An integer representing the minimum total time to complete all tasks, or -1 if impossible.",
    "constraints": [
      "1 <= tasks.length <= 10^5",
      "1 <= n <= 26",
      "tasks[i] is an uppercase letter."
    ],
    "examples": [
      {
        "input": "tasks = ['A', 'A', 'A', 'B', 'B', 'B'], n = 2",
        "output": "8",
        "explanation": "One valid scheduling: A -> B -> idle -> A -> B -> idle -> A -> B; total time = 8."
      },
      {
        "input": "tasks = ['A', 'A', 'A', 'B', 'B', 'B'], n = 0",
        "output": "6",
        "explanation": "With no cooldown, tasks can be completed back-to-back."
      },
      {
        "input": "tasks = ['A', 'A', 'A', 'B', 'B', 'B'], n = 3",
        "output": "10",
        "explanation": "One valid scheduling: A -> idle -> idle -> idle -> B -> idle -> idle -> idle -> A -> B; total time = 10."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a frequency map to count occurrences of each task.",
      "Priority queue can help in managing the next task to execute.",
      "Consider if cooldowns are possible given the frequencies."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. You need to ensure that the intervals are sorted based on their starting points, and then merge them if they overlap. The output should be a new list of merged intervals.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Intervals"
    ],
    "input_format": "A list of intervals, where each interval is represented by a pair of integers [start, end].",
    "output_format": "A list of merged intervals, where each interval is represented by a pair of integers [start, end].",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "The intervals [1,3] and [2,6] overlap, so they are merged into [1,6]. The other intervals do not overlap."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "The intervals [1,4] and [4,5] touch, so they are merged into [1,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort intervals based on the starting point.",
      "Use a single list to keep track of merged intervals."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Fibonacci Number",
    "description": "The Fibonacci sequence is a series of numbers in which each number (after the first two) is the sum of the two preceding ones. The sequence typically starts with 0 and 1. Given an integer n, return the n-th Fibonacci number.",
    "topic": "Dynamic Programming",
    "subtopic": "Recursion",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Fibonacci"
    ],
    "input_format": "An integer n (0 <= n <= 30).",
    "output_format": "An integer representing the n-th Fibonacci number.",
    "constraints": [
      "0 <= n <= 30"
    ],
    "examples": [
      {
        "input": "n = 0",
        "output": "0",
        "explanation": "The 0th Fibonacci number is 0."
      },
      {
        "input": "n = 1",
        "output": "1",
        "explanation": "The 1st Fibonacci number is 1."
      },
      {
        "input": "n = 5",
        "output": "5",
        "explanation": "The Fibonacci sequence up to 5 is 0, 1, 1, 2, 3, 5. Hence, the 5th Fibonacci number is 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "The Fibonacci numbers can be calculated using a simple recursive function.",
      "Consider using memoization to optimize your recursive solution."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Find Median from Data Stream",
    "description": "The median is the middle value in a list of numbers sorted in ascending order. If there is an even number of numbers, there is no distinct middle value and the median will be the average of the two middle values. Design a data structure that supports the following two operations: 1. `addNum(num: int)`: Add a integer number from the data stream to the data structure. 2. `findMedian() -> float`: Return the median of all elements so far. The overall runtime complexity should be O(log(n)) for the `addNum` function and O(1) for the `findMedian` function.",
    "topic": "Design",
    "subtopic": "Data Structures",
    "tags": [
      "Heap",
      "Binary Search",
      "Design"
    ],
    "input_format": "An integer num for the addNum method.",
    "output_format": "A float representing the median of all numbers added so far.",
    "constraints": [
      "0 <= num <= 10^5",
      "The total number of calls to `addNum` will not exceed 10^4."
    ],
    "examples": [
      {
        "input": "addNum(1), addNum(2), findMedian()",
        "output": "1.5",
        "explanation": "The data stream is [1, 2]. The median is (1 + 2) / 2 = 1.5."
      },
      {
        "input": "addNum(3), findMedian()",
        "output": "2",
        "explanation": "The data stream is [1, 2, 3]. The median is 2."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using two heaps to maintain the median.",
      "The max heap can store the lower half of the numbers.",
      "The min heap can store the upper half of the numbers."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Rotate Image",
    "description": "You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise) in-place. You need to modify the input matrix directly.",
    "topic": "Matrix",
    "subtopic": "In-Place Transformation",
    "tags": [
      "Matrix",
      "In-Place",
      "Transformation"
    ],
    "input_format": "An n x n 2D array of integers, where 1 <= n <= 20, and 0 <= matrix[i][j] <= 1000.",
    "output_format": "The input matrix should be rotated in-place, with no return value.",
    "constraints": [
      "The matrix is of size n x n.",
      "1 <= n <= 20.",
      "0 <= matrix[i][j] <= 1000."
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]",
        "explanation": "The original matrix rotated 90 degrees clockwise results in the output matrix."
      },
      {
        "input": "matrix = [[ 5, 1, 9, 11], [ 2, 4, 8, 10], [13, 3, 6, 7], [15,14,12,16]]",
        "output": "[[15,13,2,5],[14, 3, 4, 1],[12, 6, 8, 9],[16, 7, 10, 11]]",
        "explanation": "The original matrix rotated 90 degrees clockwise results in the output matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider rotating the matrix layer by layer.",
      "You can use transposition followed by reversing the rows."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of k linked-lists, each linked-list is sorted in ascending order. Write a function to merge all the linked-lists into one sorted linked-list and return it.",
    "topic": "Linked List",
    "subtopic": "Merge Sorted Lists",
    "tags": [
      "Linked List",
      "Sorting",
      "Merge"
    ],
    "input_format": "An array of k linked-list nodes, where each linked-list node is represented as an object with a value and a pointer to the next node.",
    "output_format": "A single linked-list node that represents the head of the merged sorted linked-list.",
    "constraints": [
      "0 <= k <= 10^4",
      "0 <= node.val <= 10^4",
      "The total number of nodes in all linked-lists does not exceed 10^4."
    ],
    "examples": [
      {
        "input": "[1 -> 4 -> 5, 1 -> 3 -> 4, 2 -> 6]",
        "output": "1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6",
        "explanation": "Merging the three sorted linked-lists yields a single sorted list."
      },
      {
        "input": "[]",
        "output": "null",
        "explanation": "If there are no linked-lists to merge, the result is null."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a min-heap to efficiently get the smallest element.",
      "You can start with a dummy node to simplify the merging process."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "String to Integer (atoi)",
    "description": "Implement the function atoi that converts a string to a 32-bit signed integer. The function should ignore any leading whitespace characters and may only parse numbers until a non-numeric character is encountered. The result must be clamped to the range of a 32-bit signed integer. If the string does not contain a valid integer, return 0.",
    "topic": "String",
    "subtopic": "Parsing",
    "tags": [
      "String",
      "Parsing",
      "Integer"
    ],
    "input_format": "A string s representing the input string to be converted.",
    "output_format": "A 32-bit signed integer representing the converted value.",
    "constraints": [
      "1 <= s.length <= 200",
      "The resulting integer must fit within the range of a 32-bit signed integer."
    ],
    "examples": [
      {
        "input": "s = '   -42'",
        "output": "-42",
        "explanation": "Leading spaces are ignored, and the negative sign is recognized, resulting in -42."
      },
      {
        "input": "s = '4193 with words'",
        "output": "4193",
        "explanation": "Only '4193' is parsed before the letters, resulting in the integer 4193."
      },
      {
        "input": "s = 'words and 987'",
        "output": "0",
        "explanation": "The string does not begin with a number, so the result is 0."
      },
      {
        "input": "s = '-91283472332'",
        "output": "-2147483648",
        "explanation": "The number exceeds the lower limit of 32-bit signed integer, resulting in clamping to -2147483648."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Ignore leading whitespace.",
      "Identify the sign of the number.",
      "Convert characters to integers until you hit a non-numeric character.",
      "Clamp the result within 32-bit signed integer limits."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Rectangle Area",
    "description": "Write a function that calculates the area of a rectangle given its length and width. The function should take two parameters: length and width, and return the calculated area. The area of a rectangle is given by the formula: area = length * width.",
    "topic": "Geometry",
    "subtopic": "Area Calculation",
    "tags": [
      "Geometry",
      "Mathematics",
      "Area"
    ],
    "input_format": "Two integers representing the length and width of the rectangle.",
    "output_format": "An integer representing the area of the rectangle.",
    "constraints": [
      "1 <= length, width <= 10^4"
    ],
    "examples": [
      {
        "input": "length = 5, width = 3",
        "output": "15",
        "explanation": "The area is calculated as 5 * 3 = 15."
      },
      {
        "input": "length = 10, width = 10",
        "output": "100",
        "explanation": "The area is calculated as 10 * 10 = 100."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Remember to multiply length and width to get the area."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of bars in a histogram, compute how much water it can trap after raining. The water trapped between the bars depends on the heights of the bars to the left and right of each bar.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers representing the heights of the bars.",
    "output_format": "An integer representing the total amount of trapped rainwater.",
    "constraints": [
      "0 <= height.length <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The water trapped is 6 units. The total trapped water can be visualized as follows: 0 units at index 0, 0 at index 1, 1 at index 2, 0 at index 3, 1 at index 4, 2 at index 5, 1 at index 6, 3 at index 7, 2 at index 8, 1 at index 9, 2 at index 10, and 1 at index 11."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The amount of water trapped is 9 units. The visual representation shows water trapped between the heights considering the barriers on left and right sides."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the height of the tallest bar to the left and right of each bar.",
      "Use two pointers to traverse the array and calculate trapped water effectively.",
      "Think about the limiting height for trapping water at each index."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Find the Duplicate Number",
    "description": "Given an array of integers nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. You must not modify the input array and you must solve the problem in O(n) time and O(1) space. Return any duplicate number found in the array.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums, where 1 <= nums.length <= 10^5.",
    "output_format": "An integer representing any duplicate number found in the input array.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i] <= n"
    ],
    "examples": [
      {
        "input": "nums = [3, 1, 3, 4, 2]",
        "output": "3",
        "explanation": "The number 3 is repeated in the array."
      },
      {
        "input": "nums = [1, 2, 2]",
        "output": "2",
        "explanation": "The number 2 is repeated in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using two pointers to find the duplicate.",
      "Think about how you can relate to the indices of the array elements."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "topic": "Dynamic Programming",
    "subtopic": "Fibonacci Sequence",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Fibonacci"
    ],
    "input_format": "An integer n representing the total number of steps in the staircase.",
    "output_format": "An integer representing the number of distinct ways to climb to the top.",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: 1 step + 1 step or 2 steps."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, or 2 steps + 1 step."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider the base cases for small values of n.",
      "Can you express the problem in terms of smaller instances?"
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Kth Largest Element in an Array",
    "description": "Given an integer array nums and an integer k, return the k-th largest element in the array. Note that it is the k-th largest element in the sorted order, not the k-th distinct element. You must solve it in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Sorting and Searching",
    "tags": [
      "Array",
      "Sorting",
      "Searching"
    ],
    "input_format": "An integer array nums of length n and an integer k.",
    "output_format": "An integer representing the k-th largest element in the array.",
    "constraints": [
      "1 <= n <= 10^5",
      "1 <= k <= n",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 1, 5, 6, 4], k = 2",
        "output": "5",
        "explanation": "The second largest element in the sorted array [1, 2, 3, 4, 5, 6] is 5."
      },
      {
        "input": "nums = [3, 2, 3, 1, 2, 4, 5, 5, 6], k = 4",
        "output": "4",
        "explanation": "The fourth largest element in the sorted array [1, 2, 2, 3, 3, 4, 5, 5, 6] is 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a min-heap to keep track of the k largest elements.",
      "You can use the Quickselect algorithm to achieve O(n) time complexity."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Insert Delete GetRandom O(1)",
    "description": "Design a data structure that supports the following operations: insert, delete, and getRandom. All operations should be done in average O(1) time complexity.\n\n- insert(val): Inserts an item val to the set if not present.\n- remove(val): Removes an item val from the set if present.\n- getRandom: Returns a random element from the current set of elements (it can be assumed that the set is non-empty).",
    "topic": "Design",
    "subtopic": "Data Structure",
    "tags": [
      "Design",
      "Random",
      "Data Structure"
    ],
    "input_format": "You can assume that the input will only contain the operations insert, remove, and getRandom.",
    "output_format": "Return the random value from the set for the getRandom operation.",
    "constraints": [
      "All elements in the set will be unique.",
      "Operations will be performed using a valid input and will not exceed 10^6.",
      "You may assume getRandom will only be called if there is at least one element in the set."
    ],
    "examples": [
      {
        "input": "obj = RandomizedSet()\nobj.insert(1)\nobj.remove(2)\nobj.insert(2)\nobj.getRandom()",
        "output": "1 or 2",
        "explanation": "After the operations, the set contains [1, 2]. getRandom returns either 1 or 2 with equal probability."
      },
      {
        "input": "obj = RandomizedSet()\nobj.insert(1)\nobj.remove(1)\nobj.insert(2)\nobj.getRandom()",
        "output": "2",
        "explanation": "After removing 1, only 2 is in the set, so getRandom returns 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about using a hash map for constant time access.",
      "Consider an array to store the elements for random access."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Copy List with Random Pointer",
    "description": "You are given a linked list with a random pointer, where each node contains a value, a next pointer to the next node in the list, and a random pointer, which can point to any node in the list or null. Your task is to create a deep copy of the linked list. Each node in the new linked list should have the same value as the corresponding node in the original list. The next pointers of the copied nodes should point to the copied nodes in the order they were in the original list, and the random pointers should point to the correct copied nodes as they did in the original list.",
    "topic": "Linked List",
    "subtopic": "Copying Linked List",
    "tags": [
      "Linked List",
      "Deep Copy",
      "Pointers"
    ],
    "input_format": "The head of the linked list with random pointers.",
    "output_format": "The head of the new copied linked list.",
    "constraints": [
      "1 <= N <= 1000",
      "All node values are unique.",
      "The random pointer of a node can point to any node in the list or null."
    ],
    "examples": [
      {
        "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "explanation": "Each node is copied with proper next and random pointer references."
      },
      {
        "input": "head = [[1,1],[2,1]]",
        "output": "[[1,1],[2,1]]",
        "explanation": "There are two nodes, both have random pointers pointing to the first node."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hashmap to keep track of copied nodes.",
      "Consider two passes over the linked list."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Intersection of Two Linked Lists",
    "description": "Given the heads of two singly linked lists, determine if the two linked lists intersect. If they do, return the node at which the intersection occurs. If they do not, return null. For example, the intersection of list A and list B can be defined as the node that exists in both lists.",
    "topic": "Linked List",
    "subtopic": "Intersection",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Intersection"
    ],
    "input_format": "The heads of two singly linked lists, A and B.",
    "output_format": "A reference to the node where the two linked lists intersect, or null if there is no intersection.",
    "constraints": [
      "The number of nodes in the lists will be in the range [0, 10^4].",
      "The values of the nodes will range between 0 and 10^6.",
      "The input lists are guaranteed to not have cycles."
    ],
    "examples": [
      {
        "input": "A = [4, 1, 8, 4], B = [5, 0, 1, 8, 4]",
        "output": "Node with value 8",
        "explanation": "The two lists intersect at node with value 8."
      },
      {
        "input": "A = [1, 9, 1, 2, 4], B = [3, 2, 4]",
        "output": "Node with value 2",
        "explanation": "The two lists intersect at node with value 2."
      },
      {
        "input": "A = [2, 6, 4], B = [1, 5]",
        "output": "null",
        "explanation": "The two lists do not intersect."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to traverse both lists.",
      "If they coincide, they are at the intersection point.",
      "Consider the lengths of both lists."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "H-Index",
    "description": "Given an array of citations where citations[i] is the number of citations a researcher received for their i-th paper, compute the researcher's H-index. The H-index is defined as the maximum value h such that the researcher has published h papers that have each been cited at least h times.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Greedy"
    ],
    "input_format": "An array of integers citations where 0 <= citations[i] <= 1000.",
    "output_format": "An integer representing the H-index of the researcher.",
    "constraints": [
      "1 <= citations.length <= 5000",
      "0 <= citations[i] <= 1000"
    ],
    "examples": [
      {
        "input": "[3, 0, 6, 1, 5]",
        "output": "3",
        "explanation": "The researcher has 3 papers with at least 3 citations each (3, 5, and 6), so the H-index is 3."
      },
      {
        "input": "[1, 3, 1]",
        "output": "1",
        "explanation": "The researcher has 1 paper with at least 1 citation, so the H-index is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the citations array to simplify determining the H-index.",
      "Consider the relationship between the index and the number of citations."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Validate Binary Search Tree",
    "description": "Given the root of a binary tree, determine if it is a valid Binary Search Tree (BST). A BST is valid if for every node, all values in its left subtree are less than the node's value, and all values in its right subtree are greater than the node's value.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "The input is the root node of a binary tree.",
    "output_format": "Return true if the binary tree is a valid BST, otherwise return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 10^4].",
      "0 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "root = [2, 1, 3]",
        "output": "true",
        "explanation": "The left subtree contains nodes with values less than 2, and the right subtree contains nodes with values greater than 2, hence it is a valid BST."
      },
      {
        "input": "root = [5, 1, 4, null, null, 3, 6]",
        "output": "false",
        "explanation": "The node with value 3 is in the right subtree of 5 but is less than 5, hence it is not a valid BST."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a recursive approach to verify the BST properties.",
      "Keep track of the valid range for each node while traversing."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List II",
    "description": "Given the head of a singly linked list and two integers left and right, reverse the nodes of the list from position left to position right, and return the modified list.",
    "topic": "Linked List",
    "subtopic": "Reversal",
    "tags": [
      "Linked List",
      "Reversal",
      "Two Pointers"
    ],
    "input_format": "The first input is the head of the linked list. The second and third inputs are the integers left and right specifying the range to reverse.",
    "output_format": "The head of the modified linked list after reversing the specified range.",
    "constraints": [
      "1 <= left <= right <= n (where n is the number of nodes in the list)",
      "The number of nodes in the list is within the range [1, 500]."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], left = 2, right = 4",
        "output": "[1, 4, 3, 2, 5]",
        "explanation": "Reversing the nodes from position 2 to position 4 yields the modified list."
      },
      {
        "input": "head = [1, 2, 3, 4, 5], left = 1, right = 1",
        "output": "[1, 2, 3, 4, 5]",
        "explanation": "No reversal is needed when left and right are the same."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dummy node to simplify the reversal at any position.",
      "Consider reversing the links in-place using pointers."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Sliding Puzzle",
    "description": "You are given a 3x2 grid representing a sliding puzzle. The puzzle contains six tiles numbered from 1 to 5 and a blank space. The objective is to move the tiles such that they are arranged in the following order: [[1, 2, 3], [4, 5, 0]]. The blank space is represented by 0. You can slide a tile into the empty space if they are adjacent. Write a function to determine if it's possible to reach the goal state from the initial state. Return true if it is possible, otherwise return false.",
    "topic": "Backtracking",
    "subtopic": "Game State",
    "tags": [
      "Backtracking",
      "Game",
      "State"
    ],
    "input_format": "A 2D list representing the initial state of the sliding puzzle.",
    "output_format": "A boolean value indicating whether it is possible to reach the goal state.",
    "constraints": [
      "The grid consists of numbers 0-5 where 0 represents the blank space.",
      "The initial state is always a valid configuration."
    ],
    "examples": [
      {
        "input": "[[1, 2, 3], [4, 0, 5]]",
        "output": "true",
        "explanation": "You can slide the tile '5' to the left to obtain the goal state."
      },
      {
        "input": "[[1, 2, 3], [5, 4, 0]]",
        "output": "false",
        "explanation": "No sequence of moves can rearrange the tiles to the goal state."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the possible positions of the blank space in relation to adjacent tiles.",
      "Think about how many positions the tiles can reach from the initial configuration."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Single Element in a Sorted Array",
    "description": "You are given a sorted array of integers where every element appears exactly twice, except for one element that appears only once. Your task is to find that single element in the array. The array is sorted in non-decreasing order.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Binary Search",
      "Searching"
    ],
    "input_format": "An array of integers nums where each element appears exactly twice except for one element.",
    "output_format": "An integer representing the single element that appears only once.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "nums[i] == nums[i + 1] or nums[i] == nums[i - 1] for i in range(1, nums.length - 1)",
      "The array is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2, 2, 3, 3, 4, 5, 5]",
        "output": "4",
        "explanation": "The number 4 appears only once in the array, while all other numbers appear twice."
      },
      {
        "input": "nums = [0, 1, 1, 2, 2, 3, 3, 7, 7]",
        "output": "0",
        "explanation": "The number 0 appears only once in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using a binary search to find the single element.",
      "If the mid index is even, check the next index to see if it's the same.",
      "When elements are paired, the first element of the pair will always be at an even index."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order. The spiral order starts from the top-left corner of the matrix and proceeds to the right, then downwards, then to the left, and finally upwards, continuing this pattern until all elements are visited.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral"
    ],
    "input_format": "An m x n matrix of integers.",
    "output_format": "A list of integers representing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "m * n <= 10^6",
      "-10^9 <= matrix[i][j] <= 10^9"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The elements in spiral order are 1, 2, 3, 6, 9, 8, 7, 4, and 5."
      },
      {
        "input": "matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]",
        "output": "[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]",
        "explanation": "Following the spiral order, we traverse through the matrix elements as shown."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider maintaining a boundary for the left, right, top, and bottom sides of the matrix.",
      "Use a direction variable to navigate through the matrix in the correct order."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Maximal Square",
    "description": "Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "2D DP Array",
    "tags": [
      "Dynamic Programming",
      "Matrix",
      "Square"
    ],
    "input_format": "A 2D binary matrix represented as a list of lists, where each element is either '0' or '1'.",
    "output_format": "An integer representing the area of the largest square containing only 1's.",
    "constraints": [
      "1 <= matrix.length <= 300",
      "1 <= matrix[i].length <= 300",
      "matrix[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": [
          [
            "1",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "0",
            "1",
            "1",
            "1"
          ],
          [
            "1",
            "1",
            "1",
            "1",
            "1"
          ],
          [
            "1",
            "0",
            "0",
            "1",
            "0"
          ]
        ],
        "output": "4",
        "explanation": "The largest square has a side length of 2, thus its area is 2 * 2 = 4."
      },
      {
        "input": [
          [
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "1",
            "1"
          ],
          [
            "0",
            "1",
            "1"
          ]
        ],
        "output": "4",
        "explanation": "The largest square has a side length of 2 which forms the area of 2 * 2 = 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dynamic programming approach to solve the problem.",
      "Use a DP array to store the largest square ending at each point."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Snapshot Array",
    "description": "Design a data structure that supports the following operations on a snapshot array:\n\n1. `init(int length)`: Initializes a snapshot array with a given length, where each element is initialized to 0.\n2. `set(int index, int val)`: Sets the value at index `index` to `val`.\n3. `snap()`: Takes a snapshot of the array and returns the snapshot's index. A snapshot is a read-only view of the array at the time of the call.\n4. `get(int index, int snap_id)`: Returns the value at the given `index` from the snapshot with the given `snap_id`.\n\nA `snap_id` is a non-negative integer representing the snapshot's order of creation, starting at 0 for the first `snap()` call. The value returned by `get(index, snap_id)` is the value of the array for the given index at the time the snap was taken.",
    "topic": "Design",
    "subtopic": "Data Structure",
    "tags": [
      "Design",
      "Data Structure",
      "Array"
    ],
    "input_format": "The input consists of multiple operations defined sequentially as per the above methods.",
    "output_format": "Output from the `snap()` and `get(index, snap_id)` methods.",
    "constraints": [
      "1 <= length <= 5000",
      "0 <= index < length",
      "0 <= val <= 10^9",
      "Snap operations do not exceed 5000."
    ],
    "examples": [
      {
        "input": "SnapshotArray snapshotArray = new SnapshotArray(3);\nsnapshotArray.set(0, 5);\nsnapshotArray.snap();\nsnapshotArray.set(0, 6);\nint val = snapshotArray.get(0, 0);",
        "output": "5",
        "explanation": "After setting index 0 to 5, we take a snapshot which returns snap_id 0. Then, we set index 0 to 6, but when we call get(0, 0), it returns the value at index 0 from snapshot 0, which is 5."
      },
      {
        "input": "snapshotArray.set(0, 10);\nsnapshotArray.snap();\nsnapshotArray.set(0, 15);\nint val = snapshotArray.get(0, 0);",
        "output": "10",
        "explanation": "The first snapshot captures the value 10 at index 0. The subsequent sets do not affect the first snapshot, so get(0, 0) returns 10."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a list of dictionaries to store snapshots.",
      "Indexes of snapshots can be managed using an incremental variable."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Break a Palindrome",
    "description": "Given a string that represents a palindrome, your task is to break it by changing exactly one character. If it's not possible to break the palindrome, return an empty string. A palindrome is a string that reads the same forwards and backwards.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Palindrome",
      "Manipulation"
    ],
    "input_format": "A single string s, which is guaranteed to be a palindrome.",
    "output_format": "A string that is not a palindrome after changing one character, or an empty string if it's not possible.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "aba",
        "output": "aaa",
        "explanation": "Changing the second 'b' to 'a' would break the palindrome, resulting in 'aaa'."
      },
      {
        "input": "abba",
        "output": "aaba",
        "explanation": "Changing the second 'b' to 'a' results in 'aaba', which is not a palindrome."
      },
      {
        "input": "aa",
        "output": "ab",
        "explanation": "Changing the second 'a' to 'b' results in 'ab', which is not a palindrome."
      },
      {
        "input": "a",
        "output": "",
        "explanation": "It's impossible to make a single character non-palindromic."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider changing the first character if possible.",
      "If all characters are the same, try changing the last character."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Binary Tree Maximum Path Sum",
    "description": "Given a non-empty binary tree, return the maximum path sum. The path may start and end at any node in the tree. The path sum of a tree node is defined as the sum of the node's value, plus the maximum sum of the nodes' values from both its left and right children. If a node has no left or right child, its contribution to the path sum is considered as 0. Therefore, for a single node tree, the maximum path sum is the value of the node itself.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth-First Search",
      "Dynamic Programming"
    ],
    "input_format": "A binary tree node represented using a TreeNode class where each node contains an integer value and pointers to its left and right children.",
    "output_format": "An integer representing the maximum path sum in the binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 3 * 10^4].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [-10, 9, 20, null, null, 15, 7]",
        "output": "42",
        "explanation": "The maximum path sum is 15 -> 20 -> 7, which is 15 + 20 + 7 = 42."
      },
      {
        "input": "root = [1]",
        "output": "1",
        "explanation": "The maximum path sum is the only node itself, which is 1."
      },
      {
        "input": "root = [2, -1, 3]",
        "output": "5",
        "explanation": "The maximum path sum is 2 -> 3, which is 2 + 3 = 5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using DFS to explore all paths.",
      "Keep track of the maximum sum found during traversal.",
      "A path may include both children of a node but consider the path from the node to a leaf."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Delete Duplicate Folders in System",
    "description": "You are given a list of folder paths in a file system. Each folder path is represented as a string, and the path starts with a '/' followed by the folder names separated by '/'. Your task is to delete duplicate folders such that the unique folder structures remain. Two folders are considered duplicates if their structures are identical. Return a list of the unique folder paths in lexicographic order.",
    "topic": "String",
    "subtopic": "Path Manipulation",
    "tags": [
      "String",
      "Path",
      "Data Structure"
    ],
    "input_format": "A list of strings representing folder paths.",
    "output_format": "A list of strings representing unique folder paths in lexicographic order.",
    "constraints": [
      "1 <= folderPaths.length <= 10^4",
      "1 <= folderPaths[i].length <= 100"
    ],
    "examples": [
      {
        "input": "folderPaths = ['/a', '/a/b', '/a/b/c', '/a/b']",
        "output": "['/a', '/a/b', '/a/b/c']",
        "explanation": "Folder '/a/b' is a duplicate and can be deleted."
      },
      {
        "input": "folderPaths = ['/a/b/c', '/a/b', '/a/b/c/d', '/a']",
        "output": "['/a', '/a/b', '/a/b/c', '/a/b/c/d']",
        "explanation": "No folders are duplicates, all remain."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Utilize a data structure to track existing folder structures.",
      "Consider a depth-first or breadth-first approach to navigate through the folder paths."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Minimum Size Subarray Sum",
    "description": "Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Two Pointers"
    ],
    "input_format": "An array of positive integers nums and a positive integer target.",
    "output_format": "An integer representing the minimal length of a contiguous subarray with sum >= target, or 0 if no such subarray exists.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i] <= 10^9",
      "1 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2,3,1,2,4,3], target = 7",
        "output": "2",
        "explanation": "The subarray [4,3] has the minimal length under the constraint, as its sum is 7."
      },
      {
        "input": "nums = [1,4,4], target = 4",
        "output": "1",
        "explanation": "The subarray [4] is of length 1 and has a sum of 4, which meets the target."
      },
      {
        "input": "nums = [1,1,1,1,1,1,1,1], target = 11",
        "output": "0",
        "explanation": "No subarray can meet the target sum of 11."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to use a sliding window approach to keep track of the sum.",
      "When the sum exceeds or meets the target, try to shrink the window from the left."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Serialize and Deserialize Binary Tree",
    "description": "Implement a binary tree serialization and deserialization algorithm. A binary tree is a tree data structure where each node has at most two children. Your goal is to create a method `serialize` that converts a binary tree to a string representation and a method `deserialize` that converts the string back to the original binary tree. The serialization format should be a level order traversal of the tree, where `null` represents empty child nodes.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Serialization",
      "Deserialization"
    ],
    "input_format": "A binary tree rooted at the given node.",
    "output_format": "A string that represents the serialized binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "The values of the nodes are in the range [-10^4, 10^4]."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, null, null, 4, 5]",
        "output": "'[1,2,3,null,null,4,5]'",
        "explanation": "The serialized string represents a binary tree where the root is 1, its left child is 2, its right child is 3, and so on."
      },
      {
        "input": "root = []",
        "output": "'[]'",
        "explanation": "An empty tree is serialized to an empty string."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a queue to help with level order traversal.",
      "Use a delimiter to separate values in the serialized string."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Maximum Sum of Distinct Subarrays With Length K",
    "description": "Given an array of integers nums, return the maximum sum of distinct elements among all subarrays of length K. A subarray is a contiguous part of an array. If no such subarray exists, return 0.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "An integer array nums and an integer K.",
    "output_format": "An integer representing the maximum sum of distinct elements among all subarrays of length K.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= K <= nums.length",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 1, 3, 4], K = 3",
        "output": "7",
        "explanation": "The distinct subarray of length 3 is [1, 3, 4] with a sum of 7."
      },
      {
        "input": "nums = [4, 5, 4, 2, 4], K = 2",
        "output": "9",
        "explanation": "The distinct subarray of length 2 is [4, 5] with a sum of 9."
      },
      {
        "input": "nums = [1, 1, 1, 1], K = 2",
        "output": "0",
        "explanation": "There are no distinct elements in any subarray of length 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a HashMap to track the counts of elements within the window.",
      "Use a sliding window approach to maintain the current subarray of length K."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function that finds the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".",
    "topic": "String",
    "subtopic": "Prefix",
    "tags": [
      "String",
      "Prefix",
      "Array"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A string representing the longest common prefix.",
    "constraints": [
      "0 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "All strings consist of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The longest common prefix is \"fl\"."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among the strings."
      },
      {
        "input": "strs = [\"ab\", \"a\"]",
        "output": "\"a\"",
        "explanation": "The longest common prefix is \"a\"."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Check characters one by one until they differ.",
      "You can start with the first string as a prefix and compare it with others."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Convert Binary Search Tree to Sorted Doubly Linked List",
    "description": "Given the root of a Binary Search Tree (BST), convert it to a sorted doubly linked list in place. The left and right pointers in the tree nodes should point to the previous and next nodes in the doubly linked list respectively. The head of the doubly linked list should be returned.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Doubly Linked List"
    ],
    "input_format": "The root of a Binary Search Tree (TreeNode).",
    "output_format": "The head of the sorted doubly linked list (TreeNode).",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [4,2,5,1,3]",
        "output": "[1,2,3,4,5]",
        "explanation": "The doubly linked list is: 1 <-> 2 <-> 3 <-> 4 <-> 5."
      },
      {
        "input": "root = [2,1,3]",
        "output": "[1,2,3]",
        "explanation": "The doubly linked list is: 1 <-> 2 <-> 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Inorder traversal of the BST gives a sorted array.",
      "Keep track of the previous node during traversal."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List",
    "description": "Given the head of a singly linked list, reverse the list and return its reversed head.",
    "topic": "Linked List",
    "subtopic": "Reversing a Linked List",
    "tags": [
      "LinkedList",
      "Reversal",
      "Pointer Manipulation"
    ],
    "input_format": "The head of a singly linked list where each node has a value and a reference to the next node.",
    "output_format": "The head of the reversed singly linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 5000].",
      "-5000 <= Node.val <= 5000"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5]",
        "output": "[5, 4, 3, 2, 1]",
        "explanation": "Reversing the linked list results in the order being flipped from 1 -> 2 -> 3 -> 4 -> 5 to 5 -> 4 -> 3 -> 2 -> 1."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "An empty linked list remains empty when reversed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using three pointers to reverse the links in the list.",
      "Think about the base case when you reach the end of the list."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Find Pivot Index",
    "description": "Given an integer array nums, find the pivot index of this array. The pivot index is the index where the sum of all the numbers to the left of the index is equal to the sum of all the numbers to the right of the index. If no such index exists, return -1. If there are multiple pivot indexes, you should return the leftmost pivot index.",
    "topic": "Array",
    "subtopic": "Prefix Sum",
    "tags": [
      "Array",
      "Prefix Sum",
      "Sum"
    ],
    "input_format": "An integer array nums of length n.",
    "output_format": "An integer representing the pivot index or -1 if it does not exist.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-1000 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [1, 7, 3, 6, 5, 6]",
        "output": "3",
        "explanation": "The pivot index is 3 because the sum of numbers to the left is 1 + 7 + 3 = 11, and the sum of numbers to the right is 5 + 6 = 11."
      },
      {
        "input": "nums = [1, 2, 3]",
        "output": "-1",
        "explanation": "There is no pivot index as the sum of left side is not equal to the sum of right side at any index."
      },
      {
        "input": "nums = [2, 1, -1]",
        "output": "0",
        "explanation": "The pivot index is 0 because the sum of numbers to the left is 0, and the sum of numbers to the right is 1 + -1 = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a prefix sum to keep track of the left sum.",
      "Iterate through the array once and calculate the right sum in each iteration.",
      "Remember to subtract the current element from the total when calculating the right sum."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Ways to Make a Fair Array",
    "description": "You are given an array of integers. Your task is to determine the number of ways you can split the array into two non-empty parts such that the sum of the elements in both parts is equal. A split is defined by choosing an index such that all elements before that index belong to the first part and all elements from that index and after belong to the second part. Return the number of valid splits.",
    "topic": "Array",
    "subtopic": "Prefix Sum",
    "tags": [
      "Array",
      "Prefix Sum",
      "Counting"
    ],
    "input_format": "An array of integers, nums.",
    "output_format": "An integer representing the number of valid splits.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 1, 1, 1]",
        "output": "4",
        "explanation": "All splits between indices 1 and 4 are valid because both parts will have equal sums (3 each)."
      },
      {
        "input": "nums = [2, 3, 6, 4, 2, 1]",
        "output": "1",
        "explanation": "Only one split (index 3) gives two parts with equal sums (11 each)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a prefix sum to keep track of the sum of elements.",
      "Check conditions for splits while iterating through the array."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Design HashMap",
    "description": "Design a HashMap without using built-in hash table libraries. It should support the following operations: put(key, value), get(key), remove(key). Implement the methods such that the average time complexity for each of these operations is O(1).",
    "topic": "Data Structure",
    "subtopic": "Hash Table",
    "tags": [
      "HashMap",
      "Data Structure",
      "Design"
    ],
    "input_format": "The input will consist of a list of operations to perform, each represented as a tuple (operation, key, value). For the 'get' and 'remove' operations, the value can be ignored.",
    "output_format": "Return the results for all 'get' operations in the order they were called.",
    "constraints": [
      "All keys are unique.",
      "The number of operations will not exceed 10^4.",
      "Keys and values are non-negative integers."
    ],
    "examples": [
      {
        "input": "[('put', 1, 1), ('put', 2, 2), ('get', 1), ('get', 3), ('put', 2, 1), ('get', 2), ('remove', 2), ('get', 2)]",
        "output": "[1, -1, 1, -1]",
        "explanation": "get(1) returns 1, get(3) returns -1 as key 3 does not exist, get(2) returns 1 after updating key 2."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider collision resolution strategies like chaining or open addressing.",
      "Use a list to store values at each index of the hash table."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Double a Number Represented as a Linked List",
    "description": "Given a non-negative integer represented as a linked list, where each node contains a single digit, double the number and return the result as a linked list. The digits are stored in reverse order, meaning that the head of the list represents the least significant digit.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "LinkedList",
      "Mathematics",
      "Simulation"
    ],
    "input_format": "The head of a singly linked list representing a non-negative integer.",
    "output_format": "The head of a new linked list representing the doubled number.",
    "constraints": [
      "The linked list has at least one node.",
      "Each node's value is a digit in the range [0, 9]."
    ],
    "examples": [
      {
        "input": "[2, 4, 3]",
        "output": "[4, 8, 6]",
        "explanation": "The number represented is 342. Doubling it gives 684, which is represented as [4, 8, 6] in reverse order."
      },
      {
        "input": "[1, 0, 0]",
        "output": "[0, 0, 2]",
        "explanation": "The number represented is 100. Doubling it gives 200, which is represented as [0, 0, 2] in reverse order."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to handle carry while doubling each digit.",
      "You may need a new node if the doubled digit exceeds 9."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Find The Original Array of Prefix Xor",
    "description": "You are given an array 'prefix' of length n, where prefix[i] is the XOR of the elements from the start of the original array to the ith index. Your task is to reconstruct the original array from the given prefix array. You may assume that the original array only contains non-negative integers.",
    "topic": "Array",
    "subtopic": "XOR",
    "tags": [
      "Array",
      "XOR",
      "Bit Manipulation"
    ],
    "input_format": "An array of integers prefix representing the prefix XORs of the original array.",
    "output_format": "An array of integers representing the reconstructed original array.",
    "constraints": [
      "1 <= prefix.length <= 10^5",
      "0 <= prefix[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "prefix = [1, 3, 2, 0]",
        "output": "[1, 2, 1, 0]",
        "explanation": "The original array can be calculated as follows: original[0] = prefix[0], original[1] = prefix[1] XOR prefix[0], original[2] = prefix[2] XOR prefix[1], original[3] = prefix[3] XOR prefix[2]."
      },
      {
        "input": "prefix = [5, 1, 1, 0]",
        "output": "[5, 4, 0, 0]",
        "explanation": "Using the prefix XOR, we can reconstruct the original array: original[0] = 5, original[1] = 5 XOR 1 = 4, original[2] = 1 XOR 1 = 0, original[3] = 0 XOR 1 = 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "The first element of the original array is the same as the first element of the prefix array.",
      "Use the XOR properties to derive the elements of the original array from the prefix array."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Minimum Knight Moves",
    "description": "A knight is positioned on an infinite chessboard, and it is allowed to move in an L-shape (two squares in one direction and then one square perpendicular, or vice versa). Given a starting position of the knight, you need to determine the minimum number of moves required for the knight to reach a target position on the chessboard. The positions are given as coordinates (x, y).",
    "topic": "Graph",
    "subtopic": "Shortest Path",
    "tags": [
      "Graph",
      "BFS",
      "Shortest Path"
    ],
    "input_format": "Two pairs of integers, start and target, representing the starting coordinates and the target coordinates respectively.",
    "output_format": "An integer representing the minimum number of moves required from the start position to reach the target.",
    "constraints": [
      "-300 <= start[0], start[1], target[0], target[1] <= 300"
    ],
    "examples": [
      {
        "input": "start = [0, 0], target = [1, 2]",
        "output": "1",
        "explanation": "The knight can reach (1, 2) from (0, 0) in one move."
      },
      {
        "input": "start = [0, 0], target = [2, 1]",
        "output": "1",
        "explanation": "The knight can reach (2, 1) from (0, 0) in one move."
      },
      {
        "input": "start = [0, 0], target = [3, 3]",
        "output": "2",
        "explanation": "The knight can move to (1, 2) then to (3, 3) in 2 moves."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a BFS approach to explore all possible moves.",
      "Track visited positions to prevent cycles."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Merge Sorted Array",
    "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. You need to merge nums2 into nums1 as one sorted array. Note that nums1 has enough space (size that is equal to m + n) to hold additional elements from nums2.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "Two integer arrays nums1 and nums2, and two integers m and n.",
    "output_format": "No return value; modify nums1 in-place to be the merged sorted array.",
    "constraints": [
      "0 <= m, n <= 200",
      "1 <= m + n <= 200",
      "-10^9 <= nums1[i], nums2[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3",
        "output": "[1, 2, 2, 3, 5, 6]",
        "explanation": "After merging, the sorted array is [1, 2, 2, 3, 5, 6]."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "No elements to merge, so nums1 remains [1]."
      },
      {
        "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
        "output": "[1]",
        "explanation": "nums1 is empty, so after merging, it becomes [1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers to traverse both arrays.",
      "Start merging from the back of the arrays to utilize the space effectively."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Implement Trie (Prefix Tree)",
    "description": "A Trie (pronounced as 'try') is a special type of tree used to store associative data structures. A trie can be used to search for words in a prefix-based manner. Implement the following operations in your Trie class: insert(word), search(word), and startsWith(prefix). Your implementation should be efficient in terms of time and space complexity.",
    "topic": "Design",
    "subtopic": "Trie",
    "tags": [
      "Trie",
      "Data Structure",
      "Design"
    ],
    "input_format": "A string `word` for the insert and search methods, and a string `prefix` for the startsWith method.",
    "output_format": "Return true if the word is in the trie, false otherwise for `search`. For `startsWith`, return true if there is any word in the trie that starts with the given prefix, false otherwise.",
    "constraints": [
      "1 <= word.length, prefix.length <= 200",
      "All inputs are lowercase letters a-z."
    ],
    "examples": [
      {
        "input": "Trie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");",
        "output": "true",
        "explanation": "The word 'apple' was inserted into the trie and is successfully found by the search method."
      },
      {
        "input": "trie.search(\"app\");",
        "output": "false",
        "explanation": "The word 'app' has not been inserted into the trie."
      },
      {
        "input": "trie.startsWith(\"app\");",
        "output": "true",
        "explanation": "There is a word 'apple' in the trie that starts with the prefix 'app'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to represent each character in a node of the trie.",
      "Use an array or map for child nodes of each trie node."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Max Points on a Line",
    "description": "Given an array of points where points[i] = [xi, yi] represents a point on a 2D plane, return the maximum number of points that lie on the same straight line.",
    "topic": "Geometry",
    "subtopic": "Line and Points",
    "tags": [
      "Geometry",
      "Math",
      "Points",
      "Line"
    ],
    "input_format": "An array of points represented as a list of lists, where each inner list contains two integers [xi, yi].",
    "output_format": "An integer representing the maximum number of points that lie on the same straight line.",
    "constraints": [
      "1 <= points.length <= 3000",
      "-10^4 <= points[i][0], points[i][1] <= 10^4",
      "All the points are unique."
    ],
    "examples": [
      {
        "input": "points = [[1,1],[2,2],[3,3]]",
        "output": "3",
        "explanation": "All three points are on the line y = x."
      },
      {
        "input": "points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]",
        "output": "4",
        "explanation": "The points [1,1], [2,3], [3,2], and [4,1] can be shown to lie on the same line."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a hashmap to track the slopes of the lines formed by points.",
      "Consider vertical lines as a special case.",
      "Iterate through each point and calculate the slopes with every other point."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Keys and Rooms",
    "description": "You have n rooms labeled from 0 to n - 1. Each room may contain some keys to other rooms. Initially, you are in room 0. You are given an array of lists rooms where rooms[i] is a list of keys that you can get in room i. For instance, if rooms[0] = [1, 2], then you can find the keys for rooms 1 and 2 in room 0. Your task is to determine if you can visit all rooms.",
    "topic": "Graph",
    "subtopic": "Depth First Search",
    "tags": [
      "Graph",
      "DFS",
      "Backtracking"
    ],
    "input_format": "An array of lists where each list contains integers representing the keys found in each room.",
    "output_format": "Return true if you can visit all rooms, otherwise return false.",
    "constraints": [
      "1 <= rooms.length <= 100",
      "0 <= rooms[i].length <= 100",
      "The keys in rooms[i] are unique."
    ],
    "examples": [
      {
        "input": "rooms = [[1],[2],[3],[]]",
        "output": "true",
        "explanation": "You start in room 0, and you can access rooms 1, 2, and 3 sequentially."
      },
      {
        "input": "rooms = [[1,3],[3,0,1],[2],[0]]",
        "output": "false",
        "explanation": "You can access room 1 but cannot access room 2 or room 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth First Search (DFS) or Breadth First Search (BFS) to explore the rooms.",
      "Maintain a visited set to track which rooms have been accessed."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Find Peak Element",
    "description": "A peak element in an array is an element that is greater than or equal to its neighbors. Given an integer array nums, you need to find a peak element and return its index. You may imagine that nums[-1] = nums[n] = -\u221e. You must write an algorithm that runs in O(log n) time complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Peak Element"
    ],
    "input_format": "An integer array nums with at least one element.",
    "output_format": "An integer representing the index of any peak element.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "\u221210^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "2",
        "explanation": "nums[2] = 3 is a peak element as it is greater than its neighbors nums[1] = 2 and nums[3] = 1."
      },
      {
        "input": "nums = [1, 2, 1, 3, 5, 6, 4]",
        "output": "1 or 5",
        "explanation": "nums[1] = 2 is a peak element or nums[5] = 6 can also be a peak element."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a binary search approach.",
      "Look for a point where the order changes."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Majority Element",
    "description": "Given an integer array nums of size n, return the majority element. The majority element is the element that appears more than n / 2 times. You may assume that the majority element always exists in the array.",
    "topic": "Array",
    "subtopic": "Finding Elements",
    "tags": [
      "Array",
      "Counting",
      "Majority Element"
    ],
    "input_format": "An integer array nums.",
    "output_format": "An integer representing the majority element.",
    "constraints": [
      "1 <= n <= 5 * 10^4",
      "\u221210^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 3]",
        "output": "3",
        "explanation": "The number 3 appears 2 times which is more than 3/2 = 1.5."
      },
      {
        "input": "nums = [2, 2, 1, 1, 1, 2, 2]",
        "output": "2",
        "explanation": "The number 2 appears 4 times which is more than 7/2 = 3.5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a hash map to count occurrences.",
      "More efficient than O(n) for time complexity can be achieved."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock IV",
    "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. However, you can complete at most k transactions. A transaction consists of buying and then selling one share of the stock. Return the maximum profit you can achieve after at most k transactions. If you cannot achieve any profit, return 0.",
    "topic": "Dynamic Programming",
    "subtopic": "Stock Buy and Sell",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An integer k representing the maximum number of transactions, and an integer array prices representing the price of a stock on each day.",
    "output_format": "An integer representing the maximum profit.",
    "constraints": [
      "0 <= k <= 100",
      "0 <= prices.length <= 1000",
      "0 <= prices[i] <= 1000"
    ],
    "examples": [
      {
        "input": "k = 2, prices = [2,4,1]",
        "output": "2",
        "explanation": "Buy on day 1 (price = 2) and sell on day 2 (price = 4). Profit = 4 - 2 = 2."
      },
      {
        "input": "k = 2, prices = [3,2,6,5,0,3]",
        "output": "7",
        "explanation": "Buy on day 2 (price = 2) and sell on day 3 (price = 6) with profit 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3) with profit 3. Total profit = 4 + 3 = 7."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the maximum profit at each transaction level.",
      "Use dynamic programming to track profit for each transaction.",
      "Think about how to handle multiple transactions effectively."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "House Robber",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. The only constraint stopping you from robbing two adjacent houses is that adjacent houses have security systems connected, and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array 'nums' representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "topic": "Dynamic Programming",
    "subtopic": "House Robber Problem",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Greedy"
    ],
    "input_format": "An integer array nums where 1 <= nums.length <= 100 and 0 <= nums[i] <= 400.",
    "output_format": "An integer representing the maximum amount of money you can rob.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 400"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 1]",
        "output": "4",
        "explanation": "Robbing houses 1 and 3 yields the maximum amount. 1 + 3 = 4."
      },
      {
        "input": "nums = [2, 7, 9, 3, 1]",
        "output": "12",
        "explanation": "Robbing houses 1, 3, and 5 yields the maximum amount. 2 + 9 + 1 = 12."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use dynamic programming to keep track of the maximum amounts at each house.",
      "You can choose to either rob the current house or skip it.",
      "Think about the recurrence relation for maximizing profits."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Set Matrix Zeroes",
    "description": "Given a m x n matrix. If an element is 0, set its entire row and column to 0. Do it in place. You must do it without using extra space.",
    "topic": "Matrix",
    "subtopic": "In-place Manipulation",
    "tags": [
      "Matrix",
      "In-place",
      "Array"
    ],
    "input_format": "A 2D array of integers matrix where 0 <= matrix[i][j] <= 50.",
    "output_format": "Modify the input matrix in place without returning anything.",
    "constraints": [
      "1 <= matrix.length <= 200",
      "1 <= matrix[0].length <= 200",
      "-100 <= matrix[i][j] <= 100"
    ],
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "matrix = [[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": "The element at (1, 1) is 0, hence the entire second row and column are set to 0."
      },
      {
        "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
        "output": "matrix = [[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
        "explanation": "The elements at (0, 0) and (0, 3) are 0. Therefore, the entire first row and respective columns are set to 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using the first row and first column to mark which rows and columns need to be zeroed.",
      "Remember to handle the first row and column separately if they need to be zeroed."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Course Schedule II",
    "description": "You are given 'numCourses' courses numbered from 0 to 'numCourses - 1'. You are also given a list of prerequisite pairs 'prerequisites' where prerequisites[i] = [a, b] indicates that you must take course b before course a. Return the order in which you should take the courses if possible. If it is impossible to finish all courses, return an empty array.",
    "topic": "Graph",
    "subtopic": "Topological Sorting",
    "tags": [
      "Graph",
      "Topological Sort",
      "BFS",
      "DFS"
    ],
    "input_format": "An integer 'numCourses' and a list of prerequisite pairs 'prerequisites'.",
    "output_format": "A list of integers representing the order of courses.",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= prerequisites[i][0], prerequisites[i][1] < numCourses"
    ],
    "examples": [
      {
        "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
        "output": "[0,1,2,3]",
        "explanation": "The order of courses can be taken as 0 -> 1 -> 2 -> 3."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
        "output": "[]",
        "explanation": "It is impossible to complete the courses due to a cycle."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a graph representation.",
      "Think about how to detect cycles in your graph."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Verify Preorder Sequence in Binary Search Tree",
    "description": "Given an array of integers representing the preorder traversal of a binary search tree (BST), verify if the sequence is a valid preorder traversal of a BST. A BST is defined as a tree where each node has at most two children, and the left child is less than the parent node, while the right child is greater than the parent node.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "BST",
      "Traversal"
    ],
    "input_format": "An array of integers representing the preorder traversal of a BST.",
    "output_format": "A boolean value indicating whether the input array represents a valid preorder traversal of a BST.",
    "constraints": [
      "1 <= preorder.length <= 1000",
      "-10^9 <= preorder[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "[5, 2, 1, 3, 6]",
        "output": "true",
        "explanation": "The given sequence is a valid preorder traversal of the BST where 5 is the root, 2 is the left child of 5, 1 is the left child of 2, and 3 is the right child of 2, with 6 as the right child of 5."
      },
      {
        "input": "[5, 1, 6, 3, 2]",
        "output": "false",
        "explanation": "The sequence is invalid as it violates BST properties; 6 should not be present after 1 in the preorder traversal."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to validate the BST properties.",
      "Keep track of the last element and the lower bounds."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Counting Bits",
    "description": "Given an integer n, return an array ans of length n + 1 such that ans[i] is the number of 1's in the binary representation of i for 0 <= i <= n.",
    "topic": "Dynamic Programming",
    "subtopic": "Bit Manipulation",
    "tags": [
      "Dynamic Programming",
      "Bit Manipulation",
      "Counting"
    ],
    "input_format": "An integer n (0 <= n <= 10^5).",
    "output_format": "An array of integers representing the number of 1's in the binary representation of each number from 0 to n.",
    "constraints": [
      "0 <= n <= 10^5"
    ],
    "examples": [
      {
        "input": "n = 5",
        "output": "[0, 1, 1, 2, 1, 2]",
        "explanation": "The binary representations are 0 (0), 1 (1), 2 (10), 3 (11), 4 (100), 5 (101). The counts of 1's are 0, 1, 1, 2, 1, 2."
      },
      {
        "input": "n = 0",
        "output": "[0]",
        "explanation": "For n = 0, there is only one number: 0, which has 0 bits set."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using the properties of binary numbers.",
      "Use previously computed values to derive new values."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Intersection of Two Arrays",
    "description": "Given two integer arrays, nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.",
    "topic": "Array",
    "subtopic": "Set Operations",
    "tags": [
      "Array",
      "Intersection",
      "Set"
    ],
    "input_format": "Two integer arrays, nums1 and nums2.",
    "output_format": "An array of unique integers representing the intersection of the two input arrays.",
    "constraints": [
      "1 <= nums1.length, nums2.length <= 1000",
      "-1000 <= nums1[i], nums2[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]",
        "output": "[2]",
        "explanation": "The intersection of the two arrays is {2}. Although 2 appears twice in nums1, the result should contain unique elements."
      },
      {
        "input": "nums1 = [4, 9, 5], nums2 = [9, 4, 9, 8, 4]",
        "output": "[9, 4]",
        "explanation": "The intersection of the two arrays is {4, 9}. Both elements are unique in the result."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a set to store unique elements.",
      "Use built-in intersection methods if available."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Shuffle an Array",
    "description": "Given an integer array nums, return an array that is the shuffled version of the original array. The shuffle should be performed in such a way that all elements at even indices are from the first half of the array and all elements at odd indices are from the second half of the array. The original order of elements should be preserved within these halves.",
    "topic": "Array",
    "subtopic": "Shuffling",
    "tags": [
      "Array",
      "Shuffle",
      "In-Place"
    ],
    "input_format": "An integer array nums of length n.",
    "output_format": "An array containing the shuffled version of nums.",
    "constraints": [
      "1 <= n <= 10^4",
      "nums.length == n",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5, 6]",
        "output": "[1, 4, 2, 5, 3, 6]",
        "explanation": "The even indexed elements are [1, 2, 3] and the odd indexed elements are [4, 5, 6]. The shuffled array maintains this structure."
      },
      {
        "input": "nums = [7, 8, 9, 10]",
        "output": "[7, 10, 8, 9]",
        "explanation": "The first half consists of [7, 8] and the second half consists of [9, 10]. The shuffled array has the form [7, 10, 8, 9]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to split the array into two halves.",
      "You may want to use two pointers to construct the shuffled array."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Linked List Random Node",
    "description": "Design a class that selects a random node from a singly linked list. Each node in the linked list has a distinct integer value. Implement the RandomListNode class with the following methods: \n\n- __init__(val): Initializes the node with an integer value. \n- getRandom(): Returns a random node's value from the linked list. It should run in O(1) time complexity.",
    "topic": "Linked List",
    "subtopic": "Random Selection",
    "tags": [
      "Linked List",
      "Random",
      "Reservoir Sampling"
    ],
    "input_format": "A singly linked list with nodes having distinct integer values.",
    "output_format": "An integer value corresponding to a randomly selected node from the linked list.",
    "constraints": [
      "The linked list will not be empty.",
      "1 <= number of nodes <= 10^4"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3] \nRandomListNode list = new RandomListNode(head);\nint randomValue = list.getRandom();",
        "output": "1 or 2 or 3",
        "explanation": "Any of the values from the list can be returned with equal probability."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a reservoir sampling technique for random selection.",
      "Keep track of the count of elements seen so far."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Reverse Integer",
    "description": "Given a 32-bit signed integer, reverse the digits of the integer. If the reversed integer overflows, return 0. For example, reversing 123 will give 321, while reversing -123 will give -321.",
    "topic": "Mathematics",
    "subtopic": "Integer Manipulation",
    "tags": [
      "Integer",
      "Math",
      "String Manipulation"
    ],
    "input_format": "A single integer x within the range of [-2^31, 2^31 - 1].",
    "output_format": "A single integer representing the reversed digits of the input integer, or 0 if it overflows.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 123",
        "output": "321",
        "explanation": "The digits of 123 reversed give 321."
      },
      {
        "input": "x = -123",
        "output": "-321",
        "explanation": "The digits of -123 reversed give -321."
      },
      {
        "input": "x = 120",
        "output": "21",
        "explanation": "The digits of 120 reversed give 21, noting that leading zeros are dropped."
      },
      {
        "input": "x = 1534236469",
        "output": "0",
        "explanation": "Reversing this integer gives 9646324351, which overflows a 32-bit signed integer."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using integer division and modulo operations to extract digits.",
      "Handle edge cases for negative numbers and overflow carefully."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Fizz Buzz",
    "description": "Write a program that prints the numbers from 1 to n. But for multiples of three the program should print 'Fizz' instead of the number and for the multiples of five print 'Buzz'. For numbers which are multiples of both three and five print 'FizzBuzz'.",
    "topic": "Mathematics",
    "subtopic": "Basic Arithmetic",
    "tags": [
      "Mathematics",
      "String Manipulation"
    ],
    "input_format": "An integer n (1 <= n <= 10^4), the upper limit of the number range.",
    "output_format": "A list of strings representing the Fizz Buzz output for numbers from 1 to n.",
    "constraints": [
      "1 <= n <= 10^4"
    ],
    "examples": [
      {
        "input": "n = 15",
        "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]",
        "explanation": "The output follows the rules of Fizz Buzz for numbers from 1 to 15."
      },
      {
        "input": "n = 3",
        "output": "[\"1\", \"2\", \"Fizz\"]",
        "explanation": "For numbers 1 to 3, \"Fizz\" replaces the number 3."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a loop to iterate from 1 to n.",
      "Use the modulo operator to determine multiples of 3 and 5."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Coin Change",
    "description": "Given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money, return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.",
    "topic": "Dynamic Programming",
    "subtopic": "Coin Change Problem",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An integer array coins and an integer amount.",
    "output_format": "An integer representing the fewest number of coins needed to make up the amount, or -1 if it cannot be made up.",
    "constraints": [
      "1 <= coins.length <= 12",
      "1 <= coins[i] <= 2^31 - 1",
      "0 <= amount <= 5000"
    ],
    "examples": [
      {
        "input": "coins = [1, 2, 5], amount = 11",
        "output": "3",
        "explanation": "11 can be made up with two 5's and one 1. Thus, the fewest number of coins is 3."
      },
      {
        "input": "coins = [2], amount = 3",
        "output": "-1",
        "explanation": "3 cannot be made up with denominations of 2."
      },
      {
        "input": "coins = [1], amount = 0",
        "output": "0",
        "explanation": "0 amount can be made up with no coins."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to build up the solution.",
      "Think about how you can reduce the problem to subproblems.",
      "You can use an array to track the minimum coins needed for each amount."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Print in Order",
    "description": "You are given a list of integers. Your task is to print the integers in ascending order. Implement a function that takes an array of integers as input and returns a new array containing the integers sorted in non-decreasing order.",
    "topic": "Sorting",
    "subtopic": "Basic Sorting Algorithms",
    "tags": [
      "Sorting",
      "Array",
      "Basic Algorithm"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An array of integers sorted in non-decreasing order.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [7, 2, 9, 1, 5]",
        "output": "[1, 2, 5, 7, 9]",
        "explanation": "The sorted order of the numbers is 1, 2, 5, 7, 9."
      },
      {
        "input": "nums = [-1, 0, 1]",
        "output": "[-1, 0, 1]",
        "explanation": "The numbers are already in sorted order."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using built-in sorting functions.",
      "Think about how to implement a simple sorting algorithm."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted List",
    "description": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.",
    "topic": "Linked List",
    "subtopic": "Two Pointers",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Deletion"
    ],
    "input_format": "A singly linked list represented by the head node.",
    "output_format": "The head of the modified linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 300].",
      "-100 <= Node.val <= 100",
      "The list is guaranteed to be sorted in ascending order."
    ],
    "examples": [
      {
        "input": "head = [1, 1, 2]",
        "output": "[1, 2]",
        "explanation": "The duplicates are removed, leaving only [1, 2]."
      },
      {
        "input": "head = [1, 1, 2, 3, 3]",
        "output": "[1, 2, 3]",
        "explanation": "After removing duplicates, the list becomes [1, 2, 3]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a pointer to traverse the list and compare each node with its next node."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Maximum Product Subarray",
    "description": "Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Return the largest product you can get.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Product"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum product of a contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, -2, 4]",
        "output": "6",
        "explanation": "The subarray [2, 3] has the largest product 6."
      },
      {
        "input": "nums = [-2, 0, -1]",
        "output": "0",
        "explanation": "The subarray [0] has the largest product 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider both the maximum and minimum products at each position.",
      "Negative numbers can turn a small positive product into a large one."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Validate IP Address",
    "description": "Given a string s, you need to determine if it is a valid IPv4 or IPv6 address. An IPv4 address consists of four decimal numbers, each ranging from 0 to 255, separated by dots '.'. An IPv6 address consists of eight groups of four hexadecimal digits, separated by colons ':'. Your task is to implement a function that checks the validity of the given IP address.",
    "topic": "String",
    "subtopic": "Validation",
    "tags": [
      "String",
      "Validation",
      "IP Address"
    ],
    "input_format": "A single string s representing the IP address to be validated.",
    "output_format": "A string 'IPv4' if the address is a valid IPv4 address, 'IPv6' if valid IPv6, and 'Neither' if it's neither.",
    "constraints": [
      "1 <= s.length <= 50"
    ],
    "examples": [
      {
        "input": "s = \"192.168.1.1\"",
        "output": "IPv4",
        "explanation": "This is a valid IPv4 address as it consists of four decimal numbers each in the range of 0 to 255."
      },
      {
        "input": "s = \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"",
        "output": "IPv6",
        "explanation": "This is a valid IPv6 address since it consists of eight groups of four hexadecimal digits."
      },
      {
        "input": "s = \"256.256.256.256\"",
        "output": "Neither",
        "explanation": "This is invalid as the numbers in an IPv4 address cannot exceed 255."
      },
      {
        "input": "s = \"ghijk::1234\"",
        "output": "Neither",
        "explanation": "This is invalid since it contains non-hexadecimal characters."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Check if the address contains exactly four parts for IPv4.",
      "For IPv6, ensure there are eight groups of four hexadecimal digits."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Beautiful Arrangement",
    "description": "Suppose you have a list of positive integers and you want to arrange them in such a way that for each integer at index i (1-based), the integer's value is divisible by i or i is divisible by the integer's value. Your task is to count how many beautiful arrangements can be made with a given number n, which represents the integers from 1 to n.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Permutations",
      "Count"
    ],
    "input_format": "An integer n (1 <= n <= 15), representing the total number of integers to arrange.",
    "output_format": "An integer representing the number of beautiful arrangements.",
    "constraints": [
      "1 <= n <= 15"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "The valid arrangements are [1, 2] and [2, 1]. Both arrangements satisfy the conditions."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "The valid arrangements are [1, 2, 3], [1, 3, 2], and [2, 1, 3]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to generate all possible arrangements.",
      "Keep track of the current index and check divisibility conditions."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Backtracking"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A list of unique triplets that sum up to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]",
        "explanation": "The triplets that sum to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no elements to form triplets."
      },
      {
        "input": "nums = [0,1,1]",
        "output": "[]",
        "explanation": "No triplets can sum to zero."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try sorting the array to make it easier to find unique triplets.",
      "Use a two-pointer approach to reduce the time complexity."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Longest Increasing Path in a Matrix",
    "description": "Given an m x n integers matrix, return the length of the longest increasing path in the matrix. From each cell, you can move to four directions: up, down, left, or right. You may not move to the same cell in two consecutive moves. The path must be strictly increasing.",
    "topic": "Dynamic Programming",
    "subtopic": "Graph Traversal",
    "tags": [
      "Matrix",
      "DFS",
      "Dynamic Programming"
    ],
    "input_format": "An m x n integer matrix.",
    "output_format": "An integer representing the length of the longest increasing path.",
    "constraints": [
      "1 <= m, n <= 200",
      "0 <= matrix[i][j] <= 10^4"
    ],
    "examples": [
      {
        "input": "matrix = [[9,9,4],[6,6,8],[2,1,1]]",
        "output": "4",
        "explanation": "The longest increasing path is [1 -> 2 -> 6 -> 9]."
      },
      {
        "input": "matrix = [[3,4,5],[3,2,6],[2,2,1]]",
        "output": "4",
        "explanation": "The longest increasing path is [1 -> 2 -> 3 -> 4 -> 5] or [2 -> 3 -> 4 -> 5]."
      },
      {
        "input": "matrix = [[1]]",
        "output": "1",
        "explanation": "The longest increasing path is the single element itself."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using DFS with memoization to explore potential paths.",
      "Try to store the lengths of paths computed for cells to avoid redundant calculations.",
      "Make sure to handle edge cases like a single row or single column matrix."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Single Number",
    "description": "Given a non-empty array of integers, every element appears twice except for one. Find that single one.",
    "topic": "Array",
    "subtopic": "Bit Manipulation",
    "tags": [
      "Array",
      "Bit Manipulation",
      "Math"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the number that appears only once.",
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-3 * 10^4 <= nums[i] <= 3 * 10^4",
      "Each element in the array appears exactly twice except for one element."
    ],
    "examples": [
      {
        "input": "nums = [2, 2, 1]",
        "output": "1",
        "explanation": "The number 1 appears only once, while 2 appears twice."
      },
      {
        "input": "nums = [4, 1, 2, 1, 2]",
        "output": "4",
        "explanation": "The number 4 appears only once, while 1 and 2 appear twice."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Try to use bit manipulation techniques.",
      "Consider how XOR operation works."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Robot Bounded In Circle",
    "description": "A robot is initially positioned at the origin (0, 0) and faces north. The robot can move forward, turn left, or turn right, based on the given instructions. The robot is said to be bounded in a circle if it can return to its original position after following the instructions. Given a string representing the robot's movement instructions, return true if the robot is bounded in a circle, and false otherwise.",
    "topic": "Geometry",
    "subtopic": "Simulation",
    "tags": [
      "Geometry",
      "Simulation",
      "Bounded Movement"
    ],
    "input_format": "A string instructions consisting of characters 'G', 'L', and 'R'.",
    "output_format": "A boolean value, true if the robot is bounded in a circle, false otherwise.",
    "constraints": [
      "1 <= instructions.length <= 100",
      "instructions[i] is either 'G', 'L', or 'R'."
    ],
    "examples": [
      {
        "input": "instructions = 'GGLLGG'",
        "output": "true",
        "explanation": "The robot moves two steps forward, turns left, moves two steps forward, and ends up back at the origin."
      },
      {
        "input": "instructions = 'GL'",
        "output": "true",
        "explanation": "The robot moves forward, turns left, and then again moves forward, eventually returning to the original position."
      },
      {
        "input": "instructions = 'GLGLGGLG'",
        "output": "false",
        "explanation": "The series of moves results in the robot moving in a line and never returning to the origin."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the robot's direction and how it changes after each instruction.",
      "Determine if the robot returns to the origin or its direction becomes non-north after executing the instructions."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Min Stack",
    "description": "Design a stack that supports the following operations: push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class with the following methods: push(val), pop(), top(), and getMin(). The getMin() method should return the minimum element from the stack.",
    "topic": "Design",
    "subtopic": "Data Structure",
    "tags": [
      "Stack",
      "Design",
      "Data Structure"
    ],
    "input_format": "The input consists of multiple operations on the MinStack. Each operation can be 'push(val)', 'pop()', 'top()', or 'getMin()'.",
    "output_format": "Each 'getMin()' operation returns the minimum element in the stack, while 'top()' returns the top element.",
    "constraints": [
      "All operations are valid.",
      "There will be at most 1000 operations."
    ],
    "examples": [
      {
        "input": "minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin();",
        "output": "-3",
        "explanation": "After pushing -2, 0, and -3 onto the stack, -3 is the minimum value."
      },
      {
        "input": "minStack.pop(); minStack.top(); minStack.getMin();",
        "output": "-2",
        "explanation": "After popping -3, the top of the stack is 0 and the minimum is now -2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "You may need a second stack to keep track of the minimum values."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Course Schedule",
    "description": "You are given the total number of courses you have to take, denoted by `numCourses`, and a list `prerequisites` where `prerequisites[i] = [a_i, b_i]` indicates that you must take course `b_i` before course `a_i`. Determine if it is possible for you to complete all courses. Return true if you can finish all courses; otherwise, return false.",
    "topic": "Graph",
    "subtopic": "Topological Sort",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Topological Sort"
    ],
    "input_format": "An integer numCourses followed by a list of prerequisite pairs.",
    "output_format": "A boolean value indicating if all courses can be completed.",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= a_i, b_i < numCourses"
    ],
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = [[1, 0]]",
        "output": "true",
        "explanation": "You can take course 0 before course 1, hence all courses can be completed."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1, 0], [0, 1]]",
        "output": "false",
        "explanation": "There is a circular dependency: to take course 0, you need to take course 1 and vice versa."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a graph representation to track dependencies.",
      "Check for cycles in the graph."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Delete Node in a Linked List",
    "description": "You are given the pointer to a node in a singly linked list. The node will not be the last node of the list, and you need to delete that node from the list without access to the head of the list.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "Linked List",
      "Deletion",
      "O(1) Space"
    ],
    "input_format": "A reference to the node to be deleted from the linked list.",
    "output_format": "The linked list after the specified node has been deleted.",
    "constraints": [
      "The node to be deleted is guaranteed not to be the last node.",
      "The linked list has at least two nodes."
    ],
    "examples": [
      {
        "input": "head = [4, 5, 1, 9], node = 5",
        "output": "[4, 1, 9]",
        "explanation": "After deleting the node with value 5, the list becomes 4 -> 1 -> 9."
      },
      {
        "input": "head = [4, 5, 1, 9], node = 1",
        "output": "[4, 5, 9]",
        "explanation": "After deleting the node with value 1, the list becomes 4 -> 5 -> 9."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Copy the value of the next node into the current node.",
      "Link the current node to the next node's next."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Meeting Rooms II",
    "description": "Given an array of meeting time intervals consisting of start and end times, determine the minimum number of meeting rooms required to hold all the meetings. Each meeting is represented as a pair [start, end] and meetings can only occur in separate rooms if their time intervals overlap.",
    "topic": "Greedy",
    "subtopic": "Interval Scheduling",
    "tags": [
      "Greedy",
      "Heap",
      "Interval",
      "Sorting"
    ],
    "input_format": "An array of meeting intervals, where each interval is represented as a pair of integers [start, end].",
    "output_format": "An integer representing the minimum number of meeting rooms required.",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "0 <= intervals[i][0] < intervals[i][1] <= 10^6"
    ],
    "examples": [
      {
        "input": "intervals = [[0, 30], [5, 10], [15, 20]]",
        "output": "2",
        "explanation": "At least two rooms are needed. The first room can hold meetings [0, 30] and the second room can hold the meetings [5, 10] and [15, 20]."
      },
      {
        "input": "intervals = [[7, 10], [2, 4]]",
        "output": "1",
        "explanation": "Only one meeting room is needed as the meetings do not overlap."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on start times.",
      "Use a priority queue to keep track of end times of meetings."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Range Sum Query 2D - Immutable",
    "description": "You are given a 2D matrix and an array of queries. Each query consists of four integers (row1, col1, row2, col2) representing the top-left and bottom-right corners of a rectangular submatrix. Your task is to implement a method that returns the sum of the elements in the specified submatrix for each query. Note that the matrix is immutable after it is initialized.",
    "topic": "Matrix",
    "subtopic": "Range Sum",
    "tags": [
      "Matrix",
      "Prefix Sum",
      "Query"
    ],
    "input_format": "A 2D integer matrix and an array of queries, where each query is represented by four integers.",
    "output_format": "An array of integers, each representing the result of the corresponding query.",
    "constraints": [
      "1 <= matrix.length, matrix[i].length <= 100",
      "-10^5 <= matrix[i][j] <= 10^5",
      "1 <= queries.length <= 10^4",
      "0 <= row1 <= row2 < matrix.length",
      "0 <= col1 <= col2 < matrix[0].length"
    ],
    "examples": [
      {
        "input": {
          "matrix": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "queries": [
            [
              0,
              0,
              1,
              1
            ],
            [
              1,
              1,
              2,
              2
            ],
            [
              0,
              0,
              2,
              2
            ]
          ]
        },
        "output": [
          12,
          28,
          45
        ],
        "explanation": "For the first query, the sum is 1 + 2 + 4 + 5 = 12. For the second query, the sum is 5 + 6 + 8 + 9 = 28. For the third query, the total is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a prefix sum array to optimize the range sum queries.",
      "Each query can be solved in O(1) time once the prefix sum array is built."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Is Subsequence",
    "description": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., 'ace' is a subsequence of 'abcde' while 'aec' is not).",
    "topic": "String",
    "subtopic": "Subsequence",
    "tags": [
      "String",
      "Two Pointers",
      "Subsequence"
    ],
    "input_format": "Two strings s and t.",
    "output_format": "A boolean value indicating whether s is a subsequence of t.",
    "constraints": [
      "0 <= s.length <= 100",
      "0 <= t.length <= 10^4",
      "s and t consist of English letters (lowercase and uppercase)."
    ],
    "examples": [
      {
        "input": "s = \"abc\", t = \"ahbgdc\"",
        "output": "true",
        "explanation": "The characters 'a', 'b', and 'c' appear in t in the same order, therefore s is a subsequence of t."
      },
      {
        "input": "s = \"axc\", t = \"ahbgdc\"",
        "output": "false",
        "explanation": "The characters 'a', 'x', and 'c' do not appear in t in that order, so s is not a subsequence of t."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to iterate through both strings.",
      "If you run out of characters in s before t, s is a subsequence."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Remove Nth Node From End of List",
    "description": "Given the head of a linked list, remove the N-th node from the end of the list and return its head. The list can be represented as a sequence of nodes where each node contains an integer value and a pointer to the next node. The N-th node from the end is the node that should be removed.",
    "topic": "Linked List",
    "subtopic": "Two Pointers",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Removal"
    ],
    "input_format": "A linked list represented by a head node and an integer N.",
    "output_format": "The head of the modified linked list.",
    "constraints": [
      "1 <= N <= the number of nodes in the list.",
      "The list will have at least one node."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], N = 2",
        "output": "[1, 2, 3, 5]",
        "explanation": "Removing the 2nd node from the end (which is 4) results in the list [1, 2, 3, 5]."
      },
      {
        "input": "head = [1], N = 1",
        "output": "[]",
        "explanation": "Removing the only node in the list results in an empty list."
      },
      {
        "input": "head = [1, 2], N = 1",
        "output": "[1]",
        "explanation": "Removing the last node (which is 2) results in the list [1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a two-pointer approach to determine the node to remove.",
      "Maintain a gap of N nodes between the two pointers."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Number of Operations to Make Network Connected",
    "description": "You are given n computers that are connected by some number of cables. The computers are represented as nodes in a graph, where each cable represents an undirected edge between two nodes. You need to find the minimum number of operations required to connect all the computers together. Each operation involves either connecting two unconnected computers directly or replacing a broken cable. A connected network does not require any broken cables. If it is impossible to connect all computers, return -1.",
    "topic": "Graph",
    "subtopic": "Union Find",
    "tags": [
      "Graph",
      "Union Find",
      "Connectivity"
    ],
    "input_format": "An integer n representing the number of computers, and a list of pairs of integers connections representing the direct connections between the computers.",
    "output_format": "An integer representing the minimum number of operations required to connect all the computers, or -1 if it's impossible.",
    "constraints": [
      "1 <= n <= 10^5",
      "0 <= connections.length <= 10^5",
      "connections[i].length == 2",
      "0 <= connections[i][0], connections[i][1] < n"
    ],
    "examples": [
      {
        "input": "n = 4, connections = [[0, 1], [0, 2], [1, 2]]",
        "output": "1",
        "explanation": "The computers are connected in such a way that you need one operation to connect the unconnected computer (3)."
      },
      {
        "input": "n = 6, connections = [[0, 1], [0, 2], [0, 3], [1, 2]]",
        "output": "-1",
        "explanation": "There are not enough connections to connect all computers. You need at least 5 connections to connect 6 computers."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to represent the connections using a graph.",
      "You may want to use Union-Find to keep track of connections.",
      "Count the number of connected components."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Sort Characters By Frequency",
    "description": "Given a string s, sort it in decreasing order based on the frequency of the characters. Characters with the same frequency should be sorted in decreasing order by their lexicographical order. Return the sorted string.",
    "topic": "String",
    "subtopic": "Sorting",
    "tags": [
      "String",
      "Sorting",
      "Frequency"
    ],
    "input_format": "A string s consisting of lowercase and uppercase letters.",
    "output_format": "A string that represents the characters sorted by their frequency and order.",
    "constraints": [
      "1 <= s.length <= 10^5"
    ],
    "examples": [
      {
        "input": "tree",
        "output": "eert",
        "explanation": "The character 'e' appears twice, and 't' and 'r' appear once. So, 'e' is ahead of 't' and 'r'."
      },
      {
        "input": "cccaaa",
        "output": "aaaccc",
        "explanation": "'c' appears three times and 'a' appears three times. Both must be sorted, so 'aaa' comes before 'ccc'."
      },
      {
        "input": "Aabb",
        "output": "bbAa",
        "explanation": "'b' appears twice, 'a' appears once, and case matters. So, 'bb' comes before 'Aa'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a frequency dictionary to count the occurrences of each character.",
      "Consider sorting the characters based on their frequency and lexicographical order after counting."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Swapping Nodes in a Linked List",
    "description": "Given the head of a linked list, you need to swap every two adjacent nodes and return its head. If the list contains an odd number of nodes, the last node should remain in the same position.",
    "topic": "Linked List",
    "subtopic": "Node Manipulation",
    "tags": [
      "Linked List",
      "Swapping",
      "Node Manipulation"
    ],
    "input_format": "The head of the linked list, which is a ListNode object.",
    "output_format": "The head of the modified linked list after swapping adjacent nodes.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 100].",
      "0 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "[1, 2, 3, 4]",
        "output": "[2, 1, 4, 3]",
        "explanation": "The pairs (1, 2) and (3, 4) are swapped to return the transformed list."
      },
      {
        "input": "[1, 2, 3]",
        "output": "[2, 1, 3]",
        "explanation": "The pair (1, 2) is swapped, while the single node 3 remains unchanged."
      },
      {
        "input": "[1]",
        "output": "[1]",
        "explanation": "With only one node, no swaps occur, and the list remains the same."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dummy node to simplify the edge cases.",
      "Iterate through the list and perform swaps in pairs."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Valid Sudoku",
    "description": "Determine if a 9x9 Sudoku board is valid according to the rules of Sudoku. Only the filled cells need to be validated according to the following rules: each row must contain the digits 1-9 without repetition, each column must contain the digits 1-9 without repetition, and each of the nine 3x3 sub-boxes must contain the digits 1-9 without repetition. An empty cell is denoted by the character '.'",
    "topic": "Array",
    "subtopic": "2D Array",
    "tags": [
      "Array",
      "Matrix",
      "Validation"
    ],
    "input_format": "A 2D array of characters representing the Sudoku board.",
    "output_format": "Return true if the Sudoku board is valid, otherwise return false.",
    "constraints": [
      "The board is a 9x9 grid.",
      "Each cell can be a digit from '1' to '9' or '.' for empty cells."
    ],
    "examples": [
      {
        "input": [
          [
            "5",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            ".",
            "2",
            "8",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": "true",
        "explanation": "The Sudoku board is valid as it follows all the rules."
      },
      {
        "input": [
          [
            "8",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            ".",
            "2",
            "8",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": "false",
        "explanation": "The first row has two '8's, which violates the Sudoku rule."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Check each row for duplicates.",
      "Check each column for duplicates.",
      "Check each 3x3 box for duplicates."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Subarray Product Less Than K",
    "description": "Given an array of positive integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is less than k.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Product"
    ],
    "input_format": "An array of positive integers nums and an integer k.",
    "output_format": "An integer representing the number of contiguous subarrays with a product less than k.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "1 <= nums[i] < k <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [10, 5, 2, 6], k = 100",
        "output": "8",
        "explanation": "The subarrays are [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], and [10, 5, 2], which all have products less than 100."
      },
      {
        "input": "nums = [1, 2, 3], k = 0",
        "output": "0",
        "explanation": "There are no subarrays with a product less than 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use the sliding window technique to maintain the product.",
      "Keep expanding the window until the product reaches or exceeds k."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Rectangle Overlap",
    "description": "Given the coordinates of two rectangles in a 2D plane, determine whether they overlap. Each rectangle is defined by its bottom-left and top-right corners. The coordinates are given in the form of two pairs: the first rectangle is defined by the coordinates (x1, y1) for its bottom-left corner and (x2, y2) for its top-right corner, while the second rectangle is defined similarly by coordinates (x3, y3) and (x4, y4).",
    "topic": "Geometry",
    "subtopic": "Rectangle Intersection",
    "tags": [
      "Geometry",
      "Rectangle",
      "Overlap",
      "Intersection"
    ],
    "input_format": "Four integers x1, y1, x2, y2 representing the first rectangle and four integers x3, y3, x4, y4 representing the second rectangle.",
    "output_format": "Return true if the two rectangles overlap, and false otherwise.",
    "constraints": [
      "-10^4 <= x1 < x2 <= 10^4",
      "-10^4 <= y1 < y2 <= 10^4",
      "-10^4 <= x3 < x4 <= 10^4",
      "-10^4 <= y3 < y4 <= 10^4"
    ],
    "examples": [
      {
        "input": "x1 = 0, y1 = 0, x2 = 2, y2 = 2, x3 = 1, y3 = 1, x4 = 3, y4 = 3",
        "output": "true",
        "explanation": "The first rectangle is defined by (0, 0) and (2, 2), and the second rectangle is defined by (1, 1) and (3, 3). They overlap since part of the area of the first rectangle lies within the second."
      },
      {
        "input": "x1 = 0, y1 = 0, x2 = 1, y2 = 1, x3 = 1, y3 = 1, x4 = 2, y4 = 2",
        "output": "false",
        "explanation": "The first rectangle is defined by (0, 0) and (1, 1), and the second rectangle is defined by (1, 1) and (2, 2). They touch at one point but do not overlap."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Check if one rectangle is to the left or above the other rectangle."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "All Possible Full Binary Trees",
    "description": "A full binary tree is a binary tree where every node has either 0 or 2 children. Given an integer n, return all the structurally unique full binary trees that have n nodes. You may return the answer in any order.",
    "topic": "Tree",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Tree",
      "Binary Trees",
      "Dynamic Programming"
    ],
    "input_format": "An integer n representing the number of nodes in the full binary tree.",
    "output_format": "An array of root nodes of all unique full binary trees.",
    "constraints": [
      "1 <= n <= 20",
      "n is an odd integer."
    ],
    "examples": [
      {
        "input": "n = 7",
        "output": "A list containing 5 unique full binary tree structures.",
        "explanation": "For n = 7, there are 5 unique full binary trees possible."
      },
      {
        "input": "n = 3",
        "output": "A list containing 1 unique full binary tree structure.",
        "explanation": "For n = 3, there is only 1 unique full binary tree, which has one root and two children."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to recursively build the left and right subtrees.",
      "Use dynamic programming to cache the results for each count of nodes."
    ],
    "company": "Nvidia"
  },
  {
    "question_id": "",
    "title": "Greatest Common Divisor of Strings",
    "description": "Given two strings str1 and str2, return the largest string X such that X divides both str1 and str2. A string X is said to divide another string Y if Y can be constructed by concatenating multiple copies of X. If there is no such string X, return an empty string.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "GCD",
      "Concatenation"
    ],
    "input_format": "Two strings str1 and str2.",
    "output_format": "A string representing the largest common divisor string or an empty string if none exists.",
    "constraints": [
      "1 <= str1.length, str2.length <= 1000",
      "str1 and str2 consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "str1 = 'ABCABC', str2 = 'ABC'",
        "output": "'ABC'",
        "explanation": "'ABC' is the largest string that can be concatenated to form both str1 and str2."
      },
      {
        "input": "str1 = 'ABABAB', str2 = 'ABAB'",
        "output": "'AB'",
        "explanation": "'AB' is the largest string that can be concatenated to form both str1 and str2."
      },
      {
        "input": "str1 = 'LEET', str2 = 'CODE'",
        "output": "''",
        "explanation": "There is no string that can divide both 'LEET' and 'CODE'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Check the lengths of the strings and their greatest common divisor.",
      "If str1 + str2 is not equal to str2 + str1, return an empty string."
    ],
    "company": "Nvidia"
  }
]