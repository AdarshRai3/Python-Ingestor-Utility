[
  {
    "question_id": "",
    "title": "Replace the Substring for Balanced String",
    "description": "You are given a string containing only 'Q', 'W', 'E', and 'R'. A string is considered balanced when the number of 'Q's, 'W's, 'E's, and 'R's are all equal. You are allowed to replace any character in the string with any of the other three characters. Your task is to determine the minimum number of replacements required to make the string balanced. If it is already balanced, return 0.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Manipulation",
      "Counting"
    ],
    "input_format": "A string s consisting of the characters 'Q', 'W', 'E', and 'R'.",
    "output_format": "An integer representing the minimum number of replacements needed to make the string balanced.",
    "constraints": [
      "1 <= s.length <= 100",
      "s consists of only the characters 'Q', 'W', 'E', and 'R'."
    ],
    "examples": [
      {
        "input": "s = \"QWER\"",
        "output": "0",
        "explanation": "The string is already balanced with one of each character."
      },
      {
        "input": "s = \"QQWWER\"",
        "output": "1",
        "explanation": "We can replace one 'Q' with 'E' or 'R' to balance the counts."
      },
      {
        "input": "s = \"QQQW\"",
        "output": "2",
        "explanation": "We need to change 2 'Q's to achieve a balance with the other characters."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Count how many of each character there are.",
      "Aim for equal counts for all four characters."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Merge Operations to Turn Array Into a Palindrome",
    "description": "Given an array of integers, you can perform a series of merge operations to turn this array into a palindrome. A merge operation involves selecting two adjacent numbers in the array and merging them into their sum. You need to determine the minimum number of merge operations required to convert the given array into a palindrome. If it's not possible to turn the array into a palindrome using merge operations, return -1.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Palindrome"
    ],
    "input_format": "An array of integers nums representing the input array.",
    "output_format": "An integer representing the minimum number of merge operations required to make the array a palindrome, or -1 if it is not possible.",
    "constraints": [
      "1 <= nums.length <= 1000",
      "1 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 2, 2, 3, 1]",
        "output": "0",
        "explanation": "The array is already a palindrome."
      },
      {
        "input": "nums = [1, 2, 2, 1, 3]",
        "output": "1",
        "explanation": "Merging the last element (3) with the previous (1) results in [1, 2, 2, 4], which can be turned into a palindrome."
      },
      {
        "input": "nums = [5, 3, 2, 1, 4]",
        "output": "-1",
        "explanation": "It is not possible to turn this array into a palindrome by any number of merges."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use two pointers to check for matching elements.",
      "When elements don't match, consider merging to balance the array."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers and a target value, return the indices of the two numbers such that they add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hash Table",
    "tags": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^3",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 2 + 7 = 9."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "nums[1] + nums[2] = 2 + 4 = 6."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 3 + 3 = 6."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash table to store the difference between the target and the current element."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "topic": "Dynamic Programming",
    "subtopic": "Fibonacci Sequence",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Mathematics"
    ],
    "input_format": "An integer n (1 <= n <= 45) representing the number of steps to reach the top.",
    "output_format": "An integer representing the number of distinct ways to climb to the top.",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: (1 step + 1 step) or (2 steps)."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top: (1 step + 1 step + 1 step), (1 step + 2 steps), or (2 steps + 1 step)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a dynamic programming approach to solve this problem.",
      "The number of ways to reach the nth step can be defined in relation to the (n-1)th and (n-2)th steps."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters. A substring is a contiguous sequence of characters within the string. The function should return an integer representing the length of the longest substring without repeating characters.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A single string s consisting of uppercase and lowercase English letters.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 10^5",
      "s consists of English letters, digits, symbols and spaces."
    ],
    "examples": [
      {
        "input": "s = 'abcabcbb'",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'abc', which has a length of 3."
      },
      {
        "input": "s = 'bbbbb'",
        "output": "1",
        "explanation": "The longest substring without repeating characters is 'b', with a length of 1."
      },
      {
        "input": "s = 'pwwkew'",
        "output": "3",
        "explanation": "The longest substring without repeating characters is 'wke', which has a length of 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window to track the current substring.",
      "Use a hash set to store characters and their indices."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Binary Tree Right Side View",
    "description": "Given the root of a binary tree, imagine you are viewing it from the right side. Return the values of the nodes that you can see ordered from top to bottom.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth-First Search",
      "Breadth-First Search"
    ],
    "input_format": "The root of a binary tree represented as a TreeNode object.",
    "output_format": "A list of integers representing the visible values from the right side of the binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, null, 5, null, 4]",
        "output": "[1, 3, 4]",
        "explanation": "From the right side, we can see nodes 1 (the root), 3 (the right child of 1), and 4 (the right child of 3)."
      },
      {
        "input": "root = [1, null, 3]",
        "output": "[1, 3]",
        "explanation": "From the right side, we can see nodes 1 (the root) and 3 (the right child of 1)."
      },
      {
        "input": "root = [1]",
        "output": "[1]",
        "explanation": "Only the root node is present."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a level order traversal to capture the rightmost elements.",
      "Consider using a queue to implement BFS.",
      "Keep track of the last element visited at each level."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is considered valid if the brackets are closed in the correct order. Every opening bracket must have a corresponding closing bracket of the same type.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A string s consisting of characters '(', ')', '{', '}', '[' and ']'",
    "output_format": "A boolean value, true if the string is valid, otherwise false.",
    "constraints": [
      "0 <= s.length <= 10^4",
      "s consists of parentheses only."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The parentheses are properly closed."
      },
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "All pairs of parentheses are closed and in the correct order."
      },
      {
        "input": "s = '(]'",
        "output": "false",
        "explanation": "The parentheses are not in the correct order."
      },
      {
        "input": "s = '([)]'",
        "output": "false",
        "explanation": "The parentheses are closed in the wrong order."
      },
      {
        "input": "s = '{[]}')",
        "output": "true",
        "explanation": "The parentheses are properly nested and closed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "Check if the last opened bracket matches the current closed bracket."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A palindromic substring is a string that reads the same backward as forward.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Palindrome"
    ],
    "input_format": "A single string s, where 1 <= s.length <= 1000.",
    "output_format": "A string representing the longest palindromic substring in s.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only digits and English letters."
    ],
    "examples": [
      {
        "input": "s = 'babad'",
        "output": "'bab'",
        "explanation": "Both 'bab' and 'aba' are valid longest palindromic substrings of 'babad'."
      },
      {
        "input": "s = 'cbbd'",
        "output": "'bb'",
        "explanation": "'bb' is the longest palindromic substring in 'cbbd'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding around the center.",
      "All single letter strings are palindromes."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of bars in a histogram, compute how much water it can trap after raining. The width of each bar is 1. For example, if the bars are represented as [0,1,0,2,1,0,1,3,2,1,2,1], water can be trapped between the bars, and the solution should calculate the total volume of trapped water.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers representing the heights of the bars.",
    "output_format": "An integer representing the total amount of trapped water.",
    "constraints": [
      "0 <= height.length <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The water trapped is represented by the spaces between the bars, calculated to be 6 units."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The water trapped between the heights results in a total of 9 units."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the maximum height to the left and right of each bar.",
      "Use a two-pointer approach for optimal performance."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". A common prefix is defined as the substring that appears at the beginning of each string in the array. If the array is empty, return \"\".",
    "topic": "String",
    "subtopic": "Prefix",
    "tags": [
      "String",
      "Prefix",
      "Array"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A string representing the longest common prefix.",
    "constraints": [
      "0 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "strs[i] consists of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The longest common prefix is \"fl\"."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix, so the result is an empty string."
      },
      {
        "input": "strs = []",
        "output": "\"\"",
        "explanation": "The input array is empty, thus the longest common prefix is an empty string."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider sorting the array to simplify the problem.",
      "The common prefix will be the same for the first and last strings in the sorted array."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Reverse Vowels of a String",
    "description": "Given a string s, write a function that reverses only the vowels in the string. Vowels are 'a', 'e', 'i', 'o', and 'u' (case insensitive). The vowels should be reversed in the output string, but all other characters should remain in the same position.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Two Pointers",
      "In-Place"
    ],
    "input_format": "A single string s, where 1 <= s.length <= 3 * 10^5.",
    "output_format": "A string with the vowels reversed.",
    "constraints": [
      "1 <= s.length <= 3 * 10^5",
      "s consists of printable ASCII characters."
    ],
    "examples": [
      {
        "input": "hello",
        "output": "holle",
        "explanation": "The vowels 'e' and 'o' are reversed."
      },
      {
        "input": "leetcode",
        "output": "leotcede",
        "explanation": "The vowels 'e', 'e', and 'o' are reversed."
      },
      {
        "input": "aA",
        "output": "Aa",
        "explanation": "The vowels 'a' and 'A' are reversed."
      },
      {
        "input": "A man, a plan, a canal: Panama",
        "output": "P enum, a plAn, a cAnal: a mAn",
        "explanation": "The vowels 'A', 'a', 'a', 'a', 'a' are reversed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers to solve the problem.",
      "Make sure to handle both uppercase and lowercase vowels."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "You are given a rotated sorted array 'nums' and an integer 'target'. Your task is to search for 'target' in 'nums' and return its index. If the target does not exist in the array, return -1. You must write a solution with O(log n) time complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Searching"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "Return the index of target in nums, or -1 if it is not present.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "Let's assume the array does not contain duplicates.",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [4, 5, 6, 7, 0, 1, 2], target = 0",
        "output": "4",
        "explanation": "The target 0 is located at index 4 in the rotated array."
      },
      {
        "input": "nums = [4, 5, 6, 7, 0, 1, 2], target = 3",
        "output": "-1",
        "explanation": "The target 3 is not present in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to use binary search, but account for the rotation.",
      "Identify the sorted half of the array during your search."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Longest Common Subsequence",
    "description": "Given two strings text1 and text2, return the length of their longest common subsequence. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., 'ACE' is a subsequence of 'ABCDE' while 'AEC' is not). A common subsequence of two strings is a subsequence that is common to both strings.",
    "topic": "Dynamic Programming",
    "subtopic": "String Processing",
    "tags": [
      "Dynamic Programming",
      "String",
      "Subsequence"
    ],
    "input_format": "Two strings text1 and text2.",
    "output_format": "An integer representing the length of the longest common subsequence.",
    "constraints": [
      "1 <= text1.length, text2.length <= 1000",
      "text1 and text2 consist of English letters."
    ],
    "examples": [
      {
        "input": "text1 = 'abcde', text2 = 'ace'",
        "output": "3",
        "explanation": "The longest common subsequence is 'ace' which has a length of 3."
      },
      {
        "input": "text1 = 'abc', text2 = 'def'",
        "output": "0",
        "explanation": "There is no common subsequence, so the output is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store the lengths of common subsequences.",
      "Try to identify patterns in how to construct the solution from smaller subproblems."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array II",
    "description": "Given a sorted array of integers, remove duplicates such that each element appears at most twice and return the new length of the array. Do not allocate extra space for another array; instead, modify the input array in-place and return the length of the modified array. You must do this in O(n) time complexity.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An integer array nums sorted in non-decreasing order.",
    "output_format": "An integer representing the new length of the modified array.",
    "constraints": [
      "0 <= nums.length <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3]",
        "output": "5",
        "explanation": "After removing duplicates, the array will be [1,1,2,2,3] and the new length is 5."
      },
      {
        "input": "nums = [0,0,1,1,1,1,2,3,3]",
        "output": "7",
        "explanation": "After removing duplicates, the array will be [0,0,1,1,2,3,3] and the new length is 7."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use two pointers to keep track of the position for the next unique element.",
      "Remember to check for duplicate elements before incrementing the count."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with the x-axis forms a container, such that the container contains the most water.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Binary Search"
    ],
    "input_format": "An integer array heights where heights[i] is the height of the ith line.",
    "output_format": "An integer representing the maximum amount of water that can be contained.",
    "constraints": [
      "2 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The maximum area is formed between lines 1 and 8, which is 7 units wide and 7 units tall."
      },
      {
        "input": "heights = [1,1]",
        "output": "1",
        "explanation": "The only possible container formed is between the two lines, which have height 1 and a width of 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using two pointers to optimize the search for the maximum area.",
      "The area is limited by the shorter of the two lines."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Asteroid Collision",
    "description": "We have an array of integers representing asteroids in a row. Each asteroid is a positive or negative integer, where a positive integer represents an asteroid moving to the right and a negative integer represents an asteroid moving to the left. When two asteroids collide, the smaller one will explode. If they are of the same size, both will explode. Return the state of the asteroids after all collisions have taken place.",
    "topic": "Stack",
    "subtopic": "Collision Detection",
    "tags": [
      "Stack",
      "Simulation",
      "Array"
    ],
    "input_format": "An array of integers representing the asteroids.",
    "output_format": "An array of integers representing the asteroids left after all collisions.",
    "constraints": [
      "1 <= asteroids.length <= 10^4",
      "-1000 <= asteroids[i] <= 1000",
      "Asteroids moving to the left and right are represented by negative and positive integers respectively."
    ],
    "examples": [
      {
        "input": "asteroids = [5, 10, -5]",
        "output": "[5, 10]",
        "explanation": "The asteroid 10 collides with -5, and since 10 > 5, -5 explodes. The remaining asteroids are [5, 10]."
      },
      {
        "input": "asteroids = [8, -8]",
        "output": "[]",
        "explanation": "Both asteroids collide and explode since they are of the same size."
      },
      {
        "input": "asteroids = [10, 2, -5]",
        "output": "[10]",
        "explanation": "2 collides with -5 and explodes. The remaining asteroid is [10]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to keep track of the surviving asteroids.",
      "Iterate through the asteroids and handle collisions as you process each asteroid.",
      "When two asteroids collide, remember to compare their absolute values."
    ],
    "company": "Accolite"
  },
  {
    "question_id": "",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Dynamic Programming",
    "subtopic": "Optimization",
    "tags": [
      "Dynamic Programming",
      "Array",
      "Greedy"
    ],
    "input_format": "An array of integers prices representing the stock prices on different days.",
    "output_format": "An integer representing the maximum profit that can be made.",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5."
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Keep track of the minimum price seen so far.",
      "The maximum profit can be calculated by subtracting the minimum price from the current price."
    ],
    "company": "Accolite"
  }
]