[
  {
    "question_id": "",
    "title": "Walls and Gates",
    "description": "You are given a grid represented as a 2D matrix of integers. The grid contains the following values: 0 represents a gate, INF (Integer.MAX_VALUE) represents an empty room, and -1 represents a wall. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, the distance should remain as INF. The distance for a gate is 0, and for an empty room, it is the number of steps to the nearest gate. You need to update the grid in-place with the correct distances.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "Matrix"
    ],
    "input_format": "A 2D matrix grid with values {0, INF, -1}.",
    "output_format": "The same 2D matrix grid with distances filled in for each empty room.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 250",
      "grid[i][j] is either 0, -1, or INF."
    ],
    "examples": [
      {
        "input": "grid = [[0, -1, INF, INF], [INF, INF, -1, 0], [INF, -1, INF, INF], [0, -1, INF, INF]]",
        "output": "[[0, -1, 1, 2],[1, 2, -1, 0],[2, -1, 1, 1],[0, -1, 2, 3]]",
        "explanation": "The nearest gate distances are filled for each empty room."
      },
      {
        "input": "grid = [[INF]]",
        "output": "[[INF]]",
        "explanation": "There are no gates, so the distance remains INF."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use BFS starting from all gates simultaneously.",
      "Consider using a queue to help you manage the BFS."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Binary Tree Maximum Path Sum",
    "description": "Given a binary tree, find the maximum path sum. The path may start and end at any node in the tree. The path must contain at least one node and does not need to go through the root. A path goes from one node to another node in the tree, including the node where the path starts and the node where the path ends.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Depth-First Search",
      "Dynamic Programming"
    ],
    "input_format": "A binary tree represented by a root node, where each node contains an integer value.",
    "output_format": "An integer representing the maximum path sum.",
    "constraints": [
      "-10^4 <= node.val <= 10^4",
      "The number of nodes in the tree is in the range [1, 3 * 10^4]"
    ],
    "examples": [
      {
        "input": "root = [-10, 9, 20, null, null, 15, 7]",
        "output": "42",
        "explanation": "The maximum path sum is 15 + 20 + 7 = 42."
      },
      {
        "input": "root = [1, 2, 3]",
        "output": "6",
        "explanation": "The maximum path sum is 1 + 2 + 3 = 6."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider each node as a potential endpoint of a path.",
      "Keep track of the maximum sum at each node as you traverse the tree.",
      "Use recursion to explore all paths in the binary tree."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Longest Increasing Path in a Matrix",
    "description": "Given an m x n integers matrix, return the length of the longest increasing path in the matrix. From each cell, you can move to four directions (up, down, left, or right). You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).",
    "topic": "Matrix",
    "subtopic": "Depth First Search",
    "tags": [
      "Matrix",
      "DFS",
      "Dynamic Programming"
    ],
    "input_format": "An m x n matrix of integers.",
    "output_format": "An integer representing the length of the longest increasing path.",
    "constraints": [
      "1 <= m, n <= 200",
      "-10^4 <= matrix[i][j] <= 10^4"
    ],
    "examples": [
      {
        "input": "matrix = [[9,9,4],[6,6,8],[2,1,1]]",
        "output": "4",
        "explanation": "The longest increasing path is [1, 2, 6, 9]."
      },
      {
        "input": "matrix = [[3, 4, 5],[3, 2, 6],[2, 2, 1]]",
        "output": "4",
        "explanation": "The longest increasing path is [1, 2, 3, 4] or [1, 2, 3, 5]."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use Depth First Search (DFS) with memoization.",
      "Keep track of visited nodes to avoid cycles."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Maximum Profit in Job Scheduling",
    "description": "Given a list of jobs where each job has a start time, end time, and profit, calculate the maximum profit that can be obtained by scheduling jobs non-overlapping. Each job is represented as a tuple (start_time, end_time, profit). You may assume that all jobs are finished by the end time of the last job and that no two jobs can overlap in time.",
    "topic": "Dynamic Programming",
    "subtopic": "Scheduling",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Interval Scheduling"
    ],
    "input_format": "A list of tuples, where each tuple contains three integers representing the start time, end time, and profit of the job.",
    "output_format": "An integer representing the maximum profit obtained by scheduling jobs non-overlapping.",
    "constraints": [
      "1 <= jobs.length <= 10^4",
      "0 <= start_time < end_time <= 10^9",
      "0 <= profit <= 10^4"
    ],
    "examples": [
      {
        "input": "jobs = [(1, 3, 50), (2, 5, 10), (6, 19, 100), (2, 100, 200)]",
        "output": "250",
        "explanation": "The optimal jobs to schedule are (1, 3, 50) and (6, 19, 100), yielding a maximum profit of 50 + 100 = 150."
      },
      {
        "input": "jobs = [(1, 2, 10), (2, 3, 20), (3, 4, 30), (4, 5, 40)]",
        "output": "100",
        "explanation": "Scheduling all jobs one after another gives the maximum profit of 10 + 20 + 30 + 40 = 100."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Sort the jobs based on their end time.",
      "Use dynamic programming to keep track of the maximum profit.",
      "Consider using binary search to find the last non-conflicting job."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Search Suggestions System",
    "description": "Design a system that provides auto-suggestions for search queries based on a provided list of valid search terms. Given an array of strings representing valid search terms, and a search prefix string, your task is to return a list of suggested valid search terms that begin with the given prefix. The suggestions should be returned as a list of lists, where each inner list contains up to three suggestions corresponding to the length of the prefix from 1 to the length of the search prefix.",
    "topic": "String",
    "subtopic": "Trie",
    "tags": [
      "String",
      "Binary Search",
      "Trie"
    ],
    "input_format": "Two inputs: an array of strings 'words' (1 <= words.length <= 1000, 1 <= words[i].length <= 100) and a string 'prefix' (1 <= prefix.length <= 100).",
    "output_format": "A list of lists of strings, where each list contains up to three auto-suggestions.",
    "constraints": [
      "1 <= words.length <= 1000",
      "1 <= words[i].length <= 100",
      "All strings in words are unique.",
      "1 <= prefix.length <= 100"
    ],
    "examples": [
      {
        "input": {
          "words": [
            "mobile",
            "mouse",
            "moneypot",
            "monitor",
            "mousepad"
          ],
          "prefix": "mo"
        },
        "output": [
          [
            "mobile",
            "moneypot",
            "monitor"
          ],
          [
            "mobile",
            "moneypot",
            "monitor"
          ],
          [
            "mobile",
            "moneypot",
            "monitor"
          ]
        ],
        "explanation": "For the prefix 'mo', the suggestions are 'mobile', 'moneypot', and 'monitor'. For 'mo' with one character, there are three valid suggestions available."
      },
      {
        "input": {
          "words": [
            "apple",
            "app",
            "apricot",
            "banana",
            "berry"
          ],
          "prefix": "ap"
        },
        "output": [
          [
            "apple",
            "app",
            "apricot"
          ],
          [
            "apple",
            "app",
            "apricot"
          ]
        ],
        "explanation": "For the prefix 'ap', the suggestions are 'apple', 'app', and 'apricot'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a Trie data structure to store the search terms.",
      "For each prefix length, generate a list of matching words."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Koko Eating Bananas",
    "description": "Koko loves bananas. There are n piles of bananas, where the ith pile has bananas[i] bananas. Koko can eat some bananas from a pile at a rate of k bananas per hour. Koko wants to eat all the bananas in the piles, but she is also curious to know the minimum integer k such that she can eat all the bananas within h hours.",
    "topic": "Binary Search",
    "subtopic": "Optimization",
    "tags": [
      "Binary Search",
      "Greedy",
      "Array"
    ],
    "input_format": "Two integers n and h, followed by an array of integers representing the piles of bananas.",
    "output_format": "An integer representing the minimum k that allows Koko to eat all bananas in h hours.",
    "constraints": [
      "1 <= piles.length <= 10^4",
      "1 <= piles[i] <= 10^9",
      "1 <= h <= 10^9"
    ],
    "examples": [
      {
        "input": "piles = [3, 6, 7, 11], h = 8",
        "output": "4",
        "explanation": "If Koko eats 4 bananas/hour, she will finish eating all piles in 8 hours."
      },
      {
        "input": "piles = [30, 11, 23, 4, 20], h = 5",
        "output": "30",
        "explanation": "Koko must eat at least 30 bananas/hour to finish in 5 hours."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to find the minimum k.",
      "Check if Koko can finish the bananas in h hours with a given k by summing the hours needed for each pile."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Most Profit Assigning Work",
    "description": "You are given a list of jobs where each job has a profit value and a deadline. Your task is to maximize the total profit you can earn by completing the jobs on or before their respective deadlines. Each job takes exactly one unit of time, and you can schedule at most one job per unit of time. Determine the maximum profit you can earn by choosing which jobs to complete.",
    "topic": "Greedy Algorithms",
    "subtopic": "Job Scheduling",
    "tags": [
      "Greedy",
      "Scheduling",
      "Profit"
    ],
    "input_format": "An array of pairs representing jobs, where each pair contains two integers: profit and deadline.",
    "output_format": "An integer representing the maximum profit that can be earned.",
    "constraints": [
      "1 <= jobs.length <= 1000",
      "1 <= jobs[i][0] <= 10^4",
      "1 <= jobs[i][1] <= 10^4"
    ],
    "examples": [
      {
        "input": "[[100, 2], [19, 1], [27, 1], [25, 1], [15, 3]]",
        "output": "142",
        "explanation": "Select jobs (100, 2) and (15, 3) for maximum profit."
      },
      {
        "input": "[[5, 1], [10, 2], [15, 2], [20, 1]]",
        "output": "25",
        "explanation": "Select jobs (10, 2) and (15, 2) for maximum profit."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the jobs based on profit.",
      "Utilize a max-heap or priority queue for optimal job scheduling."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Design File System",
    "description": "Implement a file system that supports the following operations: create, addContentToFile, readContentFromFile, and delete. The file system should support folders and files. Each path is separated by '/' and a file can be created at any level in the file system. Users can read the content of a file, add content to an existing file, or delete a file. The operations must reflect the actual structure of the file system when paths are created or removed.",
    "topic": "Design",
    "subtopic": "File System",
    "tags": [
      "Design",
      "File System",
      "OOP"
    ],
    "input_format": "An operation which is one of the following: create(path), addContentToFile(path, content), readContentFromFile(path), delete(path).",
    "output_format": "For readContentFromFile, output the content of the file. For other operations, output nothing.",
    "constraints": [
      "1 <= length of path <= 100",
      "1 <= length of content <= 1000",
      "Path will only contain lowercase letters and '/'"
    ],
    "examples": [
      {
        "input": "create('/a/b/c')",
        "output": "",
        "explanation": "Creates a folder structure with a folder 'a', inside it folder 'b', and inside it folder 'c'."
      },
      {
        "input": "addContentToFile('/a/b/c/file.txt', 'Hello')",
        "output": "",
        "explanation": "Adds 'Hello' to 'file.txt'."
      },
      {
        "input": "readContentFromFile('/a/b/c/file.txt')",
        "output": "Hello",
        "explanation": "Reads the content of 'file.txt', which is now 'Hello'."
      },
      {
        "input": "delete('/a/b/c/file.txt')",
        "output": "",
        "explanation": "Deletes the file 'file.txt' from its path."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to represent the hierarchy of files and folders.",
      "Use a hashmap for folder/file management structure."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Check if One String Swap Can Make Strings Equal",
    "description": "Given two strings s1 and s2, check if you can make s1 equal to s2 by performing exactly one swap of two characters in s1. If it's possible, return true; otherwise, return false.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Swap",
      "Comparison"
    ],
    "input_format": "Two strings s1 and s2, each containing only lowercase letters.",
    "output_format": "A boolean value indicating whether one swap can make the two strings equal.",
    "constraints": [
      "1 <= s1.length, s2.length <= 100",
      "s1 and s2 consist of lowercase English letters only."
    ],
    "examples": [
      {
        "input": "s1 = 'ab', s2 = 'ba'",
        "output": "true",
        "explanation": "Swapping 'a' and 'b' in s1 makes it equal to s2."
      },
      {
        "input": "s1 = 'ab', s2 = 'ab'",
        "output": "false",
        "explanation": "No swap is needed, but exactly one swap is required."
      },
      {
        "input": "s1 = 'aa', s2 = 'aa'",
        "output": "false",
        "explanation": "No difference between strings, cannot perform a swap."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Count the characters that are different between both strings.",
      "If there are exactly two characters that are different, check if they can be swapped."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Shortest Distance from All Buildings",
    "description": "You are given a 2D grid representing a city, where each cell can be either a building, an obstacle, or an empty land. You need to find a location that will minimize the total distance from all buildings. You can only walk up, down, left, or right. The output should be the shortest distance from this optimal location to all buildings. If it is not possible to reach all buildings, return -1.",
    "topic": "Graph",
    "subtopic": "Shortest Path",
    "tags": [
      "Graph",
      "BFS",
      "Distance"
    ],
    "input_format": "A 2D grid of size m x n where each element is either 0 (empty land), 1 (building), or 2 (obstacle).",
    "output_format": "An integer representing the minimum distance from the optimal location to all buildings, or -1 if it is not possible.",
    "constraints": [
      "The grid has at most 500 x 500 cells.",
      "There will be at least one building in the grid."
    ],
    "examples": [
      {
        "input": "[[1,0,2,0,1],[0,0,0,0,0],[1,0,2,0,1]]",
        "output": "7",
        "explanation": "The optimal location for minimizing the distance is the middle cell, which has a total distance of 7 to all buildings."
      },
      {
        "input": "[[1,0,1],[0,0,0],[1,0,1]]",
        "output": "4",
        "explanation": "The optimal location is any of the empty lands which gives a total distance of 4 to the buildings."
      },
      {
        "input": "[[1,0,2],[0,0,0],[0,0,1]]",
        "output": "-1",
        "explanation": "There is no valid location that can reach all buildings due to the obstacle."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using BFS to find distances from each building.",
      "Keep track of the number of buildings that can reach each empty land."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Minimum Number of Steps to Make Two Strings Anagram",
    "description": "Given two strings 's' and 't', return the minimum number of steps required to make 's' and 't' anagrams of each other. In one step, you can delete exactly one character from either of the strings. An anagram of a string is a new string that is formed by rearranging the characters of the original string using all the original characters exactly once.",
    "topic": "String",
    "subtopic": "Frequency Count",
    "tags": [
      "String",
      "Anagram",
      "Frequency"
    ],
    "input_format": "Two strings 's' and 't' that need to be compared.",
    "output_format": "An integer representing the minimum number of steps required to make the strings anagrams.",
    "constraints": [
      "1 <= s.length, t.length <= 2 * 10^5",
      "s and t consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = 'lee', t = 'ze'",
        "output": "4",
        "explanation": "To make 'lee' and 'ze' anagrams, we need to remove 'l', 'e', and 'z' from 'lee' and 'ze', totaling 4 deletions."
      },
      {
        "input": "s = 'night', t = 'thing'",
        "output": "0",
        "explanation": "'night' is already an anagram of 'thing'. No steps are required."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Count the frequency of characters in both strings.",
      "Calculate the difference in frequencies to find the number of deletions needed."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Single-Threaded CPU",
    "description": "Consider a system with a single-threaded CPU that executes tasks. Each task has a unique ID, a duration, and a priority level. The CPU processes tasks based on their priority, with the highest priority being processed first. In the case of a tie in priority, the task with the shorter duration is executed first. If two tasks have the same priority and duration, they will be executed in the order they are provided. Given a list of tasks, your job is to determine the order in which the CPU will process the tasks.",
    "topic": "Sorting",
    "subtopic": "Priority Queue",
    "tags": [
      "Sorting",
      "Priority Queue",
      "Greedy"
    ],
    "input_format": "A list of tasks, where each task is represented as a tuple (id, duration, priority).",
    "output_format": "A list of task IDs representing the order in which the tasks will be executed.",
    "constraints": [
      "1 <= tasks.length <= 10^4",
      "1 <= duration <= 1000",
      "1 <= priority <= 100"
    ],
    "examples": [
      {
        "input": "tasks = [(1, 5, 2), (2, 3, 1), (3, 4, 1), (4, 2, 3)]",
        "output": "[4, 2, 3, 1]",
        "explanation": "Task 4 has the highest priority, followed by tasks 2 and 3, which have the same priority but different durations. Task 1 is last due to its lower priority."
      },
      {
        "input": "tasks = [(1, 2, 1), (2, 2, 2), (3, 3, 2), (4, 1, 1)]",
        "output": "[2, 3, 4, 1]",
        "explanation": "Tasks 2 and 3 have the highest priority, with task 2 being processed first due to its shorter duration."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sorting function that considers both priority and duration.",
      "Consider using a data structure to maintain the order of tasks according to their properties."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Find K Closest Elements",
    "description": "Given a sorted array of integers and a target value, find the K closest elements to the target in the array. The result should be returned in sorted order, and the closest elements are defined as having the smallest absolute difference from the target. If there are ties, choose the smaller elements first.",
    "topic": "Binary Search",
    "subtopic": "Two Pointers",
    "tags": [
      "Binary Search",
      "Two Pointers",
      "Array"
    ],
    "input_format": "An integer array arr, an integer target, and an integer k.",
    "output_format": "An array of the K closest integers to the target value, sorted in ascending order.",
    "constraints": [
      "1 <= arr.length <= 10^4",
      "arr is sorted in ascending order.",
      "1 <= k <= arr.length",
      "-10^9 <= arr[i], target <= 10^9"
    ],
    "examples": [
      {
        "input": "arr = [1, 2, 3, 4, 5], target = 3, k = 2",
        "output": "[2, 3]",
        "explanation": "The closest elements to 3 are 2 and 3."
      },
      {
        "input": "arr = [1, 5, 10], target = 8, k = 2",
        "output": "[5, 10]",
        "explanation": "The closest elements to 8 are 5 and 10."
      },
      {
        "input": "arr = [1, 2, 3, 4, 5], target = 4, k = 3",
        "output": "[2, 3, 4]",
        "explanation": "The closest elements to 4 are 2, 3, and 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to find the closest elements.",
      "Use two pointers to find the K closest elements from the target."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Buddy Strings",
    "description": "Given two strings A and B of lowercase letters, return true if we can swap two letters in A so that the result equals B. Otherwise, return false. The letters that we swap must be different. For example, given A = 'ab' and B = 'ba', we can swap 'a' and 'b' to get 'ba'.",
    "topic": "String",
    "subtopic": "Character Manipulation",
    "tags": [
      "String",
      "Simulation",
      "Swap"
    ],
    "input_format": "Two strings A and B where 1 <= A.length, B.length <= 2 * 10^4.",
    "output_format": "A boolean value - true if the conditions for buddy strings are met, or false otherwise.",
    "constraints": [
      "A and B consist of only lowercase letters.",
      "A.length == B.length"
    ],
    "examples": [
      {
        "input": "A = 'ab', B = 'ba'",
        "output": "true",
        "explanation": "Swapping 'a' and 'b' in 'ab' gives 'ba', which is equal to B."
      },
      {
        "input": "A = 'aa', B = 'aa'",
        "output": "true",
        "explanation": "Swapping the two 'a's in 'aa' results in 'aa', which is still equal to B."
      },
      {
        "input": "A = 'abcd', B = 'badc'",
        "output": "false",
        "explanation": "No single swap can make 'abcd' equal to 'badc'."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Check the characters that differ between A and B.",
      "Remember to handle cases where A and B are identical."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Next Greater Element III",
    "description": "Given a positive integer n, find the smallest integer which has exactly the same digits as n and is greater than n. If no such integer exists, return -1.",
    "topic": "Math",
    "subtopic": "Permutation",
    "tags": [
      "Math",
      "Permutation",
      "Greedy"
    ],
    "input_format": "A single integer n (1 <= n <= 10^9).",
    "output_format": "An integer representing the next greater number with same digits, or -1 if it doesn't exist.",
    "constraints": [
      "1 <= n <= 10^9"
    ],
    "examples": [
      {
        "input": "n = 12",
        "output": "21",
        "explanation": "The next greater number with same digits is 21."
      },
      {
        "input": "n = 21",
        "output": "-1",
        "explanation": "There is no greater number with same digits as 21."
      },
      {
        "input": "n = 1234",
        "output": "1243",
        "explanation": "The next greater number with same digits is 1243."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how to identify the rightmost digit that can be incremented.",
      "Consider using a stack to help rearrange the digits."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Find Nearest Point That Has the Same X or Y Coordinate",
    "description": "You are given a list of points on a 2D plane, where each point is represented as an integer pair (x, y). Write a function to find the index of the nearest point (based on Manhattan distance) that shares either the same x-coordinate or the same y-coordinate as a given point. If there are multiple closest points, return the index of the point with the smallest index. If there is no such point, return -1.",
    "topic": "Geometry",
    "subtopic": "Manhattan Distance",
    "tags": [
      "Geometry",
      "Distance",
      "Points"
    ],
    "input_format": "A list of points represented as pairs of integers and a target point represented as a pair of integers.",
    "output_format": "An integer representing the index of the nearest point or -1 if no such point exists.",
    "constraints": [
      "1 <= points.length <= 100",
      "-10^4 <= points[i][0], points[i][1] <= 10^4",
      "The target point is also a valid point in `points`."
    ],
    "examples": [
      {
        "input": "points = [[1, 2], [3, 4], [2, 3], [1, 3]], target = [1, 2]",
        "output": "3",
        "explanation": "The point (1, 3) has the same x-coordinate as the target (1, 2) and is the nearest point."
      },
      {
        "input": "points = [[1, 2], [3, 4], [2, 3]], target = [5, 5]",
        "output": "-1",
        "explanation": "There are no points that share the same x or y coordinate as the target point (5, 5)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Calculate the Manhattan distance using the formula |x1 - x2| + |y1 - y2|.",
      "Keep track of the nearest point and its index as you iterate through the list."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Design In-Memory File System",
    "description": "Implement a simple in-memory file system that supports basic file and directory operations. You should be able to create files, create directories, read from files, and list the files and directories in the current directory. Each file should have a content which can be read and modified.",
    "topic": "System Design",
    "subtopic": "File System",
    "tags": [
      "File System",
      "Design",
      "Simulation"
    ],
    "input_format": "Define a class `FileSystem` with methods for file and directory operations.",
    "output_format": "The operations return results according to the specified function signatures.",
    "constraints": [
      "The maximum number of files or directories in any path will not exceed 10^4.",
      "File content will not exceed 10^6 characters."
    ],
    "examples": [
      {
        "input": "fs = FileSystem(); fs.mkdir('/a'); fs.createFile('/a/b.txt', 'Hello World'); fs.readFile('/a/b.txt')",
        "output": "'Hello World'",
        "explanation": "Creates a directory `/a`, then a file `b.txt` in that directory with content 'Hello World'. Reading this file returns the content."
      },
      {
        "input": "fs = FileSystem(); fs.mkdir('/a'); fs.createFile('/a/c.txt', 'Test'); fs.mkdir('/a/b'); fs.createFile('/a/b/d.txt', 'Another Test'); fs.readFile('/a/b/d.txt')",
        "output": "'Another Test'",
        "explanation": "Creates a directory `/a`, a file `c.txt` with 'Test', and another directory `b` with a file `d.txt` containing 'Another Test'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a nested dictionary structure to represent directories and files.",
      "Implement methods for adding, retrieving, and listing contents."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Basic Calculator III",
    "description": "Implement a basic calculator to evaluate a simple mathematical expression represented as a string. The expression may contain non-negative integers, '+', '-', '*', '/', '(', and ')'. The order of operations should be respected, following the standard rules of arithmetic, including the precedence of operations and parentheses.",
    "topic": "Mathematics",
    "subtopic": "Expression Evaluation",
    "tags": [
      "Calculator",
      "Math",
      "Expression Parsing"
    ],
    "input_format": "A string expression containing non-negative integers and operators.",
    "output_format": "An integer representing the result of the evaluated expression.",
    "constraints": [
      "The input expression is guaranteed to be valid.",
      "The length of the input expression will not exceed 1000 characters."
    ],
    "examples": [
      {
        "input": "\"2*(5+5*2)/3+(6/2+8)\"",
        "output": "21",
        "explanation": "Following the order of operations: 2*(5+10)/3+8 = 2*15/3+8 = 10+8 = 18."
      },
      {
        "input": "\" 3+5 / 2 \"",
        "output": "5",
        "explanation": "The expression evaluates as: 3 + (5/2) = 3 + 2 = 5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to handle parentheses and operator precedence.",
      "Remember to handle integer division carefully."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Making A Large Island",
    "description": "You are given a grid of 0s (water) and 1s (land), where '1' represents land and '0' represents water. Your task is to find the maximum area of an island in the grid. An island is formed by connecting adjacent lands horizontally or vertically. Write a function that returns the maximum area of an island in the given grid.",
    "topic": "Depth-First Search",
    "subtopic": "Graph Traversal",
    "tags": [
      "DFS",
      "Graph",
      "Matrix",
      "Recursion"
    ],
    "input_format": "A 2D grid of integers where each integer is either 0 or 1.",
    "output_format": "An integer representing the maximum area of an island.",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[0].length <= 300",
      "grid[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "grid = [[0, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0], [1, 1, 0, 1]]",
        "output": "5",
        "explanation": "The maximum area of an island in this grid is 5, formed by the 1s connected vertically in the second and third rows."
      },
      {
        "input": "grid = [[1, 1, 0, 0], [1, 0, 0, 1], [0, 0, 1, 1]]",
        "output": "4",
        "explanation": "The largest island is formed by 1s in the first two rows, providing an area of 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use depth-first search to explore each island.",
      "Maintain a visited matrix to prevent counting the same land multiple times.",
      "Consider edge cases where there are no islands."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Count Sub Islands",
    "description": "You are given a 2D grid where '1' represents land and '0' represents water. A sub-island is defined as a group of connected '1's (land) that is completely surrounded by '0's (water) or the boundary of the grid. A sub-island can be connected horizontally or vertically. Your task is to count the number of distinct sub-islands in the grid.",
    "topic": "Graph",
    "subtopic": "DFS/BFS",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Matrix"
    ],
    "input_format": "A 2D grid represented as a list of lists where each inner list contains integers (0 or 1).",
    "output_format": "An integer representing the number of distinct sub-islands.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 100",
      "grid[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "grid = [[1, 1, 0, 0], [0, 1, 0, 1], [0, 0, 1, 1], [1, 0, 0, 0]]",
        "output": "2",
        "explanation": "There are two sub-islands: one consisting of the top two 1's and another consisting of the bottom-right 1's."
      },
      {
        "input": "grid = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]",
        "output": "4",
        "explanation": "Each '1' in the grid is a separate sub-island as each is surrounded by water."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth First Search (DFS) or Breadth First Search (BFS) to explore the islands.",
      "Make sure to track whether an explored island is fully surrounded by water."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Asteroid Collision",
    "description": "We have a list of integers representing asteroids in a row. Each asteroid is a positive or negative integer, where the absolute value represents the size of the asteroid. A positive integer represents a moving right asteroid, and a negative integer represents a moving left asteroid. When two asteroids collide, the smaller one (by absolute value) will explode. If both are the same size, both will explode. Return the final state of the asteroids after all collisions have taken place.",
    "topic": "Stack",
    "subtopic": "Collision Management",
    "tags": [
      "Stack",
      "Simulation",
      "Collision"
    ],
    "input_format": "An array of integers asteroids, where 1 <= asteroids.length <= 10^4 and -1000 <= asteroids[i] <= 1000.",
    "output_format": "An array of integers representing the final state of the asteroids after all collisions.",
    "constraints": [
      "1 <= asteroids.length <= 10^4",
      "-1000 <= asteroids[i] <= 1000"
    ],
    "examples": [
      {
        "input": "asteroids = [5, 10, -5]",
        "output": "[5, 10]",
        "explanation": "The asteroid 10 and 5 are moving right, while -5 is moving left. -5 collides with 10 and is destroyed, resulting in [5, 10]."
      },
      {
        "input": "asteroids = [8, -8]",
        "output": "[]",
        "explanation": "Both asteroids collide and destroy each other, resulting in an empty list."
      },
      {
        "input": "asteroids = [10, 2, -5]",
        "output": "[10]",
        "explanation": "Asteroid 2 collides with -5 and is destroyed. The remaining asteroid 10 does not collide with anything."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to help manage the states of the asteroids.",
      "Check the sign of the current asteroid and the top of the stack before determining if a collision occurs."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Count Nodes With the Highest Score",
    "description": "You are given a binary tree where each node has an associated score defined as the sum of all values in its subtree, including the node itself. Your task is to find the number of nodes that have the highest score in the binary tree. A node's score is calculated as the sum of all its descendants' values plus its own value. Return the count of such nodes with the highest score.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "DFS"
    ],
    "input_format": "The root of a binary tree is provided as an input.",
    "output_format": "An integer representing the count of nodes with the highest score.",
    "constraints": [
      "1 <= Number of nodes <= 10^5",
      "Node values are between -10^4 and 10^4."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, 4, 5, null, 6]",
        "output": "2",
        "explanation": "The scores are: Node 1: 21, Node 2: 11, Node 3: 6, Node 4: 4, Node 5: 5, Node 6: 6. Nodes 1 and 2 have the highest score (21 and 11 respectively), so the count is 2."
      },
      {
        "input": "root = [1]",
        "output": "1",
        "explanation": "There is only one node with a score of 1. Thus, the count is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider DFS to calculate scores for each node.",
      "Keep track of nodes with the maximum score during the traversal."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Serialize and Deserialize Binary Tree",
    "description": "Implement a binary tree class that has methods to serialize a binary tree to a string and deserialize a string back to the original binary tree structure. Serialization is the process of converting the tree into a string representation, and deserialization is the process of converting the string back into a tree structure. You can assume that the input tree is a valid binary tree.",
    "topic": "Tree",
    "subtopic": "Binary Tree Serialization",
    "tags": [
      "Tree",
      "Binary Tree",
      "Serialization",
      "Deserialization"
    ],
    "input_format": "The binary tree; for serialization, the tree should be represented in a string format, and for deserialization, a string representation of the tree is given.",
    "output_format": "Return the serialized string representation for the serialization method and return the root of the deserialized tree for the deserialization method.",
    "constraints": [
      "The number of nodes in the binary tree is in the range [0, 10^4].",
      "The values of the binary tree nodes are integers in the range [-10^5, 10^5]."
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3, null, null, 4, 5]",
        "output": "\"1,2,3,null,null,4,5\"",
        "explanation": "The tree structure corresponds to the serialized form '1,2,3,null,null,4,5'."
      },
      {
        "input": "data = \"1,2,3,null,null,4,5\"",
        "output": "[1, 2, 3, null, null, 4, 5]",
        "explanation": "The string representation '1,2,3,null,null,4,5' corresponds back to the original tree structure."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using pre-order or level-order traversal for serialization.",
      "You might need to include delimiters to differentiate between nodes and structure during serialization."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Basic Calculator II",
    "description": "Implement a basic calculator to evaluate a simple expression string containing non-negative integers, '+', '-', '*', and '/', and empty spaces. The integer division should truncate toward zero. You may assume that the given expression is always valid. The division by zero will not occur. The order of operations should follow the standard arithmetic rules where multiplication and division are performed before addition and subtraction.",
    "topic": "Math",
    "subtopic": "Expression Evaluation",
    "tags": [
      "Math",
      "Expression",
      "Calculator"
    ],
    "input_format": "A string s representing the expression to evaluate.",
    "output_format": "An integer result of the evaluated expression.",
    "constraints": [
      "1 <= s.length <= 3 * 10^5",
      "s consists of integers and operators (+, -, *, /) and spaces.",
      "All integer values in s are non-negative."
    ],
    "examples": [
      {
        "input": "s = \"3+2*2\"",
        "output": "7",
        "explanation": "2*2 is evaluated first to get 4, and then 3+4 = 7."
      },
      {
        "input": "s = \" 3/2 \"",
        "output": "1",
        "explanation": "3 divided by 2 truncates to 1."
      },
      {
        "input": "s = \" 3+5 / 2 \"",
        "output": "5",
        "explanation": "5 divided by 2 is 2, and adding 3 gives 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to handle the operations.",
      "Keep track of the last operation encountered."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Count All Valid Pickup and Delivery Options",
    "description": "You are tasked with counting the number of valid pickup and delivery options given a number of orders. Each order has a unique pickup and delivery location. A valid option occurs when each delivery location has its corresponding pickup location taken into account. You need to consider that the orders are processed sequentially, and the total number of valid pickup and delivery arrangements would be the result of all valid combinations.",
    "topic": "Dynamic Programming",
    "subtopic": "Combinatorial Counting",
    "tags": [
      "Dynamic Programming",
      "Combinatorics",
      "Mathematics"
    ],
    "input_format": "An integer n, representing the number of orders.",
    "output_format": "An integer representing the number of valid pickup and delivery options.",
    "constraints": [
      "1 <= n <= 500"
    ],
    "examples": [
      {
        "input": "n = 1",
        "output": "1",
        "explanation": "With 1 order, there is only 1 way to pick up and deliver."
      },
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "With 2 orders, we can either (P1,D1)(P2,D2) or (P2,D2)(P1,D1)."
      },
      {
        "input": "n = 3",
        "output": "5",
        "explanation": "The valid arrangements are: (P1,D1)(P2,D2)(P3,D3), (P1,D1)(P3,D3)(P2,D2), (P2,D2)(P1,D1)(P3,D3), (P2,D2)(P3,D3)(P1,D1), (P3,D3)(P1,D1)(P2,D2)."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use dynamic programming to break the problem into subproblems.",
      "Consider the factorial function in combination with valid orderings.",
      "Look for a pattern in the valid arrangements as n increases."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Course Schedule II",
    "description": "There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, and you are given an array of pairs where pairs[i] = [a, b] indicates that to take course a you have to first take course b. You need to return the ordering of courses you should take to finish all courses. If it is impossible to finish all courses, return an empty array.",
    "topic": "Graph",
    "subtopic": "Topological Sorting",
    "tags": [
      "Graph",
      "Topological Sorting",
      "DFS",
      "BFS"
    ],
    "input_format": "Two integers n and prerequisites where prerequisites is a list of pairs representing the prerequisites of courses.",
    "output_format": "A list of integers representing the order of courses. If not possible, return an empty list.",
    "constraints": [
      "1 <= n <= 2000",
      "0 <= prerequisites.length <= n * (n - 1) / 2",
      "prerequisites[i].length == 2",
      "0 <= prerequisites[i][0], prerequisites[i][1] < n"
    ],
    "examples": [
      {
        "input": "n = 4, prerequisites = [[1,0],[2,1],[3,2]]",
        "output": "[0,1,2,3]",
        "explanation": "Course 0 should be taken before 1, 1 before 2, and 2 before 3."
      },
      {
        "input": "n = 2, prerequisites = [[1,0],[0,1]]",
        "output": "[]",
        "explanation": "It's impossible to complete the courses due to circular dependency."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using graph traversal techniques like BFS or DFS.",
      "Topological sorting is key to solving the problem."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Best Meeting Point",
    "description": "Given a grid where each cell contains non-negative integers representing the positions of people, your task is to find the optimal meeting point (i.e., cell) such that the total distance traveled by all the people is minimized. The distance is calculated as the Manhattan distance between points.",
    "topic": "Dynamic Programming",
    "subtopic": "Optimization",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Matrix"
    ],
    "input_format": "A 2D grid of non-negative integers where grid[i][j] indicates the number of people at position (i, j).",
    "output_format": "An integer representing the minimum total distance traveled by all people to the meeting point.",
    "constraints": [
      "1 <= grid.length <= 100",
      "1 <= grid[0].length <= 100",
      "0 <= grid[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]",
        "output": "2",
        "explanation": "The optimal meeting point is (1, 1). All 1 person can reach it with a distance of 2."
      },
      {
        "input": "grid = [[1, 0, 0], [0, 0, 0], [0, 0, 1]]",
        "output": "4",
        "explanation": "The optimal meeting point is (0, 1) or (2, 1). The total distance is minimized to 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider the properties of Manhattan distance.",
      "Try calculating distances in both dimensions separately.",
      "Sorting the coordinates can help find the best meeting point."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Vertical Order Traversal of a Binary Tree",
    "description": "Given the root of a binary tree, return the vertical order traversal of its nodes' values. For each node at the same horizontal position, return the values in increasing order from top to bottom. If two nodes are in the same row and column, the order of their values should reflect their order in level traversal from left to right.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Traversal"
    ],
    "input_format": "The input consists of a binary tree defined by its root node.",
    "output_format": "A 2D array of integers representing the vertical order traversal of the tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[9],[3,15],[20],[7]]",
        "explanation": "The vertical order traversal of the given tree is [[9],[3,15],[20],[7]]."
      },
      {
        "input": "root = [1,2,3,4,5,6,7]",
        "output": "[[4],[2],[1,5,6],[3],[7]]",
        "explanation": "The vertical order traversal of the given tree is [[4],[2],[1,5,6],[3],[7]]."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use BFS or DFS to traverse the tree while keeping track of the vertical positions.",
      "Utilize a data structure to group nodes at the same vertical level.",
      "Sort the nodes at each vertical position before returning the final result."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Immediate Food Delivery I",
    "description": "A food delivery service needs to determine whether it can fulfill all the orders received within a specified time limit. Given a list of orders, where each order consists of a preparation time and a delivery time, you are to find out if all orders can be delivered on time. The total time taken for each order is the sum of its preparation and delivery times. If the total time for any order exceeds the specified time limit, then it cannot be delivered on time.",
    "topic": "Greedy Algorithms",
    "subtopic": "Scheduling",
    "tags": [
      "Greedy",
      "Scheduling",
      "Array"
    ],
    "input_format": "The input consists of two arrays: the first array `prep_times` represents the preparation time for each order, and the second array `delivery_times` represents the delivery time for each order. An integer `time_limit` is also provided, which represents the maximum time allowed for delivery.",
    "output_format": "Return a boolean value: `true` if all orders can be delivered on time, `false` otherwise.",
    "constraints": [
      "1 <= prep_times.length <= 1000",
      "1 <= delivery_times.length <= 1000",
      "prep_times.length == delivery_times.length",
      "1 <= prep_times[i], delivery_times[i] <= 100"
    ],
    "examples": [
      {
        "input": {
          "prep_times": [
            10,
            20,
            30
          ],
          "delivery_times": [
            5,
            10,
            5
          ],
          "time_limit": 60
        },
        "output": true,
        "explanation": "Total times are [15, 30, 35] which are all within the time limit of 60."
      },
      {
        "input": {
          "prep_times": [
            10,
            20
          ],
          "delivery_times": [
            5,
            20
          ],
          "time_limit": 25
        },
        "output": false,
        "explanation": "Total times are [15, 40] and the second order exceeds the time limit of 25."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Calculate the total time for each order and compare it to the time limit.",
      "Use a loop to iterate through each order."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Immediate Food Delivery II",
    "description": "A delivery service has a list of orders, each with a time when it is received and a delivery time. The service must determine if each order can be delivered within its specified time. Given an array of orders where each order is represented by a pair of integers (arrival time and delivery time), determine if all orders can be delivered on time. If an order cannot be delivered on time, return 'NO' for that order; otherwise, return 'YES'.",
    "topic": "Greedy",
    "subtopic": "Scheduling",
    "tags": [
      "Greedy",
      "Scheduling",
      "Array"
    ],
    "input_format": "An array of pairs of integers orders where each pair is [arrival_time, delivery_time].",
    "output_format": "An array of strings where each string is 'YES' or 'NO' indicating whether each corresponding order can be delivered on time.",
    "constraints": [
      "1 <= orders.length <= 10^5",
      "0 <= arrival_time, delivery_time <= 24"
    ],
    "examples": [
      {
        "input": "orders = [[1, 3], [2, 5], [4, 6]]",
        "output": "['YES', 'YES', 'NO']",
        "explanation": "The first order can be delivered by time 3, the second by 5. The third order arrives at time 4 but can only be delivered by time 6, which is not feasible given the previous delivery."
      },
      {
        "input": "orders = [[0, 1], [1, 2], [2, 3]]",
        "output": "['YES', 'YES', 'YES']",
        "explanation": "All orders can be delivered on time as there is no overlap."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the orders by arrival time and manage the delivery times accordingly.",
      "Consider using a variable to keep track of the last time an order was delivered."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Implement Trie (Prefix Tree)",
    "description": "Design and implement a Trie (prefix tree) with the following operations: insert, search, and startsWith. Trie is a special tree used to store associative data structures. A common application of a Trie is storing a predictive text or autocomplete dictionary. The implementation should support the following methods: \n\n1. insert(word) - Inserts the string 'word' into the Trie. \n2. search(word) - Returns true if the string 'word' is in the Trie (i.e., was inserted before), and false otherwise. \n3. startsWith(prefix) - Returns true if there is a previously inserted string that starts with the given prefix.",
    "topic": "Data Structures",
    "subtopic": "Trie",
    "tags": [
      "Trie",
      "Data Structures",
      "String"
    ],
    "input_format": "You will be given an operation type (string) and a word (string) to perform operations on the Trie.",
    "output_format": "The output will be a boolean indicating the result of the search and startsWith operations.",
    "constraints": [
      "1 <= word.length <= 200",
      "The input only contains lowercase English letters."
    ],
    "examples": [
      {
        "input": [
          {
            "operation": "insert",
            "word": "apple"
          },
          {
            "operation": "search",
            "word": "apple"
          },
          {
            "operation": "search",
            "word": "app"
          },
          {
            "operation": "startsWith",
            "prefix": "app"
          },
          {
            "operation": "insert",
            "word": "app"
          },
          {
            "operation": "search",
            "word": "app"
          }
        ],
        "output": [
          null,
          true,
          false,
          true,
          null,
          true
        ],
        "explanation": "The word 'apple' is inserted. Searching for 'apple' returns true. 'app' is not in the Trie yet, so it returns false. 'app' starts with 'app', so it returns true. After inserting 'app', searching for 'app' returns true."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "A Trie node can store child nodes corresponding to each character.",
      "Use a boolean flag to indicate if a node marks the end of a word."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Two Pointers",
      "Hash Map"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "nums[0] + nums[1] = 2 + 7 = 9."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "nums[1] + nums[2] = 2 + 4 = 6."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "Both elements at index 0 and 1 make the sum of 6."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hash map to track the indices of the elements.",
      "You can iterate through the array and check if the complement exists in the hash map."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Subsequence With the Minimum Score",
    "description": "Given two strings, 's' and 't', you need to remove some characters from 's' to create a new subsequence that is also a subsequence of 't'. The score of the new subsequence is defined as the sum of the ASCII values of the removed characters. Your goal is to find the minimum score possible by removing characters from 's'.",
    "topic": "String",
    "subtopic": "Subsequence",
    "tags": [
      "String",
      "Subsequence",
      "Dynamic Programming"
    ],
    "input_format": "Two strings 's' and 't', where 1 <= s.length, t.length <= 1000.",
    "output_format": "An integer representing the minimum score by removing characters from 's'.",
    "constraints": [
      "1 <= s.length, t.length <= 1000",
      "All characters in 's' and 't' are lowercase English letters."
    ],
    "examples": [
      {
        "input": "s = 'abac', t = 'bcbc'",
        "output": "97",
        "explanation": "By removing 'a' (ASCII 97) from 's', the remaining characters 'bac' can form the subsequence 'bc' which is a subsequence of 't'."
      },
      {
        "input": "s = 'abc', t = 'cba'",
        "output": "195",
        "explanation": "All characters from 's' need to be removed to form a valid subsequence of 't', resulting in a sum of ASCII values: 'a' (97) + 'b' (98) + 'c' (99) = 294."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to compare subsequences.",
      "Keep track of ASCII sums as you evaluate potential subsequences."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Interval List Intersections",
    "description": "Given two lists of intervals, return the intersection of these two lists. Each list of intervals is represented as a list of intervals, where each interval is a pair of integers [start, end]. The intersection of two intervals [a, b] and [c, d] is defined as [max(a, c), min(b, d)], provided that max(a, c) <= min(b, d). If there is no intersection, return an empty interval.",
    "topic": "Array",
    "subtopic": "Interval Management",
    "tags": [
      "Array",
      "Interval",
      "Intersection"
    ],
    "input_format": "Two lists of intervals, firstList and secondList, where each interval is represented as a list of two integers.",
    "output_format": "A list of intervals representing the intersections.",
    "constraints": [
      "0 <= firstList.length, secondList.length <= 1000",
      "firstList[i][0] <= firstList[i][1]",
      "secondList[j][0] <= secondList[j][1]",
      "The intervals in both lists must be sorted by their start time."
    ],
    "examples": [
      {
        "input": "firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]",
        "output": "[[1,2],[5,5],[15,23],[24,24]]",
        "explanation": "The intersections are: [1,2], [5,5], [15,23], [24,24]."
      },
      {
        "input": "firstList = [[1,3],[5,9]], secondList = [[2,5],[8,10]]",
        "output": "[[2,3],[5,5]]",
        "explanation": "The intersections are: [2,3], [5,5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider merging both lists in a single sorted array.",
      "Use two pointers to traverse both lists."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Mice and Cheese",
    "description": "You have a row of cheese positioned on a number line, and you want to place mice at certain positions. Each mouse can eat the cheese within a certain distance. Given an array of integers representing the positions of cheese and an array of integers representing the positions of mice, your task is to determine how many pieces of cheese can be eaten by the mice. Each mouse can only eat one piece of cheese, and a piece of cheese can only be eaten by one mouse. A mouse can eat a piece of cheese if it is within a given distance.",
    "topic": "Greedy",
    "subtopic": "Two Pointers",
    "tags": [
      "Greedy",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "Two arrays of integers, cheese and mice, where each element represents their respective positions on a number line.",
    "output_format": "An integer representing the maximum number of pieces of cheese that can be eaten by the mice.",
    "constraints": [
      "1 <= cheese.length, mice.length <= 1000",
      "-10^9 <= cheese[i], mice[j] <= 10^9",
      "1 <= d <= 10^9"
    ],
    "examples": [
      {
        "input": {
          "cheese": [
            1,
            2,
            3
          ],
          "mice": [
            2,
            3
          ],
          "d": 1
        },
        "output": "2",
        "explanation": "Mouse at position 2 can eat cheese at position 2, and the mouse at position 3 can eat cheese at position 3."
      },
      {
        "input": {
          "cheese": [
            1,
            4,
            8
          ],
          "mice": [
            1,
            3
          ],
          "d": 2
        },
        "output": "2",
        "explanation": "Mouse at position 1 can eat cheese at position 1, and mouse at position 3 can eat either piece of cheese at positions 4 or 8."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort both arrays to optimize matching.",
      "Use two pointers to traverse the arrays efficiently."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Jump Game",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Write a function to determine if you can reach the last index starting from the first index.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "A boolean value indicating whether you can reach the last index.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "true",
        "explanation": "You can jump to index 1 (jump 2 steps) then jump to the last index 4."
      },
      {
        "input": "nums = [3, 2, 1, 0, 4]",
        "output": "false",
        "explanation": "You will always arrive at index 3, which has a jump length of 0, so you cannot reach the last index."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to keep track of the maximum index you can reach.",
      "If at any point the maximum index you can reach is less than the current index, return false."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Task Scheduler",
    "description": "You are given a list of tasks and a non-negative integer n representing the cooldown period between the same tasks. Each task is represented by a single uppercase English letter. You need to determine the minimum time required to execute all tasks such that the same tasks do not appear in the cooldown period. If it is impossible to execute all tasks without violating the cooldown constraint, return -1.",
    "topic": "Greedy",
    "subtopic": "Task Scheduling",
    "tags": [
      "Greedy",
      "Array",
      "Task Scheduling"
    ],
    "input_format": "An array of characters representing tasks and an integer n for the cooldown period.",
    "output_format": "An integer representing the minimum time required to finish all tasks, or -1 if impossible.",
    "constraints": [
      "1 <= tasks.length <= 10^4",
      "0 <= n <= 26"
    ],
    "examples": [
      {
        "input": "tasks = ['A', 'A', 'A', 'B', 'B', 'B'], n = 2",
        "output": "8",
        "explanation": "One possible order of execution is A -> B -> A -> B -> A - > idle -> B. Total time is 8."
      },
      {
        "input": "tasks = ['A', 'A', 'A', 'B', 'B', 'B'], n = 0",
        "output": "6",
        "explanation": "With no cooldown, all tasks can be executed back-to-back. Total time is 6."
      },
      {
        "input": "tasks = ['A', 'A', 'A', 'B', 'B', 'B'], n = 3",
        "output": "nbogh532g34331",
        "explanation": ""
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider counting the frequency of each task.",
      "How many tasks can be executed between the same task occurrences?",
      "Think about filling idle times with the least frequent tasks."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Largest Rectangle in Histogram",
    "description": "Given an array representing the heights of bars in a histogram, find the area of the largest rectangle that can be formed within the histogram. The width of the rectangle is bounded by the distance between the two bars, and the height is determined by the shorter of the two bars. Calculate the maximum area that can be formed by any rectangle within the given histogram.",
    "topic": "Stack",
    "subtopic": "Monotonic Stack",
    "tags": [
      "Stack",
      "Histogram",
      "Array",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers 'heights' where 0 <= heights[i] <= 10^4, represents the height of the histogram bars.",
    "output_format": "An integer representing the area of the largest rectangle.",
    "constraints": [
      "1 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [2, 1, 5, 6, 2, 3]",
        "output": "10",
        "explanation": "The largest rectangle can be formed between heights 5 and 6, giving an area of 5 * 2 = 10."
      },
      {
        "input": "heights = [2, 4]",
        "output": "4",
        "explanation": "The largest rectangle can be formed at height 2, giving an area of 2 * 2 = 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to keep track of the indices of the histogram bars.",
      "When traversing the histogram, maintain the heights in a way that allows quick area calculation.",
      "Think about the conditions under which you can compute the area of a rectangle for a given height."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Basic Calculator",
    "description": "Implement a basic calculator to evaluate a simple expression string containing non-negative integers, '+', '-', '(', and ')'. The calculator should respect the order of operations and handle nested parentheses appropriately. For instance, the expression '1 + 2 - 3' should evaluate to '0', while '(1 + 2) - 3' should be evaluated as '3 - 3', yielding '0'.",
    "topic": "Math",
    "subtopic": "Parsing Expressions",
    "tags": [
      "Math",
      "Parsing",
      "Calculator"
    ],
    "input_format": "A string expression containing non-negative integers and the operators '+', '-', '(', and ')'.",
    "output_format": "An integer representing the evaluated result of the expression.",
    "constraints": [
      "The input string is not empty and contains only valid characters.",
      "The number of characters in the expression does not exceed 10^4."
    ],
    "examples": [
      {
        "input": "(1 + 2) - (3 + (4 - 2))",
        "output": "0",
        "explanation": "The expression evaluates to 3 - 3 = 0."
      },
      {
        "input": "2 - 1 + 2",
        "output": "3",
        "explanation": "The expression evaluates to 2 - 1 + 2 = 3."
      },
      {
        "input": "1 + 1",
        "output": "2",
        "explanation": "The expression evaluates to 2."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to help with parentheses.",
      "Keep track of the current number and the sign before it."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "01 Matrix",
    "description": "Given a binary matrix, update it so that each cell contains the distance of the cell to the nearest 0. The distance between two adjacent cells is 1. If a cell contains a 0, its distance to itself is 0.",
    "topic": "Breadth-First Search",
    "subtopic": "Matrix",
    "tags": [
      "BFS",
      "Matrix",
      "Distance"
    ],
    "input_format": "A binary matrix of size m x n, where 0 represents the cell containing a zero and 1 represents a cell containing a one.",
    "output_format": "A matrix of the same size where each element is the distance to the nearest zero.",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 10^4",
      "matrix[i][j] is 0 or 1"
    ],
    "examples": [
      {
        "input": "matrix = [[0,0,0],[0,1,0],[0,0,0]]",
        "output": "[[0,0,0],[0,1,0],[0,0,0]]",
        "explanation": "Each 1 has the nearest 0 at distance 1."
      },
      {
        "input": "matrix = [[0,0,0],[1,1,1],[0,0,0]]",
        "output": "[[0,0,0],[1,1,1],[0,0,0]]",
        "explanation": "Each 1 has a nearest 0 at distance 1 or 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to perform BFS from all 0s simultaneously.",
      "Keep track of visited nodes to avoid cycles."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Next Permutation",
    "description": "Implement the next permutation algorithm, which modifies the input array of integers into its next lexicographical permutation. The algorithm should rearrange the numbers to create the next greater permutation of numbers in-place. If such arrangement is not possible, it must rearrange it to the lowest possible order (i.e., sorted in ascending order).",
    "topic": "Array",
    "subtopic": "Permutation",
    "tags": [
      "Array",
      "Permutation",
      "In-place"
    ],
    "input_format": "An array of integers nums, where nums[i] is the ith element of the array.",
    "output_format": "Modify nums in-place to represent the next permutation.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[1, 3, 2]",
        "explanation": "The next permutation of [1, 2, 3] is [1, 3, 2]."
      },
      {
        "input": "nums = [3, 2, 1]",
        "output": "[1, 2, 3]",
        "explanation": "Since [3, 2, 1] is the highest permutation, the next permutation is [1, 2, 3], which is the lowest."
      },
      {
        "input": "nums = [1, 1, 5]",
        "output": "[1, 5, 1]",
        "explanation": "The next permutation of [1, 1, 5] is [1, 5, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Look for the first number that is smaller than the number next to it from the end.",
      "Find the smallest number on the right side of that number and swap them.",
      "Reverse the sequence after the original position of that number."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Word Search II",
    "description": "Given a 2D board and a list of words, find all words in the board. Each word must be constructed from letters of sequentially adjacent cells, where 'adjacent' cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Return all words that can be found in the board.",
    "topic": "Backtracking",
    "subtopic": "Trie",
    "tags": [
      "Backtracking",
      "Trie",
      "Search"
    ],
    "input_format": "A 2D board of characters and a list of words.",
    "output_format": "A list of words that can be constructed from the board.",
    "constraints": [
      "m == board.length",
      "n == board[i].length",
      "1 <= m, n <= 12",
      "1 <= words.length <= 3 * 10^4",
      "1 <= words[i].length <= 10",
      "All characters in the board and words are lowercase English letters."
    ],
    "examples": [
      {
        "input": {
          "board": [
            [
              "o",
              "a",
              "a",
              "n"
            ],
            [
              "e",
              "t",
              "a",
              "e"
            ],
            [
              "i",
              "h",
              "k",
              "r"
            ],
            [
              "i",
              "f",
              "l",
              "v"
            ]
          ],
          "words": [
            "oath",
            "pea",
            "eat",
            "rain"
          ]
        },
        "output": [
          "eat",
          "oath"
        ],
        "explanation": "The words 'eat' and 'oath' can be found in the board."
      },
      {
        "input": {
          "board": [
            [
              "a",
              "b"
            ],
            [
              "c",
              "d"
            ]
          ],
          "words": [
            "abcb"
          ]
        },
        "output": [],
        "explanation": "The word 'abcb' cannot be found in the board."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a trie for efficient prefix searching.",
      "Backtrack from each cell in the board to find valid words.",
      "Keep track of visited cells to avoid repetition."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Max Area of Island",
    "description": "Given a 2D grid consisting of 0s (water) and 1s (land), write a function to calculate the maximum area of an island. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Depth-First Search",
    "subtopic": "Grid Traversal",
    "tags": [
      "DFS",
      "Grid",
      "BFS",
      "Area Calculation"
    ],
    "input_format": "A 2D grid represented as a list of lists containing integers (0 or 1).",
    "output_format": "An integer representing the maximum area of an island.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 50",
      "grid[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "grid = [[0,0,0,0,0,0],[0,1,1,0,0,0],[0,0,1,0,1,1],[0,0,0,0,0,0]]",
        "output": "4",
        "explanation": "The maximum area is 4, which corresponds to the island formed by the 1s in the second and third rows."
      },
      {
        "input": "grid = [[0,0,0,0],[0,0,0,0]]",
        "output": "0",
        "explanation": "There are no islands present in the grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use depth-first search (DFS) to explore the area of the island.",
      "Keep track of visited cells to avoid counting them more than once.",
      "Consider the boundaries of the grid when traversing."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Longest Common Subsequence",
    "description": "Given two strings text1 and text2, return the length of their longest common subsequence. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. (i.e., 'ace' is a subsequence of 'abcde' while 'aec' is not). A common subsequence of two strings is a subsequence that is common to both strings. If there is no common subsequence, return 0.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Subsequence"
    ],
    "input_format": "Two strings text1 and text2, where 1 <= text1.length, text2.length <= 1000.",
    "output_format": "An integer representing the length of the longest common subsequence.",
    "constraints": [
      "1 <= text1.length, text2.length <= 1000",
      "text1 and text2 consist of only English letters."
    ],
    "examples": [
      {
        "input": "text1 = \"abcde\", text2 = \"ace\"",
        "output": "3",
        "explanation": "The longest common subsequence is \"ace\" which has length 3."
      },
      {
        "input": "text1 = \"abc\", text2 = \"def\"",
        "output": "0",
        "explanation": "There is no common subsequence, so the output is 0."
      },
      {
        "input": "text1 = \"abc\", text2 = \"abc\"",
        "output": "3",
        "explanation": "Both strings are identical, so the longest common subsequence is \"abc\" with length 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try using dynamic programming to build a solution.",
      "Consider using a 2D array to store lengths of common subsequences."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Minimum Size Subarray Sum",
    "description": "Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Prefix Sum"
    ],
    "input_format": "An array of positive integers nums and an integer target.",
    "output_format": "An integer representing the minimal length of the subarray with sum >= target.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i] <= 10^4",
      "1 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 2, 4, 3], target = 7",
        "output": "2",
        "explanation": "The subarray [4, 3] has the minimal length of 2 and a sum of 7."
      },
      {
        "input": "nums = [1, 4, 4], target = 4",
        "output": "1",
        "explanation": "The subarray [4] has the minimal length of 1 and a sum of 4."
      },
      {
        "input": "nums = [1, 1, 1, 1, 1, 1], target = 11",
        "output": "0",
        "explanation": "No subarray can achieve a sum of 11."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window approach to find the required subarray length.",
      "Maintain a running sum and adjust the window size based on the condition."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Number of Visible People in a Queue",
    "description": "You are given an array of integers where each integer represents the height of a person standing in a queue. A person can see another person if they are taller than all the persons in front of them. Your task is to determine how many people can see at least one other person in the queue.",
    "topic": "Array",
    "subtopic": "Stack",
    "tags": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "input_format": "An array of integers heights where heights[i] represents the height of the i-th person in the queue.",
    "output_format": "An integer representing the number of people who can see at least one other person.",
    "constraints": [
      "1 <= heights.length <= 10^5",
      "1 <= heights[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "heights = [1, 2, 3, 4, 5]",
        "output": "4",
        "explanation": "Only the first person (1) cannot see anyone in front of them. All other persons can see the person in front of them."
      },
      {
        "input": "heights = [5, 3, 8, 6, 7]",
        "output": "3",
        "explanation": "Persons with heights 5, 6, and 7 can see at least one person; person 3 cannot see anyone in front of them."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to maintain the heights of people as you iterate.",
      "Only push a height onto the stack if it is greater than the height of the person currently being evaluated."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Swim in Rising Water",
    "description": "You are given a 2D grid representing a map where '0' represents land and '1' represents water. Initially, water starts flooding the grid from the edges horizontally and vertically. The water level rises by one unit every minute. You must determine how long it takes for the water to reach every land cell. If there are any land cells that will never be reached by the water, return -1. Otherwise, return the time in minutes it takes for the last land cell to be submerged.",
    "topic": "Graph",
    "subtopic": "BFS",
    "tags": [
      "Graph",
      "BFS",
      "Flood Fill"
    ],
    "input_format": "A 2D grid of integers where 0 = land and 1 = water.",
    "output_format": "An integer representing the time in minutes for the last land cell to be submerged, or -1 if some land cells are unreachable.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 100",
      "grid[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "[[0,0,1],[0,0,0],[0,1,1]]",
        "output": "4",
        "explanation": "Water from the edges starts flooding cells which takes 4 minutes for the last land cell to be submerged."
      },
      {
        "input": "[[0,0,0],[0,1,0],[0,0,0]]",
        "output": "-1",
        "explanation": "The land cell (1,1) will never be reached, hence the result is -1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use BFS to simulate the spread of water.",
      "Maintain a queue to keep track of flooded cells."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Design Add and Search Words Data Structure",
    "description": "Implement a data structure that supports adding new words and searching for a specific word. The search can also take a dot '.' which represents any letter. For example, if you search 'a.b', it should match 'abc', 'axb', 'a1b', etc. Your implementation should support the following operations: addWord(word) and search(word).",
    "topic": "Trie",
    "subtopic": "Data Structure",
    "tags": [
      "Trie",
      "Design",
      "Data Structure"
    ],
    "input_format": "You will receive a string in the format of a word for addWord and a pattern for search.",
    "output_format": "A boolean value indicating whether the word or pattern exists in the data structure.",
    "constraints": [
      "1 <= word.length <= 10",
      "1 <= pattern.length <= 10",
      "The input consists of lowercase letters a-z."
    ],
    "examples": [
      {
        "input": {
          "addWord": "mad",
          "search": "pad"
        },
        "output": false,
        "explanation": "The word 'pad' is not in the data structure."
      },
      {
        "input": {
          "addWord": "mad",
          "search": "b.."
        },
        "output": true,
        "explanation": "The pattern 'b..' matches 'bad'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Using a Trie can help efficiently store and search words.",
      "Consider how to implement the wildcard search."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Jump Game II",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Write a function that returns the minimum number of jumps necessary to reach the end of the array. If you cannot reach the end, return -1.",
    "topic": "Greedy",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Greedy",
      "Dynamic Programming",
      "Array"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "An integer representing the minimum number of jumps needed to reach the last index, or -1 if it's not possible.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "2",
        "explanation": "The minimum number of jumps to reach the last index is 2. Jump from index 0 to index 1 and then from index 1 to the last index."
      },
      {
        "input": "nums = [2, 3, 0, 1, 4]",
        "output": "2",
        "explanation": "The minimum number of jumps to reach the last index is 2. Jump from index 0 to index 1 and then directly to the last index from index 1."
      },
      {
        "input": "nums = [0]",
        "output": "0",
        "explanation": "You are already at the last index, so no jumps are needed."
      },
      {
        "input": "nums = [1, 2, 3]",
        "output": "2",
        "explanation": "Jump from index 0 to index 1, then from index 1 to index 2 (the last index)."
      },
      {
        "input": "nums = [1, 1, 0, 0]",
        "output": "-1",
        "explanation": "It is not possible to reach the last index due to zeros blocking the path."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "You can use a greedy approach to minimize the number of jumps.",
      "Track the farthest position you can reach at each jump.",
      "Make jumps only when necessary to progress towards the target."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Binary Tree Vertical Order Traversal",
    "description": "Given the root of a binary tree, return the vertical order traversal of its nodes' values. For each column, the nodes should be ordered from top to bottom. For nodes in the same row, they should be ordered from left to right. If two nodes are in the same position in different columns, then the leftmost should appear first.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Traversal"
    ],
    "input_format": "The input is the root node of a binary tree.",
    "output_format": "A list of lists of integers representing the vertical order traversal.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[9],[3,15],[20],[7]]",
        "explanation": "The binary tree is: [3,9,20,null,null,15,7]. The vertical order is: 9 (column -1), 3 and 15 (column 0), 20 (column 1), 7 (column 2)."
      },
      {
        "input": "root = [1,2,3,4,5,6,7]",
        "output": "[[4],[2],[1,5,6],[3],[7]]",
        "explanation": "The binary tree is: [1,2,3,4,5,6,7]. The vertical order is: 4 (column -2), 2 (column -1), 1,5,6 (column 0), 3 (column 1), 7 (column 2)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to perform a breadth-first traversal of the tree.",
      "Maintain a mapping of column indices to node values.",
      "Sort the final output by column indices and row indices."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Minimize Malware Spread",
    "description": "In a network represented as an undirected graph, each node represents a computer and an edge represents a direct connection between two computers. Some nodes are initially infected by malware. Your task is to find the node whose removal will result in minimizing the spread of malware. If there's a tie, choose the node with the smallest index.",
    "topic": "Graph",
    "subtopic": "Graph Traversal",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Sorting"
    ],
    "input_format": "An integer n representing the number of nodes, an integer[][] edges representing the connections between nodes, and an integer[] initial representing the initially infected nodes.",
    "output_format": "An integer representing the node that should be removed to minimize the spread of malware.",
    "constraints": [
      "1 <= n <= 1000",
      "0 <= edges.length <= 10000",
      "0 <= edges[i][0], edges[i][1] < n",
      "edges[i][0] != edges[i][1]",
      "1 <= initial.length <= n"
    ],
    "examples": [
      {
        "input": "n = 5, edges = [[0,1],[0,2],[1,2],[1,3],[3,4]], initial = [1, 0]",
        "output": "0",
        "explanation": "Removing node 0 will minimize the spread, as it connects most initially infected nodes."
      },
      {
        "input": "n = 6, edges = [[0,1],[0,2],[0,3],[1,4],[1,5]], initial = [4, 5]",
        "output": "1",
        "explanation": "Removing node 1 will isolate the initially infected nodes from the remaining nodes."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using graph algorithms to traverse and analyze the spread.",
      "Count the number of initially infected neighbors for each node.",
      "Use priority to resolve ties based on node index."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Sudoku Solver",
    "description": "Implement a function to solve a given Sudoku puzzle by filling the empty cells. A Sudoku puzzle is represented as a 9x9 grid consisting of digits from 1 to 9. The empty cells are represented by the character '.' (dot). The solver must fill in the grid so that each row, column, and 3x3 subgrid contains all the digits from 1 to 9 exactly once.",
    "topic": "Backtracking",
    "subtopic": "Sudoku",
    "tags": [
      "Backtracking",
      "Recursion",
      "Array"
    ],
    "input_format": "A 2D array of characters representing the Sudoku puzzle. Each element is either a digit (1-9) or '.' for empty cells.",
    "output_format": "The 2D array of characters representing the solved Sudoku puzzle.",
    "constraints": [
      "The given Sudoku puzzle has a unique solution.",
      "1 <= board.length <= 9",
      "1 <= board[i].length <= 9",
      "board[i][j] is a '.' or a digit from '1' to '9'."
    ],
    "examples": [
      {
        "input": [
          [
            "5",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            ".",
            "2",
            "8",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": [
          [
            "5",
            "3",
            "4",
            "6",
            "7",
            "8",
            "9",
            "1",
            "2"
          ],
          [
            "6",
            "7",
            "2",
            "1",
            "9",
            "5",
            "3",
            "4",
            "8"
          ],
          [
            "1",
            "9",
            "8",
            "3",
            "4",
            "2",
            "5",
            "6",
            "7"
          ],
          [
            "8",
            "5",
            "9",
            "7",
            "6",
            "1",
            "4",
            "2",
            "3"
          ],
          [
            "4",
            "2",
            "6",
            "8",
            "5",
            "3",
            "7",
            "9",
            "1"
          ],
          [
            "7",
            "1",
            "3",
            "9",
            "2",
            "4",
            "8",
            "5",
            "6"
          ],
          [
            "9",
            "6",
            "1",
            "5",
            "3",
            "7",
            "2",
            "8",
            "4"
          ],
          [
            "2",
            "8",
            "7",
            "4",
            "1",
            "9",
            "6",
            "3",
            "5"
          ],
          [
            "3",
            "4",
            "5",
            "2",
            "8",
            "6",
            "1",
            "7",
            "9"
          ]
        ],
        "explanation": "The input Sudoku is filled correctly, ensuring all rows, columns, and 3x3 grids contain the digits from 1 to 9 exactly once."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Try using backtracking to explore potential placements.",
      "Keep track of used numbers for each row, column, and subgrid.",
      "If you reach an invalid placement, backtrack and try the next number."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Ways to Make a Fair Array",
    "description": "You are given an integer array nums of even length. You can split the array into two parts of equal length. Each part consists of a contiguous slice of the original array. Your task is to find the number of ways you can split the array such that the sum of the elements in both parts is the same. Implement a function that returns the number of valid splits possible.",
    "topic": "Array",
    "subtopic": "Prefix Sum",
    "tags": [
      "Array",
      "Prefix Sum",
      "Mathematics"
    ],
    "input_format": "A list of integers nums representing the array.",
    "output_format": "An integer representing the number of ways to split the array into two equal parts with equal sums.",
    "constraints": [
      "2 <= nums.length <= 10^5",
      "nums.length % 2 == 0",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5, 6]",
        "output": "3",
        "explanation": "The valid splits are at indices: [2] => ([1, 2], [3, 4, 5, 6]), [3] => ([1, 2, 3], [4, 5, 6]), and [4] => ([1, 2, 3, 4], [5, 6])."
      },
      {
        "input": "nums = [0, 0, 0, 0]",
        "output": "3",
        "explanation": "All parts can be split such that both parts are equal and sum to 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using prefix sums to keep track of sums efficiently.",
      "You'll need to explore how to compare the two parts after each possible split."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Sliding Window Median",
    "description": "Given an integer array nums and an integer k, return the median of all the sliding windows of size k in nums. The median is the middle value in an ordered list of numbers. If there are two middle values, consider the smaller one as the median.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Median",
      "Heap"
    ],
    "input_format": "An integer array nums of size n and an integer k where k is the size of the sliding window.",
    "output_format": "A list of floating-point numbers representing the medians of each sliding window.",
    "constraints": [
      "1 <= k <= n <= 10^5",
      "-10^7 <= nums[i] <= 10^7"
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 2, 5, 7, 9], k = 3",
        "output": "[2.0, 5.0, 7.0]",
        "explanation": "The medians of the sliding windows [1, 3, 2], [3, 2, 5], and [2, 5, 7] are 2.0, 5.0, and 7.0 respectively."
      },
      {
        "input": "nums = [1, 5, 2, 8, 3, 9], k = 2",
        "output": "[3.0, 5.0, 5.5, 8.0]",
        "explanation": "The medians of the sliding windows [1, 5], [5, 2], [2, 8], and [8, 3] are 3.0, 5.0, 5.5, and 8.0 respectively."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a data structure to keep track of the current window.",
      "You can use two heaps to maintain the lower and upper halves of the window.",
      "Make sure to handle the removal of elements from the sliding window."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Sliding Window Maximum",
    "description": "Given an array of integers nums and an integer k, return the maximum sliding window for each sliding window of size k. The sliding window moves from left to right and at each position, it captures the maximum of the current window of size k.",
    "topic": "Array",
    "subtopic": "Sliding Window",
    "tags": [
      "Array",
      "Sliding Window",
      "Queue"
    ],
    "input_format": "An integer array nums followed by an integer k where 1 <= k <= nums.length.",
    "output_format": "An array of integers representing the maximum values of each sliding window.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
        "output": "[3,3,5,5,6,7]",
        "explanation": "The first window is [1,3,-1], maximum is 3. The second window [-1,3,5], maximum is 5. Continuing this way gives the output."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "With only one element, the maximum is the element itself."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a deque to store indices of elements.",
      "Ensure that the maximum element's index is within the current window range."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Number of Islands",
    "description": "Given a 2D grid consisting of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "BFS",
      "Matrix"
    ],
    "input_format": "A 2D grid of characters where '1' represents land and '0' represents water.",
    "output_format": "An integer representing the number of islands in the grid.",
    "constraints": [
      "0 <= grid.length <= 300",
      "0 <= grid[i].length <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "input": "[['1','1','1','1','0'], ['1','1','0','1','0'], ['1','1','0','0','0'], ['0','0','0','0','0']]",
        "output": "1",
        "explanation": "There is one island formed by the '1's in the top portion of the grid."
      },
      {
        "input": "[['1','1','0','0','0'], ['1','1','0','0','0'], ['0','0','1','0','0'], ['0','0','0','1','1']]",
        "output": "3",
        "explanation": "There are three islands formed at different positions in the grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth-First Search (DFS) to explore and mark connected lands.",
      "Keep track of visited cells to avoid counting the same island multiple times."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Shortest Path to Get Food",
    "description": "You are given a grid representing a house. Each cell can be one of the following: '.' representing an empty space, '#' representing a wall, and 'P' representing your initial position. Your goal is to find the shortest path to reach the 'F' cell which represents food. You can move in four directions: up, down, left, and right. Return the length of the shortest path to get food. If there is no path, return -1.",
    "topic": "Graph",
    "subtopic": "Breadth-First Search",
    "tags": [
      "Graph",
      "BFS",
      "Shortest Path"
    ],
    "input_format": "A 2D grid where each cell contains either '.', '#', 'P', or 'F'.",
    "output_format": "An integer representing the length of the shortest path to get food or -1 if there is no path.",
    "constraints": [
      "The grid will have at most 1000 cells.",
      "There will be exactly one 'P' and one 'F' in the grid."
    ],
    "examples": [
      {
        "input": [
          "P..F",
          "....",
          "##..",
          "...."
        ],
        "output": "3",
        "explanation": "The shortest path is: P -> (0, 1) -> (0, 2) -> F."
      },
      {
        "input": [
          "P#F",
          "...",
          "###"
        ],
        "output": "-1",
        "explanation": "There is no way to reach the food because of the wall."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use BFS to explore all possible paths.",
      "Keep track of visited cells to avoid cycles."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Maximum Gap",
    "description": "Given an unsorted array of non-negative integers, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains fewer than 2 elements. The algorithm must run in linear time and use constant space.",
    "topic": "Array",
    "subtopic": "Sorting & Searching",
    "tags": [
      "Array",
      "Sorting",
      "Bucket Sort"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "An integer representing the maximum gap between successive elements in the sorted array.",
    "constraints": [
      "0 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [3, 6, 9, 1]",
        "output": "3",
        "explanation": "After sorting: [1, 3, 6, 9], the gaps are 2 (1-3), 3 (3-6), and 3 (6-9). The maximum gap is 3."
      },
      {
        "input": "nums = [10]",
        "output": "0",
        "explanation": "The array has less than 2 elements, so the maximum gap is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a bucket sort approach.",
      "The maximum gap cannot be smaller than the average gap."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Analyze User Website Visit Pattern",
    "description": "You are given a list of user website visit logs containing the timestamps of user visits. Your task is to analyze this data and return the number of unique users visiting the site within any given window of time. The time window can be specified in seconds. If a user visits the website multiple times within the same window, they should only be counted once for that window. Specifically, implement a function that takes the visit logs and the window size as inputs and returns a list of integers, where each integer indicates the number of unique users visiting the website for that respective time interval.",
    "topic": "Data Structures",
    "subtopic": "Hash Table",
    "tags": [
      "Data Structures",
      "Hash Table",
      "Sliding Window"
    ],
    "input_format": "A list of integers visitLogs representing timestamps when users visited the website, and an integer windowSize representing the time window in seconds.",
    "output_format": "A list of integers, where each integer denotes the number of unique users visiting within the respective time window.",
    "constraints": [
      "1 <= visitLogs.length <= 10^5",
      "0 <= visitLogs[i] <= 10^9",
      "1 <= windowSize <= 10^6"
    ],
    "examples": [
      {
        "input": "visitLogs = [1, 2, 3, 4, 5, 6], windowSize = 3",
        "output": "[3, 3, 3, 3]",
        "explanation": "For each window, (1,2,3), (2,3,4), (3,4,5), (4,5,6), unique users are always 3."
      },
      {
        "input": "visitLogs = [1, 2, 2, 3, 5, 7, 8], windowSize = 5",
        "output": "[3, 4, 4, 4]",
        "explanation": "Windows (1,2,2,3,5), (2,2,3,5,7), (2,3,5,7,8) have unique counts of 3, 4, 4 respectively."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Utilize a hash set to track unique users in the time window.",
      "Use a sliding window technique to manage the time intervals efficiently."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "LFU Cache",
    "description": "Design and implement a data structure for a Least Frequently Used (LFU) Cache. It should support the following operations: get and put.\n\nget(key) - Get the value of the key if the key exists in the cache. Otherwise, return -1.\n\nput(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For this problem, the capacity will be set as constructor parameter. The LFU Cache should be implemented as a class with methods specified above.",
    "topic": "Design",
    "subtopic": "Data Structure Design",
    "tags": [
      "Cache",
      "Data Structure",
      "Design"
    ],
    "input_format": "Initialize the LFU cache with a positive capacity.\nCall the get and put methods with respective keys and values.",
    "output_format": "Return the value of the key if it exists, otherwise return -1 for the get method. For the put method, there is no output.",
    "constraints": [
      "The capacity will be a positive integer.",
      "All keys and values used in the input will be unique.",
      "The operations will be performed in constant time."
    ],
    "examples": [
      {
        "input": [
          "LFUCache lfuCache = new LFUCache(2);",
          "lfuCache.put(1, 1);",
          "lfuCache.put(2, 2);",
          "lfuCache.get(1);",
          "lfuCache.put(3, 3);",
          "lfuCache.get(2);",
          "lfuCache.get(3);",
          "lfuCache.put(4, 4);",
          "lfuCache.get(1);",
          "lfuCache.get(3);",
          "lfuCache.get(4);"
        ],
        "output": [
          "1",
          "-1",
          "3",
          "-1",
          "4"
        ],
        "explanation": "After putting (1,1) and (2,2), getting (1) returns 1. When (3,3) is added, (2,2) is evicted as it is the least frequently used. Then, getting (2) returns -1 as it is no longer in the cache, and so on."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a hash map to store keys and their respective values and frequencies.",
      "Maintain another data structure to keep track of frequency lists."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "4Sum",
    "description": "Given an array of integers nums and an integer target, return all unique quadruplets (a, b, c, d) such that a + b + c + d = target. You may return the answer in any order. Each quadruplet must consist of distinct elements from the array.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "A list of lists of integers representing all unique quadruplets that sum up to the target.",
    "constraints": [
      "0 <= nums.length <= 200",
      "-10^9 <= nums[i] <= 10^9",
      "The solution set must not contain duplicate quadruplets."
    ],
    "examples": [
      {
        "input": "nums = [1, 0, -1, 0, -2, 2], target = 0",
        "output": "[[-2, -1, 0, 1], [0, 0, 0, 0], [-2, 0, 0, 2]]",
        "explanation": "The unique quadruplets that sum to 0 are [-2, -1, 0, 1] and [0, 0, 0, 0] for the inclusion of 0 in different permutations."
      },
      {
        "input": "nums = [2, 2, 2, 2, 2], target = 8",
        "output": "[[2, 2, 2, 2]]",
        "explanation": "There is only one unique quadruplet that sums to 8 using the number 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the array to help with managing duplicates.",
      "You can use two pointers to reduce the time complexity."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Course Schedule",
    "description": "You are given an integer numCourses representing the total number of courses you have to take, labeled from 0 to numCourses - 1. You are also given an array prerequisites where prerequisites[i] = [a, b] indicates that you must take course b before course a. Return true if you can finish all courses. Otherwise, return false.",
    "topic": "Graph",
    "subtopic": "Topological Sorting",
    "tags": [
      "Graph",
      "Topological Sort",
      "DFS",
      "BFS"
    ],
    "input_format": "An integer numCourses followed by a list of prerequisite pairs.",
    "output_format": "A boolean value indicating if it is possible to finish all courses.",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= prerequisites[i][0], prerequisites[i][1] < numCourses"
    ],
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = [[1, 0]]",
        "output": "true",
        "explanation": "You can take course 0 first, then take course 1."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1, 0], [0, 1]]",
        "output": "false",
        "explanation": "There is a cycle between courses 0 and 1, which makes it impossible to finish all courses."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using depth-first search or breadth-first search.",
      "Track the courses taken and check for cycles."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Capacity To Ship Packages Within D Days",
    "description": "A company wants to ship packages within D days. Each package weighs a certain amount, and you need to determine the minimum weight capacity of the ship that can ship all the packages in D days. The weight capacity cannot exceed the sum of the weights. This requires that at least one package can be shipped per day. Determine the minimum capacity needed to ship all packages in the given days.",
    "topic": "Binary Search",
    "subtopic": "Optimization",
    "tags": [
      "Binary Search",
      "Greedy",
      "Array"
    ],
    "input_format": "The first line contains an integer n (1 <= n <= 50000), representing the number of packages. The second line contains an array of integers weights (1 <= weights[i] <= 10^4), representing the weights of the packages. The third line contains an integer D (1 <= D <= n), representing the number of days.",
    "output_format": "An integer representing the minimum weight capacity needed to ship all packages within D days.",
    "constraints": [
      "1 <= weights.length <= 50000",
      "1 <= weights[i] <= 10^4",
      "1 <= D <= weights.length"
    ],
    "examples": [
      {
        "input": "5\n1 2 3 4 5\n2",
        "output": "9",
        "explanation": "The packages can be split into two days, e.g., [1, 2, 3] and [4, 5], giving a minimum capacity of 9."
      },
      {
        "input": "3\n2 3 1\n3",
        "output": "3",
        "explanation": "Each package can be shipped in a separate day, thus the required capacity is equal to the weight of the heaviest package."
      },
      {
        "input": "10\n1 2 3 1 2 3 1 2 3 1\n5",
        "output": "6",
        "explanation": "Packages can be grouped to ship within the given days with the maximum weight on any day being 6."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the maximum weight that can be shipped in a day.",
      "Binary search could be a viable approach to find the optimal capacity."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Maximum Path Quality of a Graph",
    "description": "You are given a graph consisting of nodes and edges where each edge has a quality value associated with it. The graph is represented as a list of edges, with each edge defined by a pair of nodes and its quality. Your task is to identify the maximum quality path from a given starting node to a destination node, where the quality of a path is defined as the minimum quality of any edge on that path. If no path exists, return -1.",
    "topic": "Graph",
    "subtopic": "Path Finding",
    "tags": [
      "Graph",
      "Pathfinding",
      "Minimum"
    ],
    "input_format": "The input consists of an integer n denoting the number of nodes, a list of edges, and two integers start and destination representing the starting and ending nodes respectively.",
    "output_format": "An integer representing the maximum quality path from start to destination or -1 if no path exists.",
    "constraints": [
      "2 <= n <= 10^5",
      "1 <= edges.length <= 2 * 10^5",
      "1 <= edges[i][0], edges[i][1] <= n",
      "1 <= edges[i][2] <= 10^6"
    ],
    "examples": [
      {
        "input": "n = 5, edges = [[1, 2, 5], [1, 3, 6], [2, 4, 3], [3, 4, 4]], start = 1, destination = 4",
        "output": "4",
        "explanation": "The path with maximum quality from node 1 to node 4 is 1 -> 3 -> 4 with a minimum edge quality of 4."
      },
      {
        "input": "n = 3, edges = [[1, 2, 1], [2, 3, 2]], start = 1, destination = 3",
        "output": "1",
        "explanation": "The path from 1 to 3 via node 2 has a minimum quality of 1."
      },
      {
        "input": "n = 4, edges = [[1, 2, 10], [2, 3, 5]], start = 1, destination = 4",
        "output": "-1",
        "explanation": "There is no path from node 1 to node 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a priority queue to explore paths in decreasing order of edge quality.",
      "Consider using Dijkstra's algorithm modified for maximum quality instead of minimum distance."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "LRU Cache",
    "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. It should support the following operations: get(key) which retrieves the value of the key if the key exists in the cache, otherwise return -1, and put(key, value) which updates or inserts the value. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item.",
    "topic": "Data Structures",
    "subtopic": "Cache",
    "tags": [
      "Cache",
      "Data Structures",
      "Design"
    ],
    "input_format": "The LRUCache will be initialized with a positive capacity. The put and get operations will be called with integer keys and values.",
    "output_format": "Return the value of the key if it exists in the cache for get operations, and return nothing for put operations.",
    "constraints": [
      "1 <= capacity <= 3000",
      "0 <= key <= 10^4",
      "0 <= value <= 10^4",
      "The functions get and put must be called at most 2 * 10^5 times."
    ],
    "examples": [
      {
        "input": "LRUCache cache = new LRUCache(2); cache.put(1, 1); cache.put(2, 2); cache.get(1); cache.put(3, 3); cache.get(2); cache.put(4, 4); cache.get(1); cache.get(3); cache.get(4);",
        "output": "[1,-1,-1,4]",
        "explanation": "cache.get(1) returns 1, cache.get(2) returns -1 since it's evicted, cache.get(3) returns 3, cache.get(4) returns 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a HashMap to store key-value pairs.",
      "Use a doubly linked list to maintain the order of usage."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Find the Celebrity",
    "description": "In a party of n people, there's one person who is known as the 'celebrity'. This celebrity is defined as someone who is known by everyone else, and who knows nobody. Your task is to identify the celebrity in the given set of relationships. If there is no celebrity, return -1.",
    "topic": "Graph",
    "subtopic": "Graph Traversal",
    "tags": [
      "Graph",
      "Traversal",
      "Celebrity"
    ],
    "input_format": "An integer n representing the number of people and a 2D array of size n x n, where arr[i][j] = 1 if person i knows person j, otherwise arr[i][j] = 0.",
    "output_format": "An integer representing the index of the celebrity, or -1 if there is no celebrity.",
    "constraints": [
      "2 <= n <= 1000",
      "arr[i][i] = 0",
      "arr[i][j] is either 0 or 1"
    ],
    "examples": [
      {
        "input": "n = 3, arr = [[0, 1, 0], [0, 0, 1], [0, 0, 0]]",
        "output": "2",
        "explanation": "Person 2 is known by persons 0 and 1, and person 2 knows no one, making them the celebrity."
      },
      {
        "input": "n = 4, arr = [[0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 0, 0], [0, 1, 1, 0]]",
        "output": "-1",
        "explanation": "There is no person who is known by everyone and knows no one."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to verify if a person is a celebrity.",
      "You may need to traverse the relationships efficiently."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Number of Provinces",
    "description": "You are given an undirected graph where each node represents a city and each edge represents a direct connection between two cities. A province is defined as a group of connected cities. Your task is to find the number of provinces in the given graph representation. The graph is represented as an adjacency matrix.",
    "topic": "Graph",
    "subtopic": "Depth-First Search",
    "tags": [
      "Graph",
      "DFS",
      "Connected Components"
    ],
    "input_format": "An n x n matrix 'isConnected' where 'isConnected[i][j] == 1' indicates that the cities 'i' and 'j' are directly connected, and 'isConnected[i][j] == 0' indicates they are not connected.",
    "output_format": "An integer representing the number of provinces.",
    "constraints": [
      "1 <= n <= 200",
      "isConnected.length == n",
      "isConnected[i].length == n",
      "isConnected[i][i] == 1",
      "isConnected[i][j] == isConnected[j][i]"
    ],
    "examples": [
      {
        "input": "isConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]",
        "output": "2",
        "explanation": "There are two provinces: the first province consists of cities 0 and 1, while the second province consists of city 2."
      },
      {
        "input": "isConnected = [[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]]",
        "output": "2",
        "explanation": "The first province consists of cities 0 and 3, and the second province consists of cities 1 and 2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using DFS or BFS to explore the graph.",
      "A new province is found when you traverse unvisited nodes."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of k linked lists, each linked list is sorted in ascending order. Merge all the linked lists into one sorted linked list and return it. The linked list should be made by splicing together the nodes of the given k lists.",
    "topic": "Linked List",
    "subtopic": "Merging",
    "tags": [
      "LinkedList",
      "Sorting",
      "Merge"
    ],
    "input_format": "An array of k linked lists where each linked list is represented by the Node class.",
    "output_format": "A linked list representing the merged sorted list.",
    "constraints": [
      "0 <= k <= 10^4",
      "0 <= Node.val <= 10^4",
      "The total number of nodes across all lists is at most 10^4."
    ],
    "examples": [
      {
        "input": "[1 -> 4 -> 5, 1 -> 3 -> 4, 2 -> 6]",
        "output": "1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6",
        "explanation": "The merged linked list is sorted and contains all elements from the input lists."
      },
      {
        "input": "[]",
        "output": "",
        "explanation": "An empty list input should return an empty linked list."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a min-heap to efficiently merge the lists.",
      "Keep track of the head and tail of the merged linked list."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Insert Delete GetRandom O(1)",
    "description": "Design a data structure that supports the following operations: insert, delete, and getRandom. Implement the data structure with O(1) time complexity for each operation. Your data structure should support the following functions:\n\n- `insert(val)`: Inserts an item val to the set if not already present.\n- `delete(val)`: Removes an item val from the set if present.\n- `getRandom()`: Returns a random element from the current set of elements (each element must have the same probability of being returned).\n\nYou may assume that all operations are valid (i.e., no duplicates will be passed to insert, and no invalid deletions will be made).",
    "topic": "Design",
    "subtopic": "Data Structures",
    "tags": [
      "Hash Table",
      "Randomized",
      "Design"
    ],
    "input_format": "The operations will be given as a sequence of strings with the value for insert and delete (where applicable).",
    "output_format": "The output of getRandom() function will return a randomly selected element from the current set.",
    "constraints": [
      "The number of operations will be in the range of [1, 2 * 10^4].",
      "Each insert and delete operation will be followed by a getRandom operation."
    ],
    "examples": [
      {
        "input": "obj = RandomizedSet(); obj.insert(1); obj.insert(2); obj.getRandom(); obj.delete(1); obj.getRandom();",
        "output": "2 (or 1, depending on the randomness)",
        "explanation": "Initially, 1 and 2 are inserted. getRandom may return either 1 or 2. After deleting 1, only 2 remains."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a hash table for fast lookups.",
      "An array can store the elements for random access."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Range Sum Query 2D - Immutable",
    "description": "Design a 2D matrix that allows calculating the sum of the elements within a rectangle defined by its corners. You should implement a NumMatrix class that supports the following operations: Constructing the matrix and calculating the sum of elements in a given rectangular area. The sum should be computed in constant time after the matrix has been constructed.",
    "topic": "Matrix",
    "subtopic": "2D Range Query",
    "tags": [
      "Matrix",
      "Range Sum",
      "Query"
    ],
    "input_format": "A 2D list of integers representing the matrix and a set of queries that specify the ranges.",
    "output_format": "Return an integer representing the sum of the elements in the specified rectangular area.",
    "constraints": [
      "0 <= matrix.length, matrix[i].length <= 200",
      "-10^5 <= matrix[i][j] <= 10^5",
      "Queries will be in the form of [row1, col1, row2, col2], where row1 <= row2 and col1 <= col2."
    ],
    "examples": [
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], sumRegion(0, 0, 1, 1)",
        "output": "12",
        "explanation": "The rectangle defined by (0,0) and (1,1) includes the elements 1, 2, 4, 5 with a sum of 1 + 2 + 4 + 5 = 12."
      },
      {
        "input": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], sumRegion(1, 1, 2, 2)",
        "output": "28",
        "explanation": "The rectangle defined by (1,1) and (2,2) includes the elements 5, 6, 8, 9 with a sum of 5 + 6 + 8 + 9 = 28."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a prefix sum array to allow constant-time queries.",
      "Traverse through the matrix only once to build the prefix sum array."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Similar String Groups",
    "description": "Given an array of strings, you want to find out how many groups of similar strings there are. Two strings are considered similar if you can transform one string into another by swapping exactly two letters. For example, 'abc' and 'acb' are similar because you can swap the letters at position 1 and 2. Your task is to return the number of distinct groups of similar strings in the given array.",
    "topic": "Strings",
    "subtopic": "Grouping",
    "tags": [
      "Strings",
      "Graph",
      "Union-Find"
    ],
    "input_format": "An array of strings `strs` of length n (1 <= n <= 100). Each string has a length of m (1 <= m <= 100).",
    "output_format": "An integer representing the number of distinct groups of similar strings.",
    "constraints": [
      "1 <= strs.length <= 100",
      "1 <= strs[i].length <= 100",
      "All strings consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"abc\", \"acb\", \"bca\", \"xyz\", \"yxz\", \"yzx\"]",
        "output": "2",
        "explanation": "The strings can be grouped into two groups: ['abc', 'acb', 'bca'] and ['xyz', 'yxz', 'yzx']."
      },
      {
        "input": "strs = [\"a\", \"b\", \"c\"]",
        "output": "3",
        "explanation": "Each string is unique and cannot be transformed into another, hence there are 3 distinct groups."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a union-find data structure to group similar strings.",
      "Check each pair of strings for similarity by counting mismatches."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s. A palindrome is a string that reads the same backward as forward. You may assume that the input string has at least one character and that the longest palindromic substring is unique.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Dynamic Programming",
      "Substring"
    ],
    "input_format": "A single string s of length n.",
    "output_format": "A string representing the longest palindromic substring.",
    "constraints": [
      "1 <= n <= 1000",
      "s consists of only printable ASCII characters"
    ],
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\"",
        "explanation": "Both \"bab\" and \"aba\" are valid longest palindromic substrings, but we return \"bab\"."
      },
      {
        "input": "s = \"cbbd\"",
        "output": "\"bb\"",
        "explanation": "\"bb\" is the longest palindromic substring in this case."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider checking for palindromes centered around each character.",
      "Expand from the center and check for the longest palindrome."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Design Search Autocomplete System",
    "description": "Implement a search autocomplete system that can suggest completions for a given input word based on a list of predefined sentences. The system should offer suggestions based on the longest matching prefix for the input word, with the suggestions ranked by their frequency of use in the input sentences. The autocomplete system should support adding sentences dynamically and retrieving suggestions efficiently.",
    "topic": "Trie",
    "subtopic": "Design",
    "tags": [
      "Trie",
      "Design",
      "Autocomplete"
    ],
    "input_format": "The input consists of a list of sentences and a series of input queries to suggest autocompletions.",
    "output_format": "A list of lists, where each inner list contains the top 3 autocomplete suggestions for the corresponding input query.",
    "constraints": [
      "1 <= sentences.length <= 10000",
      "1 <= sentences[i].length <= 100",
      "input queries can be made up of letters and spaces, and their length can reach 100."
    ],
    "examples": [
      {
        "input": {
          "sentences": [
            "i love you",
            "island",
            "i love coding",
            "i love leetcode"
          ],
          "query": "i love"
        },
        "output": [
          [
            "i love you",
            "i love coding",
            "i love leetcode"
          ]
        ],
        "explanation": "The suggestions are ranked by frequency. 'i love you' appears most often."
      },
      {
        "input": {
          "sentences": [
            "the quick brown fox",
            "the quick blue hare",
            "the quokka"
          ],
          "query": "the qu"
        },
        "output": [
          [
            "the quick brown fox",
            "the quick blue hare",
            "the quokka"
          ]
        ],
        "explanation": "All sentences start with 'the qu', suggesting the top matches based on frequency."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a Trie data structure to efficiently store and search sentences.",
      "Rank suggestions by counting their frequency in the initial sentence list."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Brace Expansion",
    "description": "Given a string with brace expansions, generate all possible strings that can result from these expansions. You can assume that the input string contains only lowercase English letters and characters '{' and '}'. For instance, input '{a,b}c{d,e}f' should expand to 'acdf', 'acef', 'bcdf', 'bcef', 'acf', and 'bef'.",
    "topic": "String",
    "subtopic": "Combination Generation",
    "tags": [
      "String",
      "Backtracking",
      "Combination"
    ],
    "input_format": "A string s representing the brace expansion.",
    "output_format": "A list of strings representing all possible expansions, sorted in lexicographical order.",
    "constraints": [
      "1 <= s.length <= 50",
      "s consists of lowercase letters, '{', and '}'.",
      "Every '{' has a matching '}'."
    ],
    "examples": [
      {
        "input": "{a,b}c{d,e}f",
        "output": [
          "acdf",
          "acef",
          "bcdf",
          "bcef",
          "acf",
          "bef"
        ],
        "explanation": "There are multiple combinations made by choosing characters from the expanded parts."
      },
      {
        "input": "abcd",
        "output": [
          "abcd"
        ],
        "explanation": "No expansion is needed as there are no braces."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about using backtracking to explore the combinations.",
      "You need to handle the separation of choices when you encounter braces."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Move Zeroes",
    "description": "Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array.",
    "topic": "Array",
    "subtopic": "In-place Moving",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An array of integers nums, where 0 <= nums.length <= 2 * 10^4 and -2 * 10^4 <= nums[i] <= 2 * 10^4.",
    "output_format": "The modified array with all 0's moved to the end.",
    "constraints": [
      "0 <= nums.length <= 2 * 10^4",
      "-2 * 10^4 <= nums[i] <= 2 * 10^4"
    ],
    "examples": [
      {
        "input": "nums = [0, 1, 0, 3, 12]",
        "output": "[1, 3, 12, 0, 0]",
        "explanation": "After moving all the zeros, the array retains the order of non-zero elements."
      },
      {
        "input": "nums = [0]",
        "output": "[0]",
        "explanation": "The input contains only one element which is 0, so it remains in its position."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to help in rearranging the elements.",
      "Keep a pointer to track the position of non-zero elements."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Path With Maximum Minimum Value",
    "description": "You are given a matrix of integers where each integer represents the value of that cell. Your task is to find a path from the top-left corner to the bottom-right corner of the matrix, where you can only move right or down. The value of the path is defined as the minimum value of the integers along the path. Your goal is to find the maximum value of all possible paths from the top-left to the bottom-right corner.",
    "topic": "Graph",
    "subtopic": "Path Finding",
    "tags": [
      "Graph",
      "Matrix",
      "Binary Search"
    ],
    "input_format": "A 2D integer array 'grid' of size m x n.",
    "output_format": "An integer representing the maximum minimum value along the path.",
    "constraints": [
      "1 <= m, n <= 100",
      "0 <= grid[i][j] <= 10^9"
    ],
    "examples": [
      {
        "input": "grid = [[5, 4, 5], [1, 2, 6], [3, 4, 8]]",
        "output": "4",
        "explanation": "The path with values [5, 4, 5] yields a minimum of 4, which is the maximum minimum value achievable."
      },
      {
        "input": "grid = [[1, 2], [3, 4]]",
        "output": "3",
        "explanation": "The path with values [1, 3] yields a minimum of 1, but the path [2, 4] yields a minimum of 2, where 2 is less than 3, as it is the next minimum down the left path."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a priority queue to explore path values efficiently.",
      "Binary search can help to optimize the checking of minimum values."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Number of Closed Islands",
    "description": "Given a 2D grid consisting of '0's (land) and '1's (water), you need to find the number of closed islands. An island is closed if it is completely surrounded by water, which means there is no occurrence of '0's connected to the border of the grid. You should implement a function that returns the total number of closed islands in the grid.",
    "topic": "Graph",
    "subtopic": "DFS/BFS",
    "tags": [
      "Graph",
      "DFS",
      "BFS"
    ],
    "input_format": "A 2D grid of integers where '0' denotes land and '1' denotes water.",
    "output_format": "An integer representing the number of closed islands in the grid.",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 100",
      "grid[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "grid = [[1,1,1,1,0,1,1],[1,0,0,1,0,1,1],[1,0,1,1,1,1,1],[1,0,0,0,0,0,1],[1,1,1,1,1,1,1]]",
        "output": "1",
        "explanation": "There is one closed island in the grid."
      },
      {
        "input": "grid = [[0,0,0,0,0],[0,1,1,1,0],[0,1,0,1,0],[0,1,1,0,0],[0,0,0,0,0]]",
        "output": "0",
        "explanation": "All the islands are open as they touch the border of the grid."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth-First Search to explore the islands.",
      "Mark the visited land cells to avoid counting them multiple times."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Valid Sudoku",
    "description": "Determine if a 9x9 Sudoku board is valid according to the rules. Each row, column, and each of the nine 3x3 sub-boxes must contain the digits 1-9 without repetition. Empty cells are represented by the '.' character.",
    "topic": "Backtracking",
    "subtopic": "Validation",
    "tags": [
      "Backtracking",
      "Validation",
      "Matrix"
    ],
    "input_format": "A 9x9 character array board representing the Sudoku board.",
    "output_format": "A boolean indicating whether the Sudoku board is valid.",
    "constraints": [
      "board.length == 9",
      "board[i].length == 9",
      "board[i][j] is either a digit '1' to '9' or '.'"
    ],
    "examples": [
      {
        "input": "board = [['5','3','.','.','7','.','.','.','.'], ['6','.','.','1','9','5','.','.','.'], ['.','9','8','.','.','.','.','6','.'], ['8','.','.','.','6','.','.','.','3'], ['4','.','9','.','.','.','7','.','1'], ['7','.','.','.','2','.','.','.','6'], ['.','6','.','.','.','2','8','.','.'], ['.','.','.','4','1','9','.','.','5'], ['.','.','.','.','8','.','.','7','9']]",
        "output": "true",
        "explanation": "The Sudoku board obeys all the rules of Sudoku."
      },
      {
        "input": "board = [['8','3','.','.','7','.','.','.','.'], ['6','.','.','1','9','5','.','.','.'], ['.','9','8','.','.','.','.','6','.'], ['8','.','.','.','6','.','.','.','3'], ['4','.','9','.','.','.','7','.','1'], ['7','.','.','.','2','.','.','.','6'], ['.','6','.','.','.','2','8','.','.'], ['.','.','.','4','1','9','.','.','5'], ['.','.','.','.','8','.','.','7','9']]",
        "output": "false",
        "explanation": "The number '8' appears twice in the first column."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a HashSet to track occurrences of numbers in rows, columns, and boxes.",
      "Check each number only if it's between '1' and '9'."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Task Scheduler II",
    "description": "You are given a list of tasks that need to be executed, where each task is represented by a character. You can execute one task at a time and there must be a cooling period (denoted by 'n') between two same tasks. Your goal is to determine the minimum time required to execute all tasks while respecting the cooling period. If it is impossible to execute all tasks while respecting the cooling period, return -1.",
    "topic": "Greedy",
    "subtopic": "Task Scheduling",
    "tags": [
      "Greedy",
      "Task Scheduling",
      "Frequency"
    ],
    "input_format": "An integer n representing the cooling period and a list of characters tasks representing the tasks to be executed.",
    "output_format": "An integer representing the minimum time required to finish all tasks, or -1 if it is impossible.",
    "constraints": [
      "1 <= tasks.length <= 100",
      "1 <= n <= 26"
    ],
    "examples": [
      {
        "input": "n = 2, tasks = ['A', 'A', 'A', 'B', 'B', 'C']",
        "output": "8",
        "explanation": "Tasks can be executed in the sequence: A, B, C, A, B, A. The time taken is 8."
      },
      {
        "input": "n = 1, tasks = ['A', 'A', 'A', 'B', 'B', 'C']",
        "output": "6",
        "explanation": "Tasks can be executed in the sequence: A, B, A, C, A, B. The time taken is 6."
      },
      {
        "input": "n = 2, tasks = ['A', 'A', 'A', 'A', 'B']",
        "output": "-1",
        "explanation": "Cannot complete all tasks due to the cooling period. It's impossible to execute all 'A's within the constraints."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to use a priority queue to manage the task frequencies.",
      "Think of how you can group tasks based on their execution frequency."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. Two words are anagrams if they have the same character counts.",
    "topic": "Hash Table",
    "subtopic": "String Manipulation",
    "tags": [
      "Hash Table",
      "Strings",
      "Anagrams"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "An array of arrays, where each sub-array contains grouped anagrams.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
        "explanation": "The groups of anagrams are: ['eat', 'tea', 'ate'] and ['tan', 'nat'] and ['bat']."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "The only string in the input is an anagram of itself."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "The only string in the input is an anagram of itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to group the words by their sorted character sequence."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Implement Trie II (Prefix Tree)",
    "description": "Implement a Trie with insert, search, and delete operations. The Trie should be able to efficiently store strings and provide functionality to check for the existence of a word in the collection and to delete a word from the Trie. Additionally, the Trie should allow prefix searches, so you can check if any word starts with a given prefix. This version should also handle the case where you might attempt to delete a word that does not exist in the Trie.",
    "topic": "Data Structures",
    "subtopic": "Trie",
    "tags": [
      "Trie",
      "Data Structures",
      "Strings",
      "Search"
    ],
    "input_format": "Operations to perform on the Trie: 'insert', 'search', and 'delete' followed by the respective word.",
    "output_format": "Return True or False for search operations, and a confirmation message for delete operations.",
    "constraints": [
      "1 <= word.length <= 100",
      "1 <= number of operations <= 1000",
      "All input words are lowercase alphabets."
    ],
    "examples": [
      {
        "input": "insert(\"apple\") --> None; search(\"apple\") --> True; delete(\"apple\") --> None; search(\"apple\") --> False;",
        "output": "True; False",
        "explanation": "Inserting 'apple' makes it present. Searching gives True. Deleting removes it, and searching again gives False."
      },
      {
        "input": "insert(\"app\") --> None; search(\"app\") --> True; search(\"ap\") --> True; delete(\"app\") --> None; search(\"app\") --> False;",
        "output": "True; True; False",
        "explanation": "Inserting 'app', finds both 'app' and prefix 'ap'. After deleting, 'app' is no longer found."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a nested dictionary to represent the Trie structure.",
      "Keep track of the end of word nodes to manage insertions and deletions."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Counting Words With a Given Prefix",
    "description": "Given a list of words and a prefix, count the number of words in the list that start with the given prefix.",
    "topic": "Strings",
    "subtopic": "String Matching",
    "tags": [
      "Strings",
      "Prefix",
      "Counting"
    ],
    "input_format": "A list of strings words and a string prefix.",
    "output_format": "An integer representing the count of words that start with the prefix.",
    "constraints": [
      "1 <= words.length <= 10^4",
      "1 <= words[i].length <= 100",
      "1 <= prefix.length <= 100"
    ],
    "examples": [
      {
        "input": "words = [\"apple\", \"app\", \"apricot\", \"banana\", \"ap\"]\nprefix = \"ap\"",
        "output": "4",
        "explanation": "The words that start with the prefix 'ap' are 'apple', 'app', 'apricot', and 'ap'. Thus, the count is 4."
      },
      {
        "input": "words = [\"car\", \"cat\", \"dog\", \"caterpillar\"]\nprefix = \"ca\"",
        "output": "2",
        "explanation": "The words that start with the prefix 'ca' are 'car' and 'cat'. Thus, the count is 2."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider iterating through each word and checking if it starts with the prefix.",
      "You can use the startsWith() function or check the substring manually."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Employee Free Time",
    "description": "You are given a list of intervals, where each interval has a start time and an end time representing the busy schedule of employees. Each interval is represented as a pair of integers [start, end]. Your task is to find all the time intervals during which no employees are busy. Return a list of intervals representing the free time periods.",
    "topic": "Intervals",
    "subtopic": "Interval Merging",
    "tags": [
      "Intervals",
      "Sorting",
      "Scheduling"
    ],
    "input_format": "A list of lists, where each nested list contains two integers [start, end].",
    "output_format": "A list of lists, where each nested list represents a free time interval [start, end].",
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "0 <= intervals[i][0] < intervals[i][1] <= 10^6"
    ],
    "examples": [
      {
        "input": "intervals = [[1, 2], [5, 6], [2, 3], [3, 5]]",
        "output": "[[4, 5]]",
        "explanation": "There is no overlap in the intervals, and the gap between 3 and 5 is free time."
      },
      {
        "input": "intervals = [[1, 3], [2, 4], [6, 8]]",
        "output": "[[4, 6]]",
        "explanation": "After the busy times from 1 to 4 and 6 to 8, the interval from 4 to 6 is free."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Sort the input intervals first.",
      "Iterate through the sorted intervals to find gaps."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Design Browser History",
    "description": "You are tasked with designing a browser history data structure that supports various operations. Implement the BrowserHistory class with the following methods: \n\n1. `BrowserHistory(string homepage)`: Initializes the object with the homepage of the browser. \n2. `void visit(string url)`: Visits the given `url` and stores it as the current page. \n3. `string back(int steps)`: Moves back `steps` in history. If there are fewer steps than the current history size, it moves back to the earliest page visited. It returns the URL of the current page after moving back. \n4. `string forward(int steps)`: Moves forward `steps` in history. If there are fewer steps than the forward history available, it moves forward to the most recent page visited. It returns the URL of the current page after moving forward.",
    "topic": "Design",
    "subtopic": "Data Structures",
    "tags": [
      "Design",
      "Data Structures",
      "History"
    ],
    "input_format": "A string representing the homepage URL and a series of operations in the form of visit, back, or forward.",
    "output_format": "A string representing the current page URL after performing the operations.",
    "constraints": [
      "1 <= url.length <= 100",
      "The homepage string and URLs are guaranteed to be valid URLs.",
      "Total number of operations will not exceed 1000."
    ],
    "examples": [
      {
        "input": "BrowserHistory browserHistory = new BrowserHistory('leetcode.com');\nbrowserHistory.visit('google.com');\nbrowserHistory.visit('facebook.com');\nbrowserHistory.back(1); // return 'google.com'\nbrowserHistory.back(1); // return 'leetcode.com'\nbrowserHistory.forward(1); // return 'google.com'\nbrowserHistory.visit('youtube.com');\nbrowserHistory.forward(2); // return 'youtube.com'\nbrowserHistory.back(2); // return 'leetcode.com'\nbrowserHistory.back(7); // return 'leetcode.com'",
        "output": "leetcode.com",
        "explanation": "After performing the described sequence of operations, the current URL ends up being 'leetcode.com', as the user is unable to go back further than the homepage."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a stack to manage the visit history.",
      "Use two pointers to keep track of the current position in history."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Diameter of N-Ary Tree",
    "description": "Given an N-ary tree, return its diameter. The diameter of a tree is defined as the length of the longest path between any two nodes in the tree. The path may or may not pass through the root.",
    "topic": "Tree",
    "subtopic": "N-Ary Tree",
    "tags": [
      "Tree",
      "Diameter",
      "N-Ary Tree"
    ],
    "input_format": "The root node of the N-Ary tree, represented as a Node class with a list of children.",
    "output_format": "An integer representing the diameter of the N-Ary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 10^4].",
      "Each node's value is unique and in the range [0, 10^4]."
    ],
    "examples": [
      {
        "input": "root = [[1,2,3],[4,5],[6]]",
        "output": "4",
        "explanation": "The longest path is between nodes 4 and 6, which has a length of 4."
      },
      {
        "input": "root = [[1],[2],[3],[4],[5]]",
        "output": "4",
        "explanation": "The longest path is between node 1 and node 5, which has a length of 4."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using Depth-First Search (DFS) to find the maximum depth of subtrees.",
      "The diameter can be calculated based on the depth of the two deepest subtrees."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Meeting Rooms II",
    "description": "You are given an array of meeting time intervals where intervals[i] = [start_time, end_time]. You need to determine the minimum number of conference rooms required to hold all meetings. Each meeting can be attended by one person, and a person can attend multiple meetings only if the meetings do not overlap. Return the minimum number of conference rooms required.",
    "topic": "Array",
    "subtopic": "Intervals",
    "tags": [
      "Array",
      "Intervals",
      "Greedy"
    ],
    "input_format": "An array of meeting intervals represented as an array of pairs of integers.",
    "output_format": "An integer representing the minimum number of conference rooms required.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "0 <= start_time < end_time <= 10^6"
    ],
    "examples": [
      {
        "input": "intervals = [[0, 30], [5, 10], [15, 20]]",
        "output": "2",
        "explanation": "The meetings [0, 30] overlaps with [5, 10] and [15, 20], thus two rooms are needed."
      },
      {
        "input": "intervals = [[7, 10], [2, 4]]",
        "output": "1",
        "explanation": "There is no overlap between the meetings, so only one room is needed."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the meeting intervals by their start times.",
      "Use a min-heap to track the end times of meetings."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Maximum Performance of a Team",
    "description": "You are tasked with forming a team of engineers, each with a specific efficiency and skill level. The overall performance of a team is determined by the minimum efficiency among the selected engineers multiplied by the sum of their skill levels. Given the efficiency and skill level of each engineer, your goal is to calculate the maximum performance that can be achieved by selecting up to 'k' engineers.",
    "topic": "Greedy",
    "subtopic": "Sorting",
    "tags": [
      "Greedy",
      "Sorting",
      "Dynamic Programming"
    ],
    "input_format": "An integer n representing the number of engineers, an array of integers efficiency of length n, and an array of integers speed of length n, along with an integer k which represents the maximum number of engineers that can be selected.",
    "output_format": "An integer representing the maximum performance of the chosen team, calculated modulo 10^9 + 7.",
    "constraints": [
      "1 <= n <= 10^5",
      "1 <= efficiency[i], speed[i] <= 10^5",
      "1 <= k <= n"
    ],
    "examples": [
      {
        "input": "n = 3, efficiency = [2, 4, 5], speed = [4, 3, 5], k = 2",
        "output": "30",
        "explanation": "Choosing engineers with efficiency 4 and 5 gives minimum efficiency 4 and skill level sum 8, resulting in performance 4 * 8 = 32."
      },
      {
        "input": "n = 5, efficiency = [1, 2, 3, 4, 5], speed = [5, 6, 7, 8, 9], k = 3",
        "output": "60",
        "explanation": "Selecting engineers with efficiency 3, 4, and 5 gives minimum efficiency 3 and skill level sum 24 yielding 3 * 24 = 72."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a priority queue to keep track of the top k speeds.",
      "Sort engineers based on efficiency in descending order.",
      "Calculate performance incrementally while iterating through the sorted engineers."
    ],
    "company": "DoorDash"
  },
  {
    "question_id": "",
    "title": "Top K Frequent Elements",
    "description": "Given a non-empty array of integers, return the k most frequent elements. You may assume that the answer is guaranteed to be unique, and order of output does not matter.",
    "topic": "Hash Table",
    "subtopic": "Frequency Counting",
    "tags": [
      "Hash Table",
      "Sorting",
      "Frequency"
    ],
    "input_format": "An array of integers nums and an integer k.",
    "output_format": "An array of the k most frequent elements.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= nums[i] <= 10^4",
      "k is always valid, 1 <= k <= number of unique elements"
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3], k = 2",
        "output": "[1,2]",
        "explanation": "The number 1 appears 3 times and 2 appears 2 times. Hence, the top 2 frequent elements are 1 and 2."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "There is only one element in the array, so the answer is [1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a hash map to count the frequency of elements.",
      "Consider using a priority queue to efficiently get the top k elements."
    ],
    "company": "DoorDash"
  }
]