[
  {
    "question_id": "",
    "title": "Two Sum",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "topic": "Array",
    "subtopic": "Hashing",
    "tags": [
      "Array",
      "Hashing",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums and an integer target.",
    "output_format": "An array of two integers representing the indices of the two numbers such that they add up to target.",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "All inputs will have exactly one solution."
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "output": "[1, 2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a hashmap to store the numbers and their indices.",
      "Check if target - nums[i] exists in the hashmap."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Hash Table"
    ],
    "input_format": "A string s of length n.",
    "output_format": "An integer representing the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 10^5",
      "s consists of English letters, digits, symbols, and spaces."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"abc\" with length 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The longest substring without repeating characters is \"b\" with length 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The longest substring without repeating characters is \"wke\" with length 3."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a sliding window approach to expand and contract the substring.",
      "Utilize a hash map to store characters and their indices."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Valid Parentheses",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if the brackets are closed in the correct order. Every opening bracket must have a corresponding closing bracket of the same type.",
    "topic": "String",
    "subtopic": "Stack",
    "tags": [
      "String",
      "Stack",
      "Validation"
    ],
    "input_format": "A string s consisting of parentheses characters.",
    "output_format": "A boolean value indicating whether the input string is valid.",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses characters only."
    ],
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The string contains one pair of parentheses, which are correctly matched."
      },
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "The string contains multiple types of brackets, all correctly matched."
      },
      {
        "input": "s = '(]'",
        "output": "false",
        "explanation": "The opening bracket '(' does not match the closing bracket ']', making the string invalid."
      },
      {
        "input": "s = '([)]'",
        "output": "false",
        "explanation": "The brackets are closing in the wrong order."
      },
      {
        "input": "s = '{[]}{}'",
        "output": "true",
        "explanation": "All opening brackets are correctly matched with their respective closing brackets."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "Check for matching pairs as you pop from the stack."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". A common prefix is defined as a substring that occurs at the start of every string in the provided array.",
    "topic": "String",
    "subtopic": "Prefix",
    "tags": [
      "String",
      "Prefix",
      "Array"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A string representing the longest common prefix. If none exists, return \"\".",
    "constraints": [
      "0 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "All strings consist of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\", \"flow\", \"flight\"]",
        "output": "\"fl\"",
        "explanation": "The longest common prefix is 'fl'."
      },
      {
        "input": "strs = [\"dog\", \"racecar\", \"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among the strings."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider the first string as the initial prefix.",
      "Iterate through each character and compare with the rest of the strings."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Median"
    ],
    "input_format": "Two integer arrays nums1 and nums2 which are both sorted in non-decreasing order.",
    "output_format": "A single floating-point number representing the median of the two sorted arrays.",
    "constraints": [
      "0 <= nums1.length <= 1000",
      "0 <= nums2.length <= 1000",
      "1 <= total length of nums1 and nums2 <= 2000",
      "-10^6 <= nums1[i], nums2[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 3], nums2 = [2]",
        "output": "2.0",
        "explanation": "The combined sorted array is [1, 2, 3]. The median is 2."
      },
      {
        "input": "nums1 = [1, 2], nums2 = [3, 4]",
        "output": "2.5",
        "explanation": "The combined sorted array is [1, 2, 3, 4]. The median is (2 + 3) / 2 = 2.5."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using binary search to find the correct partition."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Group Anagrams",
    "description": "Given an array of strings, group the anagrams together. You can return the answer in any order. Two strings are considered anagrams if they contain the same characters in the same frequency.",
    "topic": "String",
    "subtopic": "Hashing",
    "tags": [
      "String",
      "Hashing",
      "Group Anagrams"
    ],
    "input_format": "An array of strings strs.",
    "output_format": "A list of lists of strings, where each sub-list contains grouped anagrams.",
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase English letters."
    ],
    "examples": [
      {
        "input": "strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]",
        "output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
        "explanation": "The groups of anagrams are 'eat', 'tea', 'ate' and 'tan', 'nat'. 'bat' has no anagrams."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "A single empty string is an anagram of itself."
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": "A single character string is an anagram of itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the characters of each string.",
      "Use a hashmap to categorize strings by their sorted character representation."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Merge Sorted Array",
    "description": "Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. The number of elements initialized in nums1 and nums2 are m and n respectively. You must perform the merge in place, meaning that after merging, the elements in nums1 should be in sorted order.",
    "topic": "Array",
    "subtopic": "Merging Arrays",
    "tags": [
      "Array",
      "Merging",
      "Sorting"
    ],
    "input_format": "Two sorted integer arrays nums1 and nums2, where nums1 has a size of m + n, with the first m elements representing the initialized elements of nums1, and the rest n are zeros. nums2 has a size of n.",
    "output_format": "The merged array nums1 in sorted order.",
    "constraints": [
      "0 <= m, n <= 200",
      "1 <= m + n <= 200",
      "-10^9 <= nums1[i], nums2[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3",
        "output": "[1, 2, 2, 3, 5, 6]",
        "explanation": "After merging nums2 into nums1, nums1 becomes [1, 2, 2, 3, 5, 6]."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "Since nums2 is empty, the merged array is just nums1: [1]."
      },
      {
        "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
        "output": "[1]",
        "explanation": "Since nums1 has no initialized elements, the merged array becomes [1]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers to traverse both arrays.",
      "Start merging from the end of nums1 to avoid overwriting."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Merge Intervals",
    "description": "Given a collection of intervals, merge all overlapping intervals. For example, if the input is [[1,3],[2,6],[8,10],[15,18]], the output should be [[1,6],[8,10],[15,18]]. Two intervals are considered overlapping if the start of one is less than or equal to the end of the other.",
    "topic": "Greedy",
    "subtopic": "Interval Manipulation",
    "tags": [
      "Greedy",
      "Sorting",
      "Intervals"
    ],
    "input_format": "A list of intervals, where each interval is represented as a pair of integers [start, end].",
    "output_format": "A list of merged intervals after removing overlaps.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^5"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "The intervals [1,3] and [2,6] overlap, so they are merged into [1,6]. The other intervals do not overlap and remain unchanged."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "The intervals [1,4] and [4,5] touch, so they are merged into [1,5]."
      },
      {
        "input": "intervals = []",
        "output": "[]",
        "explanation": "With no intervals, the result is an empty list."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the intervals based on the starting times.",
      "Use a list to keep track of merged intervals.",
      "Iterate through the sorted intervals and merge when necessary."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Reverse Integer",
    "description": "Given a signed 32-bit integer, reverse the digits of the integer. If reversing the integer causes it to go outside the range of a 32-bit signed integer, then return 0.",
    "topic": "Math",
    "subtopic": "Number Manipulation",
    "tags": [
      "Integer",
      "Math",
      "String Manipulation"
    ],
    "input_format": "A single signed 32-bit integer x.",
    "output_format": "A signed 32-bit integer which is the reversed digits of x or 0 if it overflows.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 123",
        "output": "321",
        "explanation": "The reverse of 123 is 321."
      },
      {
        "input": "x = -123",
        "output": "-321",
        "explanation": "The reverse of -123 is -321."
      },
      {
        "input": "x = 120",
        "output": "21",
        "explanation": "The reverse of 120 is 21, as leading zeros are discarded."
      },
      {
        "input": "x = 1534236469",
        "output": "0",
        "explanation": "Reversing 1534236469 causes overflow, thus the output is 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to handle negative numbers and leading zeros.",
      "Use integer division and modulus to extract digits."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Trapping Rain Water",
    "description": "Given an array of non-negative integers representing the height of bars, compute how much water it can trap after raining. The width of each bar is 1.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers height where height[i] represents the height of the ith bar.",
    "output_format": "An integer representing the total amount of trapped rainwater.",
    "constraints": [
      "0 <= height.length <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "The water trapped on top of bars is 1 + 0 + 1 + 3 + 1 = 6."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "The water trapped above the bars forms multiple containers."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to find the maximum height on both sides of each bar.",
      "Use a two-pointer technique to optimize the solution."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Valid Sudoku",
    "description": "Sudoku is a logic-based combinatorial number-placement puzzle. A Sudoku grid is a 9x9 matrix that is divided into 3x3 sub-grids. The objective of Sudoku is to fill the grid with digits from 1 to 9, ensuring that each digit appears exactly once in each row, each column, and each 3x3 sub-grid. Given a partially filled 9x9 Sudoku board, determine if it is valid according to these rules. Note that empty cells are represented by the character '.' and can be ignored for the validity check.",
    "topic": "Array",
    "subtopic": "2D Array",
    "tags": [
      "Array",
      "Backtracking",
      "Matrix"
    ],
    "input_format": "A 9x9 2D array representing the Sudoku board, where each cell contains a digit '1' to '9' or '.' for an empty cell.",
    "output_format": "A boolean value indicating whether the Sudoku board is valid.",
    "constraints": [
      "The board consists of 9x9 cells.",
      "The values in the board are either digits '1'-'9' or '.' (empty cells)."
    ],
    "examples": [
      {
        "input": [
          [
            "5",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            ".",
            "2",
            "8",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": "true",
        "explanation": "Each number appears at most once in its row, column, and 3x3 sub-grid."
      },
      {
        "input": [
          [
            "8",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            ".",
            "2",
            "8",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": "false",
        "explanation": "The number '8' appears twice in the first column, violating the Sudoku rules."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use hash sets to track the occurrences of numbers in rows, columns, and boxes.",
      "Iterate through each cell and check if the number can be placed without conflicts."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Roman to Integer",
    "description": "Given a string representing a Roman numeral, convert it to an integer. The input string is guaranteed to be a valid Roman numeral in the range from 1 to 3999.",
    "topic": "String",
    "subtopic": "Manipulation",
    "tags": [
      "String",
      "Conversion",
      "Roman Numerals"
    ],
    "input_format": "A string representing a Roman numeral.",
    "output_format": "An integer representing the equivalent decimal value of the input Roman numeral.",
    "constraints": [
      "1 <= s.length <= 15",
      "s consists of the characters 'I', 'V', 'X', 'L', 'C', 'D', and 'M'."
    ],
    "examples": [
      {
        "input": "III",
        "output": "3",
        "explanation": "The Roman numeral III is equal to 3."
      },
      {
        "input": "IV",
        "output": "4",
        "explanation": "The Roman numeral IV is 4 (5 - 1)."
      },
      {
        "input": "IX",
        "output": "9",
        "explanation": "The Roman numeral IX is 9 (10 - 1)."
      },
      {
        "input": "LVIII",
        "output": "58",
        "explanation": "The Roman numeral LVIII is 58 (50 + 5 + 3)."
      },
      {
        "input": "MCMXCIV",
        "output": "1994",
        "explanation": "The Roman numeral MCMXCIV is 1994 (1000 + (1000 - 100) + (1000 - 10) + 5 - 1)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Map each Roman numeral character to its integer value.",
      "Consider the rules of numeral combinations for subtraction."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase. It takes N steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "topic": "Dynamic Programming",
    "subtopic": "Fibonacci Sequence",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "Fibonacci"
    ],
    "input_format": "An integer N representing the number of steps in the staircase.",
    "output_format": "An integer representing the number of distinct ways to climb to the top.",
    "constraints": [
      "1 <= N <= 45"
    ],
    "examples": [
      {
        "input": "N = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: (1, 1) and (2)."
      },
      {
        "input": "N = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top: (1, 1, 1), (1, 2), and (2, 1)."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Think about how many ways you can reach each step.",
      "Consider a recurrence relation for the number of ways."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Palindrome Number",
    "description": "Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome while 123 is not. You need to return true if the number is a palindrome, and false otherwise.",
    "topic": "Math",
    "subtopic": "Number Theory",
    "tags": [
      "Palindrome",
      "Math",
      "Number Theory"
    ],
    "input_format": "An integer x.",
    "output_format": "A boolean value indicating whether the integer is a palindrome.",
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 121",
        "output": "true",
        "explanation": "121 reads the same backward as forward."
      },
      {
        "input": "x = -121",
        "output": "false",
        "explanation": "-121 does not read the same backward."
      },
      {
        "input": "x = 10",
        "output": "false",
        "explanation": "10 reads as 01 backward."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Try reversing the number and comparing it with the original."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Spiral Matrix",
    "description": "Given a 2D matrix of size m x n, return all elements of the matrix in spiral order. Start from the top-left corner of the matrix, and traverse the elements in a spiral order until all elements have been traversed.",
    "topic": "Matrix",
    "subtopic": "Traversal",
    "tags": [
      "Matrix",
      "Traversal",
      "Spiral"
    ],
    "input_format": "A 2D list of integers representing the matrix.",
    "output_format": "A list of integers representing the elements of the matrix in spiral order.",
    "constraints": [
      "1 <= m, n <= 10^4",
      "m * n <= 10^5"
    ],
    "examples": [
      {
        "input": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
        "output": "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
        "explanation": "The elements of the matrix are traversed in the order: 1 -> 2 -> 3 -> 6 -> 9 -> 8 -> 7 -> 4 -> 5."
      },
      {
        "input": "[[1]]",
        "output": "[1]",
        "explanation": "Only one element in the matrix, which is 1."
      },
      {
        "input": "[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]",
        "output": "[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]",
        "explanation": "The elements of the matrix are traversed in the order: 1 -> 2 -> 3 -> 4 -> 8 -> 12 -> 11 -> 10 -> 9 -> 5 -> 6 -> 7."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about using four pointers to track the boundaries of the spiral.",
      "Iterate the boundaries inward after each row or column is processed."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest substring of s that is a palindrome. A palindrome is a string that reads the same forward and backward. If there are multiple longest palindromic substrings, return any one of them.",
    "topic": "String",
    "subtopic": "Dynamic Programming",
    "tags": [
      "String",
      "Palindrome",
      "Dynamic Programming"
    ],
    "input_format": "A single input string s, where 1 <= s.length <= 1000.",
    "output_format": "A string that represents the longest palindromic substring in s.",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only lowercase English letters."
    ],
    "examples": [
      {
        "input": "babad",
        "output": "bab",
        "explanation": "Both 'bab' and 'aba' are valid longest palindromic substrings."
      },
      {
        "input": "cbbd",
        "output": "bb",
        "explanation": "The longest palindromic substring is 'bb'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider expanding around the center of potential palindromes.",
      "Check both odd and even length palindromes."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contains a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.",
    "topic": "Linked List",
    "subtopic": "Addition of Numbers",
    "tags": [
      "Linked List",
      "Addition",
      "Two Pointers"
    ],
    "input_format": "Two linked lists l1 and l2.",
    "output_format": "A linked list representing the sum of the two numbers.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the input lists represent a number that does not have leading zeros."
    ],
    "examples": [
      {
        "input": "l1 = [2, 4, 3], l2 = [5, 6, 4]",
        "output": "[7, 0, 8]",
        "explanation": "The digits 342 and 465 are added to get 807. Hence the output list is [7, 0, 8]."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "Both numbers are 0, hence the output is [0]."
      },
      {
        "input": "l1 = [9, 9, 9, 9, 9, 9, 9], l2 = [9, 9, 9, 9]",
        "output": "[8, 9, 9, 9, 0, 0, 1]",
        "explanation": "The digits 9999999 and 9999 are added to get 10009998. Hence the output list is [8, 9, 9, 9, 0, 0, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to carry over if the sum of two digits exceeds 9.",
      "You can use a dummy node to simplify the process of building the resulting linked list."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "3Sum",
    "description": "Given an array of integers nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Note that the solution set must not contain duplicate triplets.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "List of unique triplets that sum to zero.",
    "constraints": [
      "0 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [-1, 0, 1, 2, -1, -4]",
        "output": "[[-1, -1, 2], [-1, 0, 1]]",
        "explanation": "The triplets that add up to zero are [-1, -1, 2] and [-1, 0, 1]."
      },
      {
        "input": "nums = []",
        "output": "[]",
        "explanation": "There are no numbers in the array, so no triplets exist."
      },
      {
        "input": "nums = [0, 0, 0]",
        "output": "[[0, 0, 0]]",
        "explanation": "The only triplet is [0, 0, 0] as all elements are zero."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array to make it easier to identify duplicates.",
      "Use two pointers to find pairs that sum to the negative of a chosen element.",
      "Skip duplicate elements to avoid repeated triplets."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Rotate Image",
    "description": "You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise) in place. You have to do this without using any extra space for another matrix. Transform the input matrix directly.",
    "topic": "Matrix",
    "subtopic": "Manipulation",
    "tags": [
      "Matrix",
      "In-place",
      "Rotation"
    ],
    "input_format": "An n x n 2D array (matrix) where 1 <= n <= 20.",
    "output_format": "The input matrix rotated 90 degrees clockwise, modified in place.",
    "constraints": [
      "The matrix is non-empty and contains only integers.",
      "1 <= matrix.length == matrix[i].length <= 20"
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]",
        "explanation": "Rotating the matrix 90 degrees clockwise changes the positions of the elements as shown in the output."
      },
      {
        "input": "matrix = [[1]]",
        "output": "[[1]]",
        "explanation": "A single element matrix remains unchanged after rotation."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider swapping elements in layers or rings.",
      "Think about the index calculations for rotation."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array",
    "description": "Given a sorted array of integers, you need to implement a function that removes the duplicates in-place such that each element appears only once and returns the new length of the array. The relative order of the elements should be kept the same as well. Note that your solution should not use extra space for another array.",
    "topic": "Array",
    "subtopic": "In-place Modification",
    "tags": [
      "Array",
      "In-place",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums, sorted in non-decreasing order.",
    "output_format": "An integer representing the new length of the array with duplicates removed.",
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "2",
        "explanation": "After removing duplicates, the array is [1, 2] and its length is 2."
      },
      {
        "input": "nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]",
        "output": "5",
        "explanation": "After removing duplicates, the array is [0, 1, 2, 3, 4] and its length is 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use two pointers to track the current position and the next unique element."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array",
    "description": "You are given an integer array nums sorted in ascending order, but the array is rotated at an unknown pivot index. Given the integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Binary Search",
    "subtopic": "Search algorithms",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An integer representing the index of target in nums, or -1 if target is not present.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "\u221210^4 <= nums[i] <= 10^4",
      "All elements of nums are unique.",
      "nums is guaranteed to be rotated at some pivot.",
      "-10^4 <= target <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "Target 0 is found at index 4."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": "Target 3 is not found in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the property of the rotated array.",
      "Use binary search to eliminate half of the search space."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Merge Two Sorted Lists",
    "description": "You are given two sorted linked lists, list1 and list2, each containing nodes in ascending order. Merge the two lists into a single sorted linked list and return it. The nodes in the merged linked list should be arranged in ascending order.",
    "topic": "Linked List",
    "subtopic": "Merging Linked Lists",
    "tags": [
      "Linked List",
      "Merge",
      "Sorting"
    ],
    "input_format": "Two pointers to the heads of the linked lists, list1 and list2.",
    "output_format": "A pointer to the head of the merged sorted linked list.",
    "constraints": [
      "The number of nodes in both linked lists is in the range [0, 1000].",
      "-100 <= Node.val <= 100",
      "Both list1 and list2 are already sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "list1 = 1 -> 2 -> 4, list2 = 1 -> 3 -> 4",
        "output": "1 -> 1 -> 2 -> 3 -> 4 -> 4",
        "explanation": "By merging the two sorted lists, we get a single sorted list: 1 -> 1 -> 2 -> 3 -> 4 -> 4."
      },
      {
        "input": "list1 = , list2 = 0 -> 1 -> 2",
        "output": "0 -> 1 -> 2",
        "explanation": "When one list is empty, the merged list is just the other list."
      },
      {
        "input": "list1 = , list2 = ",
        "output": "",
        "explanation": "When both lists are empty, the merged list is also empty."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a dummy node to simplify the merging process.",
      "Iterate through both lists and compare their values."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Sqrt(x)",
    "description": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. Implement a function that does not use built-in square root functions. You may assume that the input is always a valid non-negative integer.",
    "topic": "Math",
    "subtopic": "Binary Search",
    "tags": [
      "Math",
      "Binary Search",
      "Square Root"
    ],
    "input_format": "A single non-negative integer x.",
    "output_format": "An integer representing the square root of x rounded down.",
    "constraints": [
      "0 <= x <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "x = 4",
        "output": "2",
        "explanation": "The square root of 4 is exactly 2."
      },
      {
        "input": "x = 8",
        "output": "2",
        "explanation": "The square root of 8 is approximately 2.828, rounded down to 2."
      },
      {
        "input": "x = 0",
        "output": "0",
        "explanation": "The square root of 0 is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using binary search to find the square root.",
      "The square of a number n is n * n."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "topic": "Array",
    "subtopic": "Dynamic Programming",
    "tags": [
      "Array",
      "Dynamic Programming",
      "Subarray"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the maximum sum of a contiguous subarray.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The contiguous subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The only element is 1, which is also the max subarray."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The contiguous subarray [5,4,-1,7,8] has the largest sum 23."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to keep track of the max subarray sum.",
      "You may want to maintain a running total and update the max when it exceeds current known max."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Generate Parentheses",
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. A pair of parentheses is well-formed if every opening parenthesis is closed by a corresponding closing parenthesis in the correct order.",
    "topic": "Backtracking",
    "subtopic": "String Generation",
    "tags": [
      "Backtracking",
      "Strings",
      "Recursion"
    ],
    "input_format": "An integer n representing the number of pairs of parentheses.",
    "output_format": "A list of strings representing all combinations of well-formed parentheses.",
    "constraints": [
      "0 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[ '(())()', '()()()', '(()())', '()(())', '((()))' ]",
        "explanation": "The combinations of well-formed parentheses for 3 pairs are: '(())()', '()()()', '(()())', '()(())', '((()))'."
      },
      {
        "input": "n = 1",
        "output": "[ '()' ]",
        "explanation": "The only combination for 1 pair is '()'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to explore all possibilities.",
      "Keep track of the count of opening and closing parentheses used."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Find the Index of the First Occurrence in a String",
    "description": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.",
    "topic": "String",
    "subtopic": "Substring Search",
    "tags": [
      "String",
      "Searching",
      "Algorithm"
    ],
    "input_format": "Two strings, haystack and needle, where 0 <= haystack.length <= 10^4 and 0 <= needle.length <= 10^4.",
    "output_format": "An integer representing the index of the first occurrence of needle in haystack, or -1 if needle is not found.",
    "constraints": [
      "0 <= haystack.length <= 10^4",
      "0 <= needle.length <= 10^4"
    ],
    "examples": [
      {
        "input": "haystack = 'hello', needle = 'll'",
        "output": "2",
        "explanation": "The substring 'll' starts at index 2 in 'hello'."
      },
      {
        "input": "haystack = 'aaaaaa', needle = 'bba'",
        "output": "-1",
        "explanation": "'bba' is not present in 'aaaaaa'."
      },
      {
        "input": "haystack = '', needle = ''",
        "output": "0",
        "explanation": "An empty needle is found at index 0 in an empty haystack."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using the built-in string methods.",
      "If the needle is an empty string, return 0.",
      "Use a loop to check each substring of haystack."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Container With Most Water",
    "description": "Given n non-negative integers a1, a2, ..., an where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with the x-axis forms a container, such that the container contains the most water. Return the maximum amount of water a container can store.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "input_format": "An array of integers height representing the height of each line.",
    "output_format": "An integer representing the maximum area of water that can be contained.",
    "constraints": [
      "2 <= height.length <= 10^5",
      "0 <= height[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The maximum area is formed between lines at index 1 and 8, with a height of 7 and a width of 7."
      },
      {
        "input": "height = [1,1]",
        "output": "1",
        "explanation": "The only container formed is between the two lines which have a height of 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to maximize the area by choosing lines with larger heights.",
      "Use two pointers to find the optimal solution."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of k linked-lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
    "topic": "Linked List",
    "subtopic": "Merge",
    "tags": [
      "Linked List",
      "Sorting",
      "Merge"
    ],
    "input_format": "An array of k linked-lists where each linked-list node is represented by a ListNode class with a value and a next pointer.",
    "output_format": "A single merged linked-list in ascending order, represented by the head of the merged ListNode.",
    "constraints": [
      "0 <= k <= 10^4",
      "0 <= ListNode.val <= 10^4",
      "The total number of nodes in all lists combined is within the range of [0, 10^4]."
    ],
    "examples": [
      {
        "input": "[1->4->5, 1->3->4, 2->6]",
        "output": "[1->1->2->3->4->4->5->6]",
        "explanation": "The merged list is 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6."
      },
      {
        "input": "[]",
        "output": "[]",
        "explanation": "The input is empty; thus, the output is also an empty list."
      },
      {
        "input": "[2->4->6, 1->3->5]",
        "output": "[1->2->3->4->5->6]",
        "explanation": "The merged list is 1 -> 2 -> 3 -> 4 -> 5 -> 6."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a min-heap (priority queue) to facilitate merging.",
      "Think about how to efficiently extract the smallest element from the k lists."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Remove Element",
    "description": "Given an array of integers nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed. Since it is impossible to change the length of the array in Java, you must instead have the result be placed in the first part of the array. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.",
    "topic": "Array",
    "subtopic": "In-place Modification",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An array of integers nums followed by an integer val.",
    "output_format": "An integer representing the new length of the array after removing val.",
    "constraints": [
      "0 <= nums.length <= 100",
      "0 <= nums[i] <= 50",
      "0 <= val <= 50"
    ],
    "examples": [
      {
        "input": "nums = [3, 2, 2, 3], val = 3",
        "output": "2",
        "explanation": "After removing 3, the array will be [2, 2] and the length will be 2."
      },
      {
        "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
        "output": "5",
        "explanation": "After removing 2, the array could be [0, 1, 3, 0, 4] and the length will be 5."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using two pointers to efficiently modify the array in-place."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Search Insert Position",
    "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An integer array 'nums' followed by an integer 'target'.",
    "output_format": "An integer representing the index of the target in the array or the position it would be if not present.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "1 <= nums[i] <= 10^4",
      "nums contains distinct values."
    ],
    "examples": [
      {
        "input": "nums = [1, 3, 5, 6], target = 5",
        "output": "2",
        "explanation": "The target 5 is found at index 2."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 2",
        "output": "1",
        "explanation": "The target 2 would be inserted at index 1."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 7",
        "output": "4",
        "explanation": "The target 7 would be inserted at the end of the array, index 4."
      },
      {
        "input": "nums = [1, 3, 5, 6], target = 0",
        "output": "0",
        "explanation": "The target 0 would be inserted at the beginning of the array, index 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use binary search to find the position."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Letter Combinations of a Phone Number",
    "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters is given as follows: 2 -> 'abc', 3 -> 'def', 4 -> 'ghi', 5 -> 'jkl', 6 -> 'mno', 7 -> 'pqrs', 8 -> 'tuv', 9 -> 'wxyz'. Return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Combination Generation",
    "tags": [
      "Backtracking",
      "Recursion",
      "String",
      "Combination"
    ],
    "input_format": "A string digits representing the digits on a phone keypad.",
    "output_format": "A list of all possible letter combinations.",
    "constraints": [
      "0 <= digits.length <= 4",
      "digits[i] is a digit from '2' to '9'."
    ],
    "examples": [
      {
        "input": "digits = \"23\"",
        "output": "[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]",
        "explanation": "The digits 2 and 3 map to 'abc' and 'def' respectively, leading to the combinations."
      },
      {
        "input": "digits = \"\"",
        "output": "[]",
        "explanation": "An empty input string should return an empty list."
      },
      {
        "input": "digits = \"2\"",
        "output": "[\"a\", \"b\", \"c\"]",
        "explanation": "The digit 2 maps to 'abc'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a backtracking approach to explore all combinations.",
      "Consider using a mapping from digits to letters for easier reference.",
      "Start with an empty combination and build upon it recursively."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Remove Nth Node From End of List",
    "description": "Given the head of a singly linked list, remove the n-th node from the end of the list and return its head. The n-th node is counted from the end, and if n is greater than the number of nodes in the list, return the original list.",
    "topic": "Linked List",
    "subtopic": "Two Pointers",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Removal"
    ],
    "input_format": "The input consists of a linked list represented by the head node and an integer n.",
    "output_format": "Return the head of the linked list after removing the n-th node from the end.",
    "constraints": [
      "The linked list will have at least one node.",
      "1 <= n <= the number of nodes in the list."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], n = 2",
        "output": "[1, 2, 3, 5]",
        "explanation": "Removing the 2nd node from the end (node with value 4) results in the list [1, 2, 3, 5]."
      },
      {
        "input": "head = [1], n = 1",
        "output": "[]",
        "explanation": "Removing the 1st node from the end (the only node) results in an empty list."
      },
      {
        "input": "head = [1, 2], n = 1",
        "output": "[1]",
        "explanation": "Removing the 1st node from the end (node with value 2) results in the list [1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use two pointers to find the n-th node from the end.",
      "Consider using a dummy node to simplify edge cases."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Regular Expression Matching",
    "description": "Implement a function that checks if a given input string matches a specified pattern. The pattern may include the following: '.' which matches any single character, and '*' which matches zero or more occurrences of the preceding element. Your function should return true if the string matches the pattern; otherwise, it returns false.",
    "topic": "String",
    "subtopic": "Pattern Matching",
    "tags": [
      "String",
      "Recursion",
      "Dynamic Programming"
    ],
    "input_format": "A string s representing the input string and a string p representing the pattern.",
    "output_format": "A boolean value indicating whether the input string matches the pattern.",
    "constraints": [
      "1 <= s.length <= 20",
      "1 <= p.length <= 20"
    ],
    "examples": [
      {
        "input": "s = \"aa\", p = \"a\"",
        "output": "false",
        "explanation": "The pattern 'a' does not match the string 'aa'."
      },
      {
        "input": "s = \"aa\", p = \"a*\"",
        "output": "true",
        "explanation": "The pattern 'a*' matches the string 'aa' as '*' allows for zero or more occurrences of 'a'."
      },
      {
        "input": "s = \"ab\", p = \".*\"",
        "output": "true",
        "explanation": "The pattern '.*' matches any string, thus it matches 'ab'."
      },
      {
        "input": "s = \"mississippi\", p = \"mis*is*p*.\"",
        "output": "false",
        "explanation": "The pattern does not match the string 'mississippi'."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to solve this problem.",
      "Look for overlapping subproblems."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Find First and Last Position of Element in Sorted Array",
    "description": "Given an array of integers 'nums' sorted in ascending order and an integer 'target', write a function to search for the 'target' in 'nums'. If the target exists, return the starting and ending position of the target. If the target is not found in the array, return [-1, -1].",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An integer array 'nums' and an integer 'target'.",
    "output_format": "An array of two integers representing the starting and ending position of 'target'.",
    "constraints": [
      "0 <= nums.length <= 10^5",
      "1 <= target <= 10^9",
      "The array 'nums' is sorted in ascending order."
    ],
    "examples": [
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 8",
        "output": "[3, 4]",
        "explanation": "The target '8' appears first at index 3 and last at index 4."
      },
      {
        "input": "nums = [5, 7, 7, 8, 8, 10], target = 6",
        "output": "[-1, -1]",
        "explanation": "The target '6' does not exist in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search to find the first occurrence.",
      "After finding the first occurrence, search for the last occurrence."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Add Binary",
    "description": "Given two binary strings a and b, return their sum as a binary string.",
    "topic": "String",
    "subtopic": "Binary Arithmetic",
    "tags": [
      "String",
      "Binary",
      "Arithmetic"
    ],
    "input_format": "Two binary strings a and b, where 1 <= a.length, b.length <= 10^4.",
    "output_format": "A binary string representing the sum of a and b.",
    "constraints": [
      "The input strings are both non-empty and consist of characters '0' or '1'."
    ],
    "examples": [
      {
        "input": "a = '1010', b = '1011'",
        "output": "'10101'",
        "explanation": "10 (decimal) + 11 (decimal) = 21 (decimal) which is '10101' in binary."
      },
      {
        "input": "a = '0', b = '0'",
        "output": "'0'",
        "explanation": "0 + 0 = 0."
      },
      {
        "input": "a = '111', b = '1'",
        "output": "'1000'",
        "explanation": "7 (decimal) + 1 (decimal) = 8 (decimal) which is '1000' in binary."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a carry variable to handle binary addition.",
      "Read the strings from right to left for easier addition."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Binary Tree Level Order Traversal",
    "description": "Given a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "BFS",
      "Level Order"
    ],
    "input_format": "The root node of the binary tree, represented as a TreeNode object.",
    "output_format": "A list of lists of integers, where each list represents the node values at each level.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[9,20],[15,7]]",
        "explanation": "The tree has 3 levels. The first level has the value 3, the second level has values 9 and 20, and the third level has values 15 and 7."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree results in no nodes to traverse."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a queue to facilitate level order traversal.",
      "Each time you process a level, enqueue its children."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Maximum Depth of Binary Tree",
    "description": "Given a binary tree, return its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "topic": "Tree",
    "subtopic": "Depth First Search",
    "tags": [
      "Tree",
      "Depth",
      "DFS"
    ],
    "input_format": "The input consists of a binary tree represented by its root node.",
    "output_format": "An integer representing the maximum depth of the binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "The value of each node is between -10^5 and 10^5."
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "3",
        "explanation": "The longest path is from the root (3) to the leaf nodes (15 or 7), which has 3 nodes."
      },
      {
        "input": "root = [1,null,2]",
        "output": "2",
        "explanation": "The longest path is from the root (1) to the leaf node (2), which has 2 nodes."
      },
      {
        "input": "root = []",
        "output": "0",
        "explanation": "An empty tree has a maximum depth of 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a recursive approach to explore each branch of the tree.",
      "Base case: an empty tree has a depth of 0.",
      "Return the maximum of the depths of the left and right subtrees."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Insert Interval",
    "description": "Given a collection of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). The input intervals are sorted by their start times. You need to return the resulting list of intervals that is also sorted by the start times.",
    "topic": "Array",
    "subtopic": "Intervals",
    "tags": [
      "Array",
      "Intervals",
      "Merge"
    ],
    "input_format": "A list of intervals where each interval is represented as a list of integers [start, end], and a new interval also represented as [start, end].",
    "output_format": "A list of merged intervals sorted by their start times.",
    "constraints": [
      "0 <= intervals.length <= 10^4",
      "intervals[i].length == 2",
      "0 <= intervals[i][0] <= intervals[i][1] <= 10^5",
      "newInterval.length == 2",
      "0 <= newInterval[0] <= newInterval[1] <= 10^5"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
        "output": "[[1,5],[6,9]]",
        "explanation": "The new interval [2,5] overlaps with [1,3], merging them to [1,5]. Thus the intervals become [[1,5],[6,9]]."
      },
      {
        "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
        "output": "[[1,2],[3,10],[12,16]]",
        "explanation": "The new interval [4,8] overlaps with [3,5] and [6,7], merging them to [3,10]. So the intervals become [[1,2],[3,10],[12,16]]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the intervals that come before the new interval and the ones that come after.",
      "Use a loop to traverse through the intervals and determine where the new interval should be placed."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Largest Rectangle in Histogram",
    "description": "Given an array of integers representing the heights of bars in a histogram, return the area of the largest rectangle that can be formed within the histogram. Each bar has a width of 1.",
    "topic": "Stack",
    "subtopic": "Monotonic Stack",
    "tags": [
      "Stack",
      "Array",
      "Dynamic Programming"
    ],
    "input_format": "An array of integers heights, where 0 <= heights[i] <= 10^4.",
    "output_format": "An integer representing the area of the largest rectangle.",
    "constraints": [
      "1 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "heights = [2, 1, 5, 6, 2, 3]",
        "output": "10",
        "explanation": "The largest rectangle is formed between the heights 5 and 6, which has an area of 5 x 2 = 10."
      },
      {
        "input": "heights = [2, 4]",
        "output": "4",
        "explanation": "The largest rectangle is the second bar of height 4, which forms an area of 4 x 1 = 4."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a stack to store the indices of the bars.",
      "A rectangle's area can be calculated using height * width.",
      "Pop elements from the stack when encountering a smaller height."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Permutations",
    "description": "Given an array of distinct integers, return all possible permutations of the array. You can return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Recursion",
      "Permutations"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "A list of all possible permutations of the input array.",
    "constraints": [
      "1 <= nums.length <= 6",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": "All possible arrangements of 1, 2, and 3 are included."
      },
      {
        "input": "nums = [0, 1]",
        "output": "[[0,1],[1,0]]",
        "explanation": "The two permutations of the array [0, 1] are [0,1] and [1,0]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to use backtracking to generate permutations.",
      "Consider adding an integer to the current path and recursing."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Sort Colors",
    "description": "Given an array of n objects colored red, white, or blue, sort them in place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function.",
    "topic": "Array",
    "subtopic": "Sorting",
    "tags": [
      "Array",
      "Sorting",
      "Two Pointers"
    ],
    "input_format": "An array of integers nums, where each integer is either 0, 1, or 2.",
    "output_format": "The same array sorted in place, with all 0s followed by all 1s and all 2s.",
    "constraints": [
      "1 <= nums.length <= 300",
      "nums[i] is either 0, 1, or 2."
    ],
    "examples": [
      {
        "input": "nums = [2, 0, 2, 1, 1, 0]",
        "output": "[0, 0, 1, 1, 2, 2]",
        "explanation": "After sorting, all 0s come first, followed by all 1s and then 2s."
      },
      {
        "input": "nums = [2, 0, 1]",
        "output": "[0, 1, 2]",
        "explanation": "The array is a small example where colors are rearranged in order."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a three-pointer approach to divide the array into three parts."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Next Permutation",
    "description": "Implement an algorithm to rearrange numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it to the lowest possible order (i.e., sorted in ascending order). The replacement must be in-place and use only constant extra memory.",
    "topic": "Array",
    "subtopic": "Permutations",
    "tags": [
      "Array",
      "Permutation",
      "In-place"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "The modified array that represents the next permutation.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[1, 3, 2]",
        "explanation": "The next permutation of [1, 2, 3] is [1, 3, 2]."
      },
      {
        "input": "nums = [3, 2, 1]",
        "output": "[1, 2, 3]",
        "explanation": "Since [3, 2, 1] is the highest permutation, the next one is the lowest permutation [1, 2, 3]."
      },
      {
        "input": "nums = [1, 1, 5]",
        "output": "[1, 5, 1]",
        "explanation": "The next permutation of [1, 1, 5] is [1, 5, 1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Try to find the first decreasing element from the right.",
      "Swap this element with the next greater element.",
      "Reverse the elements after the position of the first decreasing element."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Combination Sum",
    "description": "Given an array of distinct integers candidates and a target integer target, return all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. It is guaranteed that the solution set will not exceed 10^4 unique combinations for the given input.",
    "topic": "Backtracking",
    "subtopic": "Combination Sum",
    "tags": [
      "Backtracking",
      "Recursion",
      "Combination"
    ],
    "input_format": "An array of distinct integers candidates and an integer target.",
    "output_format": "A list of lists containing all unique combinations that sum to target.",
    "constraints": [
      "1 <= candidates.length <= 30",
      "1 <= candidates[i] <= 200",
      "All elements of candidates are unique.",
      "0 <= target <= 500"
    ],
    "examples": [
      {
        "input": "candidates = [2, 3, 6, 7], target = 7",
        "output": "[[7], [2, 2, 3]]",
        "explanation": "The combinations that sum up to 7 are [7] and [2, 2, 3]."
      },
      {
        "input": "candidates = [2, 3, 5], target = 8",
        "output": "[[2, 2, 2, 2], [2, 3, 3], [3, 5]]",
        "explanation": "The combinations that sum up to 8 are [2, 2, 2, 2], [2, 3, 3] and [3, 5]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a backtracking approach.",
      "You can choose the same candidate multiple times."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Jump Game",
    "description": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Your goal is to determine if you can reach the last index. Return true if you can reach the last index, otherwise return false.",
    "topic": "Array",
    "subtopic": "Greedy",
    "tags": [
      "Array",
      "Greedy",
      "Dynamic Programming"
    ],
    "input_format": "An array of non-negative integers nums.",
    "output_format": "A boolean value indicating whether you can reach the last index.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "true",
        "explanation": "You can jump 1 step to the last index."
      },
      {
        "input": "nums = [3, 2, 1, 0, 4]",
        "output": "false",
        "explanation": "You will always arrive at index 3, which has value 0, and cannot move further."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how far you can go from each position.",
      "If at any point the maximum reachable index is less than your current index, you cannot move forward."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Symmetric Tree",
    "description": "Given a binary tree, determine if it is a mirror of itself (i.e., symmetric around its center). A tree is symmetric if the left subtree is a mirror reflection of the right subtree.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Recursion",
      "Binary Tree"
    ],
    "input_format": "The input will be the root of a binary tree represented by TreeNode.",
    "output_format": "Return true if the tree is symmetric, otherwise return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 1000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1,2,2,3,4,4,3]",
        "output": "true",
        "explanation": "The left subtree [2,3,4] is a mirror reflection of the right subtree [2,4,3]."
      },
      {
        "input": "root = [1,2,2,null,3,null,3]",
        "output": "false",
        "explanation": "The left subtree [2, null, 3] is not a mirror reflection of the right subtree [2, 3, null]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Try using a recursive function to compare the left and right nodes.",
      "Check if both nodes are null, or if one is null but the other is not.",
      "Compare the values of the nodes directly as well as their respective subtrees."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "String to Integer (atoi)",
    "description": "Implement the 'myAtoi' function, which converts a string to an integer (like C/C++'s atoi). The function should ignore leading whitespace, handle optional '+' or '-' signs, and stop converting when it first encounters a non-digit character.",
    "topic": "String",
    "subtopic": "Parsing",
    "tags": [
      "String",
      "Parsing",
      "Conversion"
    ],
    "input_format": "A string 's' which represents an integer.",
    "output_format": "An integer which is the converted value of the string, clamped between -2^31 and 2^31 - 1.",
    "constraints": [
      "0 <= s.length <= 200",
      "The input string can contain leading whitespaces.",
      "The input string may contain '+' or '-' for indicating sign."
    ],
    "examples": [
      {
        "input": "s = '   -42'",
        "output": "-42",
        "explanation": "The leading spaces are ignored, and '-42' is a valid number."
      },
      {
        "input": "s = '419 with words'",
        "output": "419",
        "explanation": "Only '419' is converted as it appears before any non-digit characters."
      },
      {
        "input": "s = 'words and 987'",
        "output": "0",
        "explanation": "The string does not start with a digit or sign, hence the output is 0."
      },
      {
        "input": "s = '-91283472332'",
        "output": "-2147483648",
        "explanation": "The value exceeds the 32-bit signed integer range, so it returns -2147483648."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Trim leading spaces before processing.",
      "Consider edge cases such as overflow or non-digit characters."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Validate Binary Search Tree",
    "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: the left subtree of a node contains only nodes with keys less than the node's key, the right subtree of a node contains only nodes with keys greater than the node's key, and both the left and right subtrees must also be binary search trees.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "The root of a binary tree, where each node contains an integer value.",
    "output_format": "A boolean value indicating whether the binary tree is a valid binary search tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 10^4].",
      "-2^31 <= Node.val <= 2^31 - 1"
    ],
    "examples": [
      {
        "input": "root = [2, 1, 3]",
        "output": "true",
        "explanation": "The tree is a valid binary search tree."
      },
      {
        "input": "root = [5, 1, 4, null, null, 3, 6]",
        "output": "false",
        "explanation": "The tree is not a valid binary search tree because the node with value 3 is in the right subtree of the node with value 5."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a recursive approach to traverse the tree.",
      "Maintain a range of valid values as you check each node."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Jump Game II",
    "description": "You are given an array of non-negative integers nums. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Write a function to return the minimum number of jumps needed to reach the last index. If it is not possible to reach the last index, return -1.",
    "topic": "Dynamic Programming",
    "subtopic": "Greedy Algorithms",
    "tags": [
      "Dynamic Programming",
      "Greedy",
      "Array"
    ],
    "input_format": "An array of non-negative integers nums where nums[i] represents the maximum jump length from that position.",
    "output_format": "An integer representing the minimum number of jumps to reach the last index, or -1 if it is not possible.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [2, 3, 1, 1, 4]",
        "output": "2",
        "explanation": "The minimum number of jumps to reach the last index is 2: jump from index 0 to 1, then jump to the last index."
      },
      {
        "input": "nums = [3, 2, 1, 0, 4]",
        "output": "-1",
        "explanation": "It is not possible to reach the last index since index 3 only allows a jump to index 4 and index 4 is unreachable."
      },
      {
        "input": "nums = [1, 2, 3]",
        "output": "2",
        "explanation": "Jump from index 0 to 1 and then to the last index."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider tracking the farthest position you can reach at each step.",
      "Use a greedy approach to minimize the number of jumps."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "4Sum",
    "description": "Given an array nums of n integers and an integer target, return all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:   - 0 <= a, b, c, d < n   - a, b, c, and d are distinct.   - nums[a] + nums[b] + nums[c] + nums[d] == target.   You may return the answer in any order.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Backtracking"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "A 2D list of unique quadruplets that sum up to the target.",
    "constraints": [
      "0 <= nums.length <= 200",
      "-10^9 <= nums[i] <= 10^9",
      "The solution set must not contain duplicate quadruplets."
    ],
    "examples": [
      {
        "input": "nums = [1, 0, -1, 0, -2, 2], target = 0",
        "output": "[[-2, -1, 0, 1], [-2, 0, 0, 2], [-1, 0, 0, 1]]",
        "explanation": "The unique quadruplets that sum up to 0 are [-2, -1, 0, 1] and [-2, 0, 0, 2]."
      },
      {
        "input": "nums = [2, 2, 2, 2, 2], target = 8",
        "output": "[[2, 2, 2, 2]]",
        "explanation": "The only quadruplet that sums up to 8 is [2, 2, 2, 2]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the array first.",
      "Use a set to avoid duplicate quadruplets.",
      "Explore using a combination of two pointer technique."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array, find the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses constant extra space.",
    "topic": "Array",
    "subtopic": "Searching",
    "tags": [
      "Array",
      "Searching",
      "Positive Integers"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "An integer representing the smallest missing positive integer.",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^6 <= nums[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums = [3, 4, -1, 1]",
        "output": "2",
        "explanation": "The smallest missing positive integer is 2."
      },
      {
        "input": "nums = [1, 2, 0]",
        "output": "3",
        "explanation": "The smallest missing positive integer is 3."
      },
      {
        "input": "nums = [7, 8, 9, 11, 12]",
        "output": "1",
        "explanation": "The smallest missing positive integer is 1."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider where to place each positive integer in the array.",
      "Check the numbers in the range [1, n] where n is the size of the array."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Pow(x, n)",
    "description": "Implement the function pow(x, n), which calculates x raised to the power n (i.e., x^n). This function should handle both positive and negative integers for n. If n is 0, the function should return 1. For negative values of n, you should return the reciprocal of x raised to the absolute value of n.",
    "topic": "Math",
    "subtopic": "Exponentiation",
    "tags": [
      "Math",
      "Exponentiation",
      "Recursion"
    ],
    "input_format": "Two integers x and n, where x is the base and n is the exponent.",
    "output_format": "A floating-point number representing the result of x raised to the power of n.",
    "constraints": [
      "-100.0 <= x <= 100.0",
      "-10^4 <= n <= 10^4"
    ],
    "examples": [
      {
        "input": "x = 2.0, n = 10",
        "output": "1024.0",
        "explanation": "2 raised to the power of 10 is 1024."
      },
      {
        "input": "x = 2.1, n = 3",
        "output": "9.261000000000001",
        "explanation": "2.1 raised to the power of 3 is approximately 9.261."
      },
      {
        "input": "x = 2.0, n = -2",
        "output": "0.25",
        "explanation": "2 raised to the power of -2 is 1/(2^2) = 0.25."
      },
      {
        "input": "x = 1.0, n = 100000",
        "output": "1.0",
        "explanation": "Any number raised to the power of 0 is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion to simplify the problem.",
      "You can reduce the problem size using the property x^n = (x^(n/2))^2."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Interleaving String",
    "description": "Given three strings s1, s2, and s3, determine if s3 is formed by the interleaving of s1 and s2. The interleaving means that s3 should be made up of characters from both s1 and s2 while maintaining the relative order of characters from each string. For example, if s1 is 'aabcc' and s2 is 'dbbca', then s3 could be 'aadbbcbcac' which represents 'a' from s1, 'a' from s1, 'd' from s2, 'b' from s2, and so on.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Interleaving"
    ],
    "input_format": "Three strings s1, s2, and s3.",
    "output_format": "A boolean value indicating whether s3 is an interleaving of s1 and s2.",
    "constraints": [
      "0 <= s1.length, s2.length, s3.length <= 100",
      "The sum of lengths of s1 and s2 must equal the length of s3."
    ],
    "examples": [
      {
        "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"",
        "output": "true",
        "explanation": "The string s3 can be formed by interleaving s1 and s2 while maintaining their character order."
      },
      {
        "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"",
        "output": "false",
        "explanation": "The string s3 cannot be formed by interleaving s1 and s2."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a 2D boolean array for dynamic programming.",
      "Check the characters at the indices of s1 and s2 to fill in the DP table."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Plus One",
    "description": "Given a non-empty array of digits representing a non-negative integer, increment the integer by one and return the resulting array of digits. You may assume the digits do not contain any leading zeros, except for the number 0 itself.",
    "topic": "Array",
    "subtopic": "Manipulating Array",
    "tags": [
      "Array",
      "Mathematics",
      "Simulation"
    ],
    "input_format": "An array of integers digits representing a non-negative integer.",
    "output_format": "An array of integers representing the resulting digits after adding one.",
    "constraints": [
      "1 <= digits.length <= 100",
      "0 <= digits[i] <= 9",
      "digits does not contain any leading zeros"
    ],
    "examples": [
      {
        "input": "digits = [1, 2, 3]",
        "output": "[1, 2, 4]",
        "explanation": "The integer represented by the array is 123. After adding one, it becomes 124, which is represented as [1, 2, 4]."
      },
      {
        "input": "digits = [9, 9, 9]",
        "output": "[1, 0, 0, 0]",
        "explanation": "The integer represented by the array is 999. After adding one, it becomes 1000, which is represented as [1, 0, 0, 0]."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider how to handle carry when adding one.",
      "You may need to reverse the digits to simplify addition."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Word Search",
    "description": "Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where 'adjacent' cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "topic": "Backtracking",
    "subtopic": "Word Search",
    "tags": [
      "Backtracking",
      "Depth-First Search",
      "Grid"
    ],
    "input_format": "A 2D board of characters and a string word.",
    "output_format": "A boolean value indicating whether the word exists in the grid.",
    "constraints": [
      "1 <= board.length, board[i].length <= 200",
      "board[i][j] consists of English letters.",
      "1 <= word.length <= 500"
    ],
    "examples": [
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "ABCCED"
        },
        "output": "true",
        "explanation": "The word 'ABCCED' is constructed from sequentially adjacent cells."
      },
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "SEE"
        },
        "output": "true",
        "explanation": "The word 'SEE' can be constructed as 'S' -> 'E' -> 'E'."
      },
      {
        "input": {
          "board": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "word": "ABCB"
        },
        "output": "false",
        "explanation": "The word 'ABCB' cannot be constructed since the letter 'B' is used twice."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to explore all possible paths.",
      "Mark cells as visited during the search."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Reverse Linked List II",
    "description": "Given the head of a linked list and two integers left and right where left <= right, reverse the nodes of the linked list from position left to position right, and return the modified list. Note that the nodes are indexed starting from 1. Do not modify the values in the list, only the nodes themselves should be changed.",
    "topic": "Linked List",
    "subtopic": "Reversing Linked List",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Reversal"
    ],
    "input_format": "The input consists of the head of a linked list represented by a ListNode object, followed by two integers left and right.",
    "output_format": "The output should be the head of the modified linked list after the specified nodes have been reversed.",
    "constraints": [
      "1 <= left <= right <= the number of nodes in the list.",
      "The number of nodes in the list is between 1 and 500."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], left = 2, right = 4",
        "output": "[1, 4, 3, 2, 5]",
        "explanation": "The nodes from position 2 to 4 are reversed. The linked list becomes 1 -> 4 -> 3 -> 2 -> 5."
      },
      {
        "input": "head = [1, 2], left = 1, right = 2",
        "output": "[2, 1]",
        "explanation": "The entire list is reversed as the reversal range covers all nodes."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a dummy node to simplify edge cases.",
      "Use a loop to find the start and end of the section to reverse.",
      "You might need to reconnect the reversed section back to the list."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Divide Two Integers",
    "description": "Implement a function that divides two integers without using the division operator. The function should truncate the result towards zero. If the divisor is zero, return the maximum integer value (2^31 - 1).",
    "topic": "Mathematics",
    "subtopic": "Bit Manipulation",
    "tags": [
      "Math",
      "Bit Manipulation",
      "Division"
    ],
    "input_format": "Two integers, dividend and divisor.",
    "output_format": "An integer representing the quotient of the division.",
    "constraints": [
      "-2^31 <= dividend, divisor <= 2^31 - 1",
      "The divisor will not be zero."
    ],
    "examples": [
      {
        "input": "dividend = 10, divisor = 3",
        "output": "3",
        "explanation": "10 divided by 3 is 3.333... , which is truncated to 3."
      },
      {
        "input": "dividend = 7, divisor = -3",
        "output": "-2",
        "explanation": "7 divided by -3 is -2.333... , which is truncated to -2."
      },
      {
        "input": "dividend = 1, divisor = 1",
        "output": "1",
        "explanation": "1 divided by 1 is 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using bit manipulation for faster calculations.",
      "Think about handling negative numbers carefully."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Binary Tree Inorder Traversal",
    "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values. In inorder traversal, the nodes are recursively visited in this order: left subtree, root node, right subtree.",
    "topic": "Tree",
    "subtopic": "Binary Tree Traversal",
    "tags": [
      "Tree",
      "DFS",
      "Recursion"
    ],
    "input_format": "A binary tree node represented as a class with properties val, left, and right.",
    "output_format": "A list of integers representing the inorder traversal of the binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[1,3,2]",
        "explanation": "The inorder traversal of the tree is [1,3,2]."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree results in an empty traversal."
      },
      {
        "input": "root = [1]",
        "output": "[1]",
        "explanation": "A tree with only one node will have that node in its traversal."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a stack or recursion to keep track of the nodes."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Set Matrix Zeroes",
    "description": "Given an m x n matrix, if an element is 0, set its entire row and column to 0. You must do it in place without using extra space for another matrix.",
    "topic": "Matrix",
    "subtopic": "In-place Operations",
    "tags": [
      "Matrix",
      "In-place",
      "Array"
    ],
    "input_format": "A 2D array of integers matrix of size m x n.",
    "output_format": "Modify the input matrix in place, no return value is needed.",
    "constraints": [
      "1 <= m, n <= 200",
      "-10^9 <= matrix[i][j] <= 10^9"
    ],
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "matrix = [[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": "The element at (1,1) is 0, so the entire second row and column are set to 0."
      },
      {
        "input": "matrix = [[0,1],[1,0]]",
        "output": "matrix = [[0,0],[0,0]]",
        "explanation": "The elements at (0,0) and (1,1) are 0, so both rows and both columns are set to 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to track which rows and columns need to be zeroed.",
      "Use the first row and first column as flags."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Wildcard Matching",
    "description": "Given two strings 's' and 'p', where 's' represents a text and 'p' represents a pattern that can include the wildcard characters '*' and '?'. The character '*' can represent any sequence of characters (including the empty sequence), while the character '?' can represent any single character. Implement a function that determines if the string 's' matches the pattern 'p'.",
    "topic": "Dynamic Programming",
    "subtopic": "String Matching",
    "tags": [
      "Dynamic Programming",
      "Recursion",
      "String"
    ],
    "input_format": "Two strings 's' and 'p' where 0 <= s.length, p.length <= 200.",
    "output_format": "A boolean value indicating whether 's' matches 'p'.",
    "constraints": [
      "0 <= s.length, p.length <= 200",
      "'s' and 'p' consist of lowercase English letters, '*' and '?'."
    ],
    "examples": [
      {
        "input": "s = 'aa', p = 'a'",
        "output": "false",
        "explanation": "'a' cannot match 'aa' since it does not allow for trailing characters."
      },
      {
        "input": "s = 'aa', p = '*'",
        "output": "true",
        "explanation": "'*' can match any string, including 'aa'."
      },
      {
        "input": "s = 'cb', p = '?a'",
        "output": "false",
        "explanation": "'?a' expects a single character followed by 'a', but 'cb' does not match that."
      },
      {
        "input": "s = 'adceb', p = '*a*b'",
        "output": "true",
        "explanation": "'*a*b' can match 'adceb' because '*' can represent 'dc', and both 'a' and 'b' can be matched correctly."
      },
      {
        "input": "s = 'acdcb', p = 'a*c?b'",
        "output": "false",
        "explanation": "'a*c?b' expects 'a', any character, and 'b', but 'acdcb' does not match this pattern."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using dynamic programming to store results of subproblems.",
      "Think about how to handle the '*' character while matching."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Search a 2D Matrix",
    "description": "Write an efficient algorithm that searches for a target value in an m x n integer matrix. This matrix has the following properties: - Integers in each row are sorted from left to right. - The first integer of each row is greater than the last integer of the previous row. If the target exists in the matrix, return true; otherwise, return false.",
    "topic": "Binary Search",
    "subtopic": "2D Matrix Search",
    "tags": [
      "Binary Search",
      "Matrix",
      "Search"
    ],
    "input_format": "An m x n matrix represented as a list of lists and an integer target.",
    "output_format": "A boolean value indicating whether the target exists in the matrix.",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 100",
      "-10^4 <= matrix[i][j], target <= 10^4"
    ],
    "examples": [
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [12, 14, 16]], target = 9",
        "output": "true",
        "explanation": "The target value 9 is present in the matrix."
      },
      {
        "input": "matrix = [[1, 3, 5], [7, 9, 11], [12, 14, 16]], target = 10",
        "output": "false",
        "explanation": "The target value 10 is not present in the matrix."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using binary search in a 1D representation of the 2D matrix.",
      "Calculate the row and column indices from a single index."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted List",
    "description": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "Linked List",
      "Duplicates",
      "Two Pointers"
    ],
    "input_format": "The input is a linked list represented by its head node.",
    "output_format": "Return the head of the linked list after removing duplicates.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 300].",
      "-100 <= Node.val <= 100",
      "The list is guaranteed to be sorted in ascending order."
    ],
    "examples": [
      {
        "input": "head = [1, 1, 2]",
        "output": "[1, 2]",
        "explanation": "The input list contains two duplicates of value 1, which should be removed."
      },
      {
        "input": "head = [1, 1, 2, 3, 3]",
        "output": "[1, 2, 3]",
        "explanation": "The input list contains duplicates of values 1 and 3, both of which should be removed."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a pointer to traverse the list.",
      "Compare the current node with the next node to identify duplicates."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Balanced Binary Tree",
    "description": "Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Depth"
    ],
    "input_format": "The input is the root node of a binary tree.",
    "output_format": "Return true if the binary tree is balanced, otherwise return false.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 5000].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "[3,9,20,null,null,15,7]",
        "output": "true",
        "explanation": "The tree is balanced because the depth of the left subtree (1) and right subtree (2) of the root node (3) differ by 1."
      },
      {
        "input": "[1,2,2,3,3,null,null,4,4]",
        "output": "false",
        "explanation": "The tree is not balanced because the depth of the left subtree (3) and right subtree (1) of the root node (1) differ by more than 1."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider using a recursive approach to check the height of the subtrees.",
      "You can determine balance by checking the heights of the left and right subtrees."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Count and Say",
    "description": "The 'Count and Say' sequence is a sequence of digit strings defined by the recursive relation: the first term is '1', and each subsequent term is generated by describing the digits of the previous term. For example, the second term is '11' (one '1'), the third term is '21' (two '1's), and the fourth term is '1211' (one '2', one '1'). Given an integer n, return the nth term of the 'Count and Say' sequence.",
    "topic": "Recursion",
    "subtopic": "String Manipulation",
    "tags": [
      "Recursion",
      "String",
      "Counting"
    ],
    "input_format": "An integer n (1 <= n <= 30).",
    "output_format": "A string representing the nth term in the Count and Say sequence.",
    "constraints": [
      "1 <= n <= 30"
    ],
    "examples": [
      {
        "input": "n = 1",
        "output": "1",
        "explanation": "The first term is '1'."
      },
      {
        "input": "n = 4",
        "output": "1211",
        "explanation": "The third term is '21', and it describes as one '2' and one '1' which gives '1211'."
      },
      {
        "input": "n = 5",
        "output": "111221",
        "explanation": "The fourth term is '1211', which describes as one '1', one '2', and two '1's yielding '111221'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how to represent the counts of each character."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Minimum Window Substring",
    "description": "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\". The input strings are such that 0 < s.length <= 1000 and 0 < t.length <= 100.",
    "topic": "String",
    "subtopic": "Sliding Window",
    "tags": [
      "String",
      "Sliding Window",
      "Hash Map"
    ],
    "input_format": "Two strings s and t.",
    "output_format": "A string representing the minimum window substring of s that contains all characters in t.",
    "constraints": [
      "1 <= s.length <= 10^5",
      "1 <= t.length <= 10^5",
      "s and t consist of English letters, digits, and symbols."
    ],
    "examples": [
      {
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
        "output": "\"BANC\"",
        "explanation": "The minimum window substring of s that contains all characters of t is \"BANC\"."
      },
      {
        "input": "s = \"AA\", t = \"AA\"",
        "output": "\"AA\"",
        "explanation": "The string s contains all characters of t. The minimum window is \"AA\"."
      },
      {
        "input": "s = \"a\", t = \"aa\"",
        "output": "\"\"",
        "explanation": "There is no window that contains all characters of t. So the output is an empty string."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a hashmap to count characters in t.",
      "Use two pointers to represent a sliding window in s.",
      "Try to minimize the window by moving the left pointer."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Subsets",
    "description": "Given a set of distinct integers, return all possible subsets (the power set). The solution set must not contain duplicate subsets. You may return the solution in any order.",
    "topic": "Backtracking",
    "subtopic": "Power Set",
    "tags": [
      "Backtracking",
      "Subsets",
      "Recursion"
    ],
    "input_format": "An array of distinct integers nums.",
    "output_format": "A 2D array of integers representing all possible subsets.",
    "constraints": [
      "0 <= nums.length <= 10",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]",
        "explanation": "The subsets of [1, 2, 3] include the empty set, each individual element, every pair of elements, and the set itself."
      },
      {
        "input": "nums = [0]",
        "output": "[[], [0]]",
        "explanation": "The only subsets of [0] are the empty set and the set containing 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using backtracking to generate subsets.",
      "Start with the empty set and add elements progressively."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "N-Queens",
    "description": "The N-Queens puzzle is the problem of placing N chess queens on an N\u00d7N chessboard such that no two queens threaten each other. This means that no two queens can share the same row, column, or diagonal. You need to return all distinct solutions to the N-Queens puzzle.",
    "topic": "Backtracking",
    "subtopic": "N-Queens Problem",
    "tags": [
      "Backtracking",
      "Chess",
      "Permutation"
    ],
    "input_format": "An integer n representing the number of queens and the size of the chessboard (n x n).",
    "output_format": "A list of distinct solutions, where each solution is represented by a list of strings. Each string represents a row of the board with 'Q' for a queen and '.' for an empty space.",
    "constraints": [
      "1 <= n <= 9"
    ],
    "examples": [
      {
        "input": "n = 4",
        "output": "[['.Q..',  '...Q',  'Q...',  '..Q.'], ['..Q.',  'Q...',  '...Q',  '.Q..']]",
        "explanation": "There are two distinct solutions for placing 4 queens on a 4x4 chessboard."
      },
      {
        "input": "n = 1",
        "output": "[['Q']]",
        "explanation": "There is only one way to place 1 queen on a 1x1 chessboard."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using backtracking to explore potential positions for the queens.",
      "Maintain separate sets to track used columns and diagonals."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Simplify Path",
    "description": "Given a string representing an absolute path for a file (Unix-style), simplify it. The path may contain redundant slashes and special directories like '.' (current directory) and '..' (parent directory). Your task is to return the simplified canonical path.",
    "topic": "String",
    "subtopic": "Path Manipulation",
    "tags": [
      "String",
      "Path",
      "Manipulation"
    ],
    "input_format": "A string path representing an absolute Unix-style file path.",
    "output_format": "A string representing the simplified canonical path.",
    "constraints": [
      "1 <= path.length <= 3000",
      "path consists of English letters, digits, '/', '.', and '..'.",
      "The path is guaranteed to be a valid absolute path."
    ],
    "examples": [
      {
        "input": "/a/./b/../../c/",
        "output": "/c",
        "explanation": "The path simplifies as: /a/current/b/back to previous directory/c."
      },
      {
        "input": "/../",
        "output": "/",
        "explanation": "The path goes to the parent directory but stays at the root, resulting in '/'."
      },
      {
        "input": "/home//foo/",
        "output": "/home/foo",
        "explanation": "The multiple slashes are redundant and should be simplified to '/home/foo'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a stack to track components of the path.",
      "Ignore empty or redundant components.",
      "Be cautious with the '..' operator to move up a directory."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Zigzag Conversion",
    "description": "The string 'PAYPALISHIRING' is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I G\nY   I   \n\nAnd then read line by line. After arranging the characters in this zigzag order, you need to return the concatenated string of the characters in each line.\n\nFor example, if the input string is 'PAYPALISHIRING' and the number of rows is 3, the output would be 'PAHNAPLSIIGY'.",
    "topic": "String",
    "subtopic": "Zigzag Conversion",
    "tags": [
      "String",
      "Zigzag",
      "Conversion"
    ],
    "input_format": "A string s and an integer numRows representing the number of rows.",
    "output_format": "A string representing the characters concatenated from each row in the zigzag pattern.",
    "constraints": [
      "1 <= s.length <= 1000",
      "1 <= numRows <= 1000"
    ],
    "examples": [
      {
        "input": "s = 'PAYPALISHIRING', numRows = 3",
        "output": "PAHNAPLSIIGY",
        "explanation": "The zigzag pattern of 'PAYPALISHIRING' with 3 rows is:\nP   A   H   N\nA P L S I G\nY   I   \nReading line by line gives 'PAHNAPLSIIGY'."
      },
      {
        "input": "s = 'A', numRows = 1",
        "output": "A",
        "explanation": "With only one row, the output is the same as the input string."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a drop_factor to determine the direction of movement in the zigzag pattern.",
      "Consider how to fill each row while traversing through the string."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Text Justification",
    "description": "Given an array of words and a length maxWidth, format the text such that each line has exactly maxWidth characters and is fully justified. You should pack the words to the left, and if there are extra spaces, they should be distributed evenly between words. If the number of spaces is not evenly divisible by the number of gaps, the extra spaces should be added from left to right. The last line should be left-justified and no extra space is inserted.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Justification",
      "Formatting"
    ],
    "input_format": "An array of strings words and an integer maxWidth.",
    "output_format": "An array of strings representing the fully justified text.",
    "constraints": [
      "1 <= words.length <= 3000",
      "0 <= words[i].length <= 100",
      "1 <= maxWidth <= 100"
    ],
    "examples": [
      {
        "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
        "output": "[\"This    is    an\", \"example  of text\", \"justification.  \"]",
        "explanation": "The first line contains 16 characters. It is fully justified, with spaces added among the words."
      },
      {
        "input": "words = [\"What\", \"must\", \"be\", \"acknowledged\", \"shall\", \"be\", \"provided\"], maxWidth = 16",
        "output": "[\"What   must   be\", \"acknowledged  \", \"shall be provided\"]",
        "explanation": "The lines are justified according to the given maxWidth."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider how to distribute spaces among words.",
      "Be mindful of the line length and the last line's handling.",
      "Use an iterative approach to build each line."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Decode Ways",
    "description": "A message containing letters from A-Z can be encoded into numbers using the following mapping: 'A' -> 1, 'B' -> 2, ..., 'Z' -> 26. Given a string s consisting of digits, return the number of ways to decode it. A valid encoding must conform to the mapping; for example, '12' can be decoded as 'AB' (1 2) or 'L' (12). The string may contain leading zeros or invalid pairs.",
    "topic": "Dynamic Programming",
    "subtopic": "String Decoding",
    "tags": [
      "Dynamic Programming",
      "String",
      "Decoding"
    ],
    "input_format": "A string s consisting of digits (0-9).",
    "output_format": "An integer representing the number of ways to decode the given string.",
    "constraints": [
      "1 <= s.length <= 100",
      "s[i] must be '0'-'9'.",
      "s cannot start with '0'."
    ],
    "examples": [
      {
        "input": "s = \"12\"",
        "output": "2",
        "explanation": "'12' can be decoded as 'AB' (1 2) or 'L' (12)."
      },
      {
        "input": "s = \"226\"",
        "output": "3",
        "explanation": "'226' can be decoded as 'BZ' (2 26), 'F' (6), or 'BBF' (2 2 6)."
      },
      {
        "input": "s = \"0\"",
        "output": "0",
        "explanation": "There are no valid encodings for '0'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to build up the solution.",
      "Track the number of ways to decode the string up to each point."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Swap Nodes in Pairs",
    "description": "Given a linked list, swap every two adjacent nodes and return its head. You must do this in place and without modifying the values of the nodes.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "Linked List",
      "Swap",
      "In-Place"
    ],
    "input_format": "The head of a singly linked list, represented as ListNode.",
    "output_format": "The head of the modified linked list, represented as ListNode.",
    "constraints": [
      "The number of nodes in the linked list is in the range [0, 100].",
      "0 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4]",
        "output": "[2, 1, 4, 3]",
        "explanation": "Swapping nodes 1 and 2, and 3 and 4 gives the linked list [2, 1, 4, 3]."
      },
      {
        "input": "head = [1]",
        "output": "[1]",
        "explanation": "Since there is only one node, no swaps are made. The output is [1]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dummy node to simplify edge cases.",
      "Consider using pointers to keep track of pairs to swap."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Minimum Path Sum",
    "description": "Given a m x n grid filled with non-negative numbers, find a path from the top left to the bottom right, which minimizes the sum of the numbers along the path. You can only move either down or right at any point in time.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Minimum Path"
    ],
    "input_format": "A 2D array grid where grid[i][j] represents the cost of cell (i, j).",
    "output_format": "An integer representing the minimum path sum from the top-left corner to the bottom-right corner.",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 200",
      "0 <= grid[i][j] <= 100"
    ],
    "examples": [
      {
        "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7",
        "explanation": "The path 1 \u2192 3 \u2192 1 \u2192 1 minimizes the sum to 7."
      },
      {
        "input": "grid = [[1,2,3],[4,5,6]]",
        "output": "12",
        "explanation": "The path 1 \u2192 2 \u2192 3 \u2192 6 minimizes the sum to 12."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using dynamic programming to store minimum sums.",
      "You can keep updating the grid in place for optimization.",
      "Think about the transitions: how can you build the solution from smaller subproblems?"
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Rotate List",
    "description": "Given the head of a linked list, rotate the list to the right by k places. The definition of rotation means moving the last k nodes to the front of the list. For example, if the list is 1 -> 2 -> 3 -> 4 -> 5 and k = 2, the list should become 4 -> 5 -> 1 -> 2 -> 3.",
    "topic": "Linked List",
    "subtopic": "Manipulation",
    "tags": [
      "Linked List",
      "Rotation",
      "Two Pointers"
    ],
    "input_format": "A linked list represented by its head node and an integer k.",
    "output_format": "The head node of the rotated linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 500].",
      "-100 <= Node.val <= 100",
      "0 <= k <= 100"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], k = 2",
        "output": "[4, 5, 1, 2, 3]",
        "explanation": "Rotating the list by 2 places results in 4 -> 5 -> 1 -> 2 -> 3."
      },
      {
        "input": "head = [0, 1, 2], k = 4",
        "output": "[2, 0, 1]",
        "explanation": "Rotating the list by 4 places (which is equivalent to 1 place) results in 2 -> 0 -> 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the length of the list to optimize the number of rotations.",
      "Connect the tail of the list to the head to form a circular list.",
      "Identify the new head after k rotations."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Integer to Roman",
    "description": "Given an integer, convert it to a Roman numeral. Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. For example, the integer 3 is represented as 'III', and 4 is represented as 'IV'. Number 9 is 'IX', and so on. The conversion rules are as follows:\n- I = 1\n- V = 5\n- X = 10\n- L = 50\n- C = 100\n- D = 500\n- M = 1000\n\nFor numbers larger than 3, the values are combined: 58 is represented as 'LVIII', which is comprised of 'L' (50), 'V' (5), and 'III' (3).",
    "topic": "Math",
    "subtopic": "Conversion",
    "tags": [
      "Math",
      "String",
      "Conversion"
    ],
    "input_format": "An integer num in the range from 1 to 3999.",
    "output_format": "A string representing the Roman numeral equivalent of the integer.",
    "constraints": [
      "1 <= num <= 3999"
    ],
    "examples": [
      {
        "input": "num = 3",
        "output": "III",
        "explanation": "The integer 3 is represented as 'III' in Roman numerals."
      },
      {
        "input": "num = 58",
        "output": "LVIII",
        "explanation": "The integer 58 is represented as 'LVIII' which is 'L' (50) + 'V' (5) + 'III' (3)."
      },
      {
        "input": "num = 1994",
        "output": "MCMXCIV",
        "explanation": "The integer 1994 is represented as 'MCMXCIV' which is 'M' (1000) + 'CM' (900) + 'XC' (90) + 'IV' (4)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a descending list of Roman numeral values.",
      "Iterate and subtract values from the integer while appending corresponding Roman symbols."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Reverse Nodes in k-Group",
    "description": "Given the head of a linked list, reverse the nodes of the list k at a time and return the modified list. If the number of nodes is not a multiple of k then left nodes in the end should remain as they are. You may not alter the values in the nodes, only nodes themselves may be changed.",
    "topic": "Linked List",
    "subtopic": "Reversing a Linked List",
    "tags": [
      "Linked List",
      "Two Pointers",
      "Recursion"
    ],
    "input_format": "The input consists of a singly linked list with a head node.",
    "output_format": "The modified head of the linked list after reversing the nodes in k-group.",
    "constraints": [
      "The number of nodes in the list is n.",
      "1 <= k <= n <= 5000",
      "0 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5], k = 2",
        "output": "[2, 1, 4, 3, 5]",
        "explanation": "The first two nodes (1 and 2) are reversed to become 2 and 1. The next two nodes (3 and 4) are reversed to become 4 and 3. The node 5 remains as it is."
      },
      {
        "input": "head = [1, 2, 3, 4, 5], k = 3",
        "output": "[3, 2, 1, 4, 5]",
        "explanation": "The first three nodes (1, 2, 3) are reversed to become 3, 2, 1. The remaining nodes (4 and 5) remain unchanged."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a dummy node to simplify the reversal and connection process.",
      "Keep track of the previous group's end and the current group's start and end."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Combinations",
    "description": "Given an integer n and an integer k, return all possible combinations of k numbers chosen from the range 1 to n. You may return the combinations in any order.",
    "topic": "Backtracking",
    "subtopic": "Combinations",
    "tags": [
      "Backtracking",
      "Combinations",
      "Recursion"
    ],
    "input_format": "Two integers n and k where 1 <= k <= n <= 20.",
    "output_format": "A list of lists containing all possible combinations of k numbers chosen from the range 1 to n.",
    "constraints": [
      "1 <= k <= n <= 20"
    ],
    "examples": [
      {
        "input": "n = 4, k = 2",
        "output": "[[2,4],[3,4],[1,2],[1,3],[1,4],[2,3]]",
        "explanation": "The combinations of 2 numbers from the range 1 to 4 are all the pairs of numbers: (1,2), (1,3), (1,4), (2,3), (2,4), and (3,4)."
      },
      {
        "input": "n = 1, k = 1",
        "output": "[[1]]",
        "explanation": "With n = 1 and k = 1, the only combination is the number itself: (1)."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use backtracking to explore all combinations.",
      "Consider the current number and the remaining choices."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Convert Sorted Array to Binary Search Tree",
    "description": "Given an integer array nums sorted in non-decreasing order, convert it to a height-balanced binary search tree. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursive"
    ],
    "input_format": "An array of integers nums sorted in non-decreasing order.",
    "output_format": "The root node of the height-balanced binary search tree.",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums = [-10, -3, 0, 5, 9]",
        "output": "[0,-3,9,-10,null,5]",
        "explanation": "One possible height-balanced binary search tree is: \n       0\n      / \\\n    -3   9\n    /   /\n  -10  5"
      },
      {
        "input": "nums = [1, 3]",
        "output": "[3, 1]",
        "explanation": "The binary search tree is: \n   3\n  /\n 1"
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Consider choosing the middle element as the root.",
      "Recursively apply the same logic to the left and right subarrays."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Sudoku Solver",
    "description": "Write a program that takes a partially filled 9x9 2D array representing a Sudoku board and solves it. You need to fill the missing numbers such that every row, every column, and every 3x3 sub-box contains the digits from 1 to 9 without repetition. The '.' character represents empty cells.",
    "topic": "Backtracking",
    "subtopic": "Depth-First Search",
    "tags": [
      "Backtracking",
      "DFS",
      "Matrix"
    ],
    "input_format": "A 2D array of characters representing the Sudoku board.",
    "output_format": "The input board filled with the correct values.",
    "constraints": [
      "The input board is guaranteed to be valid and has a unique solution.",
      "The initial empty cells will be represented by '.'"
    ],
    "examples": [
      {
        "input": [
          [
            "5",
            "3",
            ".",
            ".",
            "7",
            ".",
            ".",
            ".",
            "."
          ],
          [
            "6",
            ".",
            ".",
            "1",
            "9",
            "5",
            ".",
            ".",
            "."
          ],
          [
            ".",
            "9",
            "8",
            ".",
            ".",
            ".",
            ".",
            "6",
            "."
          ],
          [
            "8",
            ".",
            ".",
            ".",
            "6",
            ".",
            ".",
            ".",
            "3"
          ],
          [
            "4",
            ".",
            ".",
            "8",
            ".",
            "3",
            ".",
            ".",
            "1"
          ],
          [
            "7",
            ".",
            ".",
            ".",
            "2",
            ".",
            ".",
            ".",
            "6"
          ],
          [
            ".",
            "6",
            ".",
            ".",
            ".",
            ".",
            "2",
            "8",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "4",
            "1",
            "9",
            ".",
            ".",
            "5"
          ],
          [
            ".",
            ".",
            ".",
            ".",
            "8",
            ".",
            ".",
            "7",
            "9"
          ]
        ],
        "output": [
          [
            "5",
            "3",
            "4",
            "6",
            "7",
            "8",
            "9",
            "1",
            "2"
          ],
          [
            "6",
            "7",
            "2",
            "1",
            "9",
            "5",
            "3",
            "4",
            "8"
          ],
          [
            "1",
            "9",
            "8",
            "3",
            "4",
            "2",
            "5",
            "6",
            "7"
          ],
          [
            "8",
            "5",
            "9",
            "7",
            "6",
            "1",
            "4",
            "2",
            "3"
          ],
          [
            "4",
            "2",
            "6",
            "8",
            "5",
            "3",
            "7",
            "9",
            "1"
          ],
          [
            "7",
            "1",
            "3",
            "9",
            "2",
            "4",
            "8",
            "5",
            "6"
          ],
          [
            "9",
            "6",
            "1",
            "2",
            "3",
            "5",
            "2",
            "8",
            "4"
          ],
          [
            "2",
            "8",
            "7",
            "4",
            "1",
            "9",
            "6",
            "3",
            "5"
          ],
          [
            "3",
            "4",
            "5",
            "2",
            "8",
            "6",
            "1",
            "7",
            "9"
          ]
        ],
        "explanation": "The output is the completed Sudoku board filled with valid numbers according to the rules of Sudoku."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using backtracking to explore possible options.",
      "You can check for validity by ensuring numbers are unique in rows, columns, and boxes."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Partition List",
    "description": "Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions.",
    "topic": "Linked List",
    "subtopic": "Partitioning",
    "tags": [
      "Linked List",
      "Partition",
      "Two Pointers"
    ],
    "input_format": "The head of the linked list and an integer x.",
    "output_format": "The head of the modified linked list.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 200].",
      "-100 <= Node.val <= 100",
      "-200 <= x <= 200"
    ],
    "examples": [
      {
        "input": "head = 1 -> 4 -> 3 -> 2 -> 5 -> 2, x = 3",
        "output": "1 -> 2 -> 2 -> 4 -> 3 -> 5",
        "explanation": "Nodes less than 3: 1, 2, 2. Nodes greater than or equal to 3: 4, 3, 5. The final partitioned list preserves relative order."
      },
      {
        "input": "head = 2 -> 1, x = 2",
        "output": "1 -> 2",
        "explanation": "Nodes less than 2: 1. Nodes greater than or equal to 2: 2. The final partitioned list preserves relative order."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use two pointers to create two separate lists.",
      "After processing all nodes, connect the two lists."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Unique Binary Search Trees II",
    "description": "Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 to n. Each tree should be represented as a list of values, from the root to the leaves. Your task is to return all such unique trees.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "DFS",
      "Dynamic Programming"
    ],
    "input_format": "An integer n (1 <= n <= 8) representing the number of nodes in the BST.",
    "output_format": "A list of unique binary search trees, where each tree is represented as a list of integers.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[[[1, null, 2, null, 3], [1, null, 3, 2], [2, 1, 3], [3, 1, null, null, 2], [3, 2, 1]]]",
        "explanation": "The unique BSTs that can be constructed with values 1, 2, and 3 are represented in the output."
      },
      {
        "input": "n = 1",
        "output": "[[[1]]]",
        "explanation": "With just one node, the only unique BST is the node itself."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using recursion to build trees for each root and combine the left and right subtrees."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Restore IP Addresses",
    "description": "Given a string containing only digits, restore it by returning all possible valid IP address combinations. A valid IP address consists of four decimal numbers, each ranging from 0 to 255, separated by dots. Leading zeros are not allowed in any of the segments, except for the number 0 itself.",
    "topic": "Backtracking",
    "subtopic": "String Manipulation",
    "tags": [
      "Backtracking",
      "String",
      "IP Address"
    ],
    "input_format": "A string 's' of digits with length between 1 and 20.",
    "output_format": "A list of strings representing all valid IP address combinations.",
    "constraints": [
      "1 <= s.length <= 20",
      "s consists of digits only."
    ],
    "examples": [
      {
        "input": "s = '25525511135'",
        "output": [
          "255.255.11.135",
          "255.255.111.35"
        ],
        "explanation": "The valid combinations for the string '25525511135' that form valid IP addresses are: 255.255.11.135 and 255.255.111.35."
      },
      {
        "input": "s = '0000'",
        "output": [
          "0.0.0.0"
        ],
        "explanation": "The only valid combination for the string '0000' is '0.0.0.0'."
      },
      {
        "input": "s = '123123123123'",
        "output": [],
        "explanation": "There are no valid combinations for the string '123123123123' that can form an IP address."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider the limit that each segment can only be up to 3 digits.",
      "Remember to avoid leading zeros in segments."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Length of Last Word",
    "description": "Given a string s consisting of some words separated by spaces, return the length of the last word in the string. If the last word does not exist, return 0.",
    "topic": "String",
    "subtopic": "String Manipulation",
    "tags": [
      "String",
      "Length",
      "Manipulation"
    ],
    "input_format": "A single string s, where 0 <= s.length <= 10^4.",
    "output_format": "An integer representing the length of the last word.",
    "constraints": [
      "The input string s may contain leading or trailing spaces."
    ],
    "examples": [
      {
        "input": "Hello World",
        "output": "5",
        "explanation": "The last word is 'World', which has a length of 5."
      },
      {
        "input": "   fly me   to   the moon  ",
        "output": "4",
        "explanation": "The last word is 'moon', which has a length of 4."
      },
      {
        "input": "luffy is still joyboy",
        "output": "6",
        "explanation": "The last word is 'joyboy', which has a length of 6."
      },
      {
        "input": "   ",
        "output": "0",
        "explanation": "There are no words in the input, so the length is 0."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Trim the string to remove leading and trailing spaces.",
      "Split the string by spaces and find the last non-empty word."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Same Tree",
    "description": "Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Recursion"
    ],
    "input_format": "Two binary trees represented as root nodes.",
    "output_format": "A boolean value indicating whether the two trees are the same.",
    "constraints": [
      "The number of nodes in both trees is in the range [0, 100].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "examples": [
      {
        "input": "Tree1 and Tree2 where Tree1: [1, 2, 3] and Tree2: [1, 2, 3]",
        "output": "true",
        "explanation": "Both trees have the same structure and the same node values."
      },
      {
        "input": "Tree1 and Tree2 where Tree1: [1, 2] and Tree2: [1, null, 2]",
        "output": "false",
        "explanation": "The structure of the trees is different; hence, they are not the same."
      }
    ],
    "difficulty": "Easy",
    "hints": [
      "Use a recursive approach to traverse both trees simultaneously.",
      "If both nodes are null, they are the same at this position."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted List II",
    "description": "Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.",
    "topic": "Linked List",
    "subtopic": "Pointer Manipulation",
    "tags": [
      "Linked List",
      "Duplicates",
      "Two Pointers"
    ],
    "input_format": "A head node of a sorted singly linked list.",
    "output_format": "The head node of the linked list with duplicates removed.",
    "constraints": [
      "The number of nodes in the list is in the range [0, 10^4].",
      "-100 <= Node.val <= 100",
      "The list is guaranteed to be sorted in ascending order."
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 3, 4, 4, 5]",
        "output": "[1, 2, 5]",
        "explanation": "Nodes with values 3 and 4 have duplicates, so they are removed from the list."
      },
      {
        "input": "head = [1, 1, 1, 2, 3]",
        "output": "[2, 3]",
        "explanation": "All nodes with value 1 have duplicates and are removed from the list."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a dummy node to handle the edge cases.",
      "Maintain two pointers: one for the current node and another for tracking duplicates."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Edit Distance",
    "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You can perform three types of operations: insert a character, delete a character, or replace a character.",
    "topic": "Dynamic Programming",
    "subtopic": "String Manipulation",
    "tags": [
      "Dynamic Programming",
      "String",
      "Edit Distance",
      "Algorithm"
    ],
    "input_format": "Two strings word1 and word2, where 0 <= word1.length, word2.length <= 1000.",
    "output_format": "An integer representing the minimum number of operations required to convert word1 to word2.",
    "constraints": [
      "0 <= word1.length, word2.length <= 1000",
      "word1 and word2 consist of lowercase English letters."
    ],
    "examples": [
      {
        "input": "word1 = 'horse', word2 = 'ros'",
        "output": "3",
        "explanation": "The minimum operations are: replace 'h' with 'r', 'k' with 'o', and delete 'e'."
      },
      {
        "input": "word1 = 'intention', word2 = 'execution'",
        "output": "5",
        "explanation": "The minimum operations are: replace 'i' with 'e', replace 'n' with 'x', replace 't' with 'c', insert 'u', and insert 'o'."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a 2D DP array to store minimum operations for substrings.",
      "Think about the base cases when one of the strings is empty."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Unique Paths",
    "description": "A robot is located at the top-left corner of an m x n grid and wants to reach the bottom-right corner. The robot can only move either down or right at any point in time. Given the dimensions of the grid, return the number of unique paths that the robot can take to reach the bottom-right corner.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Combinatorics"
    ],
    "input_format": "Two integers m and n representing the number of rows and columns of the grid.",
    "output_format": "An integer representing the number of unique paths to reach the bottom-right corner.",
    "constraints": [
      "1 <= m, n <= 100"
    ],
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": "There are 28 unique paths for the robot to reach the bottom-right corner from the top-left corner."
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "There are 3 unique paths to reach the bottom-right corner: down -> down -> right OR down -> right -> down OR right -> down -> down."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider how many ways there are to get to a given cell from the cell above and the cell to the left.",
      "Use dynamic programming to store intermediate results."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Multiply Strings",
    "description": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. You must not use any built-in BigInteger library or convert the inputs to integers directly.",
    "topic": "String",
    "subtopic": "Mathematical Operations",
    "tags": [
      "String",
      "Mathematical",
      "Multiplication"
    ],
    "input_format": "Two strings num1 and num2 representing the non-negative integers.",
    "output_format": "A string representing the product of num1 and num2.",
    "constraints": [
      "1 <= num1.length, num2.length <= 200",
      "num1 and num2 consist of digits only and do not have leading zeros."
    ],
    "examples": [
      {
        "input": "num1 = '123', num2 = '456'",
        "output": "'56088'",
        "explanation": "The product of 123 and 456 is 56088."
      },
      {
        "input": "num1 = '2', num2 = '3'",
        "output": "'6'",
        "explanation": "The product of 2 and 3 is 6."
      },
      {
        "input": "num1 = '0', num2 = '999'",
        "output": "'0'",
        "explanation": "Multiplying any number by 0 results in 0."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Think about how you would multiply numbers by hand.",
      "Consider breaking down the multiplication into single digit products."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Subsets II",
    "description": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the answer in any order.",
    "topic": "Backtracking",
    "subtopic": "Subsets Generation",
    "tags": [
      "Array",
      "Backtracking",
      "Subsets"
    ],
    "input_format": "An array of integers nums.",
    "output_format": "A list of lists representing the unique subsets.",
    "constraints": [
      "0 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 2]",
        "output": "[[], [1], [1,2], [2], [2,2]]",
        "explanation": "The unique subsets for [1, 2, 2] are: [], [1], [2], [1,2], and [2,2]."
      },
      {
        "input": "nums = [0]",
        "output": "[[], [0]]",
        "explanation": "The unique subsets for [0] are: [] and [0]."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Sort the array to help skip duplicates.",
      "Use a backtracking approach to generate subsets.",
      "Maintain a path to track current subset and control its addition."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Maximal Rectangle",
    "description": "Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.",
    "topic": "Dynamic Programming",
    "subtopic": "Matrix Manipulation",
    "tags": [
      "Dynamic Programming",
      "Matrix",
      "Area"
    ],
    "input_format": "A binary matrix represented as a 2D list of integers, where each element is either 0 or 1.",
    "output_format": "An integer representing the area of the largest rectangle containing only 1's.",
    "constraints": [
      "1 <= matrix.length <= 200",
      "1 <= matrix[i].length <= 200",
      "matrix[i][j] is either 0 or 1."
    ],
    "examples": [
      {
        "input": "[[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]",
        "output": "6",
        "explanation": "The largest rectangle can be formed by the 1's from (1, 1) to (3, 2), which contains 6 cells."
      },
      {
        "input": "[[0,0],[0,0]]",
        "output": "0",
        "explanation": "There are no 1's in the matrix, so the largest rectangle area is 0."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Use a histogram approach to calculate the area of rectangles for each row.",
      "Keep track of heights of the histogram derived from the binary matrix.",
      "Use a stack to calculate the maximal area efficiently."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "description": "Given two integer arrays, preorder and inorder, which represent the preorder and inorder traversal of a binary tree, construct and return the binary tree. You must implement a function that reconstructs the tree based on these two arrays.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "Traversal"
    ],
    "input_format": "Two integer arrays, preorder and inorder, where the elements are distinct.",
    "output_format": "The root node of the constructed binary tree.",
    "constraints": [
      "1 <= preorder.length <= 30",
      "1 <= inorder.length <= 30",
      "preorder.length == inorder.length",
      "The elements of inorder are unique."
    ],
    "examples": [
      {
        "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",
        "output": "TreeNode(3) with left subtree rooted at TreeNode(9) and right subtree rooted at TreeNode(20).",
        "explanation": "The tree reconstructed from the given traversals will have 3 as root, with 9 as left child and 20 as right child."
      },
      {
        "input": "preorder = [1,2], inorder = [2,1]",
        "output": "TreeNode(1) with left subtree rooted at TreeNode(2).",
        "explanation": "The tree reconstructed will have 1 as root and 2 as left child."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "The first element of preorder is the root.",
      "Use the index of the root in inorder to determine left and right subtrees.",
      "Recursively repeat the process for left and right subtrees."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Permutations II",
    "description": "Given a collection of numbers that might contain duplicates, return all possible unique permutations. The order of the permutations does not matter. The solution set must not contain duplicate permutations.",
    "topic": "Backtracking",
    "subtopic": "Permutations",
    "tags": [
      "Backtracking",
      "Permutations",
      "Array"
    ],
    "input_format": "A collection of integers nums, where -10^5 <= nums[i] <= 10^5.",
    "output_format": "A list of lists of unique permutations.",
    "constraints": [
      "1 <= nums.length <= 8",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "examples": [
      {
        "input": "nums = [1, 1, 2]",
        "output": "[[1, 1, 2], [1, 2, 1], [2, 1, 1]]",
        "explanation": "The input contains duplicates, and the unique permutations are listed."
      },
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]",
        "explanation": "All permutations are unique as there are no duplicates."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a backtracking approach to build permutations.",
      "Sort the input array to handle duplicates efficiently.",
      "Skip over duplicate elements when forming permutations."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Substring with Concatenation of All Words",
    "description": "Given a string s and an array of strings words of the same length, return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Each word in words is of the same length.",
    "topic": "String",
    "subtopic": "Substring Search",
    "tags": [
      "String",
      "Substring",
      "Sliding Window",
      "HashMap"
    ],
    "input_format": "A string s and an array of strings words.",
    "output_format": "A list of starting indices of substring(s).",
    "constraints": [
      "1 <= s.length <= 10^4",
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 100",
      "words[i] consists of lowercase English letters"
    ],
    "examples": [
      {
        "input": {
          "s": "barfoothefoobarman",
          "words": [
            "foo",
            "bar"
          ]
        },
        "output": [
          0,
          9
        ],
        "explanation": "The substring starting at index 0 is 'barfoo' and the substring starting at index 9 is 'foobar', which are the concatenation of the words in the array."
      },
      {
        "input": {
          "s": "wordgoodgoodgoodbestword",
          "words": [
            "word",
            "good",
            "best",
            "word"
          ]
        },
        "output": [],
        "explanation": "There is no substring that is a concatenation of the words."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Consider using a sliding window approach.",
      "Keep track of word counts using a HashMap.",
      "The window size should equal the total length of the concatenated words."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "3Sum Closest",
    "description": "Given an integer array nums of length n and an integer target, you want to find the sum of three integers in nums such that their sum is as close to target as possible. Return the sum of the three integers. You may assume that each input would have exactly one solution and you cannot use the same element twice.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "An integer representing the closest sum of three integers.",
    "constraints": [
      "3 <= nums.length <= 10^3",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9"
    ],
    "examples": [
      {
        "input": "nums = [-1, 2, 1, -4], target = 1",
        "output": "2",
        "explanation": "The sum of three integers closest to the target 1 is 2, which is formed by -1, 2, and 1."
      },
      {
        "input": "nums = [0, 0, 0], target = 1",
        "output": "0",
        "explanation": "The only possible selection is 0, which is the closest sum to 1."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider sorting the array first.",
      "Use two pointers to find pairs that sum to a value close to the target."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Unique Paths II",
    "description": "A robot is located at the top-left corner of a m x n grid and wants to move to the bottom-right corner. The robot can only move either down or right at any point in time. Some squares in the grid are obstacles that block the robot's path. The robot cannot pass through these obstacles. Given a grid represented as a 2D array, where 0 represents an empty square and 1 represents an obstacle, return the number of unique paths from the top-left corner to the bottom-right corner.",
    "topic": "Dynamic Programming",
    "subtopic": "Grid Traversal",
    "tags": [
      "Dynamic Programming",
      "Grid",
      "Pathfinding"
    ],
    "input_format": "A 2D array grid of size m x n, where grid[i][j] is 0 or 1.",
    "output_format": "An integer representing the number of unique paths.",
    "constraints": [
      "1 <= m, n <= 100",
      "grid[i][j] is either 0 or 1.",
      "The starting cell grid[0][0] and the ending cell grid[m-1][n-1] are guaranteed to be 0."
    ],
    "examples": [
      {
        "input": "grid = [[0,0,0],[0,1,0],[0,0,0]]",
        "output": "2",
        "explanation": "There are two unique paths to the bottom-right corner: one going down then right, and the other going right then down."
      },
      {
        "input": "grid = [[0,1],[0,0]]",
        "output": "1",
        "explanation": "There is only one unique path as the cell at (0,1) is an obstacle."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use dynamic programming to build a solution iteratively.",
      "Consider how to handle obstacles during path counting."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Recover Binary Search Tree",
    "description": "Given a binary search tree (BST) that has had two of its nodes swapped by mistake, recover the tree without changing its structure. You need to restore the tree to a valid BST.",
    "topic": "Tree",
    "subtopic": "Binary Search Tree",
    "tags": [
      "Tree",
      "Binary Search Tree",
      "Recursion"
    ],
    "input_format": "The root node of the binary search tree.",
    "output_format": "The root node of the corrected binary search tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [2, 1000].",
      "Node values are unique.",
      "The values of the nodes are in the range [-10^5, 10^5]."
    ],
    "examples": [
      {
        "input": "root = [1, 3, null, null, 2]",
        "output": "[3, 1, null, null, 2]",
        "explanation": "Swapping nodes 1 and 3 makes the tree a valid BST again."
      },
      {
        "input": "root = [3, 1, 4, null, null, 2]",
        "output": "[2, 1, 4, null, null, 3]",
        "explanation": "Swapping nodes 2 and 3 makes the tree a valid BST."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Inorder traversal of a BST produces a sorted sequence.",
      "Identify the two nodes that are out of order during inorder traversal."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Search in Rotated Sorted Array II",
    "description": "Given a rotated sorted array that may contain duplicates, you need to determine whether a target value exists in the array. The array is rotated at some unknown pivot and may have duplicates, making certain elements appear multiple times. Your goal is to implement a function that efficiently searches for the target in this array.",
    "topic": "Array",
    "subtopic": "Binary Search",
    "tags": [
      "Array",
      "Binary Search",
      "Search"
    ],
    "input_format": "An integer array nums and an integer target.",
    "output_format": "A boolean indicating whether the target exists in the array.",
    "constraints": [
      "0 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums may contain duplicates."
    ],
    "examples": [
      {
        "input": "nums = [2, 5, 6, 0, 0, 1, 2], target = 0",
        "output": "true",
        "explanation": "The target 0 exists in the array."
      },
      {
        "input": "nums = [2, 5, 6, 0, 0, 1, 2], target = 3",
        "output": "false",
        "explanation": "The target 3 does not exist in the array."
      },
      {
        "input": "nums = [1, 0, 1, 1, 1], target = 0",
        "output": "true",
        "explanation": "The target 0 exists in the array."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a modified binary search.",
      "Handle the duplicates carefully to avoid missing the target."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Remove Duplicates from Sorted Array II",
    "description": "Given a sorted array of integers, you need to remove some duplicates in-place such that each element appears at most twice and return the new length of the array. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.",
    "topic": "Array",
    "subtopic": "Two Pointers",
    "tags": [
      "Array",
      "Two Pointers",
      "In-place"
    ],
    "input_format": "An integer array nums sorted in non-decreasing order.",
    "output_format": "An integer representing the new length of the modified array.",
    "constraints": [
      "0 <= nums.length <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3]",
        "output": "5",
        "explanation": "After removing duplicates, the modified array is [1,1,2,2,3] with length 5."
      },
      {
        "input": "nums = [0,0,1,1,1,1,2,3,3]",
        "output": "7",
        "explanation": "After removing duplicates, the modified array is [0,0,1,1,2,3,3] with length 7."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Consider using a two-pointer approach.",
      "Keep track of the count of each element as you iterate."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Valid Number",
    "description": "Implement a function that determines if a given string is a valid number. A valid number can be an integer, a decimal, or in scientific notation. Here are the rules for a valid number: The string can be an optional '+' or '-' followed by digits. If there is a decimal point, it can be followed by digits. A number can also be in scientific notation which is indicated by 'e' or 'E', followed by an optional '+' or '-' and digits. Numbers like '.1', '3.', '2e10', '0.1', or '2.0E-2' are considered valid, while 'abc', '1a', '1e', and '6+1' are not valid.",
    "topic": "String",
    "subtopic": "Regular Expressions",
    "tags": [
      "String",
      "Validation",
      "Regular Expressions"
    ],
    "input_format": "A string s representing a potential number.",
    "output_format": "Return true if s is a valid number, otherwise return false.",
    "constraints": [
      "1 <= s.length <= 20",
      "s is a valid string that can contain only numeric characters, '.' or 'e/E'."
    ],
    "examples": [
      {
        "input": "s = '0.1'",
        "output": "true",
        "explanation": "'0.1' is a valid decimal number."
      },
      {
        "input": "s = 'abc'",
        "output": "false",
        "explanation": "'abc' is not a valid number."
      },
      {
        "input": "s = '2e10'",
        "output": "true",
        "explanation": "'2e10' is a valid scientific notation number."
      }
    ],
    "difficulty": "Hard",
    "hints": [
      "Think about using regular expressions to validate the format.",
      "Consider edge cases such as leading/trailing spaces."
    ],
    "company": "Apple"
  },
  {
    "question_id": "",
    "title": "Flatten Binary Tree to Linked List",
    "description": "Given the root of a binary tree, flatten the tree into a linked list in-place. The linked list should follow the same order as a pre-order traversal of the binary tree. That is, the left child of each node should be null, and the right child should point to the next node in the sequence.",
    "topic": "Tree",
    "subtopic": "Binary Tree",
    "tags": [
      "Tree",
      "Binary Tree",
      "DFS",
      "In-Place"
    ],
    "input_format": "The input will be the root node of a binary tree.",
    "output_format": "The output will be the linked list formed by the flattened binary tree.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1, 2, 5, 3, 4, null, 6]",
        "output": "[1,null,2,null,3,null,4,null,5,null,6]",
        "explanation": "The pre-order traversal of the tree is [1, 2, 3, 4, 5, 6], which gives the flattened linked list structure."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "An empty tree results in an empty linked list."
      }
    ],
    "difficulty": "Medium",
    "hints": [
      "Use a pre-order traversal approach.",
      "Maintain a pointer to keep track of the last node in the flattened structure."
    ],
    "company": "Apple"
  }
]